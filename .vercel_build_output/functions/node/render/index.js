var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key3, value) =>
	key3 in obj
		? __defProp(obj, key3, { enumerable: true, configurable: true, writable: true, value })
		: (obj[key3] = value);
var __esm = (fn, res) =>
	function __init() {
		return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])((fn = 0))), res;
	};
var __commonJS = (cb, mod) =>
	function __require() {
		return (
			mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports
		);
	};
var __export = (target, all5) => {
	for (var name in all5) __defProp(target, name, { get: all5[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
	if ((from && typeof from === 'object') || typeof from === 'function') {
		for (let key3 of __getOwnPropNames(from))
			if (!__hasOwnProp.call(to, key3) && key3 !== except)
				__defProp(to, key3, {
					get: () => from[key3],
					enumerable: !(desc = __getOwnPropDesc(from, key3)) || desc.enumerable
				});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (
	(target = mod != null ? __create(__getProtoOf(mod)) : {}),
	__copyProps(
		isNodeMode || !mod || !mod.__esModule
			? __defProp(target, 'default', { value: mod, enumerable: true })
			: target,
		mod
	)
);
var __toCommonJS = (mod) => __copyProps(__defProp({}, '__esModule', { value: true }), mod);
var __publicField = (obj, key3, value) => {
	__defNormalProp(obj, typeof key3 !== 'symbol' ? key3 + '' : key3, value);
	return value;
};

// node_modules/@sveltejs/kit/dist/chunks/_commonjsHelpers.js
var commonjsGlobal;
var init_commonjsHelpers = __esm({
	'node_modules/@sveltejs/kit/dist/chunks/_commonjsHelpers.js'() {
		commonjsGlobal =
			typeof globalThis !== 'undefined'
				? globalThis
				: typeof window !== 'undefined'
				? window
				: typeof global !== 'undefined'
				? global
				: typeof self !== 'undefined'
				? self
				: {};
	}
});

// node_modules/@sveltejs/kit/dist/chunks/multipart-parser.js
var multipart_parser_exports = {};
__export(multipart_parser_exports, {
	toFormData: () => toFormData
});
function _fileName(headerValue) {
	const m2 = headerValue.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
	if (!m2) {
		return;
	}
	const match = m2[2] || m2[3] || '';
	let filename = match.slice(match.lastIndexOf('\\') + 1);
	filename = filename.replace(/%22/g, '"');
	filename = filename.replace(/&#(\d{4});/g, (m3, code3) => {
		return String.fromCharCode(code3);
	});
	return filename;
}
async function toFormData(Body2, ct) {
	if (!/multipart/i.test(ct)) {
		throw new TypeError('Failed to fetch');
	}
	const m2 = ct.match(/boundary=(?:"([^"]+)"|([^;]+))/i);
	if (!m2) {
		throw new TypeError('no or bad content-type header, no multipart boundary');
	}
	const parser = new MultipartParser(m2[1] || m2[2]);
	let headerField;
	let headerValue;
	let entryValue;
	let entryName;
	let contentType;
	let filename;
	const entryChunks = [];
	const formData = new FormData2();
	const onPartData = (ui8a) => {
		entryValue += decoder.decode(ui8a, { stream: true });
	};
	const appendToFile = (ui8a) => {
		entryChunks.push(ui8a);
	};
	const appendFileToFormData = () => {
		const file2 = new File2(entryChunks, filename, { type: contentType });
		formData.append(entryName, file2);
	};
	const appendEntryToFormData = () => {
		formData.append(entryName, entryValue);
	};
	const decoder = new TextDecoder('utf-8');
	decoder.decode();
	parser.onPartBegin = function () {
		parser.onPartData = onPartData;
		parser.onPartEnd = appendEntryToFormData;
		headerField = '';
		headerValue = '';
		entryValue = '';
		entryName = '';
		contentType = '';
		filename = null;
		entryChunks.length = 0;
	};
	parser.onHeaderField = function (ui8a) {
		headerField += decoder.decode(ui8a, { stream: true });
	};
	parser.onHeaderValue = function (ui8a) {
		headerValue += decoder.decode(ui8a, { stream: true });
	};
	parser.onHeaderEnd = function () {
		headerValue += decoder.decode();
		headerField = headerField.toLowerCase();
		if (headerField === 'content-disposition') {
			const m3 = headerValue.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);
			if (m3) {
				entryName = m3[2] || m3[3] || '';
			}
			filename = _fileName(headerValue);
			if (filename) {
				parser.onPartData = appendToFile;
				parser.onPartEnd = appendFileToFormData;
			}
		} else if (headerField === 'content-type') {
			contentType = headerValue;
		}
		headerValue = '';
		headerField = '';
	};
	for await (const chunk of Body2) {
		parser.write(chunk);
	}
	parser.end();
	return formData;
}
var s, S, f, F, LF, CR, SPACE, HYPHEN, COLON, A, Z, lower, noop, MultipartParser;
var init_multipart_parser = __esm({
	'node_modules/@sveltejs/kit/dist/chunks/multipart-parser.js'() {
		init_node();
		init_commonjsHelpers();
		s = 0;
		S = {
			START_BOUNDARY: s++,
			HEADER_FIELD_START: s++,
			HEADER_FIELD: s++,
			HEADER_VALUE_START: s++,
			HEADER_VALUE: s++,
			HEADER_VALUE_ALMOST_DONE: s++,
			HEADERS_ALMOST_DONE: s++,
			PART_DATA_START: s++,
			PART_DATA: s++,
			END: s++
		};
		f = 1;
		F = {
			PART_BOUNDARY: f,
			LAST_BOUNDARY: (f *= 2)
		};
		LF = 10;
		CR = 13;
		SPACE = 32;
		HYPHEN = 45;
		COLON = 58;
		A = 97;
		Z = 122;
		lower = (c) => c | 32;
		noop = () => {};
		MultipartParser = class {
			constructor(boundary) {
				this.index = 0;
				this.flags = 0;
				this.onHeaderEnd = noop;
				this.onHeaderField = noop;
				this.onHeadersEnd = noop;
				this.onHeaderValue = noop;
				this.onPartBegin = noop;
				this.onPartData = noop;
				this.onPartEnd = noop;
				this.boundaryChars = {};
				boundary = '\r\n--' + boundary;
				const ui8a = new Uint8Array(boundary.length);
				for (let i2 = 0; i2 < boundary.length; i2++) {
					ui8a[i2] = boundary.charCodeAt(i2);
					this.boundaryChars[ui8a[i2]] = true;
				}
				this.boundary = ui8a;
				this.lookbehind = new Uint8Array(this.boundary.length + 8);
				this.state = S.START_BOUNDARY;
			}
			write(data2) {
				let i2 = 0;
				const length_ = data2.length;
				let previousIndex = this.index;
				let { lookbehind, boundary, boundaryChars, index: index6, state, flags } = this;
				const boundaryLength = this.boundary.length;
				const boundaryEnd = boundaryLength - 1;
				const bufferLength = data2.length;
				let c;
				let cl;
				const mark3 = (name) => {
					this[name + 'Mark'] = i2;
				};
				const clear = (name) => {
					delete this[name + 'Mark'];
				};
				const callback = (callbackSymbol, start, end, ui8a) => {
					if (start === void 0 || start !== end) {
						this[callbackSymbol](ui8a && ui8a.subarray(start, end));
					}
				};
				const dataCallback = (name, clear2) => {
					const markSymbol = name + 'Mark';
					if (!(markSymbol in this)) {
						return;
					}
					if (clear2) {
						callback(name, this[markSymbol], i2, data2);
						delete this[markSymbol];
					} else {
						callback(name, this[markSymbol], data2.length, data2);
						this[markSymbol] = 0;
					}
				};
				for (i2 = 0; i2 < length_; i2++) {
					c = data2[i2];
					switch (state) {
						case S.START_BOUNDARY:
							if (index6 === boundary.length - 2) {
								if (c === HYPHEN) {
									flags |= F.LAST_BOUNDARY;
								} else if (c !== CR) {
									return;
								}
								index6++;
								break;
							} else if (index6 - 1 === boundary.length - 2) {
								if (flags & F.LAST_BOUNDARY && c === HYPHEN) {
									state = S.END;
									flags = 0;
								} else if (!(flags & F.LAST_BOUNDARY) && c === LF) {
									index6 = 0;
									callback('onPartBegin');
									state = S.HEADER_FIELD_START;
								} else {
									return;
								}
								break;
							}
							if (c !== boundary[index6 + 2]) {
								index6 = -2;
							}
							if (c === boundary[index6 + 2]) {
								index6++;
							}
							break;
						case S.HEADER_FIELD_START:
							state = S.HEADER_FIELD;
							mark3('onHeaderField');
							index6 = 0;
						case S.HEADER_FIELD:
							if (c === CR) {
								clear('onHeaderField');
								state = S.HEADERS_ALMOST_DONE;
								break;
							}
							index6++;
							if (c === HYPHEN) {
								break;
							}
							if (c === COLON) {
								if (index6 === 1) {
									return;
								}
								dataCallback('onHeaderField', true);
								state = S.HEADER_VALUE_START;
								break;
							}
							cl = lower(c);
							if (cl < A || cl > Z) {
								return;
							}
							break;
						case S.HEADER_VALUE_START:
							if (c === SPACE) {
								break;
							}
							mark3('onHeaderValue');
							state = S.HEADER_VALUE;
						case S.HEADER_VALUE:
							if (c === CR) {
								dataCallback('onHeaderValue', true);
								callback('onHeaderEnd');
								state = S.HEADER_VALUE_ALMOST_DONE;
							}
							break;
						case S.HEADER_VALUE_ALMOST_DONE:
							if (c !== LF) {
								return;
							}
							state = S.HEADER_FIELD_START;
							break;
						case S.HEADERS_ALMOST_DONE:
							if (c !== LF) {
								return;
							}
							callback('onHeadersEnd');
							state = S.PART_DATA_START;
							break;
						case S.PART_DATA_START:
							state = S.PART_DATA;
							mark3('onPartData');
						case S.PART_DATA:
							previousIndex = index6;
							if (index6 === 0) {
								i2 += boundaryEnd;
								while (i2 < bufferLength && !(data2[i2] in boundaryChars)) {
									i2 += boundaryLength;
								}
								i2 -= boundaryEnd;
								c = data2[i2];
							}
							if (index6 < boundary.length) {
								if (boundary[index6] === c) {
									if (index6 === 0) {
										dataCallback('onPartData', true);
									}
									index6++;
								} else {
									index6 = 0;
								}
							} else if (index6 === boundary.length) {
								index6++;
								if (c === CR) {
									flags |= F.PART_BOUNDARY;
								} else if (c === HYPHEN) {
									flags |= F.LAST_BOUNDARY;
								} else {
									index6 = 0;
								}
							} else if (index6 - 1 === boundary.length) {
								if (flags & F.PART_BOUNDARY) {
									index6 = 0;
									if (c === LF) {
										flags &= ~F.PART_BOUNDARY;
										callback('onPartEnd');
										callback('onPartBegin');
										state = S.HEADER_FIELD_START;
										break;
									}
								} else if (flags & F.LAST_BOUNDARY) {
									if (c === HYPHEN) {
										callback('onPartEnd');
										state = S.END;
										flags = 0;
									} else {
										index6 = 0;
									}
								} else {
									index6 = 0;
								}
							}
							if (index6 > 0) {
								lookbehind[index6 - 1] = c;
							} else if (previousIndex > 0) {
								const _lookbehind = new Uint8Array(
									lookbehind.buffer,
									lookbehind.byteOffset,
									lookbehind.byteLength
								);
								callback('onPartData', 0, previousIndex, _lookbehind);
								previousIndex = 0;
								mark3('onPartData');
								i2--;
							}
							break;
						case S.END:
							break;
						default:
							throw new Error(`Unexpected state entered: ${state}`);
					}
				}
				dataCallback('onHeaderField');
				dataCallback('onHeaderValue');
				dataCallback('onPartData');
				this.index = index6;
				this.state = state;
				this.flags = flags;
			}
			end() {
				if (
					(this.state === S.HEADER_FIELD_START && this.index === 0) ||
					(this.state === S.PART_DATA && this.index === this.boundary.length)
				) {
					this.onPartEnd();
				} else if (this.state !== S.END) {
					throw new Error('MultipartParser.end(): stream ended unexpectedly');
				}
			}
		};
	}
});

// node_modules/@sveltejs/kit/dist/node.js
function isNonEmptyString(str) {
	return typeof str === 'string' && !!str.trim();
}
function parseString(setCookieValue, options) {
	var parts = setCookieValue.split(';').filter(isNonEmptyString);
	var nameValue = parts.shift().split('=');
	var name = nameValue.shift();
	var value = nameValue.join('=');
	options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
	try {
		value = options.decodeValues ? decodeURIComponent(value) : value;
	} catch (e2) {
		console.error(
			"set-cookie-parser encountered an error while decoding a cookie with value '" +
				value +
				"'. Set options.decodeValues to false to disable this feature.",
			e2
		);
	}
	var cookie = {
		name,
		value
	};
	parts.forEach(function (part) {
		var sides = part.split('=');
		var key3 = sides.shift().trimLeft().toLowerCase();
		var value2 = sides.join('=');
		if (key3 === 'expires') {
			cookie.expires = new Date(value2);
		} else if (key3 === 'max-age') {
			cookie.maxAge = parseInt(value2, 10);
		} else if (key3 === 'secure') {
			cookie.secure = true;
		} else if (key3 === 'httponly') {
			cookie.httpOnly = true;
		} else if (key3 === 'samesite') {
			cookie.sameSite = value2;
		} else {
			cookie[key3] = value2;
		}
	});
	return cookie;
}
function parse(input, options) {
	options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
	if (!input) {
		if (!options.map) {
			return [];
		} else {
			return {};
		}
	}
	if (input.headers && input.headers['set-cookie']) {
		input = input.headers['set-cookie'];
	} else if (input.headers) {
		var sch =
			input.headers[
				Object.keys(input.headers).find(function (key3) {
					return key3.toLowerCase() === 'set-cookie';
				})
			];
		if (!sch && input.headers.cookie && !options.silent) {
			console.warn(
				'Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.'
			);
		}
		input = sch;
	}
	if (!Array.isArray(input)) {
		input = [input];
	}
	options = options ? Object.assign({}, defaultParseOptions, options) : defaultParseOptions;
	if (!options.map) {
		return input.filter(isNonEmptyString).map(function (str) {
			return parseString(str, options);
		});
	} else {
		var cookies = {};
		return input.filter(isNonEmptyString).reduce(function (cookies2, str) {
			var cookie = parseString(str, options);
			cookies2[cookie.name] = cookie;
			return cookies2;
		}, cookies);
	}
}
function splitCookiesString(cookiesString) {
	if (Array.isArray(cookiesString)) {
		return cookiesString;
	}
	if (typeof cookiesString !== 'string') {
		return [];
	}
	var cookiesStrings = [];
	var pos = 0;
	var start;
	var ch;
	var lastComma;
	var nextStart;
	var cookiesSeparatorFound;
	function skipWhitespace() {
		while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
			pos += 1;
		}
		return pos < cookiesString.length;
	}
	function notSpecialChar() {
		ch = cookiesString.charAt(pos);
		return ch !== '=' && ch !== ';' && ch !== ',';
	}
	while (pos < cookiesString.length) {
		start = pos;
		cookiesSeparatorFound = false;
		while (skipWhitespace()) {
			ch = cookiesString.charAt(pos);
			if (ch === ',') {
				lastComma = pos;
				pos += 1;
				skipWhitespace();
				nextStart = pos;
				while (pos < cookiesString.length && notSpecialChar()) {
					pos += 1;
				}
				if (pos < cookiesString.length && cookiesString.charAt(pos) === '=') {
					cookiesSeparatorFound = true;
					pos = nextStart;
					cookiesStrings.push(cookiesString.substring(start, lastComma));
					start = pos;
				} else {
					pos = lastComma + 1;
				}
			} else {
				pos += 1;
			}
		}
		if (!cookiesSeparatorFound || pos >= cookiesString.length) {
			cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
		}
	}
	return cookiesStrings;
}
async function* toIterator(parts, clone2) {
	for (const part of parts) {
		if ('stream' in part) {
			yield* part.stream();
		} else if (ArrayBuffer.isView(part)) {
			if (clone2) {
				let position3 = part.byteOffset;
				const end = part.byteOffset + part.byteLength;
				while (position3 !== end) {
					const size = Math.min(end - position3, POOL_SIZE);
					const chunk = part.buffer.slice(position3, position3 + size);
					position3 += chunk.byteLength;
					yield new Uint8Array(chunk);
				}
			} else {
				yield part;
			}
		} else {
			let position3 = 0,
				b = part;
			while (position3 !== b.size) {
				const chunk = b.slice(position3, Math.min(b.size, position3 + POOL_SIZE));
				const buffer2 = await chunk.arrayBuffer();
				position3 += buffer2.byteLength;
				yield new Uint8Array(buffer2);
			}
		}
	}
}
function formDataToBlob(F2, B = Blob$12) {
	var b = `${r()}${r()}`.replace(/\./g, '').slice(-28).padStart(32, '-'),
		c = [],
		p2 = `--${b}\r
Content-Disposition: form-data; name="`;
	F2.forEach((v, n) =>
		typeof v == 'string'
			? c.push(
					p2 +
						e(n) +
						`"\r
\r
${v.replace(/\r(?!\n)|(?<!\r)\n/g, '\r\n')}\r
`
			  )
			: c.push(
					p2 +
						e(n) +
						`"; filename="${e(v.name, 1)}"\r
Content-Type: ${v.type || 'application/octet-stream'}\r
\r
`,
					v,
					'\r\n'
			  )
	);
	c.push(`--${b}--`);
	return new B(c, { type: 'multipart/form-data; boundary=' + b });
}
async function consumeBody(data2) {
	if (data2[INTERNALS$1].disturbed) {
		throw new TypeError(`body used already for: ${data2.url}`);
	}
	data2[INTERNALS$1].disturbed = true;
	if (data2[INTERNALS$1].error) {
		throw data2[INTERNALS$1].error;
	}
	const { body: body4 } = data2;
	if (body4 === null) {
		return import_node_buffer.Buffer.alloc(0);
	}
	if (!(body4 instanceof import_node_stream.default)) {
		return import_node_buffer.Buffer.alloc(0);
	}
	const accum = [];
	let accumBytes = 0;
	try {
		for await (const chunk of body4) {
			if (data2.size > 0 && accumBytes + chunk.length > data2.size) {
				const error2 = new FetchError(
					`content size at ${data2.url} over limit: ${data2.size}`,
					'max-size'
				);
				body4.destroy(error2);
				throw error2;
			}
			accumBytes += chunk.length;
			accum.push(chunk);
		}
	} catch (error2) {
		const error_ =
			error2 instanceof FetchBaseError
				? error2
				: new FetchError(
						`Invalid response body while trying to fetch ${data2.url}: ${error2.message}`,
						'system',
						error2
				  );
		throw error_;
	}
	if (body4.readableEnded === true || body4._readableState.ended === true) {
		try {
			if (accum.every((c) => typeof c === 'string')) {
				return import_node_buffer.Buffer.from(accum.join(''));
			}
			return import_node_buffer.Buffer.concat(accum, accumBytes);
		} catch (error2) {
			throw new FetchError(
				`Could not create Buffer from response body for ${data2.url}: ${error2.message}`,
				'system',
				error2
			);
		}
	} else {
		throw new FetchError(`Premature close of server response while trying to fetch ${data2.url}`);
	}
}
function validateReferrerPolicy(referrerPolicy2) {
	if (!ReferrerPolicy.has(referrerPolicy2)) {
		throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy2}`);
	}
	return referrerPolicy2;
}
function get_raw_body(req) {
	const h3 = req.headers;
	if (!h3['content-type']) {
		return null;
	}
	const length = Number(h3['content-length']);
	if (isNaN(length) && h3['transfer-encoding'] == null) {
		return null;
	}
	return new ReadableStream({
		start(controller) {
			req.on('error', (error2) => {
				controller.error(error2);
			});
			let size = 0;
			req.on('data', (chunk) => {
				size += chunk.length;
				if (size > length) {
					controller.error(new Error('content-length exceeded'));
				}
				controller.enqueue(chunk);
			});
			req.on('end', () => {
				controller.close();
			});
		}
	});
}
async function getRequest(base4, req) {
	let headers2 = req.headers;
	if (req.httpVersionMajor === 2) {
		headers2 = Object.assign({}, headers2);
		delete headers2[':method'];
		delete headers2[':path'];
		delete headers2[':authority'];
		delete headers2[':scheme'];
	}
	const request2 = new Request(base4 + req.url, {
		method: req.method,
		headers: headers2,
		body: get_raw_body(req)
	});
	request2.formData = async () => {
		return new Request$12(request2.url, {
			method: request2.method,
			headers: request2.headers,
			body: request2.body && import_stream2.Readable.from(request2.body)
		}).formData();
	};
	return request2;
}
async function setResponse(res, response2) {
	const headers2 = Object.fromEntries(response2.headers);
	if (response2.headers.has('set-cookie')) {
		const header = response2.headers.get('set-cookie');
		const split = splitCookiesString_1(header);
		headers2['set-cookie'] = split;
	}
	res.writeHead(response2.status, headers2);
	if (response2.body) {
		let cancelled = false;
		const reader = response2.body.getReader();
		res.on('close', () => {
			reader.cancel();
			cancelled = true;
		});
		const next = async () => {
			const { done, value } = await reader.read();
			if (cancelled) return;
			if (done) {
				res.end();
				return;
			}
			res.write(Buffer.from(value), (error2) => {
				if (error2) {
					console.error('Error writing stream', error2);
					res.end();
				} else {
					next();
				}
			});
		};
		next();
	} else {
		res.end();
	}
}
var import_node_http,
	import_node_stream,
	import_node_buffer,
	import_node_url,
	import_node_util,
	import_stream2,
	setCookie,
	defaultParseOptions,
	splitCookiesString_1,
	ponyfill_es2018,
	POOL_SIZE$1,
	POOL_SIZE,
	_Blob,
	Blob3,
	Blob$12,
	_File,
	File2,
	t,
	i,
	h,
	r,
	m,
	f2,
	e,
	x,
	FormData2,
	FetchBaseError,
	FetchError,
	NAME,
	isURLSearchParameters,
	isBlob,
	isAbortSignal,
	INTERNALS$1,
	Body,
	clone,
	getNonSpecFormDataBoundary,
	extractContentType,
	validateHeaderName2,
	validateHeaderValue2,
	Headers3,
	ReferrerPolicy,
	INTERNALS,
	isRequest,
	doBadDataWarn,
	Request$12;
var init_node = __esm({
	'node_modules/@sveltejs/kit/dist/node.js'() {
		import_node_http = __toESM(require('node:http'), 1);
		import_node_stream = __toESM(require('node:stream'), 1);
		import_node_buffer = require('node:buffer');
		import_node_url = require('node:url');
		import_node_util = require('node:util');
		init_commonjsHelpers();
		import_stream2 = require('stream');
		setCookie = { exports: {} };
		defaultParseOptions = {
			decodeValues: true,
			map: false,
			silent: false
		};
		setCookie.exports = parse;
		setCookie.exports.parse = parse;
		setCookie.exports.parseString = parseString;
		splitCookiesString_1 = setCookie.exports.splitCookiesString = splitCookiesString;
		ponyfill_es2018 = { exports: {} };
		(function (module2, exports) {
			(function (global3, factory2) {
				factory2(exports);
			})(commonjsGlobal, function (exports2) {
				const SymbolPolyfill =
					typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol'
						? Symbol
						: (description) => `Symbol(${description})`;
				function noop3() {
					return void 0;
				}
				function getGlobals() {
					if (typeof self !== 'undefined') {
						return self;
					} else if (typeof window !== 'undefined') {
						return window;
					} else if (typeof commonjsGlobal !== 'undefined') {
						return commonjsGlobal;
					}
					return void 0;
				}
				const globals2 = getGlobals();
				function typeIsObject(x2) {
					return (typeof x2 === 'object' && x2 !== null) || typeof x2 === 'function';
				}
				const rethrowAssertionErrorRejection = noop3;
				const originalPromise = Promise;
				const originalPromiseThen = Promise.prototype.then;
				const originalPromiseResolve = Promise.resolve.bind(originalPromise);
				const originalPromiseReject = Promise.reject.bind(originalPromise);
				function newPromise(executor) {
					return new originalPromise(executor);
				}
				function promiseResolvedWith(value) {
					return originalPromiseResolve(value);
				}
				function promiseRejectedWith(reason) {
					return originalPromiseReject(reason);
				}
				function PerformPromiseThen(promise, onFulfilled, onRejected) {
					return originalPromiseThen.call(promise, onFulfilled, onRejected);
				}
				function uponPromise(promise, onFulfilled, onRejected) {
					PerformPromiseThen(
						PerformPromiseThen(promise, onFulfilled, onRejected),
						void 0,
						rethrowAssertionErrorRejection
					);
				}
				function uponFulfillment(promise, onFulfilled) {
					uponPromise(promise, onFulfilled);
				}
				function uponRejection(promise, onRejected) {
					uponPromise(promise, void 0, onRejected);
				}
				function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
					return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
				}
				function setPromiseIsHandledToTrue(promise) {
					PerformPromiseThen(promise, void 0, rethrowAssertionErrorRejection);
				}
				const queueMicrotask2 = (() => {
					const globalQueueMicrotask = globals2 && globals2.queueMicrotask;
					if (typeof globalQueueMicrotask === 'function') {
						return globalQueueMicrotask;
					}
					const resolvedPromise = promiseResolvedWith(void 0);
					return (fn) => PerformPromiseThen(resolvedPromise, fn);
				})();
				function reflectCall(F2, V, args) {
					if (typeof F2 !== 'function') {
						throw new TypeError('Argument is not a function');
					}
					return Function.prototype.apply.call(F2, V, args);
				}
				function promiseCall(F2, V, args) {
					try {
						return promiseResolvedWith(reflectCall(F2, V, args));
					} catch (value) {
						return promiseRejectedWith(value);
					}
				}
				const QUEUE_MAX_ARRAY_SIZE = 16384;
				class SimpleQueue {
					constructor() {
						this._cursor = 0;
						this._size = 0;
						this._front = {
							_elements: [],
							_next: void 0
						};
						this._back = this._front;
						this._cursor = 0;
						this._size = 0;
					}
					get length() {
						return this._size;
					}
					push(element4) {
						const oldBack = this._back;
						let newBack = oldBack;
						if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
							newBack = {
								_elements: [],
								_next: void 0
							};
						}
						oldBack._elements.push(element4);
						if (newBack !== oldBack) {
							this._back = newBack;
							oldBack._next = newBack;
						}
						++this._size;
					}
					shift() {
						const oldFront = this._front;
						let newFront = oldFront;
						const oldCursor = this._cursor;
						let newCursor = oldCursor + 1;
						const elements = oldFront._elements;
						const element4 = elements[oldCursor];
						if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
							newFront = oldFront._next;
							newCursor = 0;
						}
						--this._size;
						this._cursor = newCursor;
						if (oldFront !== newFront) {
							this._front = newFront;
						}
						elements[oldCursor] = void 0;
						return element4;
					}
					forEach(callback) {
						let i2 = this._cursor;
						let node = this._front;
						let elements = node._elements;
						while (i2 !== elements.length || node._next !== void 0) {
							if (i2 === elements.length) {
								node = node._next;
								elements = node._elements;
								i2 = 0;
								if (elements.length === 0) {
									break;
								}
							}
							callback(elements[i2]);
							++i2;
						}
					}
					peek() {
						const front = this._front;
						const cursor = this._cursor;
						return front._elements[cursor];
					}
				}
				function ReadableStreamReaderGenericInitialize(reader, stream2) {
					reader._ownerReadableStream = stream2;
					stream2._reader = reader;
					if (stream2._state === 'readable') {
						defaultReaderClosedPromiseInitialize(reader);
					} else if (stream2._state === 'closed') {
						defaultReaderClosedPromiseInitializeAsResolved(reader);
					} else {
						defaultReaderClosedPromiseInitializeAsRejected(reader, stream2._storedError);
					}
				}
				function ReadableStreamReaderGenericCancel(reader, reason) {
					const stream2 = reader._ownerReadableStream;
					return ReadableStreamCancel(stream2, reason);
				}
				function ReadableStreamReaderGenericRelease(reader) {
					if (reader._ownerReadableStream._state === 'readable') {
						defaultReaderClosedPromiseReject(
							reader,
							new TypeError(
								`Reader was released and can no longer be used to monitor the stream's closedness`
							)
						);
					} else {
						defaultReaderClosedPromiseResetToRejected(
							reader,
							new TypeError(
								`Reader was released and can no longer be used to monitor the stream's closedness`
							)
						);
					}
					reader._ownerReadableStream._reader = void 0;
					reader._ownerReadableStream = void 0;
				}
				function readerLockException(name) {
					return new TypeError('Cannot ' + name + ' a stream using a released reader');
				}
				function defaultReaderClosedPromiseInitialize(reader) {
					reader._closedPromise = newPromise((resolve2, reject) => {
						reader._closedPromise_resolve = resolve2;
						reader._closedPromise_reject = reject;
					});
				}
				function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
					defaultReaderClosedPromiseInitialize(reader);
					defaultReaderClosedPromiseReject(reader, reason);
				}
				function defaultReaderClosedPromiseInitializeAsResolved(reader) {
					defaultReaderClosedPromiseInitialize(reader);
					defaultReaderClosedPromiseResolve(reader);
				}
				function defaultReaderClosedPromiseReject(reader, reason) {
					if (reader._closedPromise_reject === void 0) {
						return;
					}
					setPromiseIsHandledToTrue(reader._closedPromise);
					reader._closedPromise_reject(reason);
					reader._closedPromise_resolve = void 0;
					reader._closedPromise_reject = void 0;
				}
				function defaultReaderClosedPromiseResetToRejected(reader, reason) {
					defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
				}
				function defaultReaderClosedPromiseResolve(reader) {
					if (reader._closedPromise_resolve === void 0) {
						return;
					}
					reader._closedPromise_resolve(void 0);
					reader._closedPromise_resolve = void 0;
					reader._closedPromise_reject = void 0;
				}
				const AbortSteps = SymbolPolyfill('[[AbortSteps]]');
				const ErrorSteps = SymbolPolyfill('[[ErrorSteps]]');
				const CancelSteps = SymbolPolyfill('[[CancelSteps]]');
				const PullSteps = SymbolPolyfill('[[PullSteps]]');
				const NumberIsFinite =
					Number.isFinite ||
					function (x2) {
						return typeof x2 === 'number' && isFinite(x2);
					};
				const MathTrunc =
					Math.trunc ||
					function (v) {
						return v < 0 ? Math.ceil(v) : Math.floor(v);
					};
				function isDictionary(x2) {
					return typeof x2 === 'object' || typeof x2 === 'function';
				}
				function assertDictionary(obj, context) {
					if (obj !== void 0 && !isDictionary(obj)) {
						throw new TypeError(`${context} is not an object.`);
					}
				}
				function assertFunction(x2, context) {
					if (typeof x2 !== 'function') {
						throw new TypeError(`${context} is not a function.`);
					}
				}
				function isObject2(x2) {
					return (typeof x2 === 'object' && x2 !== null) || typeof x2 === 'function';
				}
				function assertObject(x2, context) {
					if (!isObject2(x2)) {
						throw new TypeError(`${context} is not an object.`);
					}
				}
				function assertRequiredArgument(x2, position3, context) {
					if (x2 === void 0) {
						throw new TypeError(`Parameter ${position3} is required in '${context}'.`);
					}
				}
				function assertRequiredField(x2, field, context) {
					if (x2 === void 0) {
						throw new TypeError(`${field} is required in '${context}'.`);
					}
				}
				function convertUnrestrictedDouble(value) {
					return Number(value);
				}
				function censorNegativeZero(x2) {
					return x2 === 0 ? 0 : x2;
				}
				function integerPart(x2) {
					return censorNegativeZero(MathTrunc(x2));
				}
				function convertUnsignedLongLongWithEnforceRange(value, context) {
					const lowerBound = 0;
					const upperBound = Number.MAX_SAFE_INTEGER;
					let x2 = Number(value);
					x2 = censorNegativeZero(x2);
					if (!NumberIsFinite(x2)) {
						throw new TypeError(`${context} is not a finite number`);
					}
					x2 = integerPart(x2);
					if (x2 < lowerBound || x2 > upperBound) {
						throw new TypeError(
							`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`
						);
					}
					if (!NumberIsFinite(x2) || x2 === 0) {
						return 0;
					}
					return x2;
				}
				function assertReadableStream(x2, context) {
					if (!IsReadableStream(x2)) {
						throw new TypeError(`${context} is not a ReadableStream.`);
					}
				}
				function AcquireReadableStreamDefaultReader(stream2) {
					return new ReadableStreamDefaultReader(stream2);
				}
				function ReadableStreamAddReadRequest(stream2, readRequest) {
					stream2._reader._readRequests.push(readRequest);
				}
				function ReadableStreamFulfillReadRequest(stream2, chunk, done) {
					const reader = stream2._reader;
					const readRequest = reader._readRequests.shift();
					if (done) {
						readRequest._closeSteps();
					} else {
						readRequest._chunkSteps(chunk);
					}
				}
				function ReadableStreamGetNumReadRequests(stream2) {
					return stream2._reader._readRequests.length;
				}
				function ReadableStreamHasDefaultReader(stream2) {
					const reader = stream2._reader;
					if (reader === void 0) {
						return false;
					}
					if (!IsReadableStreamDefaultReader(reader)) {
						return false;
					}
					return true;
				}
				class ReadableStreamDefaultReader {
					constructor(stream2) {
						assertRequiredArgument(stream2, 1, 'ReadableStreamDefaultReader');
						assertReadableStream(stream2, 'First parameter');
						if (IsReadableStreamLocked(stream2)) {
							throw new TypeError(
								'This stream has already been locked for exclusive reading by another reader'
							);
						}
						ReadableStreamReaderGenericInitialize(this, stream2);
						this._readRequests = new SimpleQueue();
					}
					get closed() {
						if (!IsReadableStreamDefaultReader(this)) {
							return promiseRejectedWith(defaultReaderBrandCheckException('closed'));
						}
						return this._closedPromise;
					}
					cancel(reason = void 0) {
						if (!IsReadableStreamDefaultReader(this)) {
							return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));
						}
						if (this._ownerReadableStream === void 0) {
							return promiseRejectedWith(readerLockException('cancel'));
						}
						return ReadableStreamReaderGenericCancel(this, reason);
					}
					read() {
						if (!IsReadableStreamDefaultReader(this)) {
							return promiseRejectedWith(defaultReaderBrandCheckException('read'));
						}
						if (this._ownerReadableStream === void 0) {
							return promiseRejectedWith(readerLockException('read from'));
						}
						let resolvePromise;
						let rejectPromise;
						const promise = newPromise((resolve2, reject) => {
							resolvePromise = resolve2;
							rejectPromise = reject;
						});
						const readRequest = {
							_chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
							_closeSteps: () => resolvePromise({ value: void 0, done: true }),
							_errorSteps: (e2) => rejectPromise(e2)
						};
						ReadableStreamDefaultReaderRead(this, readRequest);
						return promise;
					}
					releaseLock() {
						if (!IsReadableStreamDefaultReader(this)) {
							throw defaultReaderBrandCheckException('releaseLock');
						}
						if (this._ownerReadableStream === void 0) {
							return;
						}
						if (this._readRequests.length > 0) {
							throw new TypeError(
								'Tried to release a reader lock when that reader has pending read() calls un-settled'
							);
						}
						ReadableStreamReaderGenericRelease(this);
					}
				}
				Object.defineProperties(ReadableStreamDefaultReader.prototype, {
					cancel: { enumerable: true },
					read: { enumerable: true },
					releaseLock: { enumerable: true },
					closed: { enumerable: true }
				});
				if (typeof SymbolPolyfill.toStringTag === 'symbol') {
					Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
						value: 'ReadableStreamDefaultReader',
						configurable: true
					});
				}
				function IsReadableStreamDefaultReader(x2) {
					if (!typeIsObject(x2)) {
						return false;
					}
					if (!Object.prototype.hasOwnProperty.call(x2, '_readRequests')) {
						return false;
					}
					return x2 instanceof ReadableStreamDefaultReader;
				}
				function ReadableStreamDefaultReaderRead(reader, readRequest) {
					const stream2 = reader._ownerReadableStream;
					stream2._disturbed = true;
					if (stream2._state === 'closed') {
						readRequest._closeSteps();
					} else if (stream2._state === 'errored') {
						readRequest._errorSteps(stream2._storedError);
					} else {
						stream2._readableStreamController[PullSteps](readRequest);
					}
				}
				function defaultReaderBrandCheckException(name) {
					return new TypeError(
						`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`
					);
				}
				const AsyncIteratorPrototype = Object.getPrototypeOf(
					Object.getPrototypeOf(async function* () {}).prototype
				);
				class ReadableStreamAsyncIteratorImpl {
					constructor(reader, preventCancel) {
						this._ongoingPromise = void 0;
						this._isFinished = false;
						this._reader = reader;
						this._preventCancel = preventCancel;
					}
					next() {
						const nextSteps = () => this._nextSteps();
						this._ongoingPromise = this._ongoingPromise
							? transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps)
							: nextSteps();
						return this._ongoingPromise;
					}
					return(value) {
						const returnSteps = () => this._returnSteps(value);
						return this._ongoingPromise
							? transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps)
							: returnSteps();
					}
					_nextSteps() {
						if (this._isFinished) {
							return Promise.resolve({ value: void 0, done: true });
						}
						const reader = this._reader;
						if (reader._ownerReadableStream === void 0) {
							return promiseRejectedWith(readerLockException('iterate'));
						}
						let resolvePromise;
						let rejectPromise;
						const promise = newPromise((resolve2, reject) => {
							resolvePromise = resolve2;
							rejectPromise = reject;
						});
						const readRequest = {
							_chunkSteps: (chunk) => {
								this._ongoingPromise = void 0;
								queueMicrotask2(() => resolvePromise({ value: chunk, done: false }));
							},
							_closeSteps: () => {
								this._ongoingPromise = void 0;
								this._isFinished = true;
								ReadableStreamReaderGenericRelease(reader);
								resolvePromise({ value: void 0, done: true });
							},
							_errorSteps: (reason) => {
								this._ongoingPromise = void 0;
								this._isFinished = true;
								ReadableStreamReaderGenericRelease(reader);
								rejectPromise(reason);
							}
						};
						ReadableStreamDefaultReaderRead(reader, readRequest);
						return promise;
					}
					_returnSteps(value) {
						if (this._isFinished) {
							return Promise.resolve({ value, done: true });
						}
						this._isFinished = true;
						const reader = this._reader;
						if (reader._ownerReadableStream === void 0) {
							return promiseRejectedWith(readerLockException('finish iterating'));
						}
						if (!this._preventCancel) {
							const result = ReadableStreamReaderGenericCancel(reader, value);
							ReadableStreamReaderGenericRelease(reader);
							return transformPromiseWith(result, () => ({ value, done: true }));
						}
						ReadableStreamReaderGenericRelease(reader);
						return promiseResolvedWith({ value, done: true });
					}
				}
				const ReadableStreamAsyncIteratorPrototype = {
					next() {
						if (!IsReadableStreamAsyncIterator(this)) {
							return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));
						}
						return this._asyncIteratorImpl.next();
					},
					return(value) {
						if (!IsReadableStreamAsyncIterator(this)) {
							return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));
						}
						return this._asyncIteratorImpl.return(value);
					}
				};
				if (AsyncIteratorPrototype !== void 0) {
					Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
				}
				function AcquireReadableStreamAsyncIterator(stream2, preventCancel) {
					const reader = AcquireReadableStreamDefaultReader(stream2);
					const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
					const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
					iterator._asyncIteratorImpl = impl;
					return iterator;
				}
				function IsReadableStreamAsyncIterator(x2) {
					if (!typeIsObject(x2)) {
						return false;
					}
					if (!Object.prototype.hasOwnProperty.call(x2, '_asyncIteratorImpl')) {
						return false;
					}
					try {
						return x2._asyncIteratorImpl instanceof ReadableStreamAsyncIteratorImpl;
					} catch (_a) {
						return false;
					}
				}
				function streamAsyncIteratorBrandCheckException(name) {
					return new TypeError(
						`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`
					);
				}
				const NumberIsNaN =
					Number.isNaN ||
					function (x2) {
						return x2 !== x2;
					};
				function CreateArrayFromList(elements) {
					return elements.slice();
				}
				function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
					new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
				}
				function TransferArrayBuffer(O) {
					return O;
				}
				function IsDetachedBuffer(O) {
					return false;
				}
				function ArrayBufferSlice(buffer2, begin, end) {
					if (buffer2.slice) {
						return buffer2.slice(begin, end);
					}
					const length = end - begin;
					const slice = new ArrayBuffer(length);
					CopyDataBlockBytes(slice, 0, buffer2, begin, length);
					return slice;
				}
				function IsNonNegativeNumber(v) {
					if (typeof v !== 'number') {
						return false;
					}
					if (NumberIsNaN(v)) {
						return false;
					}
					if (v < 0) {
						return false;
					}
					return true;
				}
				function CloneAsUint8Array(O) {
					const buffer2 = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
					return new Uint8Array(buffer2);
				}
				function DequeueValue(container) {
					const pair = container._queue.shift();
					container._queueTotalSize -= pair.size;
					if (container._queueTotalSize < 0) {
						container._queueTotalSize = 0;
					}
					return pair.value;
				}
				function EnqueueValueWithSize(container, value, size) {
					if (!IsNonNegativeNumber(size) || size === Infinity) {
						throw new RangeError('Size must be a finite, non-NaN, non-negative number.');
					}
					container._queue.push({ value, size });
					container._queueTotalSize += size;
				}
				function PeekQueueValue(container) {
					const pair = container._queue.peek();
					return pair.value;
				}
				function ResetQueue(container) {
					container._queue = new SimpleQueue();
					container._queueTotalSize = 0;
				}
				class ReadableStreamBYOBRequest {
					constructor() {
						throw new TypeError('Illegal constructor');
					}
					get view() {
						if (!IsReadableStreamBYOBRequest(this)) {
							throw byobRequestBrandCheckException('view');
						}
						return this._view;
					}
					respond(bytesWritten) {
						if (!IsReadableStreamBYOBRequest(this)) {
							throw byobRequestBrandCheckException('respond');
						}
						assertRequiredArgument(bytesWritten, 1, 'respond');
						bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');
						if (this._associatedReadableByteStreamController === void 0) {
							throw new TypeError('This BYOB request has been invalidated');
						}
						if (IsDetachedBuffer(this._view.buffer));
						ReadableByteStreamControllerRespond(
							this._associatedReadableByteStreamController,
							bytesWritten
						);
					}
					respondWithNewView(view) {
						if (!IsReadableStreamBYOBRequest(this)) {
							throw byobRequestBrandCheckException('respondWithNewView');
						}
						assertRequiredArgument(view, 1, 'respondWithNewView');
						if (!ArrayBuffer.isView(view)) {
							throw new TypeError('You can only respond with array buffer views');
						}
						if (this._associatedReadableByteStreamController === void 0) {
							throw new TypeError('This BYOB request has been invalidated');
						}
						if (IsDetachedBuffer(view.buffer));
						ReadableByteStreamControllerRespondWithNewView(
							this._associatedReadableByteStreamController,
							view
						);
					}
				}
				Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
					respond: { enumerable: true },
					respondWithNewView: { enumerable: true },
					view: { enumerable: true }
				});
				if (typeof SymbolPolyfill.toStringTag === 'symbol') {
					Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
						value: 'ReadableStreamBYOBRequest',
						configurable: true
					});
				}
				class ReadableByteStreamController {
					constructor() {
						throw new TypeError('Illegal constructor');
					}
					get byobRequest() {
						if (!IsReadableByteStreamController(this)) {
							throw byteStreamControllerBrandCheckException('byobRequest');
						}
						return ReadableByteStreamControllerGetBYOBRequest(this);
					}
					get desiredSize() {
						if (!IsReadableByteStreamController(this)) {
							throw byteStreamControllerBrandCheckException('desiredSize');
						}
						return ReadableByteStreamControllerGetDesiredSize(this);
					}
					close() {
						if (!IsReadableByteStreamController(this)) {
							throw byteStreamControllerBrandCheckException('close');
						}
						if (this._closeRequested) {
							throw new TypeError('The stream has already been closed; do not close it again!');
						}
						const state = this._controlledReadableByteStream._state;
						if (state !== 'readable') {
							throw new TypeError(
								`The stream (in ${state} state) is not in the readable state and cannot be closed`
							);
						}
						ReadableByteStreamControllerClose(this);
					}
					enqueue(chunk) {
						if (!IsReadableByteStreamController(this)) {
							throw byteStreamControllerBrandCheckException('enqueue');
						}
						assertRequiredArgument(chunk, 1, 'enqueue');
						if (!ArrayBuffer.isView(chunk)) {
							throw new TypeError('chunk must be an array buffer view');
						}
						if (chunk.byteLength === 0) {
							throw new TypeError('chunk must have non-zero byteLength');
						}
						if (chunk.buffer.byteLength === 0) {
							throw new TypeError(`chunk's buffer must have non-zero byteLength`);
						}
						if (this._closeRequested) {
							throw new TypeError('stream is closed or draining');
						}
						const state = this._controlledReadableByteStream._state;
						if (state !== 'readable') {
							throw new TypeError(
								`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`
							);
						}
						ReadableByteStreamControllerEnqueue(this, chunk);
					}
					error(e2 = void 0) {
						if (!IsReadableByteStreamController(this)) {
							throw byteStreamControllerBrandCheckException('error');
						}
						ReadableByteStreamControllerError(this, e2);
					}
					[CancelSteps](reason) {
						ReadableByteStreamControllerClearPendingPullIntos(this);
						ResetQueue(this);
						const result = this._cancelAlgorithm(reason);
						ReadableByteStreamControllerClearAlgorithms(this);
						return result;
					}
					[PullSteps](readRequest) {
						const stream2 = this._controlledReadableByteStream;
						if (this._queueTotalSize > 0) {
							const entry5 = this._queue.shift();
							this._queueTotalSize -= entry5.byteLength;
							ReadableByteStreamControllerHandleQueueDrain(this);
							const view = new Uint8Array(entry5.buffer, entry5.byteOffset, entry5.byteLength);
							readRequest._chunkSteps(view);
							return;
						}
						const autoAllocateChunkSize = this._autoAllocateChunkSize;
						if (autoAllocateChunkSize !== void 0) {
							let buffer2;
							try {
								buffer2 = new ArrayBuffer(autoAllocateChunkSize);
							} catch (bufferE) {
								readRequest._errorSteps(bufferE);
								return;
							}
							const pullIntoDescriptor = {
								buffer: buffer2,
								bufferByteLength: autoAllocateChunkSize,
								byteOffset: 0,
								byteLength: autoAllocateChunkSize,
								bytesFilled: 0,
								elementSize: 1,
								viewConstructor: Uint8Array,
								readerType: 'default'
							};
							this._pendingPullIntos.push(pullIntoDescriptor);
						}
						ReadableStreamAddReadRequest(stream2, readRequest);
						ReadableByteStreamControllerCallPullIfNeeded(this);
					}
				}
				Object.defineProperties(ReadableByteStreamController.prototype, {
					close: { enumerable: true },
					enqueue: { enumerable: true },
					error: { enumerable: true },
					byobRequest: { enumerable: true },
					desiredSize: { enumerable: true }
				});
				if (typeof SymbolPolyfill.toStringTag === 'symbol') {
					Object.defineProperty(
						ReadableByteStreamController.prototype,
						SymbolPolyfill.toStringTag,
						{
							value: 'ReadableByteStreamController',
							configurable: true
						}
					);
				}
				function IsReadableByteStreamController(x2) {
					if (!typeIsObject(x2)) {
						return false;
					}
					if (!Object.prototype.hasOwnProperty.call(x2, '_controlledReadableByteStream')) {
						return false;
					}
					return x2 instanceof ReadableByteStreamController;
				}
				function IsReadableStreamBYOBRequest(x2) {
					if (!typeIsObject(x2)) {
						return false;
					}
					if (
						!Object.prototype.hasOwnProperty.call(x2, '_associatedReadableByteStreamController')
					) {
						return false;
					}
					return x2 instanceof ReadableStreamBYOBRequest;
				}
				function ReadableByteStreamControllerCallPullIfNeeded(controller) {
					const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
					if (!shouldPull) {
						return;
					}
					if (controller._pulling) {
						controller._pullAgain = true;
						return;
					}
					controller._pulling = true;
					const pullPromise = controller._pullAlgorithm();
					uponPromise(
						pullPromise,
						() => {
							controller._pulling = false;
							if (controller._pullAgain) {
								controller._pullAgain = false;
								ReadableByteStreamControllerCallPullIfNeeded(controller);
							}
						},
						(e2) => {
							ReadableByteStreamControllerError(controller, e2);
						}
					);
				}
				function ReadableByteStreamControllerClearPendingPullIntos(controller) {
					ReadableByteStreamControllerInvalidateBYOBRequest(controller);
					controller._pendingPullIntos = new SimpleQueue();
				}
				function ReadableByteStreamControllerCommitPullIntoDescriptor(stream2, pullIntoDescriptor) {
					let done = false;
					if (stream2._state === 'closed') {
						done = true;
					}
					const filledView =
						ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
					if (pullIntoDescriptor.readerType === 'default') {
						ReadableStreamFulfillReadRequest(stream2, filledView, done);
					} else {
						ReadableStreamFulfillReadIntoRequest(stream2, filledView, done);
					}
				}
				function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
					const bytesFilled = pullIntoDescriptor.bytesFilled;
					const elementSize = pullIntoDescriptor.elementSize;
					return new pullIntoDescriptor.viewConstructor(
						pullIntoDescriptor.buffer,
						pullIntoDescriptor.byteOffset,
						bytesFilled / elementSize
					);
				}
				function ReadableByteStreamControllerEnqueueChunkToQueue(
					controller,
					buffer2,
					byteOffset,
					byteLength
				) {
					controller._queue.push({ buffer: buffer2, byteOffset, byteLength });
					controller._queueTotalSize += byteLength;
				}
				function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(
					controller,
					pullIntoDescriptor
				) {
					const elementSize = pullIntoDescriptor.elementSize;
					const currentAlignedBytes =
						pullIntoDescriptor.bytesFilled - (pullIntoDescriptor.bytesFilled % elementSize);
					const maxBytesToCopy = Math.min(
						controller._queueTotalSize,
						pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled
					);
					const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
					const maxAlignedBytes = maxBytesFilled - (maxBytesFilled % elementSize);
					let totalBytesToCopyRemaining = maxBytesToCopy;
					let ready = false;
					if (maxAlignedBytes > currentAlignedBytes) {
						totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
						ready = true;
					}
					const queue = controller._queue;
					while (totalBytesToCopyRemaining > 0) {
						const headOfQueue = queue.peek();
						const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
						const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
						CopyDataBlockBytes(
							pullIntoDescriptor.buffer,
							destStart,
							headOfQueue.buffer,
							headOfQueue.byteOffset,
							bytesToCopy
						);
						if (headOfQueue.byteLength === bytesToCopy) {
							queue.shift();
						} else {
							headOfQueue.byteOffset += bytesToCopy;
							headOfQueue.byteLength -= bytesToCopy;
						}
						controller._queueTotalSize -= bytesToCopy;
						ReadableByteStreamControllerFillHeadPullIntoDescriptor(
							controller,
							bytesToCopy,
							pullIntoDescriptor
						);
						totalBytesToCopyRemaining -= bytesToCopy;
					}
					return ready;
				}
				function ReadableByteStreamControllerFillHeadPullIntoDescriptor(
					controller,
					size,
					pullIntoDescriptor
				) {
					pullIntoDescriptor.bytesFilled += size;
				}
				function ReadableByteStreamControllerHandleQueueDrain(controller) {
					if (controller._queueTotalSize === 0 && controller._closeRequested) {
						ReadableByteStreamControllerClearAlgorithms(controller);
						ReadableStreamClose(controller._controlledReadableByteStream);
					} else {
						ReadableByteStreamControllerCallPullIfNeeded(controller);
					}
				}
				function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
					if (controller._byobRequest === null) {
						return;
					}
					controller._byobRequest._associatedReadableByteStreamController = void 0;
					controller._byobRequest._view = null;
					controller._byobRequest = null;
				}
				function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
					while (controller._pendingPullIntos.length > 0) {
						if (controller._queueTotalSize === 0) {
							return;
						}
						const pullIntoDescriptor = controller._pendingPullIntos.peek();
						if (
							ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(
								controller,
								pullIntoDescriptor
							)
						) {
							ReadableByteStreamControllerShiftPendingPullInto(controller);
							ReadableByteStreamControllerCommitPullIntoDescriptor(
								controller._controlledReadableByteStream,
								pullIntoDescriptor
							);
						}
					}
				}
				function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
					const stream2 = controller._controlledReadableByteStream;
					let elementSize = 1;
					if (view.constructor !== DataView) {
						elementSize = view.constructor.BYTES_PER_ELEMENT;
					}
					const ctor = view.constructor;
					const buffer2 = TransferArrayBuffer(view.buffer);
					const pullIntoDescriptor = {
						buffer: buffer2,
						bufferByteLength: buffer2.byteLength,
						byteOffset: view.byteOffset,
						byteLength: view.byteLength,
						bytesFilled: 0,
						elementSize,
						viewConstructor: ctor,
						readerType: 'byob'
					};
					if (controller._pendingPullIntos.length > 0) {
						controller._pendingPullIntos.push(pullIntoDescriptor);
						ReadableStreamAddReadIntoRequest(stream2, readIntoRequest);
						return;
					}
					if (stream2._state === 'closed') {
						const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
						readIntoRequest._closeSteps(emptyView);
						return;
					}
					if (controller._queueTotalSize > 0) {
						if (
							ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(
								controller,
								pullIntoDescriptor
							)
						) {
							const filledView =
								ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
							ReadableByteStreamControllerHandleQueueDrain(controller);
							readIntoRequest._chunkSteps(filledView);
							return;
						}
						if (controller._closeRequested) {
							const e2 = new TypeError('Insufficient bytes to fill elements in the given buffer');
							ReadableByteStreamControllerError(controller, e2);
							readIntoRequest._errorSteps(e2);
							return;
						}
					}
					controller._pendingPullIntos.push(pullIntoDescriptor);
					ReadableStreamAddReadIntoRequest(stream2, readIntoRequest);
					ReadableByteStreamControllerCallPullIfNeeded(controller);
				}
				function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
					const stream2 = controller._controlledReadableByteStream;
					if (ReadableStreamHasBYOBReader(stream2)) {
						while (ReadableStreamGetNumReadIntoRequests(stream2) > 0) {
							const pullIntoDescriptor =
								ReadableByteStreamControllerShiftPendingPullInto(controller);
							ReadableByteStreamControllerCommitPullIntoDescriptor(stream2, pullIntoDescriptor);
						}
					}
				}
				function ReadableByteStreamControllerRespondInReadableState(
					controller,
					bytesWritten,
					pullIntoDescriptor
				) {
					ReadableByteStreamControllerFillHeadPullIntoDescriptor(
						controller,
						bytesWritten,
						pullIntoDescriptor
					);
					if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
						return;
					}
					ReadableByteStreamControllerShiftPendingPullInto(controller);
					const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
					if (remainderSize > 0) {
						const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
						const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
						ReadableByteStreamControllerEnqueueChunkToQueue(
							controller,
							remainder,
							0,
							remainder.byteLength
						);
					}
					pullIntoDescriptor.bytesFilled -= remainderSize;
					ReadableByteStreamControllerCommitPullIntoDescriptor(
						controller._controlledReadableByteStream,
						pullIntoDescriptor
					);
					ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
				}
				function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
					const firstDescriptor = controller._pendingPullIntos.peek();
					ReadableByteStreamControllerInvalidateBYOBRequest(controller);
					const state = controller._controlledReadableByteStream._state;
					if (state === 'closed') {
						ReadableByteStreamControllerRespondInClosedState(controller);
					} else {
						ReadableByteStreamControllerRespondInReadableState(
							controller,
							bytesWritten,
							firstDescriptor
						);
					}
					ReadableByteStreamControllerCallPullIfNeeded(controller);
				}
				function ReadableByteStreamControllerShiftPendingPullInto(controller) {
					const descriptor = controller._pendingPullIntos.shift();
					return descriptor;
				}
				function ReadableByteStreamControllerShouldCallPull(controller) {
					const stream2 = controller._controlledReadableByteStream;
					if (stream2._state !== 'readable') {
						return false;
					}
					if (controller._closeRequested) {
						return false;
					}
					if (!controller._started) {
						return false;
					}
					if (
						ReadableStreamHasDefaultReader(stream2) &&
						ReadableStreamGetNumReadRequests(stream2) > 0
					) {
						return true;
					}
					if (
						ReadableStreamHasBYOBReader(stream2) &&
						ReadableStreamGetNumReadIntoRequests(stream2) > 0
					) {
						return true;
					}
					const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
					if (desiredSize > 0) {
						return true;
					}
					return false;
				}
				function ReadableByteStreamControllerClearAlgorithms(controller) {
					controller._pullAlgorithm = void 0;
					controller._cancelAlgorithm = void 0;
				}
				function ReadableByteStreamControllerClose(controller) {
					const stream2 = controller._controlledReadableByteStream;
					if (controller._closeRequested || stream2._state !== 'readable') {
						return;
					}
					if (controller._queueTotalSize > 0) {
						controller._closeRequested = true;
						return;
					}
					if (controller._pendingPullIntos.length > 0) {
						const firstPendingPullInto = controller._pendingPullIntos.peek();
						if (firstPendingPullInto.bytesFilled > 0) {
							const e2 = new TypeError('Insufficient bytes to fill elements in the given buffer');
							ReadableByteStreamControllerError(controller, e2);
							throw e2;
						}
					}
					ReadableByteStreamControllerClearAlgorithms(controller);
					ReadableStreamClose(stream2);
				}
				function ReadableByteStreamControllerEnqueue(controller, chunk) {
					const stream2 = controller._controlledReadableByteStream;
					if (controller._closeRequested || stream2._state !== 'readable') {
						return;
					}
					const buffer2 = chunk.buffer;
					const byteOffset = chunk.byteOffset;
					const byteLength = chunk.byteLength;
					const transferredBuffer = TransferArrayBuffer(buffer2);
					if (controller._pendingPullIntos.length > 0) {
						const firstPendingPullInto = controller._pendingPullIntos.peek();
						if (IsDetachedBuffer(firstPendingPullInto.buffer));
						firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
					}
					ReadableByteStreamControllerInvalidateBYOBRequest(controller);
					if (ReadableStreamHasDefaultReader(stream2)) {
						if (ReadableStreamGetNumReadRequests(stream2) === 0) {
							ReadableByteStreamControllerEnqueueChunkToQueue(
								controller,
								transferredBuffer,
								byteOffset,
								byteLength
							);
						} else {
							if (controller._pendingPullIntos.length > 0) {
								ReadableByteStreamControllerShiftPendingPullInto(controller);
							}
							const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
							ReadableStreamFulfillReadRequest(stream2, transferredView, false);
						}
					} else if (ReadableStreamHasBYOBReader(stream2)) {
						ReadableByteStreamControllerEnqueueChunkToQueue(
							controller,
							transferredBuffer,
							byteOffset,
							byteLength
						);
						ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
					} else {
						ReadableByteStreamControllerEnqueueChunkToQueue(
							controller,
							transferredBuffer,
							byteOffset,
							byteLength
						);
					}
					ReadableByteStreamControllerCallPullIfNeeded(controller);
				}
				function ReadableByteStreamControllerError(controller, e2) {
					const stream2 = controller._controlledReadableByteStream;
					if (stream2._state !== 'readable') {
						return;
					}
					ReadableByteStreamControllerClearPendingPullIntos(controller);
					ResetQueue(controller);
					ReadableByteStreamControllerClearAlgorithms(controller);
					ReadableStreamError(stream2, e2);
				}
				function ReadableByteStreamControllerGetBYOBRequest(controller) {
					if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
						const firstDescriptor = controller._pendingPullIntos.peek();
						const view = new Uint8Array(
							firstDescriptor.buffer,
							firstDescriptor.byteOffset + firstDescriptor.bytesFilled,
							firstDescriptor.byteLength - firstDescriptor.bytesFilled
						);
						const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
						SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
						controller._byobRequest = byobRequest;
					}
					return controller._byobRequest;
				}
				function ReadableByteStreamControllerGetDesiredSize(controller) {
					const state = controller._controlledReadableByteStream._state;
					if (state === 'errored') {
						return null;
					}
					if (state === 'closed') {
						return 0;
					}
					return controller._strategyHWM - controller._queueTotalSize;
				}
				function ReadableByteStreamControllerRespond(controller, bytesWritten) {
					const firstDescriptor = controller._pendingPullIntos.peek();
					const state = controller._controlledReadableByteStream._state;
					if (state === 'closed') {
						if (bytesWritten !== 0) {
							throw new TypeError(
								'bytesWritten must be 0 when calling respond() on a closed stream'
							);
						}
					} else {
						if (bytesWritten === 0) {
							throw new TypeError(
								'bytesWritten must be greater than 0 when calling respond() on a readable stream'
							);
						}
						if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
							throw new RangeError('bytesWritten out of range');
						}
					}
					firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
					ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
				}
				function ReadableByteStreamControllerRespondWithNewView(controller, view) {
					const firstDescriptor = controller._pendingPullIntos.peek();
					const state = controller._controlledReadableByteStream._state;
					if (state === 'closed') {
						if (view.byteLength !== 0) {
							throw new TypeError(
								"The view's length must be 0 when calling respondWithNewView() on a closed stream"
							);
						}
					} else {
						if (view.byteLength === 0) {
							throw new TypeError(
								"The view's length must be greater than 0 when calling respondWithNewView() on a readable stream"
							);
						}
					}
					if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
						throw new RangeError('The region specified by view does not match byobRequest');
					}
					if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
						throw new RangeError('The buffer of view has different capacity than byobRequest');
					}
					if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
						throw new RangeError('The region specified by view is larger than byobRequest');
					}
					const viewByteLength = view.byteLength;
					firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
					ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
				}
				function SetUpReadableByteStreamController(
					stream2,
					controller,
					startAlgorithm,
					pullAlgorithm,
					cancelAlgorithm,
					highWaterMark,
					autoAllocateChunkSize
				) {
					controller._controlledReadableByteStream = stream2;
					controller._pullAgain = false;
					controller._pulling = false;
					controller._byobRequest = null;
					controller._queue = controller._queueTotalSize = void 0;
					ResetQueue(controller);
					controller._closeRequested = false;
					controller._started = false;
					controller._strategyHWM = highWaterMark;
					controller._pullAlgorithm = pullAlgorithm;
					controller._cancelAlgorithm = cancelAlgorithm;
					controller._autoAllocateChunkSize = autoAllocateChunkSize;
					controller._pendingPullIntos = new SimpleQueue();
					stream2._readableStreamController = controller;
					const startResult = startAlgorithm();
					uponPromise(
						promiseResolvedWith(startResult),
						() => {
							controller._started = true;
							ReadableByteStreamControllerCallPullIfNeeded(controller);
						},
						(r2) => {
							ReadableByteStreamControllerError(controller, r2);
						}
					);
				}
				function SetUpReadableByteStreamControllerFromUnderlyingSource(
					stream2,
					underlyingByteSource,
					highWaterMark
				) {
					const controller = Object.create(ReadableByteStreamController.prototype);
					let startAlgorithm = () => void 0;
					let pullAlgorithm = () => promiseResolvedWith(void 0);
					let cancelAlgorithm = () => promiseResolvedWith(void 0);
					if (underlyingByteSource.start !== void 0) {
						startAlgorithm = () => underlyingByteSource.start(controller);
					}
					if (underlyingByteSource.pull !== void 0) {
						pullAlgorithm = () => underlyingByteSource.pull(controller);
					}
					if (underlyingByteSource.cancel !== void 0) {
						cancelAlgorithm = (reason) => underlyingByteSource.cancel(reason);
					}
					const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
					if (autoAllocateChunkSize === 0) {
						throw new TypeError('autoAllocateChunkSize must be greater than 0');
					}
					SetUpReadableByteStreamController(
						stream2,
						controller,
						startAlgorithm,
						pullAlgorithm,
						cancelAlgorithm,
						highWaterMark,
						autoAllocateChunkSize
					);
				}
				function SetUpReadableStreamBYOBRequest(request2, controller, view) {
					request2._associatedReadableByteStreamController = controller;
					request2._view = view;
				}
				function byobRequestBrandCheckException(name) {
					return new TypeError(
						`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`
					);
				}
				function byteStreamControllerBrandCheckException(name) {
					return new TypeError(
						`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`
					);
				}
				function AcquireReadableStreamBYOBReader(stream2) {
					return new ReadableStreamBYOBReader(stream2);
				}
				function ReadableStreamAddReadIntoRequest(stream2, readIntoRequest) {
					stream2._reader._readIntoRequests.push(readIntoRequest);
				}
				function ReadableStreamFulfillReadIntoRequest(stream2, chunk, done) {
					const reader = stream2._reader;
					const readIntoRequest = reader._readIntoRequests.shift();
					if (done) {
						readIntoRequest._closeSteps(chunk);
					} else {
						readIntoRequest._chunkSteps(chunk);
					}
				}
				function ReadableStreamGetNumReadIntoRequests(stream2) {
					return stream2._reader._readIntoRequests.length;
				}
				function ReadableStreamHasBYOBReader(stream2) {
					const reader = stream2._reader;
					if (reader === void 0) {
						return false;
					}
					if (!IsReadableStreamBYOBReader(reader)) {
						return false;
					}
					return true;
				}
				class ReadableStreamBYOBReader {
					constructor(stream2) {
						assertRequiredArgument(stream2, 1, 'ReadableStreamBYOBReader');
						assertReadableStream(stream2, 'First parameter');
						if (IsReadableStreamLocked(stream2)) {
							throw new TypeError(
								'This stream has already been locked for exclusive reading by another reader'
							);
						}
						if (!IsReadableByteStreamController(stream2._readableStreamController)) {
							throw new TypeError(
								'Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte source'
							);
						}
						ReadableStreamReaderGenericInitialize(this, stream2);
						this._readIntoRequests = new SimpleQueue();
					}
					get closed() {
						if (!IsReadableStreamBYOBReader(this)) {
							return promiseRejectedWith(byobReaderBrandCheckException('closed'));
						}
						return this._closedPromise;
					}
					cancel(reason = void 0) {
						if (!IsReadableStreamBYOBReader(this)) {
							return promiseRejectedWith(byobReaderBrandCheckException('cancel'));
						}
						if (this._ownerReadableStream === void 0) {
							return promiseRejectedWith(readerLockException('cancel'));
						}
						return ReadableStreamReaderGenericCancel(this, reason);
					}
					read(view) {
						if (!IsReadableStreamBYOBReader(this)) {
							return promiseRejectedWith(byobReaderBrandCheckException('read'));
						}
						if (!ArrayBuffer.isView(view)) {
							return promiseRejectedWith(new TypeError('view must be an array buffer view'));
						}
						if (view.byteLength === 0) {
							return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));
						}
						if (view.buffer.byteLength === 0) {
							return promiseRejectedWith(
								new TypeError(`view's buffer must have non-zero byteLength`)
							);
						}
						if (IsDetachedBuffer(view.buffer));
						if (this._ownerReadableStream === void 0) {
							return promiseRejectedWith(readerLockException('read from'));
						}
						let resolvePromise;
						let rejectPromise;
						const promise = newPromise((resolve2, reject) => {
							resolvePromise = resolve2;
							rejectPromise = reject;
						});
						const readIntoRequest = {
							_chunkSteps: (chunk) => resolvePromise({ value: chunk, done: false }),
							_closeSteps: (chunk) => resolvePromise({ value: chunk, done: true }),
							_errorSteps: (e2) => rejectPromise(e2)
						};
						ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
						return promise;
					}
					releaseLock() {
						if (!IsReadableStreamBYOBReader(this)) {
							throw byobReaderBrandCheckException('releaseLock');
						}
						if (this._ownerReadableStream === void 0) {
							return;
						}
						if (this._readIntoRequests.length > 0) {
							throw new TypeError(
								'Tried to release a reader lock when that reader has pending read() calls un-settled'
							);
						}
						ReadableStreamReaderGenericRelease(this);
					}
				}
				Object.defineProperties(ReadableStreamBYOBReader.prototype, {
					cancel: { enumerable: true },
					read: { enumerable: true },
					releaseLock: { enumerable: true },
					closed: { enumerable: true }
				});
				if (typeof SymbolPolyfill.toStringTag === 'symbol') {
					Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
						value: 'ReadableStreamBYOBReader',
						configurable: true
					});
				}
				function IsReadableStreamBYOBReader(x2) {
					if (!typeIsObject(x2)) {
						return false;
					}
					if (!Object.prototype.hasOwnProperty.call(x2, '_readIntoRequests')) {
						return false;
					}
					return x2 instanceof ReadableStreamBYOBReader;
				}
				function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
					const stream2 = reader._ownerReadableStream;
					stream2._disturbed = true;
					if (stream2._state === 'errored') {
						readIntoRequest._errorSteps(stream2._storedError);
					} else {
						ReadableByteStreamControllerPullInto(
							stream2._readableStreamController,
							view,
							readIntoRequest
						);
					}
				}
				function byobReaderBrandCheckException(name) {
					return new TypeError(
						`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`
					);
				}
				function ExtractHighWaterMark(strategy, defaultHWM) {
					const { highWaterMark } = strategy;
					if (highWaterMark === void 0) {
						return defaultHWM;
					}
					if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
						throw new RangeError('Invalid highWaterMark');
					}
					return highWaterMark;
				}
				function ExtractSizeAlgorithm(strategy) {
					const { size } = strategy;
					if (!size) {
						return () => 1;
					}
					return size;
				}
				function convertQueuingStrategy(init2, context) {
					assertDictionary(init2, context);
					const highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
					const size = init2 === null || init2 === void 0 ? void 0 : init2.size;
					return {
						highWaterMark:
							highWaterMark === void 0 ? void 0 : convertUnrestrictedDouble(highWaterMark),
						size:
							size === void 0
								? void 0
								: convertQueuingStrategySize(size, `${context} has member 'size' that`)
					};
				}
				function convertQueuingStrategySize(fn, context) {
					assertFunction(fn, context);
					return (chunk) => convertUnrestrictedDouble(fn(chunk));
				}
				function convertUnderlyingSink(original, context) {
					assertDictionary(original, context);
					const abort2 = original === null || original === void 0 ? void 0 : original.abort;
					const close = original === null || original === void 0 ? void 0 : original.close;
					const start = original === null || original === void 0 ? void 0 : original.start;
					const type = original === null || original === void 0 ? void 0 : original.type;
					const write2 = original === null || original === void 0 ? void 0 : original.write;
					return {
						abort:
							abort2 === void 0
								? void 0
								: convertUnderlyingSinkAbortCallback(
										abort2,
										original,
										`${context} has member 'abort' that`
								  ),
						close:
							close === void 0
								? void 0
								: convertUnderlyingSinkCloseCallback(
										close,
										original,
										`${context} has member 'close' that`
								  ),
						start:
							start === void 0
								? void 0
								: convertUnderlyingSinkStartCallback(
										start,
										original,
										`${context} has member 'start' that`
								  ),
						write:
							write2 === void 0
								? void 0
								: convertUnderlyingSinkWriteCallback(
										write2,
										original,
										`${context} has member 'write' that`
								  ),
						type
					};
				}
				function convertUnderlyingSinkAbortCallback(fn, original, context) {
					assertFunction(fn, context);
					return (reason) => promiseCall(fn, original, [reason]);
				}
				function convertUnderlyingSinkCloseCallback(fn, original, context) {
					assertFunction(fn, context);
					return () => promiseCall(fn, original, []);
				}
				function convertUnderlyingSinkStartCallback(fn, original, context) {
					assertFunction(fn, context);
					return (controller) => reflectCall(fn, original, [controller]);
				}
				function convertUnderlyingSinkWriteCallback(fn, original, context) {
					assertFunction(fn, context);
					return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
				}
				function assertWritableStream(x2, context) {
					if (!IsWritableStream(x2)) {
						throw new TypeError(`${context} is not a WritableStream.`);
					}
				}
				function isAbortSignal2(value) {
					if (typeof value !== 'object' || value === null) {
						return false;
					}
					try {
						return typeof value.aborted === 'boolean';
					} catch (_a) {
						return false;
					}
				}
				const supportsAbortController = typeof AbortController === 'function';
				function createAbortController() {
					if (supportsAbortController) {
						return new AbortController();
					}
					return void 0;
				}
				class WritableStream2 {
					constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
						if (rawUnderlyingSink === void 0) {
							rawUnderlyingSink = null;
						} else {
							assertObject(rawUnderlyingSink, 'First parameter');
						}
						const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');
						const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');
						InitializeWritableStream(this);
						const type = underlyingSink.type;
						if (type !== void 0) {
							throw new RangeError('Invalid type is specified');
						}
						const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
						const highWaterMark = ExtractHighWaterMark(strategy, 1);
						SetUpWritableStreamDefaultControllerFromUnderlyingSink(
							this,
							underlyingSink,
							highWaterMark,
							sizeAlgorithm
						);
					}
					get locked() {
						if (!IsWritableStream(this)) {
							throw streamBrandCheckException$2('locked');
						}
						return IsWritableStreamLocked(this);
					}
					abort(reason = void 0) {
						if (!IsWritableStream(this)) {
							return promiseRejectedWith(streamBrandCheckException$2('abort'));
						}
						if (IsWritableStreamLocked(this)) {
							return promiseRejectedWith(
								new TypeError('Cannot abort a stream that already has a writer')
							);
						}
						return WritableStreamAbort(this, reason);
					}
					close() {
						if (!IsWritableStream(this)) {
							return promiseRejectedWith(streamBrandCheckException$2('close'));
						}
						if (IsWritableStreamLocked(this)) {
							return promiseRejectedWith(
								new TypeError('Cannot close a stream that already has a writer')
							);
						}
						if (WritableStreamCloseQueuedOrInFlight(this)) {
							return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));
						}
						return WritableStreamClose(this);
					}
					getWriter() {
						if (!IsWritableStream(this)) {
							throw streamBrandCheckException$2('getWriter');
						}
						return AcquireWritableStreamDefaultWriter(this);
					}
				}
				Object.defineProperties(WritableStream2.prototype, {
					abort: { enumerable: true },
					close: { enumerable: true },
					getWriter: { enumerable: true },
					locked: { enumerable: true }
				});
				if (typeof SymbolPolyfill.toStringTag === 'symbol') {
					Object.defineProperty(WritableStream2.prototype, SymbolPolyfill.toStringTag, {
						value: 'WritableStream',
						configurable: true
					});
				}
				function AcquireWritableStreamDefaultWriter(stream2) {
					return new WritableStreamDefaultWriter(stream2);
				}
				function CreateWritableStream(
					startAlgorithm,
					writeAlgorithm,
					closeAlgorithm,
					abortAlgorithm,
					highWaterMark = 1,
					sizeAlgorithm = () => 1
				) {
					const stream2 = Object.create(WritableStream2.prototype);
					InitializeWritableStream(stream2);
					const controller = Object.create(WritableStreamDefaultController.prototype);
					SetUpWritableStreamDefaultController(
						stream2,
						controller,
						startAlgorithm,
						writeAlgorithm,
						closeAlgorithm,
						abortAlgorithm,
						highWaterMark,
						sizeAlgorithm
					);
					return stream2;
				}
				function InitializeWritableStream(stream2) {
					stream2._state = 'writable';
					stream2._storedError = void 0;
					stream2._writer = void 0;
					stream2._writableStreamController = void 0;
					stream2._writeRequests = new SimpleQueue();
					stream2._inFlightWriteRequest = void 0;
					stream2._closeRequest = void 0;
					stream2._inFlightCloseRequest = void 0;
					stream2._pendingAbortRequest = void 0;
					stream2._backpressure = false;
				}
				function IsWritableStream(x2) {
					if (!typeIsObject(x2)) {
						return false;
					}
					if (!Object.prototype.hasOwnProperty.call(x2, '_writableStreamController')) {
						return false;
					}
					return x2 instanceof WritableStream2;
				}
				function IsWritableStreamLocked(stream2) {
					if (stream2._writer === void 0) {
						return false;
					}
					return true;
				}
				function WritableStreamAbort(stream2, reason) {
					var _a;
					if (stream2._state === 'closed' || stream2._state === 'errored') {
						return promiseResolvedWith(void 0);
					}
					stream2._writableStreamController._abortReason = reason;
					(_a = stream2._writableStreamController._abortController) === null || _a === void 0
						? void 0
						: _a.abort();
					const state = stream2._state;
					if (state === 'closed' || state === 'errored') {
						return promiseResolvedWith(void 0);
					}
					if (stream2._pendingAbortRequest !== void 0) {
						return stream2._pendingAbortRequest._promise;
					}
					let wasAlreadyErroring = false;
					if (state === 'erroring') {
						wasAlreadyErroring = true;
						reason = void 0;
					}
					const promise = newPromise((resolve2, reject) => {
						stream2._pendingAbortRequest = {
							_promise: void 0,
							_resolve: resolve2,
							_reject: reject,
							_reason: reason,
							_wasAlreadyErroring: wasAlreadyErroring
						};
					});
					stream2._pendingAbortRequest._promise = promise;
					if (!wasAlreadyErroring) {
						WritableStreamStartErroring(stream2, reason);
					}
					return promise;
				}
				function WritableStreamClose(stream2) {
					const state = stream2._state;
					if (state === 'closed' || state === 'errored') {
						return promiseRejectedWith(
							new TypeError(
								`The stream (in ${state} state) is not in the writable state and cannot be closed`
							)
						);
					}
					const promise = newPromise((resolve2, reject) => {
						const closeRequest = {
							_resolve: resolve2,
							_reject: reject
						};
						stream2._closeRequest = closeRequest;
					});
					const writer = stream2._writer;
					if (writer !== void 0 && stream2._backpressure && state === 'writable') {
						defaultWriterReadyPromiseResolve(writer);
					}
					WritableStreamDefaultControllerClose(stream2._writableStreamController);
					return promise;
				}
				function WritableStreamAddWriteRequest(stream2) {
					const promise = newPromise((resolve2, reject) => {
						const writeRequest = {
							_resolve: resolve2,
							_reject: reject
						};
						stream2._writeRequests.push(writeRequest);
					});
					return promise;
				}
				function WritableStreamDealWithRejection(stream2, error2) {
					const state = stream2._state;
					if (state === 'writable') {
						WritableStreamStartErroring(stream2, error2);
						return;
					}
					WritableStreamFinishErroring(stream2);
				}
				function WritableStreamStartErroring(stream2, reason) {
					const controller = stream2._writableStreamController;
					stream2._state = 'erroring';
					stream2._storedError = reason;
					const writer = stream2._writer;
					if (writer !== void 0) {
						WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
					}
					if (!WritableStreamHasOperationMarkedInFlight(stream2) && controller._started) {
						WritableStreamFinishErroring(stream2);
					}
				}
				function WritableStreamFinishErroring(stream2) {
					stream2._state = 'errored';
					stream2._writableStreamController[ErrorSteps]();
					const storedError = stream2._storedError;
					stream2._writeRequests.forEach((writeRequest) => {
						writeRequest._reject(storedError);
					});
					stream2._writeRequests = new SimpleQueue();
					if (stream2._pendingAbortRequest === void 0) {
						WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream2);
						return;
					}
					const abortRequest = stream2._pendingAbortRequest;
					stream2._pendingAbortRequest = void 0;
					if (abortRequest._wasAlreadyErroring) {
						abortRequest._reject(storedError);
						WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream2);
						return;
					}
					const promise = stream2._writableStreamController[AbortSteps](abortRequest._reason);
					uponPromise(
						promise,
						() => {
							abortRequest._resolve();
							WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream2);
						},
						(reason) => {
							abortRequest._reject(reason);
							WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream2);
						}
					);
				}
				function WritableStreamFinishInFlightWrite(stream2) {
					stream2._inFlightWriteRequest._resolve(void 0);
					stream2._inFlightWriteRequest = void 0;
				}
				function WritableStreamFinishInFlightWriteWithError(stream2, error2) {
					stream2._inFlightWriteRequest._reject(error2);
					stream2._inFlightWriteRequest = void 0;
					WritableStreamDealWithRejection(stream2, error2);
				}
				function WritableStreamFinishInFlightClose(stream2) {
					stream2._inFlightCloseRequest._resolve(void 0);
					stream2._inFlightCloseRequest = void 0;
					const state = stream2._state;
					if (state === 'erroring') {
						stream2._storedError = void 0;
						if (stream2._pendingAbortRequest !== void 0) {
							stream2._pendingAbortRequest._resolve();
							stream2._pendingAbortRequest = void 0;
						}
					}
					stream2._state = 'closed';
					const writer = stream2._writer;
					if (writer !== void 0) {
						defaultWriterClosedPromiseResolve(writer);
					}
				}
				function WritableStreamFinishInFlightCloseWithError(stream2, error2) {
					stream2._inFlightCloseRequest._reject(error2);
					stream2._inFlightCloseRequest = void 0;
					if (stream2._pendingAbortRequest !== void 0) {
						stream2._pendingAbortRequest._reject(error2);
						stream2._pendingAbortRequest = void 0;
					}
					WritableStreamDealWithRejection(stream2, error2);
				}
				function WritableStreamCloseQueuedOrInFlight(stream2) {
					if (stream2._closeRequest === void 0 && stream2._inFlightCloseRequest === void 0) {
						return false;
					}
					return true;
				}
				function WritableStreamHasOperationMarkedInFlight(stream2) {
					if (
						stream2._inFlightWriteRequest === void 0 &&
						stream2._inFlightCloseRequest === void 0
					) {
						return false;
					}
					return true;
				}
				function WritableStreamMarkCloseRequestInFlight(stream2) {
					stream2._inFlightCloseRequest = stream2._closeRequest;
					stream2._closeRequest = void 0;
				}
				function WritableStreamMarkFirstWriteRequestInFlight(stream2) {
					stream2._inFlightWriteRequest = stream2._writeRequests.shift();
				}
				function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream2) {
					if (stream2._closeRequest !== void 0) {
						stream2._closeRequest._reject(stream2._storedError);
						stream2._closeRequest = void 0;
					}
					const writer = stream2._writer;
					if (writer !== void 0) {
						defaultWriterClosedPromiseReject(writer, stream2._storedError);
					}
				}
				function WritableStreamUpdateBackpressure(stream2, backpressure) {
					const writer = stream2._writer;
					if (writer !== void 0 && backpressure !== stream2._backpressure) {
						if (backpressure) {
							defaultWriterReadyPromiseReset(writer);
						} else {
							defaultWriterReadyPromiseResolve(writer);
						}
					}
					stream2._backpressure = backpressure;
				}
				class WritableStreamDefaultWriter {
					constructor(stream2) {
						assertRequiredArgument(stream2, 1, 'WritableStreamDefaultWriter');
						assertWritableStream(stream2, 'First parameter');
						if (IsWritableStreamLocked(stream2)) {
							throw new TypeError(
								'This stream has already been locked for exclusive writing by another writer'
							);
						}
						this._ownerWritableStream = stream2;
						stream2._writer = this;
						const state = stream2._state;
						if (state === 'writable') {
							if (!WritableStreamCloseQueuedOrInFlight(stream2) && stream2._backpressure) {
								defaultWriterReadyPromiseInitialize(this);
							} else {
								defaultWriterReadyPromiseInitializeAsResolved(this);
							}
							defaultWriterClosedPromiseInitialize(this);
						} else if (state === 'erroring') {
							defaultWriterReadyPromiseInitializeAsRejected(this, stream2._storedError);
							defaultWriterClosedPromiseInitialize(this);
						} else if (state === 'closed') {
							defaultWriterReadyPromiseInitializeAsResolved(this);
							defaultWriterClosedPromiseInitializeAsResolved(this);
						} else {
							const storedError = stream2._storedError;
							defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
							defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
						}
					}
					get closed() {
						if (!IsWritableStreamDefaultWriter(this)) {
							return promiseRejectedWith(defaultWriterBrandCheckException('closed'));
						}
						return this._closedPromise;
					}
					get desiredSize() {
						if (!IsWritableStreamDefaultWriter(this)) {
							throw defaultWriterBrandCheckException('desiredSize');
						}
						if (this._ownerWritableStream === void 0) {
							throw defaultWriterLockException('desiredSize');
						}
						return WritableStreamDefaultWriterGetDesiredSize(this);
					}
					get ready() {
						if (!IsWritableStreamDefaultWriter(this)) {
							return promiseRejectedWith(defaultWriterBrandCheckException('ready'));
						}
						return this._readyPromise;
					}
					abort(reason = void 0) {
						if (!IsWritableStreamDefaultWriter(this)) {
							return promiseRejectedWith(defaultWriterBrandCheckException('abort'));
						}
						if (this._ownerWritableStream === void 0) {
							return promiseRejectedWith(defaultWriterLockException('abort'));
						}
						return WritableStreamDefaultWriterAbort(this, reason);
					}
					close() {
						if (!IsWritableStreamDefaultWriter(this)) {
							return promiseRejectedWith(defaultWriterBrandCheckException('close'));
						}
						const stream2 = this._ownerWritableStream;
						if (stream2 === void 0) {
							return promiseRejectedWith(defaultWriterLockException('close'));
						}
						if (WritableStreamCloseQueuedOrInFlight(stream2)) {
							return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));
						}
						return WritableStreamDefaultWriterClose(this);
					}
					releaseLock() {
						if (!IsWritableStreamDefaultWriter(this)) {
							throw defaultWriterBrandCheckException('releaseLock');
						}
						const stream2 = this._ownerWritableStream;
						if (stream2 === void 0) {
							return;
						}
						WritableStreamDefaultWriterRelease(this);
					}
					write(chunk = void 0) {
						if (!IsWritableStreamDefaultWriter(this)) {
							return promiseRejectedWith(defaultWriterBrandCheckException('write'));
						}
						if (this._ownerWritableStream === void 0) {
							return promiseRejectedWith(defaultWriterLockException('write to'));
						}
						return WritableStreamDefaultWriterWrite(this, chunk);
					}
				}
				Object.defineProperties(WritableStreamDefaultWriter.prototype, {
					abort: { enumerable: true },
					close: { enumerable: true },
					releaseLock: { enumerable: true },
					write: { enumerable: true },
					closed: { enumerable: true },
					desiredSize: { enumerable: true },
					ready: { enumerable: true }
				});
				if (typeof SymbolPolyfill.toStringTag === 'symbol') {
					Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
						value: 'WritableStreamDefaultWriter',
						configurable: true
					});
				}
				function IsWritableStreamDefaultWriter(x2) {
					if (!typeIsObject(x2)) {
						return false;
					}
					if (!Object.prototype.hasOwnProperty.call(x2, '_ownerWritableStream')) {
						return false;
					}
					return x2 instanceof WritableStreamDefaultWriter;
				}
				function WritableStreamDefaultWriterAbort(writer, reason) {
					const stream2 = writer._ownerWritableStream;
					return WritableStreamAbort(stream2, reason);
				}
				function WritableStreamDefaultWriterClose(writer) {
					const stream2 = writer._ownerWritableStream;
					return WritableStreamClose(stream2);
				}
				function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
					const stream2 = writer._ownerWritableStream;
					const state = stream2._state;
					if (WritableStreamCloseQueuedOrInFlight(stream2) || state === 'closed') {
						return promiseResolvedWith(void 0);
					}
					if (state === 'errored') {
						return promiseRejectedWith(stream2._storedError);
					}
					return WritableStreamDefaultWriterClose(writer);
				}
				function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error2) {
					if (writer._closedPromiseState === 'pending') {
						defaultWriterClosedPromiseReject(writer, error2);
					} else {
						defaultWriterClosedPromiseResetToRejected(writer, error2);
					}
				}
				function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error2) {
					if (writer._readyPromiseState === 'pending') {
						defaultWriterReadyPromiseReject(writer, error2);
					} else {
						defaultWriterReadyPromiseResetToRejected(writer, error2);
					}
				}
				function WritableStreamDefaultWriterGetDesiredSize(writer) {
					const stream2 = writer._ownerWritableStream;
					const state = stream2._state;
					if (state === 'errored' || state === 'erroring') {
						return null;
					}
					if (state === 'closed') {
						return 0;
					}
					return WritableStreamDefaultControllerGetDesiredSize(stream2._writableStreamController);
				}
				function WritableStreamDefaultWriterRelease(writer) {
					const stream2 = writer._ownerWritableStream;
					const releasedError = new TypeError(
						`Writer was released and can no longer be used to monitor the stream's closedness`
					);
					WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
					WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
					stream2._writer = void 0;
					writer._ownerWritableStream = void 0;
				}
				function WritableStreamDefaultWriterWrite(writer, chunk) {
					const stream2 = writer._ownerWritableStream;
					const controller = stream2._writableStreamController;
					const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
					if (stream2 !== writer._ownerWritableStream) {
						return promiseRejectedWith(defaultWriterLockException('write to'));
					}
					const state = stream2._state;
					if (state === 'errored') {
						return promiseRejectedWith(stream2._storedError);
					}
					if (WritableStreamCloseQueuedOrInFlight(stream2) || state === 'closed') {
						return promiseRejectedWith(
							new TypeError('The stream is closing or closed and cannot be written to')
						);
					}
					if (state === 'erroring') {
						return promiseRejectedWith(stream2._storedError);
					}
					const promise = WritableStreamAddWriteRequest(stream2);
					WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
					return promise;
				}
				const closeSentinel = {};
				class WritableStreamDefaultController {
					constructor() {
						throw new TypeError('Illegal constructor');
					}
					get abortReason() {
						if (!IsWritableStreamDefaultController(this)) {
							throw defaultControllerBrandCheckException$2('abortReason');
						}
						return this._abortReason;
					}
					get signal() {
						if (!IsWritableStreamDefaultController(this)) {
							throw defaultControllerBrandCheckException$2('signal');
						}
						if (this._abortController === void 0) {
							throw new TypeError(
								'WritableStreamDefaultController.prototype.signal is not supported'
							);
						}
						return this._abortController.signal;
					}
					error(e2 = void 0) {
						if (!IsWritableStreamDefaultController(this)) {
							throw defaultControllerBrandCheckException$2('error');
						}
						const state = this._controlledWritableStream._state;
						if (state !== 'writable') {
							return;
						}
						WritableStreamDefaultControllerError(this, e2);
					}
					[AbortSteps](reason) {
						const result = this._abortAlgorithm(reason);
						WritableStreamDefaultControllerClearAlgorithms(this);
						return result;
					}
					[ErrorSteps]() {
						ResetQueue(this);
					}
				}
				Object.defineProperties(WritableStreamDefaultController.prototype, {
					abortReason: { enumerable: true },
					signal: { enumerable: true },
					error: { enumerable: true }
				});
				if (typeof SymbolPolyfill.toStringTag === 'symbol') {
					Object.defineProperty(
						WritableStreamDefaultController.prototype,
						SymbolPolyfill.toStringTag,
						{
							value: 'WritableStreamDefaultController',
							configurable: true
						}
					);
				}
				function IsWritableStreamDefaultController(x2) {
					if (!typeIsObject(x2)) {
						return false;
					}
					if (!Object.prototype.hasOwnProperty.call(x2, '_controlledWritableStream')) {
						return false;
					}
					return x2 instanceof WritableStreamDefaultController;
				}
				function SetUpWritableStreamDefaultController(
					stream2,
					controller,
					startAlgorithm,
					writeAlgorithm,
					closeAlgorithm,
					abortAlgorithm,
					highWaterMark,
					sizeAlgorithm
				) {
					controller._controlledWritableStream = stream2;
					stream2._writableStreamController = controller;
					controller._queue = void 0;
					controller._queueTotalSize = void 0;
					ResetQueue(controller);
					controller._abortReason = void 0;
					controller._abortController = createAbortController();
					controller._started = false;
					controller._strategySizeAlgorithm = sizeAlgorithm;
					controller._strategyHWM = highWaterMark;
					controller._writeAlgorithm = writeAlgorithm;
					controller._closeAlgorithm = closeAlgorithm;
					controller._abortAlgorithm = abortAlgorithm;
					const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
					WritableStreamUpdateBackpressure(stream2, backpressure);
					const startResult = startAlgorithm();
					const startPromise = promiseResolvedWith(startResult);
					uponPromise(
						startPromise,
						() => {
							controller._started = true;
							WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
						},
						(r2) => {
							controller._started = true;
							WritableStreamDealWithRejection(stream2, r2);
						}
					);
				}
				function SetUpWritableStreamDefaultControllerFromUnderlyingSink(
					stream2,
					underlyingSink,
					highWaterMark,
					sizeAlgorithm
				) {
					const controller = Object.create(WritableStreamDefaultController.prototype);
					let startAlgorithm = () => void 0;
					let writeAlgorithm = () => promiseResolvedWith(void 0);
					let closeAlgorithm = () => promiseResolvedWith(void 0);
					let abortAlgorithm = () => promiseResolvedWith(void 0);
					if (underlyingSink.start !== void 0) {
						startAlgorithm = () => underlyingSink.start(controller);
					}
					if (underlyingSink.write !== void 0) {
						writeAlgorithm = (chunk) => underlyingSink.write(chunk, controller);
					}
					if (underlyingSink.close !== void 0) {
						closeAlgorithm = () => underlyingSink.close();
					}
					if (underlyingSink.abort !== void 0) {
						abortAlgorithm = (reason) => underlyingSink.abort(reason);
					}
					SetUpWritableStreamDefaultController(
						stream2,
						controller,
						startAlgorithm,
						writeAlgorithm,
						closeAlgorithm,
						abortAlgorithm,
						highWaterMark,
						sizeAlgorithm
					);
				}
				function WritableStreamDefaultControllerClearAlgorithms(controller) {
					controller._writeAlgorithm = void 0;
					controller._closeAlgorithm = void 0;
					controller._abortAlgorithm = void 0;
					controller._strategySizeAlgorithm = void 0;
				}
				function WritableStreamDefaultControllerClose(controller) {
					EnqueueValueWithSize(controller, closeSentinel, 0);
					WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
				}
				function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
					try {
						return controller._strategySizeAlgorithm(chunk);
					} catch (chunkSizeE) {
						WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
						return 1;
					}
				}
				function WritableStreamDefaultControllerGetDesiredSize(controller) {
					return controller._strategyHWM - controller._queueTotalSize;
				}
				function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
					try {
						EnqueueValueWithSize(controller, chunk, chunkSize);
					} catch (enqueueE) {
						WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
						return;
					}
					const stream2 = controller._controlledWritableStream;
					if (!WritableStreamCloseQueuedOrInFlight(stream2) && stream2._state === 'writable') {
						const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
						WritableStreamUpdateBackpressure(stream2, backpressure);
					}
					WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
				}
				function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
					const stream2 = controller._controlledWritableStream;
					if (!controller._started) {
						return;
					}
					if (stream2._inFlightWriteRequest !== void 0) {
						return;
					}
					const state = stream2._state;
					if (state === 'erroring') {
						WritableStreamFinishErroring(stream2);
						return;
					}
					if (controller._queue.length === 0) {
						return;
					}
					const value = PeekQueueValue(controller);
					if (value === closeSentinel) {
						WritableStreamDefaultControllerProcessClose(controller);
					} else {
						WritableStreamDefaultControllerProcessWrite(controller, value);
					}
				}
				function WritableStreamDefaultControllerErrorIfNeeded(controller, error2) {
					if (controller._controlledWritableStream._state === 'writable') {
						WritableStreamDefaultControllerError(controller, error2);
					}
				}
				function WritableStreamDefaultControllerProcessClose(controller) {
					const stream2 = controller._controlledWritableStream;
					WritableStreamMarkCloseRequestInFlight(stream2);
					DequeueValue(controller);
					const sinkClosePromise = controller._closeAlgorithm();
					WritableStreamDefaultControllerClearAlgorithms(controller);
					uponPromise(
						sinkClosePromise,
						() => {
							WritableStreamFinishInFlightClose(stream2);
						},
						(reason) => {
							WritableStreamFinishInFlightCloseWithError(stream2, reason);
						}
					);
				}
				function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
					const stream2 = controller._controlledWritableStream;
					WritableStreamMarkFirstWriteRequestInFlight(stream2);
					const sinkWritePromise = controller._writeAlgorithm(chunk);
					uponPromise(
						sinkWritePromise,
						() => {
							WritableStreamFinishInFlightWrite(stream2);
							const state = stream2._state;
							DequeueValue(controller);
							if (!WritableStreamCloseQueuedOrInFlight(stream2) && state === 'writable') {
								const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
								WritableStreamUpdateBackpressure(stream2, backpressure);
							}
							WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
						},
						(reason) => {
							if (stream2._state === 'writable') {
								WritableStreamDefaultControllerClearAlgorithms(controller);
							}
							WritableStreamFinishInFlightWriteWithError(stream2, reason);
						}
					);
				}
				function WritableStreamDefaultControllerGetBackpressure(controller) {
					const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
					return desiredSize <= 0;
				}
				function WritableStreamDefaultControllerError(controller, error2) {
					const stream2 = controller._controlledWritableStream;
					WritableStreamDefaultControllerClearAlgorithms(controller);
					WritableStreamStartErroring(stream2, error2);
				}
				function streamBrandCheckException$2(name) {
					return new TypeError(
						`WritableStream.prototype.${name} can only be used on a WritableStream`
					);
				}
				function defaultControllerBrandCheckException$2(name) {
					return new TypeError(
						`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`
					);
				}
				function defaultWriterBrandCheckException(name) {
					return new TypeError(
						`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`
					);
				}
				function defaultWriterLockException(name) {
					return new TypeError('Cannot ' + name + ' a stream using a released writer');
				}
				function defaultWriterClosedPromiseInitialize(writer) {
					writer._closedPromise = newPromise((resolve2, reject) => {
						writer._closedPromise_resolve = resolve2;
						writer._closedPromise_reject = reject;
						writer._closedPromiseState = 'pending';
					});
				}
				function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
					defaultWriterClosedPromiseInitialize(writer);
					defaultWriterClosedPromiseReject(writer, reason);
				}
				function defaultWriterClosedPromiseInitializeAsResolved(writer) {
					defaultWriterClosedPromiseInitialize(writer);
					defaultWriterClosedPromiseResolve(writer);
				}
				function defaultWriterClosedPromiseReject(writer, reason) {
					if (writer._closedPromise_reject === void 0) {
						return;
					}
					setPromiseIsHandledToTrue(writer._closedPromise);
					writer._closedPromise_reject(reason);
					writer._closedPromise_resolve = void 0;
					writer._closedPromise_reject = void 0;
					writer._closedPromiseState = 'rejected';
				}
				function defaultWriterClosedPromiseResetToRejected(writer, reason) {
					defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
				}
				function defaultWriterClosedPromiseResolve(writer) {
					if (writer._closedPromise_resolve === void 0) {
						return;
					}
					writer._closedPromise_resolve(void 0);
					writer._closedPromise_resolve = void 0;
					writer._closedPromise_reject = void 0;
					writer._closedPromiseState = 'resolved';
				}
				function defaultWriterReadyPromiseInitialize(writer) {
					writer._readyPromise = newPromise((resolve2, reject) => {
						writer._readyPromise_resolve = resolve2;
						writer._readyPromise_reject = reject;
					});
					writer._readyPromiseState = 'pending';
				}
				function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
					defaultWriterReadyPromiseInitialize(writer);
					defaultWriterReadyPromiseReject(writer, reason);
				}
				function defaultWriterReadyPromiseInitializeAsResolved(writer) {
					defaultWriterReadyPromiseInitialize(writer);
					defaultWriterReadyPromiseResolve(writer);
				}
				function defaultWriterReadyPromiseReject(writer, reason) {
					if (writer._readyPromise_reject === void 0) {
						return;
					}
					setPromiseIsHandledToTrue(writer._readyPromise);
					writer._readyPromise_reject(reason);
					writer._readyPromise_resolve = void 0;
					writer._readyPromise_reject = void 0;
					writer._readyPromiseState = 'rejected';
				}
				function defaultWriterReadyPromiseReset(writer) {
					defaultWriterReadyPromiseInitialize(writer);
				}
				function defaultWriterReadyPromiseResetToRejected(writer, reason) {
					defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
				}
				function defaultWriterReadyPromiseResolve(writer) {
					if (writer._readyPromise_resolve === void 0) {
						return;
					}
					writer._readyPromise_resolve(void 0);
					writer._readyPromise_resolve = void 0;
					writer._readyPromise_reject = void 0;
					writer._readyPromiseState = 'fulfilled';
				}
				const NativeDOMException = typeof DOMException !== 'undefined' ? DOMException : void 0;
				function isDOMExceptionConstructor(ctor) {
					if (!(typeof ctor === 'function' || typeof ctor === 'object')) {
						return false;
					}
					try {
						new ctor();
						return true;
					} catch (_a) {
						return false;
					}
				}
				function createDOMExceptionPolyfill() {
					const ctor = function DOMException2(message, name) {
						this.message = message || '';
						this.name = name || 'Error';
						if (Error.captureStackTrace) {
							Error.captureStackTrace(this, this.constructor);
						}
					};
					ctor.prototype = Object.create(Error.prototype);
					Object.defineProperty(ctor.prototype, 'constructor', {
						value: ctor,
						writable: true,
						configurable: true
					});
					return ctor;
				}
				const DOMException$1 = isDOMExceptionConstructor(NativeDOMException)
					? NativeDOMException
					: createDOMExceptionPolyfill();
				function ReadableStreamPipeTo(
					source,
					dest,
					preventClose,
					preventAbort,
					preventCancel,
					signal
				) {
					const reader = AcquireReadableStreamDefaultReader(source);
					const writer = AcquireWritableStreamDefaultWriter(dest);
					source._disturbed = true;
					let shuttingDown = false;
					let currentWrite = promiseResolvedWith(void 0);
					return newPromise((resolve2, reject) => {
						let abortAlgorithm;
						if (signal !== void 0) {
							abortAlgorithm = () => {
								const error2 = new DOMException$1('Aborted', 'AbortError');
								const actions = [];
								if (!preventAbort) {
									actions.push(() => {
										if (dest._state === 'writable') {
											return WritableStreamAbort(dest, error2);
										}
										return promiseResolvedWith(void 0);
									});
								}
								if (!preventCancel) {
									actions.push(() => {
										if (source._state === 'readable') {
											return ReadableStreamCancel(source, error2);
										}
										return promiseResolvedWith(void 0);
									});
								}
								shutdownWithAction(
									() => Promise.all(actions.map((action) => action())),
									true,
									error2
								);
							};
							if (signal.aborted) {
								abortAlgorithm();
								return;
							}
							signal.addEventListener('abort', abortAlgorithm);
						}
						function pipeLoop() {
							return newPromise((resolveLoop, rejectLoop) => {
								function next(done) {
									if (done) {
										resolveLoop();
									} else {
										PerformPromiseThen(pipeStep(), next, rejectLoop);
									}
								}
								next(false);
							});
						}
						function pipeStep() {
							if (shuttingDown) {
								return promiseResolvedWith(true);
							}
							return PerformPromiseThen(writer._readyPromise, () => {
								return newPromise((resolveRead, rejectRead) => {
									ReadableStreamDefaultReaderRead(reader, {
										_chunkSteps: (chunk) => {
											currentWrite = PerformPromiseThen(
												WritableStreamDefaultWriterWrite(writer, chunk),
												void 0,
												noop3
											);
											resolveRead(false);
										},
										_closeSteps: () => resolveRead(true),
										_errorSteps: rejectRead
									});
								});
							});
						}
						isOrBecomesErrored(source, reader._closedPromise, (storedError) => {
							if (!preventAbort) {
								shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
							} else {
								shutdown(true, storedError);
							}
						});
						isOrBecomesErrored(dest, writer._closedPromise, (storedError) => {
							if (!preventCancel) {
								shutdownWithAction(
									() => ReadableStreamCancel(source, storedError),
									true,
									storedError
								);
							} else {
								shutdown(true, storedError);
							}
						});
						isOrBecomesClosed(source, reader._closedPromise, () => {
							if (!preventClose) {
								shutdownWithAction(() =>
									WritableStreamDefaultWriterCloseWithErrorPropagation(writer)
								);
							} else {
								shutdown();
							}
						});
						if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {
							const destClosed = new TypeError(
								'the destination writable stream closed before all data could be piped to it'
							);
							if (!preventCancel) {
								shutdownWithAction(
									() => ReadableStreamCancel(source, destClosed),
									true,
									destClosed
								);
							} else {
								shutdown(true, destClosed);
							}
						}
						setPromiseIsHandledToTrue(pipeLoop());
						function waitForWritesToFinish() {
							const oldCurrentWrite = currentWrite;
							return PerformPromiseThen(currentWrite, () =>
								oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : void 0
							);
						}
						function isOrBecomesErrored(stream2, promise, action) {
							if (stream2._state === 'errored') {
								action(stream2._storedError);
							} else {
								uponRejection(promise, action);
							}
						}
						function isOrBecomesClosed(stream2, promise, action) {
							if (stream2._state === 'closed') {
								action();
							} else {
								uponFulfillment(promise, action);
							}
						}
						function shutdownWithAction(action, originalIsError, originalError) {
							if (shuttingDown) {
								return;
							}
							shuttingDown = true;
							if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {
								uponFulfillment(waitForWritesToFinish(), doTheRest);
							} else {
								doTheRest();
							}
							function doTheRest() {
								uponPromise(
									action(),
									() => finalize(originalIsError, originalError),
									(newError) => finalize(true, newError)
								);
							}
						}
						function shutdown(isError, error2) {
							if (shuttingDown) {
								return;
							}
							shuttingDown = true;
							if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {
								uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error2));
							} else {
								finalize(isError, error2);
							}
						}
						function finalize(isError, error2) {
							WritableStreamDefaultWriterRelease(writer);
							ReadableStreamReaderGenericRelease(reader);
							if (signal !== void 0) {
								signal.removeEventListener('abort', abortAlgorithm);
							}
							if (isError) {
								reject(error2);
							} else {
								resolve2(void 0);
							}
						}
					});
				}
				class ReadableStreamDefaultController {
					constructor() {
						throw new TypeError('Illegal constructor');
					}
					get desiredSize() {
						if (!IsReadableStreamDefaultController(this)) {
							throw defaultControllerBrandCheckException$1('desiredSize');
						}
						return ReadableStreamDefaultControllerGetDesiredSize(this);
					}
					close() {
						if (!IsReadableStreamDefaultController(this)) {
							throw defaultControllerBrandCheckException$1('close');
						}
						if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
							throw new TypeError('The stream is not in a state that permits close');
						}
						ReadableStreamDefaultControllerClose(this);
					}
					enqueue(chunk = void 0) {
						if (!IsReadableStreamDefaultController(this)) {
							throw defaultControllerBrandCheckException$1('enqueue');
						}
						if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
							throw new TypeError('The stream is not in a state that permits enqueue');
						}
						return ReadableStreamDefaultControllerEnqueue(this, chunk);
					}
					error(e2 = void 0) {
						if (!IsReadableStreamDefaultController(this)) {
							throw defaultControllerBrandCheckException$1('error');
						}
						ReadableStreamDefaultControllerError(this, e2);
					}
					[CancelSteps](reason) {
						ResetQueue(this);
						const result = this._cancelAlgorithm(reason);
						ReadableStreamDefaultControllerClearAlgorithms(this);
						return result;
					}
					[PullSteps](readRequest) {
						const stream2 = this._controlledReadableStream;
						if (this._queue.length > 0) {
							const chunk = DequeueValue(this);
							if (this._closeRequested && this._queue.length === 0) {
								ReadableStreamDefaultControllerClearAlgorithms(this);
								ReadableStreamClose(stream2);
							} else {
								ReadableStreamDefaultControllerCallPullIfNeeded(this);
							}
							readRequest._chunkSteps(chunk);
						} else {
							ReadableStreamAddReadRequest(stream2, readRequest);
							ReadableStreamDefaultControllerCallPullIfNeeded(this);
						}
					}
				}
				Object.defineProperties(ReadableStreamDefaultController.prototype, {
					close: { enumerable: true },
					enqueue: { enumerable: true },
					error: { enumerable: true },
					desiredSize: { enumerable: true }
				});
				if (typeof SymbolPolyfill.toStringTag === 'symbol') {
					Object.defineProperty(
						ReadableStreamDefaultController.prototype,
						SymbolPolyfill.toStringTag,
						{
							value: 'ReadableStreamDefaultController',
							configurable: true
						}
					);
				}
				function IsReadableStreamDefaultController(x2) {
					if (!typeIsObject(x2)) {
						return false;
					}
					if (!Object.prototype.hasOwnProperty.call(x2, '_controlledReadableStream')) {
						return false;
					}
					return x2 instanceof ReadableStreamDefaultController;
				}
				function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
					const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
					if (!shouldPull) {
						return;
					}
					if (controller._pulling) {
						controller._pullAgain = true;
						return;
					}
					controller._pulling = true;
					const pullPromise = controller._pullAlgorithm();
					uponPromise(
						pullPromise,
						() => {
							controller._pulling = false;
							if (controller._pullAgain) {
								controller._pullAgain = false;
								ReadableStreamDefaultControllerCallPullIfNeeded(controller);
							}
						},
						(e2) => {
							ReadableStreamDefaultControllerError(controller, e2);
						}
					);
				}
				function ReadableStreamDefaultControllerShouldCallPull(controller) {
					const stream2 = controller._controlledReadableStream;
					if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
						return false;
					}
					if (!controller._started) {
						return false;
					}
					if (IsReadableStreamLocked(stream2) && ReadableStreamGetNumReadRequests(stream2) > 0) {
						return true;
					}
					const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
					if (desiredSize > 0) {
						return true;
					}
					return false;
				}
				function ReadableStreamDefaultControllerClearAlgorithms(controller) {
					controller._pullAlgorithm = void 0;
					controller._cancelAlgorithm = void 0;
					controller._strategySizeAlgorithm = void 0;
				}
				function ReadableStreamDefaultControllerClose(controller) {
					if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
						return;
					}
					const stream2 = controller._controlledReadableStream;
					controller._closeRequested = true;
					if (controller._queue.length === 0) {
						ReadableStreamDefaultControllerClearAlgorithms(controller);
						ReadableStreamClose(stream2);
					}
				}
				function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
					if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
						return;
					}
					const stream2 = controller._controlledReadableStream;
					if (IsReadableStreamLocked(stream2) && ReadableStreamGetNumReadRequests(stream2) > 0) {
						ReadableStreamFulfillReadRequest(stream2, chunk, false);
					} else {
						let chunkSize;
						try {
							chunkSize = controller._strategySizeAlgorithm(chunk);
						} catch (chunkSizeE) {
							ReadableStreamDefaultControllerError(controller, chunkSizeE);
							throw chunkSizeE;
						}
						try {
							EnqueueValueWithSize(controller, chunk, chunkSize);
						} catch (enqueueE) {
							ReadableStreamDefaultControllerError(controller, enqueueE);
							throw enqueueE;
						}
					}
					ReadableStreamDefaultControllerCallPullIfNeeded(controller);
				}
				function ReadableStreamDefaultControllerError(controller, e2) {
					const stream2 = controller._controlledReadableStream;
					if (stream2._state !== 'readable') {
						return;
					}
					ResetQueue(controller);
					ReadableStreamDefaultControllerClearAlgorithms(controller);
					ReadableStreamError(stream2, e2);
				}
				function ReadableStreamDefaultControllerGetDesiredSize(controller) {
					const state = controller._controlledReadableStream._state;
					if (state === 'errored') {
						return null;
					}
					if (state === 'closed') {
						return 0;
					}
					return controller._strategyHWM - controller._queueTotalSize;
				}
				function ReadableStreamDefaultControllerHasBackpressure(controller) {
					if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
						return false;
					}
					return true;
				}
				function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
					const state = controller._controlledReadableStream._state;
					if (!controller._closeRequested && state === 'readable') {
						return true;
					}
					return false;
				}
				function SetUpReadableStreamDefaultController(
					stream2,
					controller,
					startAlgorithm,
					pullAlgorithm,
					cancelAlgorithm,
					highWaterMark,
					sizeAlgorithm
				) {
					controller._controlledReadableStream = stream2;
					controller._queue = void 0;
					controller._queueTotalSize = void 0;
					ResetQueue(controller);
					controller._started = false;
					controller._closeRequested = false;
					controller._pullAgain = false;
					controller._pulling = false;
					controller._strategySizeAlgorithm = sizeAlgorithm;
					controller._strategyHWM = highWaterMark;
					controller._pullAlgorithm = pullAlgorithm;
					controller._cancelAlgorithm = cancelAlgorithm;
					stream2._readableStreamController = controller;
					const startResult = startAlgorithm();
					uponPromise(
						promiseResolvedWith(startResult),
						() => {
							controller._started = true;
							ReadableStreamDefaultControllerCallPullIfNeeded(controller);
						},
						(r2) => {
							ReadableStreamDefaultControllerError(controller, r2);
						}
					);
				}
				function SetUpReadableStreamDefaultControllerFromUnderlyingSource(
					stream2,
					underlyingSource,
					highWaterMark,
					sizeAlgorithm
				) {
					const controller = Object.create(ReadableStreamDefaultController.prototype);
					let startAlgorithm = () => void 0;
					let pullAlgorithm = () => promiseResolvedWith(void 0);
					let cancelAlgorithm = () => promiseResolvedWith(void 0);
					if (underlyingSource.start !== void 0) {
						startAlgorithm = () => underlyingSource.start(controller);
					}
					if (underlyingSource.pull !== void 0) {
						pullAlgorithm = () => underlyingSource.pull(controller);
					}
					if (underlyingSource.cancel !== void 0) {
						cancelAlgorithm = (reason) => underlyingSource.cancel(reason);
					}
					SetUpReadableStreamDefaultController(
						stream2,
						controller,
						startAlgorithm,
						pullAlgorithm,
						cancelAlgorithm,
						highWaterMark,
						sizeAlgorithm
					);
				}
				function defaultControllerBrandCheckException$1(name) {
					return new TypeError(
						`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`
					);
				}
				function ReadableStreamTee(stream2, cloneForBranch2) {
					if (IsReadableByteStreamController(stream2._readableStreamController)) {
						return ReadableByteStreamTee(stream2);
					}
					return ReadableStreamDefaultTee(stream2);
				}
				function ReadableStreamDefaultTee(stream2, cloneForBranch2) {
					const reader = AcquireReadableStreamDefaultReader(stream2);
					let reading = false;
					let readAgain = false;
					let canceled1 = false;
					let canceled2 = false;
					let reason1;
					let reason2;
					let branch1;
					let branch2;
					let resolveCancelPromise;
					const cancelPromise = newPromise((resolve2) => {
						resolveCancelPromise = resolve2;
					});
					function pullAlgorithm() {
						if (reading) {
							readAgain = true;
							return promiseResolvedWith(void 0);
						}
						reading = true;
						const readRequest = {
							_chunkSteps: (chunk) => {
								queueMicrotask2(() => {
									readAgain = false;
									const chunk1 = chunk;
									const chunk2 = chunk;
									if (!canceled1) {
										ReadableStreamDefaultControllerEnqueue(
											branch1._readableStreamController,
											chunk1
										);
									}
									if (!canceled2) {
										ReadableStreamDefaultControllerEnqueue(
											branch2._readableStreamController,
											chunk2
										);
									}
									reading = false;
									if (readAgain) {
										pullAlgorithm();
									}
								});
							},
							_closeSteps: () => {
								reading = false;
								if (!canceled1) {
									ReadableStreamDefaultControllerClose(branch1._readableStreamController);
								}
								if (!canceled2) {
									ReadableStreamDefaultControllerClose(branch2._readableStreamController);
								}
								if (!canceled1 || !canceled2) {
									resolveCancelPromise(void 0);
								}
							},
							_errorSteps: () => {
								reading = false;
							}
						};
						ReadableStreamDefaultReaderRead(reader, readRequest);
						return promiseResolvedWith(void 0);
					}
					function cancel1Algorithm(reason) {
						canceled1 = true;
						reason1 = reason;
						if (canceled2) {
							const compositeReason = CreateArrayFromList([reason1, reason2]);
							const cancelResult = ReadableStreamCancel(stream2, compositeReason);
							resolveCancelPromise(cancelResult);
						}
						return cancelPromise;
					}
					function cancel2Algorithm(reason) {
						canceled2 = true;
						reason2 = reason;
						if (canceled1) {
							const compositeReason = CreateArrayFromList([reason1, reason2]);
							const cancelResult = ReadableStreamCancel(stream2, compositeReason);
							resolveCancelPromise(cancelResult);
						}
						return cancelPromise;
					}
					function startAlgorithm() {}
					branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
					branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
					uponRejection(reader._closedPromise, (r2) => {
						ReadableStreamDefaultControllerError(branch1._readableStreamController, r2);
						ReadableStreamDefaultControllerError(branch2._readableStreamController, r2);
						if (!canceled1 || !canceled2) {
							resolveCancelPromise(void 0);
						}
					});
					return [branch1, branch2];
				}
				function ReadableByteStreamTee(stream2) {
					let reader = AcquireReadableStreamDefaultReader(stream2);
					let reading = false;
					let readAgainForBranch1 = false;
					let readAgainForBranch2 = false;
					let canceled1 = false;
					let canceled2 = false;
					let reason1;
					let reason2;
					let branch1;
					let branch2;
					let resolveCancelPromise;
					const cancelPromise = newPromise((resolve2) => {
						resolveCancelPromise = resolve2;
					});
					function forwardReaderError(thisReader) {
						uponRejection(thisReader._closedPromise, (r2) => {
							if (thisReader !== reader) {
								return;
							}
							ReadableByteStreamControllerError(branch1._readableStreamController, r2);
							ReadableByteStreamControllerError(branch2._readableStreamController, r2);
							if (!canceled1 || !canceled2) {
								resolveCancelPromise(void 0);
							}
						});
					}
					function pullWithDefaultReader() {
						if (IsReadableStreamBYOBReader(reader)) {
							ReadableStreamReaderGenericRelease(reader);
							reader = AcquireReadableStreamDefaultReader(stream2);
							forwardReaderError(reader);
						}
						const readRequest = {
							_chunkSteps: (chunk) => {
								queueMicrotask2(() => {
									readAgainForBranch1 = false;
									readAgainForBranch2 = false;
									const chunk1 = chunk;
									let chunk2 = chunk;
									if (!canceled1 && !canceled2) {
										try {
											chunk2 = CloneAsUint8Array(chunk);
										} catch (cloneE) {
											ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
											ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
											resolveCancelPromise(ReadableStreamCancel(stream2, cloneE));
											return;
										}
									}
									if (!canceled1) {
										ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
									}
									if (!canceled2) {
										ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
									}
									reading = false;
									if (readAgainForBranch1) {
										pull1Algorithm();
									} else if (readAgainForBranch2) {
										pull2Algorithm();
									}
								});
							},
							_closeSteps: () => {
								reading = false;
								if (!canceled1) {
									ReadableByteStreamControllerClose(branch1._readableStreamController);
								}
								if (!canceled2) {
									ReadableByteStreamControllerClose(branch2._readableStreamController);
								}
								if (branch1._readableStreamController._pendingPullIntos.length > 0) {
									ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
								}
								if (branch2._readableStreamController._pendingPullIntos.length > 0) {
									ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
								}
								if (!canceled1 || !canceled2) {
									resolveCancelPromise(void 0);
								}
							},
							_errorSteps: () => {
								reading = false;
							}
						};
						ReadableStreamDefaultReaderRead(reader, readRequest);
					}
					function pullWithBYOBReader(view, forBranch2) {
						if (IsReadableStreamDefaultReader(reader)) {
							ReadableStreamReaderGenericRelease(reader);
							reader = AcquireReadableStreamBYOBReader(stream2);
							forwardReaderError(reader);
						}
						const byobBranch = forBranch2 ? branch2 : branch1;
						const otherBranch = forBranch2 ? branch1 : branch2;
						const readIntoRequest = {
							_chunkSteps: (chunk) => {
								queueMicrotask2(() => {
									readAgainForBranch1 = false;
									readAgainForBranch2 = false;
									const byobCanceled = forBranch2 ? canceled2 : canceled1;
									const otherCanceled = forBranch2 ? canceled1 : canceled2;
									if (!otherCanceled) {
										let clonedChunk;
										try {
											clonedChunk = CloneAsUint8Array(chunk);
										} catch (cloneE) {
											ReadableByteStreamControllerError(
												byobBranch._readableStreamController,
												cloneE
											);
											ReadableByteStreamControllerError(
												otherBranch._readableStreamController,
												cloneE
											);
											resolveCancelPromise(ReadableStreamCancel(stream2, cloneE));
											return;
										}
										if (!byobCanceled) {
											ReadableByteStreamControllerRespondWithNewView(
												byobBranch._readableStreamController,
												chunk
											);
										}
										ReadableByteStreamControllerEnqueue(
											otherBranch._readableStreamController,
											clonedChunk
										);
									} else if (!byobCanceled) {
										ReadableByteStreamControllerRespondWithNewView(
											byobBranch._readableStreamController,
											chunk
										);
									}
									reading = false;
									if (readAgainForBranch1) {
										pull1Algorithm();
									} else if (readAgainForBranch2) {
										pull2Algorithm();
									}
								});
							},
							_closeSteps: (chunk) => {
								reading = false;
								const byobCanceled = forBranch2 ? canceled2 : canceled1;
								const otherCanceled = forBranch2 ? canceled1 : canceled2;
								if (!byobCanceled) {
									ReadableByteStreamControllerClose(byobBranch._readableStreamController);
								}
								if (!otherCanceled) {
									ReadableByteStreamControllerClose(otherBranch._readableStreamController);
								}
								if (chunk !== void 0) {
									if (!byobCanceled) {
										ReadableByteStreamControllerRespondWithNewView(
											byobBranch._readableStreamController,
											chunk
										);
									}
									if (
										!otherCanceled &&
										otherBranch._readableStreamController._pendingPullIntos.length > 0
									) {
										ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
									}
								}
								if (!byobCanceled || !otherCanceled) {
									resolveCancelPromise(void 0);
								}
							},
							_errorSteps: () => {
								reading = false;
							}
						};
						ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
					}
					function pull1Algorithm() {
						if (reading) {
							readAgainForBranch1 = true;
							return promiseResolvedWith(void 0);
						}
						reading = true;
						const byobRequest = ReadableByteStreamControllerGetBYOBRequest(
							branch1._readableStreamController
						);
						if (byobRequest === null) {
							pullWithDefaultReader();
						} else {
							pullWithBYOBReader(byobRequest._view, false);
						}
						return promiseResolvedWith(void 0);
					}
					function pull2Algorithm() {
						if (reading) {
							readAgainForBranch2 = true;
							return promiseResolvedWith(void 0);
						}
						reading = true;
						const byobRequest = ReadableByteStreamControllerGetBYOBRequest(
							branch2._readableStreamController
						);
						if (byobRequest === null) {
							pullWithDefaultReader();
						} else {
							pullWithBYOBReader(byobRequest._view, true);
						}
						return promiseResolvedWith(void 0);
					}
					function cancel1Algorithm(reason) {
						canceled1 = true;
						reason1 = reason;
						if (canceled2) {
							const compositeReason = CreateArrayFromList([reason1, reason2]);
							const cancelResult = ReadableStreamCancel(stream2, compositeReason);
							resolveCancelPromise(cancelResult);
						}
						return cancelPromise;
					}
					function cancel2Algorithm(reason) {
						canceled2 = true;
						reason2 = reason;
						if (canceled1) {
							const compositeReason = CreateArrayFromList([reason1, reason2]);
							const cancelResult = ReadableStreamCancel(stream2, compositeReason);
							resolveCancelPromise(cancelResult);
						}
						return cancelPromise;
					}
					function startAlgorithm() {
						return;
					}
					branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
					branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
					forwardReaderError(reader);
					return [branch1, branch2];
				}
				function convertUnderlyingDefaultOrByteSource(source, context) {
					assertDictionary(source, context);
					const original = source;
					const autoAllocateChunkSize =
						original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
					const cancel = original === null || original === void 0 ? void 0 : original.cancel;
					const pull = original === null || original === void 0 ? void 0 : original.pull;
					const start = original === null || original === void 0 ? void 0 : original.start;
					const type = original === null || original === void 0 ? void 0 : original.type;
					return {
						autoAllocateChunkSize:
							autoAllocateChunkSize === void 0
								? void 0
								: convertUnsignedLongLongWithEnforceRange(
										autoAllocateChunkSize,
										`${context} has member 'autoAllocateChunkSize' that`
								  ),
						cancel:
							cancel === void 0
								? void 0
								: convertUnderlyingSourceCancelCallback(
										cancel,
										original,
										`${context} has member 'cancel' that`
								  ),
						pull:
							pull === void 0
								? void 0
								: convertUnderlyingSourcePullCallback(
										pull,
										original,
										`${context} has member 'pull' that`
								  ),
						start:
							start === void 0
								? void 0
								: convertUnderlyingSourceStartCallback(
										start,
										original,
										`${context} has member 'start' that`
								  ),
						type:
							type === void 0
								? void 0
								: convertReadableStreamType(type, `${context} has member 'type' that`)
					};
				}
				function convertUnderlyingSourceCancelCallback(fn, original, context) {
					assertFunction(fn, context);
					return (reason) => promiseCall(fn, original, [reason]);
				}
				function convertUnderlyingSourcePullCallback(fn, original, context) {
					assertFunction(fn, context);
					return (controller) => promiseCall(fn, original, [controller]);
				}
				function convertUnderlyingSourceStartCallback(fn, original, context) {
					assertFunction(fn, context);
					return (controller) => reflectCall(fn, original, [controller]);
				}
				function convertReadableStreamType(type, context) {
					type = `${type}`;
					if (type !== 'bytes') {
						throw new TypeError(
							`${context} '${type}' is not a valid enumeration value for ReadableStreamType`
						);
					}
					return type;
				}
				function convertReaderOptions(options, context) {
					assertDictionary(options, context);
					const mode = options === null || options === void 0 ? void 0 : options.mode;
					return {
						mode:
							mode === void 0
								? void 0
								: convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
					};
				}
				function convertReadableStreamReaderMode(mode, context) {
					mode = `${mode}`;
					if (mode !== 'byob') {
						throw new TypeError(
							`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`
						);
					}
					return mode;
				}
				function convertIteratorOptions(options, context) {
					assertDictionary(options, context);
					const preventCancel =
						options === null || options === void 0 ? void 0 : options.preventCancel;
					return { preventCancel: Boolean(preventCancel) };
				}
				function convertPipeOptions(options, context) {
					assertDictionary(options, context);
					const preventAbort =
						options === null || options === void 0 ? void 0 : options.preventAbort;
					const preventCancel =
						options === null || options === void 0 ? void 0 : options.preventCancel;
					const preventClose =
						options === null || options === void 0 ? void 0 : options.preventClose;
					const signal = options === null || options === void 0 ? void 0 : options.signal;
					if (signal !== void 0) {
						assertAbortSignal(signal, `${context} has member 'signal' that`);
					}
					return {
						preventAbort: Boolean(preventAbort),
						preventCancel: Boolean(preventCancel),
						preventClose: Boolean(preventClose),
						signal
					};
				}
				function assertAbortSignal(signal, context) {
					if (!isAbortSignal2(signal)) {
						throw new TypeError(`${context} is not an AbortSignal.`);
					}
				}
				function convertReadableWritablePair(pair, context) {
					assertDictionary(pair, context);
					const readable3 = pair === null || pair === void 0 ? void 0 : pair.readable;
					assertRequiredField(readable3, 'readable', 'ReadableWritablePair');
					assertReadableStream(readable3, `${context} has member 'readable' that`);
					const writable2 = pair === null || pair === void 0 ? void 0 : pair.writable;
					assertRequiredField(writable2, 'writable', 'ReadableWritablePair');
					assertWritableStream(writable2, `${context} has member 'writable' that`);
					return { readable: readable3, writable: writable2 };
				}
				class ReadableStream3 {
					constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
						if (rawUnderlyingSource === void 0) {
							rawUnderlyingSource = null;
						} else {
							assertObject(rawUnderlyingSource, 'First parameter');
						}
						const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');
						const underlyingSource = convertUnderlyingDefaultOrByteSource(
							rawUnderlyingSource,
							'First parameter'
						);
						InitializeReadableStream(this);
						if (underlyingSource.type === 'bytes') {
							if (strategy.size !== void 0) {
								throw new RangeError('The strategy for a byte stream cannot have a size function');
							}
							const highWaterMark = ExtractHighWaterMark(strategy, 0);
							SetUpReadableByteStreamControllerFromUnderlyingSource(
								this,
								underlyingSource,
								highWaterMark
							);
						} else {
							const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
							const highWaterMark = ExtractHighWaterMark(strategy, 1);
							SetUpReadableStreamDefaultControllerFromUnderlyingSource(
								this,
								underlyingSource,
								highWaterMark,
								sizeAlgorithm
							);
						}
					}
					get locked() {
						if (!IsReadableStream(this)) {
							throw streamBrandCheckException$1('locked');
						}
						return IsReadableStreamLocked(this);
					}
					cancel(reason = void 0) {
						if (!IsReadableStream(this)) {
							return promiseRejectedWith(streamBrandCheckException$1('cancel'));
						}
						if (IsReadableStreamLocked(this)) {
							return promiseRejectedWith(
								new TypeError('Cannot cancel a stream that already has a reader')
							);
						}
						return ReadableStreamCancel(this, reason);
					}
					getReader(rawOptions = void 0) {
						if (!IsReadableStream(this)) {
							throw streamBrandCheckException$1('getReader');
						}
						const options = convertReaderOptions(rawOptions, 'First parameter');
						if (options.mode === void 0) {
							return AcquireReadableStreamDefaultReader(this);
						}
						return AcquireReadableStreamBYOBReader(this);
					}
					pipeThrough(rawTransform, rawOptions = {}) {
						if (!IsReadableStream(this)) {
							throw streamBrandCheckException$1('pipeThrough');
						}
						assertRequiredArgument(rawTransform, 1, 'pipeThrough');
						const transform2 = convertReadableWritablePair(rawTransform, 'First parameter');
						const options = convertPipeOptions(rawOptions, 'Second parameter');
						if (IsReadableStreamLocked(this)) {
							throw new TypeError(
								'ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream'
							);
						}
						if (IsWritableStreamLocked(transform2.writable)) {
							throw new TypeError(
								'ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream'
							);
						}
						const promise = ReadableStreamPipeTo(
							this,
							transform2.writable,
							options.preventClose,
							options.preventAbort,
							options.preventCancel,
							options.signal
						);
						setPromiseIsHandledToTrue(promise);
						return transform2.readable;
					}
					pipeTo(destination, rawOptions = {}) {
						if (!IsReadableStream(this)) {
							return promiseRejectedWith(streamBrandCheckException$1('pipeTo'));
						}
						if (destination === void 0) {
							return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
						}
						if (!IsWritableStream(destination)) {
							return promiseRejectedWith(
								new TypeError(
									`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`
								)
							);
						}
						let options;
						try {
							options = convertPipeOptions(rawOptions, 'Second parameter');
						} catch (e2) {
							return promiseRejectedWith(e2);
						}
						if (IsReadableStreamLocked(this)) {
							return promiseRejectedWith(
								new TypeError(
									'ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'
								)
							);
						}
						if (IsWritableStreamLocked(destination)) {
							return promiseRejectedWith(
								new TypeError(
									'ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'
								)
							);
						}
						return ReadableStreamPipeTo(
							this,
							destination,
							options.preventClose,
							options.preventAbort,
							options.preventCancel,
							options.signal
						);
					}
					tee() {
						if (!IsReadableStream(this)) {
							throw streamBrandCheckException$1('tee');
						}
						const branches = ReadableStreamTee(this);
						return CreateArrayFromList(branches);
					}
					values(rawOptions = void 0) {
						if (!IsReadableStream(this)) {
							throw streamBrandCheckException$1('values');
						}
						const options = convertIteratorOptions(rawOptions, 'First parameter');
						return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
					}
				}
				Object.defineProperties(ReadableStream3.prototype, {
					cancel: { enumerable: true },
					getReader: { enumerable: true },
					pipeThrough: { enumerable: true },
					pipeTo: { enumerable: true },
					tee: { enumerable: true },
					values: { enumerable: true },
					locked: { enumerable: true }
				});
				if (typeof SymbolPolyfill.toStringTag === 'symbol') {
					Object.defineProperty(ReadableStream3.prototype, SymbolPolyfill.toStringTag, {
						value: 'ReadableStream',
						configurable: true
					});
				}
				if (typeof SymbolPolyfill.asyncIterator === 'symbol') {
					Object.defineProperty(ReadableStream3.prototype, SymbolPolyfill.asyncIterator, {
						value: ReadableStream3.prototype.values,
						writable: true,
						configurable: true
					});
				}
				function CreateReadableStream(
					startAlgorithm,
					pullAlgorithm,
					cancelAlgorithm,
					highWaterMark = 1,
					sizeAlgorithm = () => 1
				) {
					const stream2 = Object.create(ReadableStream3.prototype);
					InitializeReadableStream(stream2);
					const controller = Object.create(ReadableStreamDefaultController.prototype);
					SetUpReadableStreamDefaultController(
						stream2,
						controller,
						startAlgorithm,
						pullAlgorithm,
						cancelAlgorithm,
						highWaterMark,
						sizeAlgorithm
					);
					return stream2;
				}
				function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
					const stream2 = Object.create(ReadableStream3.prototype);
					InitializeReadableStream(stream2);
					const controller = Object.create(ReadableByteStreamController.prototype);
					SetUpReadableByteStreamController(
						stream2,
						controller,
						startAlgorithm,
						pullAlgorithm,
						cancelAlgorithm,
						0,
						void 0
					);
					return stream2;
				}
				function InitializeReadableStream(stream2) {
					stream2._state = 'readable';
					stream2._reader = void 0;
					stream2._storedError = void 0;
					stream2._disturbed = false;
				}
				function IsReadableStream(x2) {
					if (!typeIsObject(x2)) {
						return false;
					}
					if (!Object.prototype.hasOwnProperty.call(x2, '_readableStreamController')) {
						return false;
					}
					return x2 instanceof ReadableStream3;
				}
				function IsReadableStreamLocked(stream2) {
					if (stream2._reader === void 0) {
						return false;
					}
					return true;
				}
				function ReadableStreamCancel(stream2, reason) {
					stream2._disturbed = true;
					if (stream2._state === 'closed') {
						return promiseResolvedWith(void 0);
					}
					if (stream2._state === 'errored') {
						return promiseRejectedWith(stream2._storedError);
					}
					ReadableStreamClose(stream2);
					const reader = stream2._reader;
					if (reader !== void 0 && IsReadableStreamBYOBReader(reader)) {
						reader._readIntoRequests.forEach((readIntoRequest) => {
							readIntoRequest._closeSteps(void 0);
						});
						reader._readIntoRequests = new SimpleQueue();
					}
					const sourceCancelPromise = stream2._readableStreamController[CancelSteps](reason);
					return transformPromiseWith(sourceCancelPromise, noop3);
				}
				function ReadableStreamClose(stream2) {
					stream2._state = 'closed';
					const reader = stream2._reader;
					if (reader === void 0) {
						return;
					}
					defaultReaderClosedPromiseResolve(reader);
					if (IsReadableStreamDefaultReader(reader)) {
						reader._readRequests.forEach((readRequest) => {
							readRequest._closeSteps();
						});
						reader._readRequests = new SimpleQueue();
					}
				}
				function ReadableStreamError(stream2, e2) {
					stream2._state = 'errored';
					stream2._storedError = e2;
					const reader = stream2._reader;
					if (reader === void 0) {
						return;
					}
					defaultReaderClosedPromiseReject(reader, e2);
					if (IsReadableStreamDefaultReader(reader)) {
						reader._readRequests.forEach((readRequest) => {
							readRequest._errorSteps(e2);
						});
						reader._readRequests = new SimpleQueue();
					} else {
						reader._readIntoRequests.forEach((readIntoRequest) => {
							readIntoRequest._errorSteps(e2);
						});
						reader._readIntoRequests = new SimpleQueue();
					}
				}
				function streamBrandCheckException$1(name) {
					return new TypeError(
						`ReadableStream.prototype.${name} can only be used on a ReadableStream`
					);
				}
				function convertQueuingStrategyInit(init2, context) {
					assertDictionary(init2, context);
					const highWaterMark = init2 === null || init2 === void 0 ? void 0 : init2.highWaterMark;
					assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');
					return {
						highWaterMark: convertUnrestrictedDouble(highWaterMark)
					};
				}
				const byteLengthSizeFunction = (chunk) => {
					return chunk.byteLength;
				};
				try {
					Object.defineProperty(byteLengthSizeFunction, 'name', {
						value: 'size',
						configurable: true
					});
				} catch (_a) {}
				class ByteLengthQueuingStrategy {
					constructor(options) {
						assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');
						options = convertQueuingStrategyInit(options, 'First parameter');
						this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
					}
					get highWaterMark() {
						if (!IsByteLengthQueuingStrategy(this)) {
							throw byteLengthBrandCheckException('highWaterMark');
						}
						return this._byteLengthQueuingStrategyHighWaterMark;
					}
					get size() {
						if (!IsByteLengthQueuingStrategy(this)) {
							throw byteLengthBrandCheckException('size');
						}
						return byteLengthSizeFunction;
					}
				}
				Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
					highWaterMark: { enumerable: true },
					size: { enumerable: true }
				});
				if (typeof SymbolPolyfill.toStringTag === 'symbol') {
					Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
						value: 'ByteLengthQueuingStrategy',
						configurable: true
					});
				}
				function byteLengthBrandCheckException(name) {
					return new TypeError(
						`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`
					);
				}
				function IsByteLengthQueuingStrategy(x2) {
					if (!typeIsObject(x2)) {
						return false;
					}
					if (
						!Object.prototype.hasOwnProperty.call(x2, '_byteLengthQueuingStrategyHighWaterMark')
					) {
						return false;
					}
					return x2 instanceof ByteLengthQueuingStrategy;
				}
				const countSizeFunction = () => {
					return 1;
				};
				try {
					Object.defineProperty(countSizeFunction, 'name', {
						value: 'size',
						configurable: true
					});
				} catch (_a) {}
				class CountQueuingStrategy {
					constructor(options) {
						assertRequiredArgument(options, 1, 'CountQueuingStrategy');
						options = convertQueuingStrategyInit(options, 'First parameter');
						this._countQueuingStrategyHighWaterMark = options.highWaterMark;
					}
					get highWaterMark() {
						if (!IsCountQueuingStrategy(this)) {
							throw countBrandCheckException('highWaterMark');
						}
						return this._countQueuingStrategyHighWaterMark;
					}
					get size() {
						if (!IsCountQueuingStrategy(this)) {
							throw countBrandCheckException('size');
						}
						return countSizeFunction;
					}
				}
				Object.defineProperties(CountQueuingStrategy.prototype, {
					highWaterMark: { enumerable: true },
					size: { enumerable: true }
				});
				if (typeof SymbolPolyfill.toStringTag === 'symbol') {
					Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
						value: 'CountQueuingStrategy',
						configurable: true
					});
				}
				function countBrandCheckException(name) {
					return new TypeError(
						`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`
					);
				}
				function IsCountQueuingStrategy(x2) {
					if (!typeIsObject(x2)) {
						return false;
					}
					if (!Object.prototype.hasOwnProperty.call(x2, '_countQueuingStrategyHighWaterMark')) {
						return false;
					}
					return x2 instanceof CountQueuingStrategy;
				}
				function convertTransformer(original, context) {
					assertDictionary(original, context);
					const flush = original === null || original === void 0 ? void 0 : original.flush;
					const readableType =
						original === null || original === void 0 ? void 0 : original.readableType;
					const start = original === null || original === void 0 ? void 0 : original.start;
					const transform2 = original === null || original === void 0 ? void 0 : original.transform;
					const writableType =
						original === null || original === void 0 ? void 0 : original.writableType;
					return {
						flush:
							flush === void 0
								? void 0
								: convertTransformerFlushCallback(
										flush,
										original,
										`${context} has member 'flush' that`
								  ),
						readableType,
						start:
							start === void 0
								? void 0
								: convertTransformerStartCallback(
										start,
										original,
										`${context} has member 'start' that`
								  ),
						transform:
							transform2 === void 0
								? void 0
								: convertTransformerTransformCallback(
										transform2,
										original,
										`${context} has member 'transform' that`
								  ),
						writableType
					};
				}
				function convertTransformerFlushCallback(fn, original, context) {
					assertFunction(fn, context);
					return (controller) => promiseCall(fn, original, [controller]);
				}
				function convertTransformerStartCallback(fn, original, context) {
					assertFunction(fn, context);
					return (controller) => reflectCall(fn, original, [controller]);
				}
				function convertTransformerTransformCallback(fn, original, context) {
					assertFunction(fn, context);
					return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
				}
				class TransformStream2 {
					constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
						if (rawTransformer === void 0) {
							rawTransformer = null;
						}
						const writableStrategy = convertQueuingStrategy(
							rawWritableStrategy,
							'Second parameter'
						);
						const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');
						const transformer = convertTransformer(rawTransformer, 'First parameter');
						if (transformer.readableType !== void 0) {
							throw new RangeError('Invalid readableType specified');
						}
						if (transformer.writableType !== void 0) {
							throw new RangeError('Invalid writableType specified');
						}
						const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
						const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
						const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
						const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
						let startPromise_resolve;
						const startPromise = newPromise((resolve2) => {
							startPromise_resolve = resolve2;
						});
						InitializeTransformStream(
							this,
							startPromise,
							writableHighWaterMark,
							writableSizeAlgorithm,
							readableHighWaterMark,
							readableSizeAlgorithm
						);
						SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
						if (transformer.start !== void 0) {
							startPromise_resolve(transformer.start(this._transformStreamController));
						} else {
							startPromise_resolve(void 0);
						}
					}
					get readable() {
						if (!IsTransformStream(this)) {
							throw streamBrandCheckException('readable');
						}
						return this._readable;
					}
					get writable() {
						if (!IsTransformStream(this)) {
							throw streamBrandCheckException('writable');
						}
						return this._writable;
					}
				}
				Object.defineProperties(TransformStream2.prototype, {
					readable: { enumerable: true },
					writable: { enumerable: true }
				});
				if (typeof SymbolPolyfill.toStringTag === 'symbol') {
					Object.defineProperty(TransformStream2.prototype, SymbolPolyfill.toStringTag, {
						value: 'TransformStream',
						configurable: true
					});
				}
				function InitializeTransformStream(
					stream2,
					startPromise,
					writableHighWaterMark,
					writableSizeAlgorithm,
					readableHighWaterMark,
					readableSizeAlgorithm
				) {
					function startAlgorithm() {
						return startPromise;
					}
					function writeAlgorithm(chunk) {
						return TransformStreamDefaultSinkWriteAlgorithm(stream2, chunk);
					}
					function abortAlgorithm(reason) {
						return TransformStreamDefaultSinkAbortAlgorithm(stream2, reason);
					}
					function closeAlgorithm() {
						return TransformStreamDefaultSinkCloseAlgorithm(stream2);
					}
					stream2._writable = CreateWritableStream(
						startAlgorithm,
						writeAlgorithm,
						closeAlgorithm,
						abortAlgorithm,
						writableHighWaterMark,
						writableSizeAlgorithm
					);
					function pullAlgorithm() {
						return TransformStreamDefaultSourcePullAlgorithm(stream2);
					}
					function cancelAlgorithm(reason) {
						TransformStreamErrorWritableAndUnblockWrite(stream2, reason);
						return promiseResolvedWith(void 0);
					}
					stream2._readable = CreateReadableStream(
						startAlgorithm,
						pullAlgorithm,
						cancelAlgorithm,
						readableHighWaterMark,
						readableSizeAlgorithm
					);
					stream2._backpressure = void 0;
					stream2._backpressureChangePromise = void 0;
					stream2._backpressureChangePromise_resolve = void 0;
					TransformStreamSetBackpressure(stream2, true);
					stream2._transformStreamController = void 0;
				}
				function IsTransformStream(x2) {
					if (!typeIsObject(x2)) {
						return false;
					}
					if (!Object.prototype.hasOwnProperty.call(x2, '_transformStreamController')) {
						return false;
					}
					return x2 instanceof TransformStream2;
				}
				function TransformStreamError(stream2, e2) {
					ReadableStreamDefaultControllerError(stream2._readable._readableStreamController, e2);
					TransformStreamErrorWritableAndUnblockWrite(stream2, e2);
				}
				function TransformStreamErrorWritableAndUnblockWrite(stream2, e2) {
					TransformStreamDefaultControllerClearAlgorithms(stream2._transformStreamController);
					WritableStreamDefaultControllerErrorIfNeeded(
						stream2._writable._writableStreamController,
						e2
					);
					if (stream2._backpressure) {
						TransformStreamSetBackpressure(stream2, false);
					}
				}
				function TransformStreamSetBackpressure(stream2, backpressure) {
					if (stream2._backpressureChangePromise !== void 0) {
						stream2._backpressureChangePromise_resolve();
					}
					stream2._backpressureChangePromise = newPromise((resolve2) => {
						stream2._backpressureChangePromise_resolve = resolve2;
					});
					stream2._backpressure = backpressure;
				}
				class TransformStreamDefaultController {
					constructor() {
						throw new TypeError('Illegal constructor');
					}
					get desiredSize() {
						if (!IsTransformStreamDefaultController(this)) {
							throw defaultControllerBrandCheckException('desiredSize');
						}
						const readableController =
							this._controlledTransformStream._readable._readableStreamController;
						return ReadableStreamDefaultControllerGetDesiredSize(readableController);
					}
					enqueue(chunk = void 0) {
						if (!IsTransformStreamDefaultController(this)) {
							throw defaultControllerBrandCheckException('enqueue');
						}
						TransformStreamDefaultControllerEnqueue(this, chunk);
					}
					error(reason = void 0) {
						if (!IsTransformStreamDefaultController(this)) {
							throw defaultControllerBrandCheckException('error');
						}
						TransformStreamDefaultControllerError(this, reason);
					}
					terminate() {
						if (!IsTransformStreamDefaultController(this)) {
							throw defaultControllerBrandCheckException('terminate');
						}
						TransformStreamDefaultControllerTerminate(this);
					}
				}
				Object.defineProperties(TransformStreamDefaultController.prototype, {
					enqueue: { enumerable: true },
					error: { enumerable: true },
					terminate: { enumerable: true },
					desiredSize: { enumerable: true }
				});
				if (typeof SymbolPolyfill.toStringTag === 'symbol') {
					Object.defineProperty(
						TransformStreamDefaultController.prototype,
						SymbolPolyfill.toStringTag,
						{
							value: 'TransformStreamDefaultController',
							configurable: true
						}
					);
				}
				function IsTransformStreamDefaultController(x2) {
					if (!typeIsObject(x2)) {
						return false;
					}
					if (!Object.prototype.hasOwnProperty.call(x2, '_controlledTransformStream')) {
						return false;
					}
					return x2 instanceof TransformStreamDefaultController;
				}
				function SetUpTransformStreamDefaultController(
					stream2,
					controller,
					transformAlgorithm,
					flushAlgorithm
				) {
					controller._controlledTransformStream = stream2;
					stream2._transformStreamController = controller;
					controller._transformAlgorithm = transformAlgorithm;
					controller._flushAlgorithm = flushAlgorithm;
				}
				function SetUpTransformStreamDefaultControllerFromTransformer(stream2, transformer) {
					const controller = Object.create(TransformStreamDefaultController.prototype);
					let transformAlgorithm = (chunk) => {
						try {
							TransformStreamDefaultControllerEnqueue(controller, chunk);
							return promiseResolvedWith(void 0);
						} catch (transformResultE) {
							return promiseRejectedWith(transformResultE);
						}
					};
					let flushAlgorithm = () => promiseResolvedWith(void 0);
					if (transformer.transform !== void 0) {
						transformAlgorithm = (chunk) => transformer.transform(chunk, controller);
					}
					if (transformer.flush !== void 0) {
						flushAlgorithm = () => transformer.flush(controller);
					}
					SetUpTransformStreamDefaultController(
						stream2,
						controller,
						transformAlgorithm,
						flushAlgorithm
					);
				}
				function TransformStreamDefaultControllerClearAlgorithms(controller) {
					controller._transformAlgorithm = void 0;
					controller._flushAlgorithm = void 0;
				}
				function TransformStreamDefaultControllerEnqueue(controller, chunk) {
					const stream2 = controller._controlledTransformStream;
					const readableController = stream2._readable._readableStreamController;
					if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
						throw new TypeError('Readable side is not in a state that permits enqueue');
					}
					try {
						ReadableStreamDefaultControllerEnqueue(readableController, chunk);
					} catch (e2) {
						TransformStreamErrorWritableAndUnblockWrite(stream2, e2);
						throw stream2._readable._storedError;
					}
					const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
					if (backpressure !== stream2._backpressure) {
						TransformStreamSetBackpressure(stream2, true);
					}
				}
				function TransformStreamDefaultControllerError(controller, e2) {
					TransformStreamError(controller._controlledTransformStream, e2);
				}
				function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
					const transformPromise = controller._transformAlgorithm(chunk);
					return transformPromiseWith(transformPromise, void 0, (r2) => {
						TransformStreamError(controller._controlledTransformStream, r2);
						throw r2;
					});
				}
				function TransformStreamDefaultControllerTerminate(controller) {
					const stream2 = controller._controlledTransformStream;
					const readableController = stream2._readable._readableStreamController;
					ReadableStreamDefaultControllerClose(readableController);
					const error2 = new TypeError('TransformStream terminated');
					TransformStreamErrorWritableAndUnblockWrite(stream2, error2);
				}
				function TransformStreamDefaultSinkWriteAlgorithm(stream2, chunk) {
					const controller = stream2._transformStreamController;
					if (stream2._backpressure) {
						const backpressureChangePromise = stream2._backpressureChangePromise;
						return transformPromiseWith(backpressureChangePromise, () => {
							const writable2 = stream2._writable;
							const state = writable2._state;
							if (state === 'erroring') {
								throw writable2._storedError;
							}
							return TransformStreamDefaultControllerPerformTransform(controller, chunk);
						});
					}
					return TransformStreamDefaultControllerPerformTransform(controller, chunk);
				}
				function TransformStreamDefaultSinkAbortAlgorithm(stream2, reason) {
					TransformStreamError(stream2, reason);
					return promiseResolvedWith(void 0);
				}
				function TransformStreamDefaultSinkCloseAlgorithm(stream2) {
					const readable3 = stream2._readable;
					const controller = stream2._transformStreamController;
					const flushPromise = controller._flushAlgorithm();
					TransformStreamDefaultControllerClearAlgorithms(controller);
					return transformPromiseWith(
						flushPromise,
						() => {
							if (readable3._state === 'errored') {
								throw readable3._storedError;
							}
							ReadableStreamDefaultControllerClose(readable3._readableStreamController);
						},
						(r2) => {
							TransformStreamError(stream2, r2);
							throw readable3._storedError;
						}
					);
				}
				function TransformStreamDefaultSourcePullAlgorithm(stream2) {
					TransformStreamSetBackpressure(stream2, false);
					return stream2._backpressureChangePromise;
				}
				function defaultControllerBrandCheckException(name) {
					return new TypeError(
						`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`
					);
				}
				function streamBrandCheckException(name) {
					return new TypeError(
						`TransformStream.prototype.${name} can only be used on a TransformStream`
					);
				}
				exports2.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
				exports2.CountQueuingStrategy = CountQueuingStrategy;
				exports2.ReadableByteStreamController = ReadableByteStreamController;
				exports2.ReadableStream = ReadableStream3;
				exports2.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
				exports2.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
				exports2.ReadableStreamDefaultController = ReadableStreamDefaultController;
				exports2.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
				exports2.TransformStream = TransformStream2;
				exports2.TransformStreamDefaultController = TransformStreamDefaultController;
				exports2.WritableStream = WritableStream2;
				exports2.WritableStreamDefaultController = WritableStreamDefaultController;
				exports2.WritableStreamDefaultWriter = WritableStreamDefaultWriter;
				Object.defineProperty(exports2, '__esModule', { value: true });
			});
		})(ponyfill_es2018, ponyfill_es2018.exports);
		POOL_SIZE$1 = 65536;
		if (!globalThis.ReadableStream) {
			try {
				const process2 = require('node:process');
				const { emitWarning } = process2;
				try {
					process2.emitWarning = () => {};
					Object.assign(globalThis, require('node:stream/web'));
					process2.emitWarning = emitWarning;
				} catch (error2) {
					process2.emitWarning = emitWarning;
					throw error2;
				}
			} catch (error2) {
				Object.assign(globalThis, ponyfill_es2018.exports);
			}
		}
		try {
			const { Blob: Blob4 } = require('buffer');
			if (Blob4 && !Blob4.prototype.stream) {
				Blob4.prototype.stream = function name(params) {
					let position3 = 0;
					const blob = this;
					return new ReadableStream({
						type: 'bytes',
						async pull(ctrl) {
							const chunk = blob.slice(position3, Math.min(blob.size, position3 + POOL_SIZE$1));
							const buffer2 = await chunk.arrayBuffer();
							position3 += buffer2.byteLength;
							ctrl.enqueue(new Uint8Array(buffer2));
							if (position3 === blob.size) {
								ctrl.close();
							}
						}
					});
				};
			}
		} catch (error2) {}
		POOL_SIZE = 65536;
		_Blob = class Blob2 {
			#parts = [];
			#type = '';
			#size = 0;
			#endings = 'transparent';
			constructor(blobParts = [], options = {}) {
				if (typeof blobParts !== 'object' || blobParts === null) {
					throw new TypeError(
						"Failed to construct 'Blob': The provided value cannot be converted to a sequence."
					);
				}
				if (typeof blobParts[Symbol.iterator] !== 'function') {
					throw new TypeError(
						"Failed to construct 'Blob': The object must have a callable @@iterator property."
					);
				}
				if (typeof options !== 'object' && typeof options !== 'function') {
					throw new TypeError(
						"Failed to construct 'Blob': parameter 2 cannot convert to dictionary."
					);
				}
				if (options === null) options = {};
				const encoder3 = new TextEncoder();
				for (const element4 of blobParts) {
					let part;
					if (ArrayBuffer.isView(element4)) {
						part = new Uint8Array(
							element4.buffer.slice(element4.byteOffset, element4.byteOffset + element4.byteLength)
						);
					} else if (element4 instanceof ArrayBuffer) {
						part = new Uint8Array(element4.slice(0));
					} else if (element4 instanceof Blob2) {
						part = element4;
					} else {
						part = encoder3.encode(`${element4}`);
					}
					const size = ArrayBuffer.isView(part) ? part.byteLength : part.size;
					if (size) {
						this.#size += size;
						this.#parts.push(part);
					}
				}
				this.#endings = `${options.endings === void 0 ? 'transparent' : options.endings}`;
				const type = options.type === void 0 ? '' : String(options.type);
				this.#type = /^[\x20-\x7E]*$/.test(type) ? type : '';
			}
			get size() {
				return this.#size;
			}
			get type() {
				return this.#type;
			}
			async text() {
				const decoder = new TextDecoder();
				let str = '';
				for await (const part of toIterator(this.#parts, false)) {
					str += decoder.decode(part, { stream: true });
				}
				str += decoder.decode();
				return str;
			}
			async arrayBuffer() {
				const data2 = new Uint8Array(this.size);
				let offset = 0;
				for await (const chunk of toIterator(this.#parts, false)) {
					data2.set(chunk, offset);
					offset += chunk.length;
				}
				return data2.buffer;
			}
			stream() {
				const it = toIterator(this.#parts, true);
				return new globalThis.ReadableStream({
					type: 'bytes',
					async pull(ctrl) {
						const chunk = await it.next();
						chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
					},
					async cancel() {
						await it.return();
					}
				});
			}
			slice(start = 0, end = this.size, type = '') {
				const { size } = this;
				let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
				let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);
				const span = Math.max(relativeEnd - relativeStart, 0);
				const parts = this.#parts;
				const blobParts = [];
				let added = 0;
				for (const part of parts) {
					if (added >= span) {
						break;
					}
					const size2 = ArrayBuffer.isView(part) ? part.byteLength : part.size;
					if (relativeStart && size2 <= relativeStart) {
						relativeStart -= size2;
						relativeEnd -= size2;
					} else {
						let chunk;
						if (ArrayBuffer.isView(part)) {
							chunk = part.subarray(relativeStart, Math.min(size2, relativeEnd));
							added += chunk.byteLength;
						} else {
							chunk = part.slice(relativeStart, Math.min(size2, relativeEnd));
							added += chunk.size;
						}
						relativeEnd -= size2;
						blobParts.push(chunk);
						relativeStart = 0;
					}
				}
				const blob = new Blob2([], { type: String(type).toLowerCase() });
				blob.#size = span;
				blob.#parts = blobParts;
				return blob;
			}
			get [Symbol.toStringTag]() {
				return 'Blob';
			}
			static [Symbol.hasInstance](object) {
				return (
					object &&
					typeof object === 'object' &&
					typeof object.constructor === 'function' &&
					(typeof object.stream === 'function' || typeof object.arrayBuffer === 'function') &&
					/^(Blob|File)$/.test(object[Symbol.toStringTag])
				);
			}
		};
		Object.defineProperties(_Blob.prototype, {
			size: { enumerable: true },
			type: { enumerable: true },
			slice: { enumerable: true }
		});
		Blob3 = _Blob;
		Blob$12 = Blob3;
		_File = class File3 extends Blob$12 {
			#lastModified = 0;
			#name = '';
			constructor(fileBits, fileName, options = {}) {
				if (arguments.length < 2) {
					throw new TypeError(
						`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`
					);
				}
				super(fileBits, options);
				if (options === null) options = {};
				const lastModified =
					options.lastModified === void 0 ? Date.now() : Number(options.lastModified);
				if (!Number.isNaN(lastModified)) {
					this.#lastModified = lastModified;
				}
				this.#name = String(fileName);
			}
			get name() {
				return this.#name;
			}
			get lastModified() {
				return this.#lastModified;
			}
			get [Symbol.toStringTag]() {
				return 'File';
			}
			static [Symbol.hasInstance](object) {
				return !!object && object instanceof Blob$12 && /^(File)$/.test(object[Symbol.toStringTag]);
			}
		};
		File2 = _File;
		({ toStringTag: t, iterator: i, hasInstance: h } = Symbol);
		r = Math.random;
		m = 'append,set,get,getAll,delete,keys,values,entries,forEach,constructor'.split(',');
		f2 = (a, b, c) => (
			(a += ''),
			/^(Blob|File)$/.test(b && b[t])
				? [
						((c = c !== void 0 ? c + '' : b[t] == 'File' ? b.name : 'blob'), a),
						b.name !== c || b[t] == 'blob' ? new File2([b], c, b) : b
				  ]
				: [a, b + '']
		);
		e = (c, f3) =>
			(f3 ? c : c.replace(/\r?\n|\r/g, '\r\n'))
				.replace(/\n/g, '%0A')
				.replace(/\r/g, '%0D')
				.replace(/"/g, '%22');
		x = (n, a, e2) => {
			if (a.length < e2) {
				throw new TypeError(
					`Failed to execute '${n}' on 'FormData': ${e2} arguments required, but only ${a.length} present.`
				);
			}
		};
		FormData2 = class FormData3 {
			#d = [];
			constructor(...a) {
				if (a.length)
					throw new TypeError(
						`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`
					);
			}
			get [t]() {
				return 'FormData';
			}
			[i]() {
				return this.entries();
			}
			static [h](o) {
				return (
					o &&
					typeof o === 'object' &&
					o[t] === 'FormData' &&
					!m.some((m2) => typeof o[m2] != 'function')
				);
			}
			append(...a) {
				x('append', arguments, 2);
				this.#d.push(f2(...a));
			}
			delete(a) {
				x('delete', arguments, 1);
				a += '';
				this.#d = this.#d.filter(([b]) => b !== a);
			}
			get(a) {
				x('get', arguments, 1);
				a += '';
				for (var b = this.#d, l = b.length, c = 0; c < l; c++) if (b[c][0] === a) return b[c][1];
				return null;
			}
			getAll(a, b) {
				x('getAll', arguments, 1);
				b = [];
				a += '';
				this.#d.forEach((c) => c[0] === a && b.push(c[1]));
				return b;
			}
			has(a) {
				x('has', arguments, 1);
				a += '';
				return this.#d.some((b) => b[0] === a);
			}
			forEach(a, b) {
				x('forEach', arguments, 1);
				for (var [c, d] of this) a.call(b, d, c, this);
			}
			set(...a) {
				x('set', arguments, 2);
				var b = [],
					c = true;
				a = f2(...a);
				this.#d.forEach((d) => {
					d[0] === a[0] ? c && (c = !b.push(a)) : b.push(d);
				});
				c && b.push(a);
				this.#d = b;
			}
			*entries() {
				yield* this.#d;
			}
			*keys() {
				for (var [a] of this) yield a;
			}
			*values() {
				for (var [, a] of this) yield a;
			}
		};
		FetchBaseError = class extends Error {
			constructor(message, type) {
				super(message);
				Error.captureStackTrace(this, this.constructor);
				this.type = type;
			}
			get name() {
				return this.constructor.name;
			}
			get [Symbol.toStringTag]() {
				return this.constructor.name;
			}
		};
		FetchError = class extends FetchBaseError {
			constructor(message, type, systemError) {
				super(message, type);
				if (systemError) {
					this.code = this.errno = systemError.code;
					this.erroredSysCall = systemError.syscall;
				}
			}
		};
		NAME = Symbol.toStringTag;
		isURLSearchParameters = (object) => {
			return (
				typeof object === 'object' &&
				typeof object.append === 'function' &&
				typeof object.delete === 'function' &&
				typeof object.get === 'function' &&
				typeof object.getAll === 'function' &&
				typeof object.has === 'function' &&
				typeof object.set === 'function' &&
				typeof object.sort === 'function' &&
				object[NAME] === 'URLSearchParams'
			);
		};
		isBlob = (object) => {
			return (
				object &&
				typeof object === 'object' &&
				typeof object.arrayBuffer === 'function' &&
				typeof object.type === 'string' &&
				typeof object.stream === 'function' &&
				typeof object.constructor === 'function' &&
				/^(Blob|File)$/.test(object[NAME])
			);
		};
		isAbortSignal = (object) => {
			return (
				typeof object === 'object' &&
				(object[NAME] === 'AbortSignal' || object[NAME] === 'EventTarget')
			);
		};
		(0, import_node_util.promisify)(import_node_stream.default.pipeline);
		INTERNALS$1 = Symbol('Body internals');
		Body = class {
			constructor(body4, { size = 0 } = {}) {
				let boundary = null;
				if (body4 === null) {
					body4 = null;
				} else if (isURLSearchParameters(body4)) {
					body4 = import_node_buffer.Buffer.from(body4.toString());
				} else if (isBlob(body4));
				else if (import_node_buffer.Buffer.isBuffer(body4));
				else if (import_node_util.types.isAnyArrayBuffer(body4)) {
					body4 = import_node_buffer.Buffer.from(body4);
				} else if (ArrayBuffer.isView(body4)) {
					body4 = import_node_buffer.Buffer.from(body4.buffer, body4.byteOffset, body4.byteLength);
				} else if (body4 instanceof import_node_stream.default);
				else if (body4 instanceof FormData2) {
					body4 = formDataToBlob(body4);
					boundary = body4.type.split('=')[1];
				} else {
					body4 = import_node_buffer.Buffer.from(String(body4));
				}
				let stream2 = body4;
				if (import_node_buffer.Buffer.isBuffer(body4)) {
					stream2 = import_node_stream.default.Readable.from(body4);
				} else if (isBlob(body4)) {
					stream2 = import_node_stream.default.Readable.from(body4.stream());
				}
				this[INTERNALS$1] = {
					body: body4,
					stream: stream2,
					boundary,
					disturbed: false,
					error: null
				};
				this.size = size;
				if (body4 instanceof import_node_stream.default) {
					body4.on('error', (error_) => {
						const error2 =
							error_ instanceof FetchBaseError
								? error_
								: new FetchError(
										`Invalid response body while trying to fetch ${this.url}: ${error_.message}`,
										'system',
										error_
								  );
						this[INTERNALS$1].error = error2;
					});
				}
			}
			get body() {
				return this[INTERNALS$1].stream;
			}
			get bodyUsed() {
				return this[INTERNALS$1].disturbed;
			}
			async arrayBuffer() {
				const { buffer: buffer2, byteOffset, byteLength } = await consumeBody(this);
				return buffer2.slice(byteOffset, byteOffset + byteLength);
			}
			async formData() {
				const ct = this.headers.get('content-type');
				if (ct.startsWith('application/x-www-form-urlencoded')) {
					const formData = new FormData2();
					const parameters = new URLSearchParams(await this.text());
					for (const [name, value] of parameters) {
						formData.append(name, value);
					}
					return formData;
				}
				const { toFormData: toFormData2 } = await Promise.resolve().then(
					() => (init_multipart_parser(), multipart_parser_exports)
				);
				return toFormData2(this.body, ct);
			}
			async blob() {
				const ct =
					(this.headers && this.headers.get('content-type')) ||
					(this[INTERNALS$1].body && this[INTERNALS$1].body.type) ||
					'';
				const buf = await this.arrayBuffer();
				return new Blob$12([buf], {
					type: ct
				});
			}
			async json() {
				const text7 = await this.text();
				return JSON.parse(text7);
			}
			async text() {
				const buffer2 = await consumeBody(this);
				return new TextDecoder().decode(buffer2);
			}
			buffer() {
				return consumeBody(this);
			}
		};
		Body.prototype.buffer = (0, import_node_util.deprecate)(
			Body.prototype.buffer,
			"Please use 'response.arrayBuffer()' instead of 'response.buffer()'",
			'node-fetch#buffer'
		);
		Object.defineProperties(Body.prototype, {
			body: { enumerable: true },
			bodyUsed: { enumerable: true },
			arrayBuffer: { enumerable: true },
			blob: { enumerable: true },
			json: { enumerable: true },
			text: { enumerable: true },
			data: {
				get: (0, import_node_util.deprecate)(
					() => {},
					"data doesn't exist, use json(), text(), arrayBuffer(), or body instead",
					'https://github.com/node-fetch/node-fetch/issues/1000 (response)'
				)
			}
		});
		clone = (instance, highWaterMark) => {
			let p1;
			let p2;
			let { body: body4 } = instance[INTERNALS$1];
			if (instance.bodyUsed) {
				throw new Error('cannot clone body after it is used');
			}
			if (body4 instanceof import_node_stream.default && typeof body4.getBoundary !== 'function') {
				p1 = new import_node_stream.PassThrough({ highWaterMark });
				p2 = new import_node_stream.PassThrough({ highWaterMark });
				body4.pipe(p1);
				body4.pipe(p2);
				instance[INTERNALS$1].stream = p1;
				body4 = p2;
			}
			return body4;
		};
		getNonSpecFormDataBoundary = (0, import_node_util.deprecate)(
			(body4) => body4.getBoundary(),
			"form-data doesn't follow the spec and requires special treatment. Use alternative package",
			'https://github.com/node-fetch/node-fetch/issues/1167'
		);
		extractContentType = (body4, request2) => {
			if (body4 === null) {
				return null;
			}
			if (typeof body4 === 'string') {
				return 'text/plain;charset=UTF-8';
			}
			if (isURLSearchParameters(body4)) {
				return 'application/x-www-form-urlencoded;charset=UTF-8';
			}
			if (isBlob(body4)) {
				return body4.type || null;
			}
			if (
				import_node_buffer.Buffer.isBuffer(body4) ||
				import_node_util.types.isAnyArrayBuffer(body4) ||
				ArrayBuffer.isView(body4)
			) {
				return null;
			}
			if (body4 instanceof FormData2) {
				return `multipart/form-data; boundary=${request2[INTERNALS$1].boundary}`;
			}
			if (body4 && typeof body4.getBoundary === 'function') {
				return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body4)}`;
			}
			if (body4 instanceof import_node_stream.default) {
				return null;
			}
			return 'text/plain;charset=UTF-8';
		};
		validateHeaderName2 =
			typeof import_node_http.default.validateHeaderName === 'function'
				? import_node_http.default.validateHeaderName
				: (name) => {
						if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
							const error2 = new TypeError(`Header name must be a valid HTTP token [${name}]`);
							Object.defineProperty(error2, 'code', { value: 'ERR_INVALID_HTTP_TOKEN' });
							throw error2;
						}
				  };
		validateHeaderValue2 =
			typeof import_node_http.default.validateHeaderValue === 'function'
				? import_node_http.default.validateHeaderValue
				: (name, value) => {
						if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
							const error2 = new TypeError(`Invalid character in header content ["${name}"]`);
							Object.defineProperty(error2, 'code', { value: 'ERR_INVALID_CHAR' });
							throw error2;
						}
				  };
		Headers3 = class extends URLSearchParams {
			constructor(init2) {
				let result = [];
				if (init2 instanceof Headers3) {
					const raw2 = init2.raw();
					for (const [name, values] of Object.entries(raw2)) {
						result.push(...values.map((value) => [name, value]));
					}
				} else if (init2 == null);
				else if (typeof init2 === 'object' && !import_node_util.types.isBoxedPrimitive(init2)) {
					const method = init2[Symbol.iterator];
					if (method == null) {
						result.push(...Object.entries(init2));
					} else {
						if (typeof method !== 'function') {
							throw new TypeError('Header pairs must be iterable');
						}
						result = [...init2]
							.map((pair) => {
								if (typeof pair !== 'object' || import_node_util.types.isBoxedPrimitive(pair)) {
									throw new TypeError('Each header pair must be an iterable object');
								}
								return [...pair];
							})
							.map((pair) => {
								if (pair.length !== 2) {
									throw new TypeError('Each header pair must be a name/value tuple');
								}
								return [...pair];
							});
					}
				} else {
					throw new TypeError(
						"Failed to construct 'Headers': The provided value is not of type '(sequence<sequence<ByteString>> or record<ByteString, ByteString>)"
					);
				}
				result =
					result.length > 0
						? result.map(([name, value]) => {
								validateHeaderName2(name);
								validateHeaderValue2(name, String(value));
								return [String(name).toLowerCase(), String(value)];
						  })
						: void 0;
				super(result);
				return new Proxy(this, {
					get(target, p2, receiver) {
						switch (p2) {
							case 'append':
							case 'set':
								return (name, value) => {
									validateHeaderName2(name);
									validateHeaderValue2(name, String(value));
									return URLSearchParams.prototype[p2].call(
										target,
										String(name).toLowerCase(),
										String(value)
									);
								};
							case 'delete':
							case 'has':
							case 'getAll':
								return (name) => {
									validateHeaderName2(name);
									return URLSearchParams.prototype[p2].call(target, String(name).toLowerCase());
								};
							case 'keys':
								return () => {
									target.sort();
									return new Set(URLSearchParams.prototype.keys.call(target)).keys();
								};
							default:
								return Reflect.get(target, p2, receiver);
						}
					}
				});
			}
			get [Symbol.toStringTag]() {
				return this.constructor.name;
			}
			toString() {
				return Object.prototype.toString.call(this);
			}
			get(name) {
				const values = this.getAll(name);
				if (values.length === 0) {
					return null;
				}
				let value = values.join(', ');
				if (/^content-encoding$/i.test(name)) {
					value = value.toLowerCase();
				}
				return value;
			}
			forEach(callback, thisArg = void 0) {
				for (const name of this.keys()) {
					Reflect.apply(callback, thisArg, [this.get(name), name, this]);
				}
			}
			*values() {
				for (const name of this.keys()) {
					yield this.get(name);
				}
			}
			*entries() {
				for (const name of this.keys()) {
					yield [name, this.get(name)];
				}
			}
			[Symbol.iterator]() {
				return this.entries();
			}
			raw() {
				return [...this.keys()].reduce((result, key3) => {
					result[key3] = this.getAll(key3);
					return result;
				}, {});
			}
			[Symbol.for('nodejs.util.inspect.custom')]() {
				return [...this.keys()].reduce((result, key3) => {
					const values = this.getAll(key3);
					if (key3 === 'host') {
						result[key3] = values[0];
					} else {
						result[key3] = values.length > 1 ? values : values[0];
					}
					return result;
				}, {});
			}
		};
		Object.defineProperties(
			Headers3.prototype,
			['get', 'entries', 'forEach', 'values'].reduce((result, property) => {
				result[property] = { enumerable: true };
				return result;
			}, {})
		);
		ReferrerPolicy = /* @__PURE__ */ new Set([
			'',
			'no-referrer',
			'no-referrer-when-downgrade',
			'same-origin',
			'origin',
			'strict-origin',
			'origin-when-cross-origin',
			'strict-origin-when-cross-origin',
			'unsafe-url'
		]);
		INTERNALS = Symbol('Request internals');
		isRequest = (object) => {
			return typeof object === 'object' && typeof object[INTERNALS] === 'object';
		};
		doBadDataWarn = (0, import_node_util.deprecate)(
			() => {},
			'.data is not a valid RequestInit property, use .body instead',
			'https://github.com/node-fetch/node-fetch/issues/1000 (request)'
		);
		Request$12 = class extends Body {
			constructor(input, init2 = {}) {
				let parsedURL;
				if (isRequest(input)) {
					parsedURL = new URL(input.url);
				} else {
					parsedURL = new URL(input);
					input = {};
				}
				if (parsedURL.username !== '' || parsedURL.password !== '') {
					throw new TypeError(`${parsedURL} is an url with embedded credentials.`);
				}
				let method = init2.method || input.method || 'GET';
				if (/^(delete|get|head|options|post|put)$/i.test(method)) {
					method = method.toUpperCase();
				}
				if ('data' in init2) {
					doBadDataWarn();
				}
				if (
					(init2.body != null || (isRequest(input) && input.body !== null)) &&
					(method === 'GET' || method === 'HEAD')
				) {
					throw new TypeError('Request with GET/HEAD method cannot have body');
				}
				const inputBody = init2.body
					? init2.body
					: isRequest(input) && input.body !== null
					? clone(input)
					: null;
				super(inputBody, {
					size: init2.size || input.size || 0
				});
				const headers2 = new Headers3(init2.headers || input.headers || {});
				if (inputBody !== null && !headers2.has('Content-Type')) {
					const contentType = extractContentType(inputBody, this);
					if (contentType) {
						headers2.set('Content-Type', contentType);
					}
				}
				let signal = isRequest(input) ? input.signal : null;
				if ('signal' in init2) {
					signal = init2.signal;
				}
				if (signal != null && !isAbortSignal(signal)) {
					throw new TypeError('Expected signal to be an instanceof AbortSignal or EventTarget');
				}
				let referrer = init2.referrer == null ? input.referrer : init2.referrer;
				if (referrer === '') {
					referrer = 'no-referrer';
				} else if (referrer) {
					const parsedReferrer = new URL(referrer);
					referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? 'client' : parsedReferrer;
				} else {
					referrer = void 0;
				}
				this[INTERNALS] = {
					method,
					redirect: init2.redirect || input.redirect || 'follow',
					headers: headers2,
					parsedURL,
					signal,
					referrer
				};
				this.follow =
					init2.follow === void 0 ? (input.follow === void 0 ? 20 : input.follow) : init2.follow;
				this.compress =
					init2.compress === void 0
						? input.compress === void 0
							? true
							: input.compress
						: init2.compress;
				this.counter = init2.counter || input.counter || 0;
				this.agent = init2.agent || input.agent;
				this.highWaterMark = init2.highWaterMark || input.highWaterMark || 16384;
				this.insecureHTTPParser = init2.insecureHTTPParser || input.insecureHTTPParser || false;
				this.referrerPolicy = init2.referrerPolicy || input.referrerPolicy || '';
			}
			get method() {
				return this[INTERNALS].method;
			}
			get url() {
				return (0, import_node_url.format)(this[INTERNALS].parsedURL);
			}
			get headers() {
				return this[INTERNALS].headers;
			}
			get redirect() {
				return this[INTERNALS].redirect;
			}
			get signal() {
				return this[INTERNALS].signal;
			}
			get referrer() {
				if (this[INTERNALS].referrer === 'no-referrer') {
					return '';
				}
				if (this[INTERNALS].referrer === 'client') {
					return 'about:client';
				}
				if (this[INTERNALS].referrer) {
					return this[INTERNALS].referrer.toString();
				}
				return void 0;
			}
			get referrerPolicy() {
				return this[INTERNALS].referrerPolicy;
			}
			set referrerPolicy(referrerPolicy2) {
				this[INTERNALS].referrerPolicy = validateReferrerPolicy(referrerPolicy2);
			}
			clone() {
				return new Request$12(this);
			}
			get [Symbol.toStringTag]() {
				return 'Request';
			}
		};
		Object.defineProperties(Request$12.prototype, {
			method: { enumerable: true },
			url: { enumerable: true },
			headers: { enumerable: true },
			redirect: { enumerable: true },
			clone: { enumerable: true },
			signal: { enumerable: true },
			referrer: { enumerable: true },
			referrerPolicy: { enumerable: true }
		});
		if (!globalThis.DOMException) {
			try {
				const { MessageChannel } = require('worker_threads'),
					port = new MessageChannel().port1,
					ab = new ArrayBuffer();
				port.postMessage(ab, [ab, ab]);
			} catch (err) {
				err.constructor.name === 'DOMException' && (globalThis.DOMException = err.constructor);
			}
		}
	}
});

// .svelte-kit/output/server/chunks/index-1259f1f6.js
function run(fn) {
	return fn();
}
function blank_object() {
	return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
	fns.forEach(run);
}
function set_current_component(component) {
	current_component = component;
}
function get_current_component() {
	if (!current_component) throw new Error('Function called outside component initialization');
	return current_component;
}
function setContext(key3, context) {
	get_current_component().$$.context.set(key3, context);
	return context;
}
function escape(html9) {
	return String(html9).replace(/["'&<>]/g, (match) => escaped[match]);
}
function escape_attribute_value(value) {
	return typeof value === 'string' ? escape(value) : value;
}
function each(items, fn) {
	let str = '';
	for (let i2 = 0; i2 < items.length; i2 += 1) {
		str += fn(items[i2], i2);
	}
	return str;
}
function validate_component(component, name) {
	if (!component || !component.$$render) {
		if (name === 'svelte:component') name += ' this={...}';
		throw new Error(
			`<${name}> is not a valid SSR component. You may need to review your build config to ensure that dependencies are compiled, rather than imported as pre-compiled modules`
		);
	}
	return component;
}
function create_ssr_component(fn) {
	function $$render(result, props, bindings, slots, context) {
		const parent_component = current_component;
		const $$ = {
			on_destroy,
			context: new Map(context || (parent_component ? parent_component.$$.context : [])),
			on_mount: [],
			before_update: [],
			after_update: [],
			callbacks: blank_object()
		};
		set_current_component({ $$ });
		const html9 = fn(result, props, bindings, slots);
		set_current_component(parent_component);
		return html9;
	}
	return {
		render: (props = {}, { $$slots = {}, context = /* @__PURE__ */ new Map() } = {}) => {
			on_destroy = [];
			const result = { title: '', head: '', css: /* @__PURE__ */ new Set() };
			const html9 = $$render(result, props, {}, $$slots, context);
			run_all(on_destroy);
			return {
				html: html9,
				css: {
					code: Array.from(result.css)
						.map((css8) => css8.code)
						.join('\n'),
					map: null
				},
				head: result.title + result.head
			};
		},
		$$render
	};
}
function add_attribute(name, value, boolean3) {
	if (value == null || (boolean3 && !value)) return '';
	const assignment =
		boolean3 && value === true ? '' : `="${escape_attribute_value(value.toString())}"`;
	return ` ${name}${assignment}`;
}
var current_component, escaped, missing_component, on_destroy;
var init_index_1259f1f6 = __esm({
	'.svelte-kit/output/server/chunks/index-1259f1f6.js'() {
		Promise.resolve();
		escaped = {
			'"': '&quot;',
			"'": '&#39;',
			'&': '&amp;',
			'<': '&lt;',
			'>': '&gt;'
		};
		missing_component = {
			$$render: () => ''
		};
	}
});

// .svelte-kit/output/server/chunks/hooks-1c45ba0b.js
var hooks_1c45ba0b_exports = {};
var init_hooks_1c45ba0b = __esm({
	'.svelte-kit/output/server/chunks/hooks-1c45ba0b.js'() {}
});

// .svelte-kit/output/server/entries/pages/__layout.svelte.js
var layout_svelte_exports = {};
__export(layout_svelte_exports, {
	default: () => _layout
});
var css, _layout;
var init_layout_svelte = __esm({
	'.svelte-kit/output/server/entries/pages/__layout.svelte.js'() {
		init_index_1259f1f6();
		css = {
			code: 'header.svelte-1hbqpj{display:flex;justify-content:space-between;border-bottom:1px solid lightgray;padding-left:16px;padding-right:16px}nav.svelte-1hbqpj{display:flex;justify-content:space-between;align-items:center}h1.svelte-1hbqpj{margin:5px;font-weight:400;font-size:25px}',
			map: null
		};
		_layout = create_ssr_component(($$result, $$props, $$bindings, slots) => {
			$$result.css.add(css);
			return `



<header class="${'svelte-1hbqpj'}"><h1 class="${'svelte-1hbqpj'}">My Blog</h1>
    <nav class="${'svelte-1hbqpj'}"><a href="${'/'}">Home</a></nav></header>


${slots.default ? slots.default({}) : ``}`;
		});
	}
});

// .svelte-kit/output/server/nodes/0.js
var __exports = {};
__export(__exports, {
	css: () => css2,
	entry: () => entry,
	index: () => index,
	js: () => js,
	module: () => layout_svelte_exports
});
var index, entry, js, css2;
var init__ = __esm({
	'.svelte-kit/output/server/nodes/0.js'() {
		init_layout_svelte();
		index = 0;
		entry = 'pages/__layout.svelte-a112c467.js';
		js = ['pages/__layout.svelte-a112c467.js', 'chunks/index-429e7792.js'];
		css2 = ['assets/pages/__layout.svelte-e39b3653.css'];
	}
});

// .svelte-kit/output/server/entries/fallbacks/error.svelte.js
var error_svelte_exports = {};
__export(error_svelte_exports, {
	default: () => Error2,
	load: () => load
});
function load({ error: error2, status }) {
	return { props: { error: error2, status } };
}
var Error2;
var init_error_svelte = __esm({
	'.svelte-kit/output/server/entries/fallbacks/error.svelte.js'() {
		init_index_1259f1f6();
		Error2 = create_ssr_component(($$result, $$props, $$bindings, slots) => {
			let { status } = $$props;
			let { error: error2 } = $$props;
			if ($$props.status === void 0 && $$bindings.status && status !== void 0)
				$$bindings.status(status);
			if ($$props.error === void 0 && $$bindings.error && error2 !== void 0)
				$$bindings.error(error2);
			return `<h1>${escape(status)}</h1>

<pre>${escape(error2.message)}</pre>



${error2.frame ? `<pre>${escape(error2.frame)}</pre>` : ``}
${error2.stack ? `<pre>${escape(error2.stack)}</pre>` : ``}`;
		});
	}
});

// .svelte-kit/output/server/nodes/1.js
var __exports2 = {};
__export(__exports2, {
	css: () => css3,
	entry: () => entry2,
	index: () => index2,
	js: () => js2,
	module: () => error_svelte_exports
});
var index2, entry2, js2, css3;
var init__2 = __esm({
	'.svelte-kit/output/server/nodes/1.js'() {
		init_error_svelte();
		index2 = 1;
		entry2 = 'error.svelte-f0008aab.js';
		js2 = ['error.svelte-f0008aab.js', 'chunks/index-429e7792.js'];
		css3 = [];
	}
});

// .svelte-kit/output/server/entries/pages/index.svelte.js
var index_svelte_exports = {};
__export(index_svelte_exports, {
	default: () => Routes,
	load: () => load2
});
async function load2({ fetch: fetch3 }) {
	const posts = await fetch3('/post.json').then((res) => {
		return res.json();
	});
	return { props: { posts } };
}
var Post_card, css4, Routes;
var init_index_svelte = __esm({
	'.svelte-kit/output/server/entries/pages/index.svelte.js'() {
		init_index_1259f1f6();
		Post_card = create_ssr_component(($$result, $$props, $$bindings, slots) => {
			let { title } = $$props;
			let { description } = $$props;
			let { url } = $$props;
			if ($$props.title === void 0 && $$bindings.title && title !== void 0) $$bindings.title(title);
			if ($$props.description === void 0 && $$bindings.description && description !== void 0)
				$$bindings.description(description);
			if ($$props.url === void 0 && $$bindings.url && url !== void 0) $$bindings.url(url);
			return `<article><h1>${escape(title)}</h1>
    <p>${escape(description)}</p>
    <a${add_attribute('href', url, 0)}>Read more...</a></article>`;
		});
		css4 = {
			code: 'a{color:black}main.svelte-8q8u67{padding:16px}',
			map: null
		};
		Routes = create_ssr_component(($$result, $$props, $$bindings, slots) => {
			let { posts = [] } = $$props;
			if ($$props.posts === void 0 && $$bindings.posts && posts !== void 0) $$bindings.posts(posts);
			$$result.css.add(css4);
			return `





${(($$result.head += `${(($$result.title = `<title>My Blog</title>`), '')}`), '')}

<main class="${'svelte-8q8u67'}"><h1>Posts</h1>

    
    ${
			posts
				? `${each(posts, (post, index6) => {
						return `
            
            ${validate_component(Post_card, 'PostCard').$$render(
							$$result,
							{
								title: post.title,
								description: post.description,
								url: post.url
							},
							{},
							{}
						)}`;
				  })}`
				: ``
		}
</main>`;
		});
	}
});

// .svelte-kit/output/server/nodes/2.js
var __exports3 = {};
__export(__exports3, {
	css: () => css5,
	entry: () => entry3,
	index: () => index3,
	js: () => js3,
	module: () => index_svelte_exports
});
var index3, entry3, js3, css5;
var init__3 = __esm({
	'.svelte-kit/output/server/nodes/2.js'() {
		init_index_svelte();
		index3 = 2;
		entry3 = 'pages/index.svelte-dd005461.js';
		js3 = ['pages/index.svelte-dd005461.js', 'chunks/index-429e7792.js'];
		css5 = ['assets/pages/index.svelte-0d6e5593.css'];
	}
});

// .svelte-kit/output/server/entries/pages/posts/_slug_.svelte.js
var slug_svelte_exports = {};
__export(slug_svelte_exports, {
	default: () => U5Bslugu5D,
	load: () => load3
});
async function load3({ url, params, fetch: fetch3, session, stuff }) {
	const { slug } = params;
	const post = (await fetch3(`/posts/${slug}.json`).then((r2) => r2.json())) || {};
	return { props: { post } };
}
var css6, U5Bslugu5D;
var init_slug_svelte = __esm({
	'.svelte-kit/output/server/entries/pages/posts/_slug_.svelte.js'() {
		init_index_1259f1f6();
		css6 = { code: '{padding:16px}', map: null };
		U5Bslugu5D = create_ssr_component(($$result, $$props, $$bindings, slots) => {
			let { post = {} } = $$props;
			if ($$props.post === void 0 && $$bindings.post && post !== void 0) $$bindings.post(post);
			$$result.css.add(css6);
			return `<article><h1 class="${'section-header'}">${escape(post.attributes.title)}</h1>
    <p>${escape(post.attributes.description)}</p>
    <!-- HTML_TAG_START -->${post.html}<!-- HTML_TAG_END --></article>`;
		});
	}
});

// .svelte-kit/output/server/nodes/3.js
var __exports4 = {};
__export(__exports4, {
	css: () => css7,
	entry: () => entry4,
	index: () => index4,
	js: () => js4,
	module: () => slug_svelte_exports
});
var index4, entry4, js4, css7;
var init__4 = __esm({
	'.svelte-kit/output/server/nodes/3.js'() {
		init_slug_svelte();
		index4 = 3;
		entry4 = 'pages/posts/_slug_.svelte-aae023d7.js';
		js4 = ['pages/posts/_slug_.svelte-aae023d7.js', 'chunks/index-429e7792.js'];
		css7 = ['assets/pages/posts/_slug_.svelte-57d52048.css'];
	}
});

// node_modules/fs.realpath/old.js
var require_old = __commonJS({
	'node_modules/fs.realpath/old.js'(exports) {
		var pathModule = require('path');
		var isWindows = process.platform === 'win32';
		var fs2 = require('fs');
		var DEBUG = process.env.NODE_DEBUG && /fs/.test(process.env.NODE_DEBUG);
		function rethrow() {
			var callback;
			if (DEBUG) {
				var backtrace = new Error();
				callback = debugCallback;
			} else callback = missingCallback;
			return callback;
			function debugCallback(err) {
				if (err) {
					backtrace.message = err.message;
					err = backtrace;
					missingCallback(err);
				}
			}
			function missingCallback(err) {
				if (err) {
					if (process.throwDeprecation) throw err;
					else if (!process.noDeprecation) {
						var msg = 'fs: missing callback ' + (err.stack || err.message);
						if (process.traceDeprecation) console.trace(msg);
						else console.error(msg);
					}
				}
			}
		}
		function maybeCallback(cb) {
			return typeof cb === 'function' ? cb : rethrow();
		}
		var normalize8 = pathModule.normalize;
		if (isWindows) {
			nextPartRe = /(.*?)(?:[\/\\]+|$)/g;
		} else {
			nextPartRe = /(.*?)(?:[\/]+|$)/g;
		}
		var nextPartRe;
		if (isWindows) {
			splitRootRe = /^(?:[a-zA-Z]:|[\\\/]{2}[^\\\/]+[\\\/][^\\\/]+)?[\\\/]*/;
		} else {
			splitRootRe = /^[\/]*/;
		}
		var splitRootRe;
		exports.realpathSync = function realpathSync(p2, cache) {
			p2 = pathModule.resolve(p2);
			if (cache && Object.prototype.hasOwnProperty.call(cache, p2)) {
				return cache[p2];
			}
			var original = p2,
				seenLinks = {},
				knownHard = {};
			var pos;
			var current;
			var base4;
			var previous2;
			start();
			function start() {
				var m2 = splitRootRe.exec(p2);
				pos = m2[0].length;
				current = m2[0];
				base4 = m2[0];
				previous2 = '';
				if (isWindows && !knownHard[base4]) {
					fs2.lstatSync(base4);
					knownHard[base4] = true;
				}
			}
			while (pos < p2.length) {
				nextPartRe.lastIndex = pos;
				var result = nextPartRe.exec(p2);
				previous2 = current;
				current += result[0];
				base4 = previous2 + result[1];
				pos = nextPartRe.lastIndex;
				if (knownHard[base4] || (cache && cache[base4] === base4)) {
					continue;
				}
				var resolvedLink;
				if (cache && Object.prototype.hasOwnProperty.call(cache, base4)) {
					resolvedLink = cache[base4];
				} else {
					var stat = fs2.lstatSync(base4);
					if (!stat.isSymbolicLink()) {
						knownHard[base4] = true;
						if (cache) cache[base4] = base4;
						continue;
					}
					var linkTarget = null;
					if (!isWindows) {
						var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
						if (seenLinks.hasOwnProperty(id)) {
							linkTarget = seenLinks[id];
						}
					}
					if (linkTarget === null) {
						fs2.statSync(base4);
						linkTarget = fs2.readlinkSync(base4);
					}
					resolvedLink = pathModule.resolve(previous2, linkTarget);
					if (cache) cache[base4] = resolvedLink;
					if (!isWindows) seenLinks[id] = linkTarget;
				}
				p2 = pathModule.resolve(resolvedLink, p2.slice(pos));
				start();
			}
			if (cache) cache[original] = p2;
			return p2;
		};
		exports.realpath = function realpath(p2, cache, cb) {
			if (typeof cb !== 'function') {
				cb = maybeCallback(cache);
				cache = null;
			}
			p2 = pathModule.resolve(p2);
			if (cache && Object.prototype.hasOwnProperty.call(cache, p2)) {
				return process.nextTick(cb.bind(null, null, cache[p2]));
			}
			var original = p2,
				seenLinks = {},
				knownHard = {};
			var pos;
			var current;
			var base4;
			var previous2;
			start();
			function start() {
				var m2 = splitRootRe.exec(p2);
				pos = m2[0].length;
				current = m2[0];
				base4 = m2[0];
				previous2 = '';
				if (isWindows && !knownHard[base4]) {
					fs2.lstat(base4, function (err) {
						if (err) return cb(err);
						knownHard[base4] = true;
						LOOP();
					});
				} else {
					process.nextTick(LOOP);
				}
			}
			function LOOP() {
				if (pos >= p2.length) {
					if (cache) cache[original] = p2;
					return cb(null, p2);
				}
				nextPartRe.lastIndex = pos;
				var result = nextPartRe.exec(p2);
				previous2 = current;
				current += result[0];
				base4 = previous2 + result[1];
				pos = nextPartRe.lastIndex;
				if (knownHard[base4] || (cache && cache[base4] === base4)) {
					return process.nextTick(LOOP);
				}
				if (cache && Object.prototype.hasOwnProperty.call(cache, base4)) {
					return gotResolvedLink(cache[base4]);
				}
				return fs2.lstat(base4, gotStat);
			}
			function gotStat(err, stat) {
				if (err) return cb(err);
				if (!stat.isSymbolicLink()) {
					knownHard[base4] = true;
					if (cache) cache[base4] = base4;
					return process.nextTick(LOOP);
				}
				if (!isWindows) {
					var id = stat.dev.toString(32) + ':' + stat.ino.toString(32);
					if (seenLinks.hasOwnProperty(id)) {
						return gotTarget(null, seenLinks[id], base4);
					}
				}
				fs2.stat(base4, function (err2) {
					if (err2) return cb(err2);
					fs2.readlink(base4, function (err3, target) {
						if (!isWindows) seenLinks[id] = target;
						gotTarget(err3, target);
					});
				});
			}
			function gotTarget(err, target, base5) {
				if (err) return cb(err);
				var resolvedLink = pathModule.resolve(previous2, target);
				if (cache) cache[base5] = resolvedLink;
				gotResolvedLink(resolvedLink);
			}
			function gotResolvedLink(resolvedLink) {
				p2 = pathModule.resolve(resolvedLink, p2.slice(pos));
				start();
			}
		};
	}
});

// node_modules/fs.realpath/index.js
var require_fs = __commonJS({
	'node_modules/fs.realpath/index.js'(exports, module2) {
		module2.exports = realpath;
		realpath.realpath = realpath;
		realpath.sync = realpathSync;
		realpath.realpathSync = realpathSync;
		realpath.monkeypatch = monkeypatch;
		realpath.unmonkeypatch = unmonkeypatch;
		var fs2 = require('fs');
		var origRealpath = fs2.realpath;
		var origRealpathSync = fs2.realpathSync;
		var version = process.version;
		var ok2 = /^v[0-5]\./.test(version);
		var old = require_old();
		function newError(er) {
			return (
				er &&
				er.syscall === 'realpath' &&
				(er.code === 'ELOOP' || er.code === 'ENOMEM' || er.code === 'ENAMETOOLONG')
			);
		}
		function realpath(p2, cache, cb) {
			if (ok2) {
				return origRealpath(p2, cache, cb);
			}
			if (typeof cache === 'function') {
				cb = cache;
				cache = null;
			}
			origRealpath(p2, cache, function (er, result) {
				if (newError(er)) {
					old.realpath(p2, cache, cb);
				} else {
					cb(er, result);
				}
			});
		}
		function realpathSync(p2, cache) {
			if (ok2) {
				return origRealpathSync(p2, cache);
			}
			try {
				return origRealpathSync(p2, cache);
			} catch (er) {
				if (newError(er)) {
					return old.realpathSync(p2, cache);
				} else {
					throw er;
				}
			}
		}
		function monkeypatch() {
			fs2.realpath = realpath;
			fs2.realpathSync = realpathSync;
		}
		function unmonkeypatch() {
			fs2.realpath = origRealpath;
			fs2.realpathSync = origRealpathSync;
		}
	}
});

// node_modules/glob/node_modules/minimatch/lib/path.js
var require_path = __commonJS({
	'node_modules/glob/node_modules/minimatch/lib/path.js'(exports, module2) {
		var isWindows = typeof process === 'object' && process && process.platform === 'win32';
		module2.exports = isWindows ? { sep: '\\' } : { sep: '/' };
	}
});

// node_modules/balanced-match/index.js
var require_balanced_match = __commonJS({
	'node_modules/balanced-match/index.js'(exports, module2) {
		'use strict';
		module2.exports = balanced;
		function balanced(a, b, str) {
			if (a instanceof RegExp) a = maybeMatch(a, str);
			if (b instanceof RegExp) b = maybeMatch(b, str);
			var r2 = range(a, b, str);
			return (
				r2 && {
					start: r2[0],
					end: r2[1],
					pre: str.slice(0, r2[0]),
					body: str.slice(r2[0] + a.length, r2[1]),
					post: str.slice(r2[1] + b.length)
				}
			);
		}
		function maybeMatch(reg, str) {
			var m2 = str.match(reg);
			return m2 ? m2[0] : null;
		}
		balanced.range = range;
		function range(a, b, str) {
			var begs, beg, left, right, result;
			var ai = str.indexOf(a);
			var bi = str.indexOf(b, ai + 1);
			var i2 = ai;
			if (ai >= 0 && bi > 0) {
				if (a === b) {
					return [ai, bi];
				}
				begs = [];
				left = str.length;
				while (i2 >= 0 && !result) {
					if (i2 == ai) {
						begs.push(i2);
						ai = str.indexOf(a, i2 + 1);
					} else if (begs.length == 1) {
						result = [begs.pop(), bi];
					} else {
						beg = begs.pop();
						if (beg < left) {
							left = beg;
							right = bi;
						}
						bi = str.indexOf(b, i2 + 1);
					}
					i2 = ai < bi && ai >= 0 ? ai : bi;
				}
				if (begs.length) {
					result = [left, right];
				}
			}
			return result;
		}
	}
});

// node_modules/glob/node_modules/brace-expansion/index.js
var require_brace_expansion = __commonJS({
	'node_modules/glob/node_modules/brace-expansion/index.js'(exports, module2) {
		var balanced = require_balanced_match();
		module2.exports = expandTop;
		var escSlash = '\0SLASH' + Math.random() + '\0';
		var escOpen = '\0OPEN' + Math.random() + '\0';
		var escClose = '\0CLOSE' + Math.random() + '\0';
		var escComma = '\0COMMA' + Math.random() + '\0';
		var escPeriod = '\0PERIOD' + Math.random() + '\0';
		function numeric(str) {
			return parseInt(str, 10) == str ? parseInt(str, 10) : str.charCodeAt(0);
		}
		function escapeBraces(str) {
			return str
				.split('\\\\')
				.join(escSlash)
				.split('\\{')
				.join(escOpen)
				.split('\\}')
				.join(escClose)
				.split('\\,')
				.join(escComma)
				.split('\\.')
				.join(escPeriod);
		}
		function unescapeBraces(str) {
			return str
				.split(escSlash)
				.join('\\')
				.split(escOpen)
				.join('{')
				.split(escClose)
				.join('}')
				.split(escComma)
				.join(',')
				.split(escPeriod)
				.join('.');
		}
		function parseCommaParts(str) {
			if (!str) return [''];
			var parts = [];
			var m2 = balanced('{', '}', str);
			if (!m2) return str.split(',');
			var pre = m2.pre;
			var body4 = m2.body;
			var post = m2.post;
			var p2 = pre.split(',');
			p2[p2.length - 1] += '{' + body4 + '}';
			var postParts = parseCommaParts(post);
			if (post.length) {
				p2[p2.length - 1] += postParts.shift();
				p2.push.apply(p2, postParts);
			}
			parts.push.apply(parts, p2);
			return parts;
		}
		function expandTop(str) {
			if (!str) return [];
			if (str.substr(0, 2) === '{}') {
				str = '\\{\\}' + str.substr(2);
			}
			return expand(escapeBraces(str), true).map(unescapeBraces);
		}
		function embrace(str) {
			return '{' + str + '}';
		}
		function isPadded(el) {
			return /^-?0\d/.test(el);
		}
		function lte(i2, y) {
			return i2 <= y;
		}
		function gte(i2, y) {
			return i2 >= y;
		}
		function expand(str, isTop) {
			var expansions = [];
			var m2 = balanced('{', '}', str);
			if (!m2) return [str];
			var pre = m2.pre;
			var post = m2.post.length ? expand(m2.post, false) : [''];
			if (/\$$/.test(m2.pre)) {
				for (var k = 0; k < post.length; k++) {
					var expansion = pre + '{' + m2.body + '}' + post[k];
					expansions.push(expansion);
				}
			} else {
				var isNumericSequence = /^-?\d+\.\.-?\d+(?:\.\.-?\d+)?$/.test(m2.body);
				var isAlphaSequence = /^[a-zA-Z]\.\.[a-zA-Z](?:\.\.-?\d+)?$/.test(m2.body);
				var isSequence = isNumericSequence || isAlphaSequence;
				var isOptions = m2.body.indexOf(',') >= 0;
				if (!isSequence && !isOptions) {
					if (m2.post.match(/,.*\}/)) {
						str = m2.pre + '{' + m2.body + escClose + m2.post;
						return expand(str);
					}
					return [str];
				}
				var n;
				if (isSequence) {
					n = m2.body.split(/\.\./);
				} else {
					n = parseCommaParts(m2.body);
					if (n.length === 1) {
						n = expand(n[0], false).map(embrace);
						if (n.length === 1) {
							return post.map(function (p2) {
								return m2.pre + n[0] + p2;
							});
						}
					}
				}
				var N;
				if (isSequence) {
					var x2 = numeric(n[0]);
					var y = numeric(n[1]);
					var width = Math.max(n[0].length, n[1].length);
					var incr = n.length == 3 ? Math.abs(numeric(n[2])) : 1;
					var test = lte;
					var reverse = y < x2;
					if (reverse) {
						incr *= -1;
						test = gte;
					}
					var pad = n.some(isPadded);
					N = [];
					for (var i2 = x2; test(i2, y); i2 += incr) {
						var c;
						if (isAlphaSequence) {
							c = String.fromCharCode(i2);
							if (c === '\\') c = '';
						} else {
							c = String(i2);
							if (pad) {
								var need = width - c.length;
								if (need > 0) {
									var z = new Array(need + 1).join('0');
									if (i2 < 0) c = '-' + z + c.slice(1);
									else c = z + c;
								}
							}
						}
						N.push(c);
					}
				} else {
					N = [];
					for (var j = 0; j < n.length; j++) {
						N.push.apply(N, expand(n[j], false));
					}
				}
				for (var j = 0; j < N.length; j++) {
					for (var k = 0; k < post.length; k++) {
						var expansion = pre + N[j] + post[k];
						if (!isTop || isSequence || expansion) expansions.push(expansion);
					}
				}
			}
			return expansions;
		}
	}
});

// node_modules/glob/node_modules/minimatch/minimatch.js
var require_minimatch = __commonJS({
	'node_modules/glob/node_modules/minimatch/minimatch.js'(exports, module2) {
		var minimatch = (module2.exports = (p2, pattern, options = {}) => {
			assertValidPattern(pattern);
			if (!options.nocomment && pattern.charAt(0) === '#') {
				return false;
			}
			return new Minimatch(pattern, options).match(p2);
		});
		module2.exports = minimatch;
		var path = require_path();
		minimatch.sep = path.sep;
		var GLOBSTAR = Symbol('globstar **');
		minimatch.GLOBSTAR = GLOBSTAR;
		var expand = require_brace_expansion();
		var plTypes = {
			'!': { open: '(?:(?!(?:', close: '))[^/]*?)' },
			'?': { open: '(?:', close: ')?' },
			'+': { open: '(?:', close: ')+' },
			'*': { open: '(?:', close: ')*' },
			'@': { open: '(?:', close: ')' }
		};
		var qmark = '[^/]';
		var star = qmark + '*?';
		var twoStarDot = '(?:(?!(?:\\/|^)(?:\\.{1,2})($|\\/)).)*?';
		var twoStarNoDot = '(?:(?!(?:\\/|^)\\.).)*?';
		var charSet = (s4) =>
			s4.split('').reduce((set, c) => {
				set[c] = true;
				return set;
			}, {});
		var reSpecials = charSet('().*{}+?[]^$\\!');
		var addPatternStartSet = charSet('[.(');
		var slashSplit = /\/+/;
		minimatch.filter =
			(pattern, options = {}) =>
			(p2, i2, list4) =>
				minimatch(p2, pattern, options);
		var ext = (a, b = {}) => {
			const t2 = {};
			Object.keys(a).forEach((k) => (t2[k] = a[k]));
			Object.keys(b).forEach((k) => (t2[k] = b[k]));
			return t2;
		};
		minimatch.defaults = (def) => {
			if (!def || typeof def !== 'object' || !Object.keys(def).length) {
				return minimatch;
			}
			const orig = minimatch;
			const m2 = (p2, pattern, options) => orig(p2, pattern, ext(def, options));
			m2.Minimatch = class Minimatch extends orig.Minimatch {
				constructor(pattern, options) {
					super(pattern, ext(def, options));
				}
			};
			m2.Minimatch.defaults = (options) => orig.defaults(ext(def, options)).Minimatch;
			m2.filter = (pattern, options) => orig.filter(pattern, ext(def, options));
			m2.defaults = (options) => orig.defaults(ext(def, options));
			m2.makeRe = (pattern, options) => orig.makeRe(pattern, ext(def, options));
			m2.braceExpand = (pattern, options) => orig.braceExpand(pattern, ext(def, options));
			m2.match = (list4, pattern, options) => orig.match(list4, pattern, ext(def, options));
			return m2;
		};
		minimatch.braceExpand = (pattern, options) => braceExpand(pattern, options);
		var braceExpand = (pattern, options = {}) => {
			assertValidPattern(pattern);
			if (options.nobrace || !/\{(?:(?!\{).)*\}/.test(pattern)) {
				return [pattern];
			}
			return expand(pattern);
		};
		var MAX_PATTERN_LENGTH = 1024 * 64;
		var assertValidPattern = (pattern) => {
			if (typeof pattern !== 'string') {
				throw new TypeError('invalid pattern');
			}
			if (pattern.length > MAX_PATTERN_LENGTH) {
				throw new TypeError('pattern is too long');
			}
		};
		var SUBPARSE = Symbol('subparse');
		minimatch.makeRe = (pattern, options) => new Minimatch(pattern, options || {}).makeRe();
		minimatch.match = (list4, pattern, options = {}) => {
			const mm = new Minimatch(pattern, options);
			list4 = list4.filter((f3) => mm.match(f3));
			if (mm.options.nonull && !list4.length) {
				list4.push(pattern);
			}
			return list4;
		};
		var globUnescape = (s4) => s4.replace(/\\(.)/g, '$1');
		var regExpEscape = (s4) => s4.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, '\\$&');
		var Minimatch = class {
			constructor(pattern, options) {
				assertValidPattern(pattern);
				if (!options) options = {};
				this.options = options;
				this.set = [];
				this.pattern = pattern;
				this.windowsPathsNoEscape =
					!!options.windowsPathsNoEscape || options.allowWindowsEscape === false;
				if (this.windowsPathsNoEscape) {
					this.pattern = this.pattern.replace(/\\/g, '/');
				}
				this.regexp = null;
				this.negate = false;
				this.comment = false;
				this.empty = false;
				this.partial = !!options.partial;
				this.make();
			}
			debug() {}
			make() {
				const pattern = this.pattern;
				const options = this.options;
				if (!options.nocomment && pattern.charAt(0) === '#') {
					this.comment = true;
					return;
				}
				if (!pattern) {
					this.empty = true;
					return;
				}
				this.parseNegate();
				let set = (this.globSet = this.braceExpand());
				if (options.debug) this.debug = (...args) => console.error(...args);
				this.debug(this.pattern, set);
				set = this.globParts = set.map((s4) => s4.split(slashSplit));
				this.debug(this.pattern, set);
				set = set.map((s4, si, set2) => s4.map(this.parse, this));
				this.debug(this.pattern, set);
				set = set.filter((s4) => s4.indexOf(false) === -1);
				this.debug(this.pattern, set);
				this.set = set;
			}
			parseNegate() {
				if (this.options.nonegate) return;
				const pattern = this.pattern;
				let negate = false;
				let negateOffset = 0;
				for (let i2 = 0; i2 < pattern.length && pattern.charAt(i2) === '!'; i2++) {
					negate = !negate;
					negateOffset++;
				}
				if (negateOffset) this.pattern = pattern.substr(negateOffset);
				this.negate = negate;
			}
			matchOne(file2, pattern, partial) {
				var options = this.options;
				this.debug('matchOne', { this: this, file: file2, pattern });
				this.debug('matchOne', file2.length, pattern.length);
				for (
					var fi = 0, pi = 0, fl = file2.length, pl = pattern.length;
					fi < fl && pi < pl;
					fi++, pi++
				) {
					this.debug('matchOne loop');
					var p2 = pattern[pi];
					var f3 = file2[fi];
					this.debug(pattern, p2, f3);
					if (p2 === false) return false;
					if (p2 === GLOBSTAR) {
						this.debug('GLOBSTAR', [pattern, p2, f3]);
						var fr = fi;
						var pr = pi + 1;
						if (pr === pl) {
							this.debug('** at the end');
							for (; fi < fl; fi++) {
								if (
									file2[fi] === '.' ||
									file2[fi] === '..' ||
									(!options.dot && file2[fi].charAt(0) === '.')
								)
									return false;
							}
							return true;
						}
						while (fr < fl) {
							var swallowee = file2[fr];
							this.debug('\nglobstar while', file2, fr, pattern, pr, swallowee);
							if (this.matchOne(file2.slice(fr), pattern.slice(pr), partial)) {
								this.debug('globstar found match!', fr, fl, swallowee);
								return true;
							} else {
								if (
									swallowee === '.' ||
									swallowee === '..' ||
									(!options.dot && swallowee.charAt(0) === '.')
								) {
									this.debug('dot detected!', file2, fr, pattern, pr);
									break;
								}
								this.debug('globstar swallow a segment, and continue');
								fr++;
							}
						}
						if (partial) {
							this.debug('\n>>> no match, partial?', file2, fr, pattern, pr);
							if (fr === fl) return true;
						}
						return false;
					}
					var hit;
					if (typeof p2 === 'string') {
						hit = f3 === p2;
						this.debug('string match', p2, f3, hit);
					} else {
						hit = f3.match(p2);
						this.debug('pattern match', p2, f3, hit);
					}
					if (!hit) return false;
				}
				if (fi === fl && pi === pl) {
					return true;
				} else if (fi === fl) {
					return partial;
				} else if (pi === pl) {
					return fi === fl - 1 && file2[fi] === '';
				}
				throw new Error('wtf?');
			}
			braceExpand() {
				return braceExpand(this.pattern, this.options);
			}
			parse(pattern, isSub) {
				assertValidPattern(pattern);
				const options = this.options;
				if (pattern === '**') {
					if (!options.noglobstar) return GLOBSTAR;
					else pattern = '*';
				}
				if (pattern === '') return '';
				let re = '';
				let hasMagic = !!options.nocase;
				let escaping = false;
				const patternListStack = [];
				const negativeLists = [];
				let stateChar;
				let inClass = false;
				let reClassStart = -1;
				let classStart = -1;
				let cs;
				let pl;
				let sp;
				const patternStart =
					pattern.charAt(0) === '.'
						? ''
						: options.dot
						? '(?!(?:^|\\/)\\.{1,2}(?:$|\\/))'
						: '(?!\\.)';
				const clearStateChar = () => {
					if (stateChar) {
						switch (stateChar) {
							case '*':
								re += star;
								hasMagic = true;
								break;
							case '?':
								re += qmark;
								hasMagic = true;
								break;
							default:
								re += '\\' + stateChar;
								break;
						}
						this.debug('clearStateChar %j %j', stateChar, re);
						stateChar = false;
					}
				};
				for (let i2 = 0, c; i2 < pattern.length && (c = pattern.charAt(i2)); i2++) {
					this.debug('%s	%s %s %j', pattern, i2, re, c);
					if (escaping) {
						if (c === '/') {
							return false;
						}
						if (reSpecials[c]) {
							re += '\\';
						}
						re += c;
						escaping = false;
						continue;
					}
					switch (c) {
						case '/': {
							return false;
						}
						case '\\':
							clearStateChar();
							escaping = true;
							continue;
						case '?':
						case '*':
						case '+':
						case '@':
						case '!':
							this.debug('%s	%s %s %j <-- stateChar', pattern, i2, re, c);
							if (inClass) {
								this.debug('  in class');
								if (c === '!' && i2 === classStart + 1) c = '^';
								re += c;
								continue;
							}
							this.debug('call clearStateChar %j', stateChar);
							clearStateChar();
							stateChar = c;
							if (options.noext) clearStateChar();
							continue;
						case '(':
							if (inClass) {
								re += '(';
								continue;
							}
							if (!stateChar) {
								re += '\\(';
								continue;
							}
							patternListStack.push({
								type: stateChar,
								start: i2 - 1,
								reStart: re.length,
								open: plTypes[stateChar].open,
								close: plTypes[stateChar].close
							});
							re += stateChar === '!' ? '(?:(?!(?:' : '(?:';
							this.debug('plType %j %j', stateChar, re);
							stateChar = false;
							continue;
						case ')':
							if (inClass || !patternListStack.length) {
								re += '\\)';
								continue;
							}
							clearStateChar();
							hasMagic = true;
							pl = patternListStack.pop();
							re += pl.close;
							if (pl.type === '!') {
								negativeLists.push(pl);
							}
							pl.reEnd = re.length;
							continue;
						case '|':
							if (inClass || !patternListStack.length) {
								re += '\\|';
								continue;
							}
							clearStateChar();
							re += '|';
							continue;
						case '[':
							clearStateChar();
							if (inClass) {
								re += '\\' + c;
								continue;
							}
							inClass = true;
							classStart = i2;
							reClassStart = re.length;
							re += c;
							continue;
						case ']':
							if (i2 === classStart + 1 || !inClass) {
								re += '\\' + c;
								continue;
							}
							cs = pattern.substring(classStart + 1, i2);
							try {
								RegExp('[' + cs + ']');
							} catch (er) {
								sp = this.parse(cs, SUBPARSE);
								re = re.substr(0, reClassStart) + '\\[' + sp[0] + '\\]';
								hasMagic = hasMagic || sp[1];
								inClass = false;
								continue;
							}
							hasMagic = true;
							inClass = false;
							re += c;
							continue;
						default:
							clearStateChar();
							if (reSpecials[c] && !(c === '^' && inClass)) {
								re += '\\';
							}
							re += c;
							break;
					}
				}
				if (inClass) {
					cs = pattern.substr(classStart + 1);
					sp = this.parse(cs, SUBPARSE);
					re = re.substr(0, reClassStart) + '\\[' + sp[0];
					hasMagic = hasMagic || sp[1];
				}
				for (pl = patternListStack.pop(); pl; pl = patternListStack.pop()) {
					let tail;
					tail = re.slice(pl.reStart + pl.open.length);
					this.debug('setting tail', re, pl);
					tail = tail.replace(/((?:\\{2}){0,64})(\\?)\|/g, (_, $1, $2) => {
						if (!$2) {
							$2 = '\\';
						}
						return $1 + $1 + $2 + '|';
					});
					this.debug('tail=%j\n   %s', tail, tail, pl, re);
					const t2 = pl.type === '*' ? star : pl.type === '?' ? qmark : '\\' + pl.type;
					hasMagic = true;
					re = re.slice(0, pl.reStart) + t2 + '\\(' + tail;
				}
				clearStateChar();
				if (escaping) {
					re += '\\\\';
				}
				const addPatternStart = addPatternStartSet[re.charAt(0)];
				for (let n = negativeLists.length - 1; n > -1; n--) {
					const nl = negativeLists[n];
					const nlBefore = re.slice(0, nl.reStart);
					const nlFirst = re.slice(nl.reStart, nl.reEnd - 8);
					let nlAfter = re.slice(nl.reEnd);
					const nlLast = re.slice(nl.reEnd - 8, nl.reEnd) + nlAfter;
					const openParensBefore = nlBefore.split('(').length - 1;
					let cleanAfter = nlAfter;
					for (let i2 = 0; i2 < openParensBefore; i2++) {
						cleanAfter = cleanAfter.replace(/\)[+*?]?/, '');
					}
					nlAfter = cleanAfter;
					const dollar = nlAfter === '' && isSub !== SUBPARSE ? '$' : '';
					re = nlBefore + nlFirst + nlAfter + dollar + nlLast;
				}
				if (re !== '' && hasMagic) {
					re = '(?=.)' + re;
				}
				if (addPatternStart) {
					re = patternStart + re;
				}
				if (isSub === SUBPARSE) {
					return [re, hasMagic];
				}
				if (!hasMagic) {
					return globUnescape(pattern);
				}
				const flags = options.nocase ? 'i' : '';
				try {
					return Object.assign(new RegExp('^' + re + '$', flags), {
						_glob: pattern,
						_src: re
					});
				} catch (er) {
					return new RegExp('$.');
				}
			}
			makeRe() {
				if (this.regexp || this.regexp === false) return this.regexp;
				const set = this.set;
				if (!set.length) {
					this.regexp = false;
					return this.regexp;
				}
				const options = this.options;
				const twoStar = options.noglobstar ? star : options.dot ? twoStarDot : twoStarNoDot;
				const flags = options.nocase ? 'i' : '';
				let re = set
					.map((pattern) => {
						pattern = pattern
							.map((p2) =>
								typeof p2 === 'string' ? regExpEscape(p2) : p2 === GLOBSTAR ? GLOBSTAR : p2._src
							)
							.reduce((set2, p2) => {
								if (!(set2[set2.length - 1] === GLOBSTAR && p2 === GLOBSTAR)) {
									set2.push(p2);
								}
								return set2;
							}, []);
						pattern.forEach((p2, i2) => {
							if (p2 !== GLOBSTAR || pattern[i2 - 1] === GLOBSTAR) {
								return;
							}
							if (i2 === 0) {
								if (pattern.length > 1) {
									pattern[i2 + 1] = '(?:\\/|' + twoStar + '\\/)?' + pattern[i2 + 1];
								} else {
									pattern[i2] = twoStar;
								}
							} else if (i2 === pattern.length - 1) {
								pattern[i2 - 1] += '(?:\\/|' + twoStar + ')?';
							} else {
								pattern[i2 - 1] += '(?:\\/|\\/' + twoStar + '\\/)' + pattern[i2 + 1];
								pattern[i2 + 1] = GLOBSTAR;
							}
						});
						return pattern.filter((p2) => p2 !== GLOBSTAR).join('/');
					})
					.join('|');
				re = '^(?:' + re + ')$';
				if (this.negate) re = '^(?!' + re + ').*$';
				try {
					this.regexp = new RegExp(re, flags);
				} catch (ex) {
					this.regexp = false;
				}
				return this.regexp;
			}
			match(f3, partial = this.partial) {
				this.debug('match', f3, this.pattern);
				if (this.comment) return false;
				if (this.empty) return f3 === '';
				if (f3 === '/' && partial) return true;
				const options = this.options;
				if (path.sep !== '/') {
					f3 = f3.split(path.sep).join('/');
				}
				f3 = f3.split(slashSplit);
				this.debug(this.pattern, 'split', f3);
				const set = this.set;
				this.debug(this.pattern, 'set', set);
				let filename;
				for (let i2 = f3.length - 1; i2 >= 0; i2--) {
					filename = f3[i2];
					if (filename) break;
				}
				for (let i2 = 0; i2 < set.length; i2++) {
					const pattern = set[i2];
					let file2 = f3;
					if (options.matchBase && pattern.length === 1) {
						file2 = [filename];
					}
					const hit = this.matchOne(file2, pattern, partial);
					if (hit) {
						if (options.flipNegate) return true;
						return !this.negate;
					}
				}
				if (options.flipNegate) return false;
				return this.negate;
			}
			static defaults(def) {
				return minimatch.defaults(def).Minimatch;
			}
		};
		minimatch.Minimatch = Minimatch;
	}
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
	'node_modules/inherits/inherits_browser.js'(exports, module2) {
		if (typeof Object.create === 'function') {
			module2.exports = function inherits(ctor, superCtor) {
				if (superCtor) {
					ctor.super_ = superCtor;
					ctor.prototype = Object.create(superCtor.prototype, {
						constructor: {
							value: ctor,
							enumerable: false,
							writable: true,
							configurable: true
						}
					});
				}
			};
		} else {
			module2.exports = function inherits(ctor, superCtor) {
				if (superCtor) {
					ctor.super_ = superCtor;
					var TempCtor = function () {};
					TempCtor.prototype = superCtor.prototype;
					ctor.prototype = new TempCtor();
					ctor.prototype.constructor = ctor;
				}
			};
		}
	}
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
	'node_modules/inherits/inherits.js'(exports, module2) {
		try {
			util2 = require('util');
			if (typeof util2.inherits !== 'function') throw '';
			module2.exports = util2.inherits;
		} catch (e2) {
			module2.exports = require_inherits_browser();
		}
		var util2;
	}
});

// node_modules/glob/common.js
var require_common = __commonJS({
	'node_modules/glob/common.js'(exports) {
		exports.setopts = setopts;
		exports.ownProp = ownProp;
		exports.makeAbs = makeAbs;
		exports.finish = finish;
		exports.mark = mark3;
		exports.isIgnored = isIgnored;
		exports.childrenIgnored = childrenIgnored;
		function ownProp(obj, field) {
			return Object.prototype.hasOwnProperty.call(obj, field);
		}
		var fs2 = require('fs');
		var path = require('path');
		var minimatch = require_minimatch();
		var isAbsolute = require('path').isAbsolute;
		var Minimatch = minimatch.Minimatch;
		function alphasort(a, b) {
			return a.localeCompare(b, 'en');
		}
		function setupIgnores(self2, options) {
			self2.ignore = options.ignore || [];
			if (!Array.isArray(self2.ignore)) self2.ignore = [self2.ignore];
			if (self2.ignore.length) {
				self2.ignore = self2.ignore.map(ignoreMap);
			}
		}
		function ignoreMap(pattern) {
			var gmatcher = null;
			if (pattern.slice(-3) === '/**') {
				var gpattern = pattern.replace(/(\/\*\*)+$/, '');
				gmatcher = new Minimatch(gpattern, { dot: true });
			}
			return {
				matcher: new Minimatch(pattern, { dot: true }),
				gmatcher
			};
		}
		function setopts(self2, pattern, options) {
			if (!options) options = {};
			if (options.matchBase && pattern.indexOf('/') === -1) {
				if (options.noglobstar) {
					throw new Error('base matching requires globstar');
				}
				pattern = '**/' + pattern;
			}
			self2.silent = !!options.silent;
			self2.pattern = pattern;
			self2.strict = options.strict !== false;
			self2.realpath = !!options.realpath;
			self2.realpathCache = options.realpathCache || /* @__PURE__ */ Object.create(null);
			self2.follow = !!options.follow;
			self2.dot = !!options.dot;
			self2.mark = !!options.mark;
			self2.nodir = !!options.nodir;
			if (self2.nodir) self2.mark = true;
			self2.sync = !!options.sync;
			self2.nounique = !!options.nounique;
			self2.nonull = !!options.nonull;
			self2.nosort = !!options.nosort;
			self2.nocase = !!options.nocase;
			self2.stat = !!options.stat;
			self2.noprocess = !!options.noprocess;
			self2.absolute = !!options.absolute;
			self2.fs = options.fs || fs2;
			self2.maxLength = options.maxLength || Infinity;
			self2.cache = options.cache || /* @__PURE__ */ Object.create(null);
			self2.statCache = options.statCache || /* @__PURE__ */ Object.create(null);
			self2.symlinks = options.symlinks || /* @__PURE__ */ Object.create(null);
			setupIgnores(self2, options);
			self2.changedCwd = false;
			var cwd = process.cwd();
			if (!ownProp(options, 'cwd')) self2.cwd = path.resolve(cwd);
			else {
				self2.cwd = path.resolve(options.cwd);
				self2.changedCwd = self2.cwd !== cwd;
			}
			self2.root = options.root || path.resolve(self2.cwd, '/');
			self2.root = path.resolve(self2.root);
			self2.cwdAbs = isAbsolute(self2.cwd) ? self2.cwd : makeAbs(self2, self2.cwd);
			self2.nomount = !!options.nomount;
			if (process.platform === 'win32') {
				self2.root = self2.root.replace(/\\/g, '/');
				self2.cwd = self2.cwd.replace(/\\/g, '/');
				self2.cwdAbs = self2.cwdAbs.replace(/\\/g, '/');
			}
			options.nonegate = true;
			options.nocomment = true;
			options.allowWindowsEscape = true;
			self2.minimatch = new Minimatch(pattern, options);
			self2.options = self2.minimatch.options;
		}
		function finish(self2) {
			var nou = self2.nounique;
			var all5 = nou ? [] : /* @__PURE__ */ Object.create(null);
			for (var i2 = 0, l = self2.matches.length; i2 < l; i2++) {
				var matches = self2.matches[i2];
				if (!matches || Object.keys(matches).length === 0) {
					if (self2.nonull) {
						var literal = self2.minimatch.globSet[i2];
						if (nou) all5.push(literal);
						else all5[literal] = true;
					}
				} else {
					var m2 = Object.keys(matches);
					if (nou) all5.push.apply(all5, m2);
					else
						m2.forEach(function (m3) {
							all5[m3] = true;
						});
				}
			}
			if (!nou) all5 = Object.keys(all5);
			if (!self2.nosort) all5 = all5.sort(alphasort);
			if (self2.mark) {
				for (var i2 = 0; i2 < all5.length; i2++) {
					all5[i2] = self2._mark(all5[i2]);
				}
				if (self2.nodir) {
					all5 = all5.filter(function (e2) {
						var notDir = !/\/$/.test(e2);
						var c = self2.cache[e2] || self2.cache[makeAbs(self2, e2)];
						if (notDir && c) notDir = c !== 'DIR' && !Array.isArray(c);
						return notDir;
					});
				}
			}
			if (self2.ignore.length)
				all5 = all5.filter(function (m3) {
					return !isIgnored(self2, m3);
				});
			self2.found = all5;
		}
		function mark3(self2, p2) {
			var abs = makeAbs(self2, p2);
			var c = self2.cache[abs];
			var m2 = p2;
			if (c) {
				var isDir = c === 'DIR' || Array.isArray(c);
				var slash = p2.slice(-1) === '/';
				if (isDir && !slash) m2 += '/';
				else if (!isDir && slash) m2 = m2.slice(0, -1);
				if (m2 !== p2) {
					var mabs = makeAbs(self2, m2);
					self2.statCache[mabs] = self2.statCache[abs];
					self2.cache[mabs] = self2.cache[abs];
				}
			}
			return m2;
		}
		function makeAbs(self2, f3) {
			var abs = f3;
			if (f3.charAt(0) === '/') {
				abs = path.join(self2.root, f3);
			} else if (isAbsolute(f3) || f3 === '') {
				abs = f3;
			} else if (self2.changedCwd) {
				abs = path.resolve(self2.cwd, f3);
			} else {
				abs = path.resolve(f3);
			}
			if (process.platform === 'win32') abs = abs.replace(/\\/g, '/');
			return abs;
		}
		function isIgnored(self2, path2) {
			if (!self2.ignore.length) return false;
			return self2.ignore.some(function (item) {
				return item.matcher.match(path2) || !!(item.gmatcher && item.gmatcher.match(path2));
			});
		}
		function childrenIgnored(self2, path2) {
			if (!self2.ignore.length) return false;
			return self2.ignore.some(function (item) {
				return !!(item.gmatcher && item.gmatcher.match(path2));
			});
		}
	}
});

// node_modules/glob/sync.js
var require_sync = __commonJS({
	'node_modules/glob/sync.js'(exports, module2) {
		module2.exports = globSync;
		globSync.GlobSync = GlobSync;
		var rp = require_fs();
		var minimatch = require_minimatch();
		var Minimatch = minimatch.Minimatch;
		var Glob = require_glob().Glob;
		var util2 = require('util');
		var path = require('path');
		var assert2 = require('assert');
		var isAbsolute = require('path').isAbsolute;
		var common = require_common();
		var setopts = common.setopts;
		var ownProp = common.ownProp;
		var childrenIgnored = common.childrenIgnored;
		var isIgnored = common.isIgnored;
		function globSync(pattern, options) {
			if (typeof options === 'function' || arguments.length === 3)
				throw new TypeError(
					'callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167'
				);
			return new GlobSync(pattern, options).found;
		}
		function GlobSync(pattern, options) {
			if (!pattern) throw new Error('must provide pattern');
			if (typeof options === 'function' || arguments.length === 3)
				throw new TypeError(
					'callback provided to sync glob\nSee: https://github.com/isaacs/node-glob/issues/167'
				);
			if (!(this instanceof GlobSync)) return new GlobSync(pattern, options);
			setopts(this, pattern, options);
			if (this.noprocess) return this;
			var n = this.minimatch.set.length;
			this.matches = new Array(n);
			for (var i2 = 0; i2 < n; i2++) {
				this._process(this.minimatch.set[i2], i2, false);
			}
			this._finish();
		}
		GlobSync.prototype._finish = function () {
			assert2.ok(this instanceof GlobSync);
			if (this.realpath) {
				var self2 = this;
				this.matches.forEach(function (matchset, index6) {
					var set = (self2.matches[index6] = /* @__PURE__ */ Object.create(null));
					for (var p2 in matchset) {
						try {
							p2 = self2._makeAbs(p2);
							var real = rp.realpathSync(p2, self2.realpathCache);
							set[real] = true;
						} catch (er) {
							if (er.syscall === 'stat') set[self2._makeAbs(p2)] = true;
							else throw er;
						}
					}
				});
			}
			common.finish(this);
		};
		GlobSync.prototype._process = function (pattern, index6, inGlobStar) {
			assert2.ok(this instanceof GlobSync);
			var n = 0;
			while (typeof pattern[n] === 'string') {
				n++;
			}
			var prefix;
			switch (n) {
				case pattern.length:
					this._processSimple(pattern.join('/'), index6);
					return;
				case 0:
					prefix = null;
					break;
				default:
					prefix = pattern.slice(0, n).join('/');
					break;
			}
			var remain = pattern.slice(n);
			var read2;
			if (prefix === null) read2 = '.';
			else if (
				isAbsolute(prefix) ||
				isAbsolute(
					pattern
						.map(function (p2) {
							return typeof p2 === 'string' ? p2 : '[*]';
						})
						.join('/')
				)
			) {
				if (!prefix || !isAbsolute(prefix)) prefix = '/' + prefix;
				read2 = prefix;
			} else read2 = prefix;
			var abs = this._makeAbs(read2);
			if (childrenIgnored(this, read2)) return;
			var isGlobStar = remain[0] === minimatch.GLOBSTAR;
			if (isGlobStar) this._processGlobStar(prefix, read2, abs, remain, index6, inGlobStar);
			else this._processReaddir(prefix, read2, abs, remain, index6, inGlobStar);
		};
		GlobSync.prototype._processReaddir = function (prefix, read2, abs, remain, index6, inGlobStar) {
			var entries = this._readdir(abs, inGlobStar);
			if (!entries) return;
			var pn = remain[0];
			var negate = !!this.minimatch.negate;
			var rawGlob = pn._glob;
			var dotOk = this.dot || rawGlob.charAt(0) === '.';
			var matchedEntries = [];
			for (var i2 = 0; i2 < entries.length; i2++) {
				var e2 = entries[i2];
				if (e2.charAt(0) !== '.' || dotOk) {
					var m2;
					if (negate && !prefix) {
						m2 = !e2.match(pn);
					} else {
						m2 = e2.match(pn);
					}
					if (m2) matchedEntries.push(e2);
				}
			}
			var len = matchedEntries.length;
			if (len === 0) return;
			if (remain.length === 1 && !this.mark && !this.stat) {
				if (!this.matches[index6]) this.matches[index6] = /* @__PURE__ */ Object.create(null);
				for (var i2 = 0; i2 < len; i2++) {
					var e2 = matchedEntries[i2];
					if (prefix) {
						if (prefix.slice(-1) !== '/') e2 = prefix + '/' + e2;
						else e2 = prefix + e2;
					}
					if (e2.charAt(0) === '/' && !this.nomount) {
						e2 = path.join(this.root, e2);
					}
					this._emitMatch(index6, e2);
				}
				return;
			}
			remain.shift();
			for (var i2 = 0; i2 < len; i2++) {
				var e2 = matchedEntries[i2];
				var newPattern;
				if (prefix) newPattern = [prefix, e2];
				else newPattern = [e2];
				this._process(newPattern.concat(remain), index6, inGlobStar);
			}
		};
		GlobSync.prototype._emitMatch = function (index6, e2) {
			if (isIgnored(this, e2)) return;
			var abs = this._makeAbs(e2);
			if (this.mark) e2 = this._mark(e2);
			if (this.absolute) {
				e2 = abs;
			}
			if (this.matches[index6][e2]) return;
			if (this.nodir) {
				var c = this.cache[abs];
				if (c === 'DIR' || Array.isArray(c)) return;
			}
			this.matches[index6][e2] = true;
			if (this.stat) this._stat(e2);
		};
		GlobSync.prototype._readdirInGlobStar = function (abs) {
			if (this.follow) return this._readdir(abs, false);
			var entries;
			var lstat;
			var stat;
			try {
				lstat = this.fs.lstatSync(abs);
			} catch (er) {
				if (er.code === 'ENOENT') {
					return null;
				}
			}
			var isSym = lstat && lstat.isSymbolicLink();
			this.symlinks[abs] = isSym;
			if (!isSym && lstat && !lstat.isDirectory()) this.cache[abs] = 'FILE';
			else entries = this._readdir(abs, false);
			return entries;
		};
		GlobSync.prototype._readdir = function (abs, inGlobStar) {
			var entries;
			if (inGlobStar && !ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs);
			if (ownProp(this.cache, abs)) {
				var c = this.cache[abs];
				if (!c || c === 'FILE') return null;
				if (Array.isArray(c)) return c;
			}
			try {
				return this._readdirEntries(abs, this.fs.readdirSync(abs));
			} catch (er) {
				this._readdirError(abs, er);
				return null;
			}
		};
		GlobSync.prototype._readdirEntries = function (abs, entries) {
			if (!this.mark && !this.stat) {
				for (var i2 = 0; i2 < entries.length; i2++) {
					var e2 = entries[i2];
					if (abs === '/') e2 = abs + e2;
					else e2 = abs + '/' + e2;
					this.cache[e2] = true;
				}
			}
			this.cache[abs] = entries;
			return entries;
		};
		GlobSync.prototype._readdirError = function (f3, er) {
			switch (er.code) {
				case 'ENOTSUP':
				case 'ENOTDIR':
					var abs = this._makeAbs(f3);
					this.cache[abs] = 'FILE';
					if (abs === this.cwdAbs) {
						var error2 = new Error(er.code + ' invalid cwd ' + this.cwd);
						error2.path = this.cwd;
						error2.code = er.code;
						throw error2;
					}
					break;
				case 'ENOENT':
				case 'ELOOP':
				case 'ENAMETOOLONG':
				case 'UNKNOWN':
					this.cache[this._makeAbs(f3)] = false;
					break;
				default:
					this.cache[this._makeAbs(f3)] = false;
					if (this.strict) throw er;
					if (!this.silent) console.error('glob error', er);
					break;
			}
		};
		GlobSync.prototype._processGlobStar = function (
			prefix,
			read2,
			abs,
			remain,
			index6,
			inGlobStar
		) {
			var entries = this._readdir(abs, inGlobStar);
			if (!entries) return;
			var remainWithoutGlobStar = remain.slice(1);
			var gspref = prefix ? [prefix] : [];
			var noGlobStar = gspref.concat(remainWithoutGlobStar);
			this._process(noGlobStar, index6, false);
			var len = entries.length;
			var isSym = this.symlinks[abs];
			if (isSym && inGlobStar) return;
			for (var i2 = 0; i2 < len; i2++) {
				var e2 = entries[i2];
				if (e2.charAt(0) === '.' && !this.dot) continue;
				var instead = gspref.concat(entries[i2], remainWithoutGlobStar);
				this._process(instead, index6, true);
				var below = gspref.concat(entries[i2], remain);
				this._process(below, index6, true);
			}
		};
		GlobSync.prototype._processSimple = function (prefix, index6) {
			var exists = this._stat(prefix);
			if (!this.matches[index6]) this.matches[index6] = /* @__PURE__ */ Object.create(null);
			if (!exists) return;
			if (prefix && isAbsolute(prefix) && !this.nomount) {
				var trail = /[\/\\]$/.test(prefix);
				if (prefix.charAt(0) === '/') {
					prefix = path.join(this.root, prefix);
				} else {
					prefix = path.resolve(this.root, prefix);
					if (trail) prefix += '/';
				}
			}
			if (process.platform === 'win32') prefix = prefix.replace(/\\/g, '/');
			this._emitMatch(index6, prefix);
		};
		GlobSync.prototype._stat = function (f3) {
			var abs = this._makeAbs(f3);
			var needDir = f3.slice(-1) === '/';
			if (f3.length > this.maxLength) return false;
			if (!this.stat && ownProp(this.cache, abs)) {
				var c = this.cache[abs];
				if (Array.isArray(c)) c = 'DIR';
				if (!needDir || c === 'DIR') return c;
				if (needDir && c === 'FILE') return false;
			}
			var exists;
			var stat = this.statCache[abs];
			if (!stat) {
				var lstat;
				try {
					lstat = this.fs.lstatSync(abs);
				} catch (er) {
					if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
						this.statCache[abs] = false;
						return false;
					}
				}
				if (lstat && lstat.isSymbolicLink()) {
					try {
						stat = this.fs.statSync(abs);
					} catch (er) {
						stat = lstat;
					}
				} else {
					stat = lstat;
				}
			}
			this.statCache[abs] = stat;
			var c = true;
			if (stat) c = stat.isDirectory() ? 'DIR' : 'FILE';
			this.cache[abs] = this.cache[abs] || c;
			if (needDir && c === 'FILE') return false;
			return c;
		};
		GlobSync.prototype._mark = function (p2) {
			return common.mark(this, p2);
		};
		GlobSync.prototype._makeAbs = function (f3) {
			return common.makeAbs(this, f3);
		};
	}
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
	'node_modules/wrappy/wrappy.js'(exports, module2) {
		module2.exports = wrappy;
		function wrappy(fn, cb) {
			if (fn && cb) return wrappy(fn)(cb);
			if (typeof fn !== 'function') throw new TypeError('need wrapper function');
			Object.keys(fn).forEach(function (k) {
				wrapper[k] = fn[k];
			});
			return wrapper;
			function wrapper() {
				var args = new Array(arguments.length);
				for (var i2 = 0; i2 < args.length; i2++) {
					args[i2] = arguments[i2];
				}
				var ret = fn.apply(this, args);
				var cb2 = args[args.length - 1];
				if (typeof ret === 'function' && ret !== cb2) {
					Object.keys(cb2).forEach(function (k) {
						ret[k] = cb2[k];
					});
				}
				return ret;
			}
		}
	}
});

// node_modules/once/once.js
var require_once = __commonJS({
	'node_modules/once/once.js'(exports, module2) {
		var wrappy = require_wrappy();
		module2.exports = wrappy(once);
		module2.exports.strict = wrappy(onceStrict);
		once.proto = once(function () {
			Object.defineProperty(Function.prototype, 'once', {
				value: function () {
					return once(this);
				},
				configurable: true
			});
			Object.defineProperty(Function.prototype, 'onceStrict', {
				value: function () {
					return onceStrict(this);
				},
				configurable: true
			});
		});
		function once(fn) {
			var f3 = function () {
				if (f3.called) return f3.value;
				f3.called = true;
				return (f3.value = fn.apply(this, arguments));
			};
			f3.called = false;
			return f3;
		}
		function onceStrict(fn) {
			var f3 = function () {
				if (f3.called) throw new Error(f3.onceError);
				f3.called = true;
				return (f3.value = fn.apply(this, arguments));
			};
			var name = fn.name || 'Function wrapped with `once`';
			f3.onceError = name + " shouldn't be called more than once";
			f3.called = false;
			return f3;
		}
	}
});

// node_modules/inflight/inflight.js
var require_inflight = __commonJS({
	'node_modules/inflight/inflight.js'(exports, module2) {
		var wrappy = require_wrappy();
		var reqs = /* @__PURE__ */ Object.create(null);
		var once = require_once();
		module2.exports = wrappy(inflight);
		function inflight(key3, cb) {
			if (reqs[key3]) {
				reqs[key3].push(cb);
				return null;
			} else {
				reqs[key3] = [cb];
				return makeres(key3);
			}
		}
		function makeres(key3) {
			return once(function RES() {
				var cbs = reqs[key3];
				var len = cbs.length;
				var args = slice(arguments);
				try {
					for (var i2 = 0; i2 < len; i2++) {
						cbs[i2].apply(null, args);
					}
				} finally {
					if (cbs.length > len) {
						cbs.splice(0, len);
						process.nextTick(function () {
							RES.apply(null, args);
						});
					} else {
						delete reqs[key3];
					}
				}
			});
		}
		function slice(args) {
			var length = args.length;
			var array2 = [];
			for (var i2 = 0; i2 < length; i2++) array2[i2] = args[i2];
			return array2;
		}
	}
});

// node_modules/glob/glob.js
var require_glob = __commonJS({
	'node_modules/glob/glob.js'(exports, module2) {
		module2.exports = glob2;
		var rp = require_fs();
		var minimatch = require_minimatch();
		var Minimatch = minimatch.Minimatch;
		var inherits = require_inherits();
		var EE2 = require('events').EventEmitter;
		var path = require('path');
		var assert2 = require('assert');
		var isAbsolute = require('path').isAbsolute;
		var globSync = require_sync();
		var common = require_common();
		var setopts = common.setopts;
		var ownProp = common.ownProp;
		var inflight = require_inflight();
		var util2 = require('util');
		var childrenIgnored = common.childrenIgnored;
		var isIgnored = common.isIgnored;
		var once = require_once();
		function glob2(pattern, options, cb) {
			if (typeof options === 'function') (cb = options), (options = {});
			if (!options) options = {};
			if (options.sync) {
				if (cb) throw new TypeError('callback provided to sync glob');
				return globSync(pattern, options);
			}
			return new Glob(pattern, options, cb);
		}
		glob2.sync = globSync;
		var GlobSync = (glob2.GlobSync = globSync.GlobSync);
		glob2.glob = glob2;
		function extend2(origin, add) {
			if (add === null || typeof add !== 'object') {
				return origin;
			}
			var keys2 = Object.keys(add);
			var i2 = keys2.length;
			while (i2--) {
				origin[keys2[i2]] = add[keys2[i2]];
			}
			return origin;
		}
		glob2.hasMagic = function (pattern, options_) {
			var options = extend2({}, options_);
			options.noprocess = true;
			var g = new Glob(pattern, options);
			var set = g.minimatch.set;
			if (!pattern) return false;
			if (set.length > 1) return true;
			for (var j = 0; j < set[0].length; j++) {
				if (typeof set[0][j] !== 'string') return true;
			}
			return false;
		};
		glob2.Glob = Glob;
		inherits(Glob, EE2);
		function Glob(pattern, options, cb) {
			if (typeof options === 'function') {
				cb = options;
				options = null;
			}
			if (options && options.sync) {
				if (cb) throw new TypeError('callback provided to sync glob');
				return new GlobSync(pattern, options);
			}
			if (!(this instanceof Glob)) return new Glob(pattern, options, cb);
			setopts(this, pattern, options);
			this._didRealPath = false;
			var n = this.minimatch.set.length;
			this.matches = new Array(n);
			if (typeof cb === 'function') {
				cb = once(cb);
				this.on('error', cb);
				this.on('end', function (matches) {
					cb(null, matches);
				});
			}
			var self2 = this;
			this._processing = 0;
			this._emitQueue = [];
			this._processQueue = [];
			this.paused = false;
			if (this.noprocess) return this;
			if (n === 0) return done();
			var sync = true;
			for (var i2 = 0; i2 < n; i2++) {
				this._process(this.minimatch.set[i2], i2, false, done);
			}
			sync = false;
			function done() {
				--self2._processing;
				if (self2._processing <= 0) {
					if (sync) {
						process.nextTick(function () {
							self2._finish();
						});
					} else {
						self2._finish();
					}
				}
			}
		}
		Glob.prototype._finish = function () {
			assert2(this instanceof Glob);
			if (this.aborted) return;
			if (this.realpath && !this._didRealpath) return this._realpath();
			common.finish(this);
			this.emit('end', this.found);
		};
		Glob.prototype._realpath = function () {
			if (this._didRealpath) return;
			this._didRealpath = true;
			var n = this.matches.length;
			if (n === 0) return this._finish();
			var self2 = this;
			for (var i2 = 0; i2 < this.matches.length; i2++) this._realpathSet(i2, next);
			function next() {
				if (--n === 0) self2._finish();
			}
		};
		Glob.prototype._realpathSet = function (index6, cb) {
			var matchset = this.matches[index6];
			if (!matchset) return cb();
			var found = Object.keys(matchset);
			var self2 = this;
			var n = found.length;
			if (n === 0) return cb();
			var set = (this.matches[index6] = /* @__PURE__ */ Object.create(null));
			found.forEach(function (p2, i2) {
				p2 = self2._makeAbs(p2);
				rp.realpath(p2, self2.realpathCache, function (er, real) {
					if (!er) set[real] = true;
					else if (er.syscall === 'stat') set[p2] = true;
					else self2.emit('error', er);
					if (--n === 0) {
						self2.matches[index6] = set;
						cb();
					}
				});
			});
		};
		Glob.prototype._mark = function (p2) {
			return common.mark(this, p2);
		};
		Glob.prototype._makeAbs = function (f3) {
			return common.makeAbs(this, f3);
		};
		Glob.prototype.abort = function () {
			this.aborted = true;
			this.emit('abort');
		};
		Glob.prototype.pause = function () {
			if (!this.paused) {
				this.paused = true;
				this.emit('pause');
			}
		};
		Glob.prototype.resume = function () {
			if (this.paused) {
				this.emit('resume');
				this.paused = false;
				if (this._emitQueue.length) {
					var eq = this._emitQueue.slice(0);
					this._emitQueue.length = 0;
					for (var i2 = 0; i2 < eq.length; i2++) {
						var e2 = eq[i2];
						this._emitMatch(e2[0], e2[1]);
					}
				}
				if (this._processQueue.length) {
					var pq = this._processQueue.slice(0);
					this._processQueue.length = 0;
					for (var i2 = 0; i2 < pq.length; i2++) {
						var p2 = pq[i2];
						this._processing--;
						this._process(p2[0], p2[1], p2[2], p2[3]);
					}
				}
			}
		};
		Glob.prototype._process = function (pattern, index6, inGlobStar, cb) {
			assert2(this instanceof Glob);
			assert2(typeof cb === 'function');
			if (this.aborted) return;
			this._processing++;
			if (this.paused) {
				this._processQueue.push([pattern, index6, inGlobStar, cb]);
				return;
			}
			var n = 0;
			while (typeof pattern[n] === 'string') {
				n++;
			}
			var prefix;
			switch (n) {
				case pattern.length:
					this._processSimple(pattern.join('/'), index6, cb);
					return;
				case 0:
					prefix = null;
					break;
				default:
					prefix = pattern.slice(0, n).join('/');
					break;
			}
			var remain = pattern.slice(n);
			var read2;
			if (prefix === null) read2 = '.';
			else if (
				isAbsolute(prefix) ||
				isAbsolute(
					pattern
						.map(function (p2) {
							return typeof p2 === 'string' ? p2 : '[*]';
						})
						.join('/')
				)
			) {
				if (!prefix || !isAbsolute(prefix)) prefix = '/' + prefix;
				read2 = prefix;
			} else read2 = prefix;
			var abs = this._makeAbs(read2);
			if (childrenIgnored(this, read2)) return cb();
			var isGlobStar = remain[0] === minimatch.GLOBSTAR;
			if (isGlobStar) this._processGlobStar(prefix, read2, abs, remain, index6, inGlobStar, cb);
			else this._processReaddir(prefix, read2, abs, remain, index6, inGlobStar, cb);
		};
		Glob.prototype._processReaddir = function (prefix, read2, abs, remain, index6, inGlobStar, cb) {
			var self2 = this;
			this._readdir(abs, inGlobStar, function (er, entries) {
				return self2._processReaddir2(prefix, read2, abs, remain, index6, inGlobStar, entries, cb);
			});
		};
		Glob.prototype._processReaddir2 = function (
			prefix,
			read2,
			abs,
			remain,
			index6,
			inGlobStar,
			entries,
			cb
		) {
			if (!entries) return cb();
			var pn = remain[0];
			var negate = !!this.minimatch.negate;
			var rawGlob = pn._glob;
			var dotOk = this.dot || rawGlob.charAt(0) === '.';
			var matchedEntries = [];
			for (var i2 = 0; i2 < entries.length; i2++) {
				var e2 = entries[i2];
				if (e2.charAt(0) !== '.' || dotOk) {
					var m2;
					if (negate && !prefix) {
						m2 = !e2.match(pn);
					} else {
						m2 = e2.match(pn);
					}
					if (m2) matchedEntries.push(e2);
				}
			}
			var len = matchedEntries.length;
			if (len === 0) return cb();
			if (remain.length === 1 && !this.mark && !this.stat) {
				if (!this.matches[index6]) this.matches[index6] = /* @__PURE__ */ Object.create(null);
				for (var i2 = 0; i2 < len; i2++) {
					var e2 = matchedEntries[i2];
					if (prefix) {
						if (prefix !== '/') e2 = prefix + '/' + e2;
						else e2 = prefix + e2;
					}
					if (e2.charAt(0) === '/' && !this.nomount) {
						e2 = path.join(this.root, e2);
					}
					this._emitMatch(index6, e2);
				}
				return cb();
			}
			remain.shift();
			for (var i2 = 0; i2 < len; i2++) {
				var e2 = matchedEntries[i2];
				var newPattern;
				if (prefix) {
					if (prefix !== '/') e2 = prefix + '/' + e2;
					else e2 = prefix + e2;
				}
				this._process([e2].concat(remain), index6, inGlobStar, cb);
			}
			cb();
		};
		Glob.prototype._emitMatch = function (index6, e2) {
			if (this.aborted) return;
			if (isIgnored(this, e2)) return;
			if (this.paused) {
				this._emitQueue.push([index6, e2]);
				return;
			}
			var abs = isAbsolute(e2) ? e2 : this._makeAbs(e2);
			if (this.mark) e2 = this._mark(e2);
			if (this.absolute) e2 = abs;
			if (this.matches[index6][e2]) return;
			if (this.nodir) {
				var c = this.cache[abs];
				if (c === 'DIR' || Array.isArray(c)) return;
			}
			this.matches[index6][e2] = true;
			var st = this.statCache[abs];
			if (st) this.emit('stat', e2, st);
			this.emit('match', e2);
		};
		Glob.prototype._readdirInGlobStar = function (abs, cb) {
			if (this.aborted) return;
			if (this.follow) return this._readdir(abs, false, cb);
			var lstatkey = 'lstat\0' + abs;
			var self2 = this;
			var lstatcb = inflight(lstatkey, lstatcb_);
			if (lstatcb) self2.fs.lstat(abs, lstatcb);
			function lstatcb_(er, lstat) {
				if (er && er.code === 'ENOENT') return cb();
				var isSym = lstat && lstat.isSymbolicLink();
				self2.symlinks[abs] = isSym;
				if (!isSym && lstat && !lstat.isDirectory()) {
					self2.cache[abs] = 'FILE';
					cb();
				} else self2._readdir(abs, false, cb);
			}
		};
		Glob.prototype._readdir = function (abs, inGlobStar, cb) {
			if (this.aborted) return;
			cb = inflight('readdir\0' + abs + '\0' + inGlobStar, cb);
			if (!cb) return;
			if (inGlobStar && !ownProp(this.symlinks, abs)) return this._readdirInGlobStar(abs, cb);
			if (ownProp(this.cache, abs)) {
				var c = this.cache[abs];
				if (!c || c === 'FILE') return cb();
				if (Array.isArray(c)) return cb(null, c);
			}
			var self2 = this;
			self2.fs.readdir(abs, readdirCb(this, abs, cb));
		};
		function readdirCb(self2, abs, cb) {
			return function (er, entries) {
				if (er) self2._readdirError(abs, er, cb);
				else self2._readdirEntries(abs, entries, cb);
			};
		}
		Glob.prototype._readdirEntries = function (abs, entries, cb) {
			if (this.aborted) return;
			if (!this.mark && !this.stat) {
				for (var i2 = 0; i2 < entries.length; i2++) {
					var e2 = entries[i2];
					if (abs === '/') e2 = abs + e2;
					else e2 = abs + '/' + e2;
					this.cache[e2] = true;
				}
			}
			this.cache[abs] = entries;
			return cb(null, entries);
		};
		Glob.prototype._readdirError = function (f3, er, cb) {
			if (this.aborted) return;
			switch (er.code) {
				case 'ENOTSUP':
				case 'ENOTDIR':
					var abs = this._makeAbs(f3);
					this.cache[abs] = 'FILE';
					if (abs === this.cwdAbs) {
						var error2 = new Error(er.code + ' invalid cwd ' + this.cwd);
						error2.path = this.cwd;
						error2.code = er.code;
						this.emit('error', error2);
						this.abort();
					}
					break;
				case 'ENOENT':
				case 'ELOOP':
				case 'ENAMETOOLONG':
				case 'UNKNOWN':
					this.cache[this._makeAbs(f3)] = false;
					break;
				default:
					this.cache[this._makeAbs(f3)] = false;
					if (this.strict) {
						this.emit('error', er);
						this.abort();
					}
					if (!this.silent) console.error('glob error', er);
					break;
			}
			return cb();
		};
		Glob.prototype._processGlobStar = function (
			prefix,
			read2,
			abs,
			remain,
			index6,
			inGlobStar,
			cb
		) {
			var self2 = this;
			this._readdir(abs, inGlobStar, function (er, entries) {
				self2._processGlobStar2(prefix, read2, abs, remain, index6, inGlobStar, entries, cb);
			});
		};
		Glob.prototype._processGlobStar2 = function (
			prefix,
			read2,
			abs,
			remain,
			index6,
			inGlobStar,
			entries,
			cb
		) {
			if (!entries) return cb();
			var remainWithoutGlobStar = remain.slice(1);
			var gspref = prefix ? [prefix] : [];
			var noGlobStar = gspref.concat(remainWithoutGlobStar);
			this._process(noGlobStar, index6, false, cb);
			var isSym = this.symlinks[abs];
			var len = entries.length;
			if (isSym && inGlobStar) return cb();
			for (var i2 = 0; i2 < len; i2++) {
				var e2 = entries[i2];
				if (e2.charAt(0) === '.' && !this.dot) continue;
				var instead = gspref.concat(entries[i2], remainWithoutGlobStar);
				this._process(instead, index6, true, cb);
				var below = gspref.concat(entries[i2], remain);
				this._process(below, index6, true, cb);
			}
			cb();
		};
		Glob.prototype._processSimple = function (prefix, index6, cb) {
			var self2 = this;
			this._stat(prefix, function (er, exists) {
				self2._processSimple2(prefix, index6, er, exists, cb);
			});
		};
		Glob.prototype._processSimple2 = function (prefix, index6, er, exists, cb) {
			if (!this.matches[index6]) this.matches[index6] = /* @__PURE__ */ Object.create(null);
			if (!exists) return cb();
			if (prefix && isAbsolute(prefix) && !this.nomount) {
				var trail = /[\/\\]$/.test(prefix);
				if (prefix.charAt(0) === '/') {
					prefix = path.join(this.root, prefix);
				} else {
					prefix = path.resolve(this.root, prefix);
					if (trail) prefix += '/';
				}
			}
			if (process.platform === 'win32') prefix = prefix.replace(/\\/g, '/');
			this._emitMatch(index6, prefix);
			cb();
		};
		Glob.prototype._stat = function (f3, cb) {
			var abs = this._makeAbs(f3);
			var needDir = f3.slice(-1) === '/';
			if (f3.length > this.maxLength) return cb();
			if (!this.stat && ownProp(this.cache, abs)) {
				var c = this.cache[abs];
				if (Array.isArray(c)) c = 'DIR';
				if (!needDir || c === 'DIR') return cb(null, c);
				if (needDir && c === 'FILE') return cb();
			}
			var exists;
			var stat = this.statCache[abs];
			if (stat !== void 0) {
				if (stat === false) return cb(null, stat);
				else {
					var type = stat.isDirectory() ? 'DIR' : 'FILE';
					if (needDir && type === 'FILE') return cb();
					else return cb(null, type, stat);
				}
			}
			var self2 = this;
			var statcb = inflight('stat\0' + abs, lstatcb_);
			if (statcb) self2.fs.lstat(abs, statcb);
			function lstatcb_(er, lstat) {
				if (lstat && lstat.isSymbolicLink()) {
					return self2.fs.stat(abs, function (er2, stat2) {
						if (er2) self2._stat2(f3, abs, null, lstat, cb);
						else self2._stat2(f3, abs, er2, stat2, cb);
					});
				} else {
					self2._stat2(f3, abs, er, lstat, cb);
				}
			}
		};
		Glob.prototype._stat2 = function (f3, abs, er, stat, cb) {
			if (er && (er.code === 'ENOENT' || er.code === 'ENOTDIR')) {
				this.statCache[abs] = false;
				return cb();
			}
			var needDir = f3.slice(-1) === '/';
			this.statCache[abs] = stat;
			if (abs.slice(-1) === '/' && stat && !stat.isDirectory()) return cb(null, false, stat);
			var c = true;
			if (stat) c = stat.isDirectory() ? 'DIR' : 'FILE';
			this.cache[abs] = this.cache[abs] || c;
			if (needDir && c === 'FILE') return cb();
			return cb(null, c, stat);
		};
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/common.js
var require_common2 = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/common.js'(exports, module2) {
		'use strict';
		function isNothing(subject) {
			return typeof subject === 'undefined' || subject === null;
		}
		function isObject2(subject) {
			return typeof subject === 'object' && subject !== null;
		}
		function toArray(sequence) {
			if (Array.isArray(sequence)) return sequence;
			else if (isNothing(sequence)) return [];
			return [sequence];
		}
		function extend2(target, source) {
			var index6, length, key3, sourceKeys;
			if (source) {
				sourceKeys = Object.keys(source);
				for (index6 = 0, length = sourceKeys.length; index6 < length; index6 += 1) {
					key3 = sourceKeys[index6];
					target[key3] = source[key3];
				}
			}
			return target;
		}
		function repeat(string3, count) {
			var result = '',
				cycle;
			for (cycle = 0; cycle < count; cycle += 1) {
				result += string3;
			}
			return result;
		}
		function isNegativeZero(number3) {
			return number3 === 0 && Number.NEGATIVE_INFINITY === 1 / number3;
		}
		module2.exports.isNothing = isNothing;
		module2.exports.isObject = isObject2;
		module2.exports.toArray = toArray;
		module2.exports.repeat = repeat;
		module2.exports.isNegativeZero = isNegativeZero;
		module2.exports.extend = extend2;
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/exception.js
var require_exception = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/exception.js'(exports, module2) {
		'use strict';
		function YAMLException(reason, mark3) {
			Error.call(this);
			this.name = 'YAMLException';
			this.reason = reason;
			this.mark = mark3;
			this.message =
				(this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');
			if (Error.captureStackTrace) {
				Error.captureStackTrace(this, this.constructor);
			} else {
				this.stack = new Error().stack || '';
			}
		}
		YAMLException.prototype = Object.create(Error.prototype);
		YAMLException.prototype.constructor = YAMLException;
		YAMLException.prototype.toString = function toString2(compact) {
			var result = this.name + ': ';
			result += this.reason || '(unknown reason)';
			if (!compact && this.mark) {
				result += ' ' + this.mark.toString();
			}
			return result;
		};
		module2.exports = YAMLException;
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/mark.js
var require_mark = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/mark.js'(exports, module2) {
		'use strict';
		var common = require_common2();
		function Mark(name, buffer2, position3, line, column) {
			this.name = name;
			this.buffer = buffer2;
			this.position = position3;
			this.line = line;
			this.column = column;
		}
		Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
			var head2, start, tail, end, snippet;
			if (!this.buffer) return null;
			indent = indent || 4;
			maxLength = maxLength || 75;
			head2 = '';
			start = this.position;
			while (start > 0 && '\0\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
				start -= 1;
				if (this.position - start > maxLength / 2 - 1) {
					head2 = ' ... ';
					start += 5;
					break;
				}
			}
			tail = '';
			end = this.position;
			while (
				end < this.buffer.length &&
				'\0\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1
			) {
				end += 1;
				if (end - this.position > maxLength / 2 - 1) {
					tail = ' ... ';
					end -= 5;
					break;
				}
			}
			snippet = this.buffer.slice(start, end);
			return (
				common.repeat(' ', indent) +
				head2 +
				snippet +
				tail +
				'\n' +
				common.repeat(' ', indent + this.position - start + head2.length) +
				'^'
			);
		};
		Mark.prototype.toString = function toString2(compact) {
			var snippet,
				where = '';
			if (this.name) {
				where += 'in "' + this.name + '" ';
			}
			where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);
			if (!compact) {
				snippet = this.getSnippet();
				if (snippet) {
					where += ':\n' + snippet;
				}
			}
			return where;
		};
		module2.exports = Mark;
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type.js
var require_type = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type.js'(exports, module2) {
		'use strict';
		var YAMLException = require_exception();
		var TYPE_CONSTRUCTOR_OPTIONS = [
			'kind',
			'resolve',
			'construct',
			'instanceOf',
			'predicate',
			'represent',
			'defaultStyle',
			'styleAliases'
		];
		var YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping'];
		function compileStyleAliases(map4) {
			var result = {};
			if (map4 !== null) {
				Object.keys(map4).forEach(function (style2) {
					map4[style2].forEach(function (alias) {
						result[String(alias)] = style2;
					});
				});
			}
			return result;
		}
		function Type(tag, options) {
			options = options || {};
			Object.keys(options).forEach(function (name) {
				if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
					throw new YAMLException(
						'Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.'
					);
				}
			});
			this.tag = tag;
			this.kind = options['kind'] || null;
			this.resolve =
				options['resolve'] ||
				function () {
					return true;
				};
			this.construct =
				options['construct'] ||
				function (data2) {
					return data2;
				};
			this.instanceOf = options['instanceOf'] || null;
			this.predicate = options['predicate'] || null;
			this.represent = options['represent'] || null;
			this.defaultStyle = options['defaultStyle'] || null;
			this.styleAliases = compileStyleAliases(options['styleAliases'] || null);
			if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
				throw new YAMLException(
					'Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.'
				);
			}
		}
		module2.exports = Type;
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema.js
var require_schema = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema.js'(exports, module2) {
		'use strict';
		var common = require_common2();
		var YAMLException = require_exception();
		var Type = require_type();
		function compileList(schema, name, result) {
			var exclude = [];
			schema.include.forEach(function (includedSchema) {
				result = compileList(includedSchema, name, result);
			});
			schema[name].forEach(function (currentType) {
				result.forEach(function (previousType, previousIndex) {
					if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
						exclude.push(previousIndex);
					}
				});
				result.push(currentType);
			});
			return result.filter(function (type, index6) {
				return exclude.indexOf(index6) === -1;
			});
		}
		function compileMap() {
			var result = {
					scalar: {},
					sequence: {},
					mapping: {},
					fallback: {}
				},
				index6,
				length;
			function collectType(type) {
				result[type.kind][type.tag] = result['fallback'][type.tag] = type;
			}
			for (index6 = 0, length = arguments.length; index6 < length; index6 += 1) {
				arguments[index6].forEach(collectType);
			}
			return result;
		}
		function Schema3(definition3) {
			this.include = definition3.include || [];
			this.implicit = definition3.implicit || [];
			this.explicit = definition3.explicit || [];
			this.implicit.forEach(function (type) {
				if (type.loadKind && type.loadKind !== 'scalar') {
					throw new YAMLException(
						'There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.'
					);
				}
			});
			this.compiledImplicit = compileList(this, 'implicit', []);
			this.compiledExplicit = compileList(this, 'explicit', []);
			this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
		}
		Schema3.DEFAULT = null;
		Schema3.create = function createSchema() {
			var schemas, types2;
			switch (arguments.length) {
				case 1:
					schemas = Schema3.DEFAULT;
					types2 = arguments[0];
					break;
				case 2:
					schemas = arguments[0];
					types2 = arguments[1];
					break;
				default:
					throw new YAMLException('Wrong number of arguments for Schema.create function');
			}
			schemas = common.toArray(schemas);
			types2 = common.toArray(types2);
			if (
				!schemas.every(function (schema) {
					return schema instanceof Schema3;
				})
			) {
				throw new YAMLException(
					'Specified list of super schemas (or a single Schema object) contains a non-Schema object.'
				);
			}
			if (
				!types2.every(function (type) {
					return type instanceof Type;
				})
			) {
				throw new YAMLException(
					'Specified list of YAML types (or a single Type object) contains a non-Type object.'
				);
			}
			return new Schema3({
				include: schemas,
				explicit: types2
			});
		};
		module2.exports = Schema3;
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/str.js
var require_str = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/str.js'(exports, module2) {
		'use strict';
		var Type = require_type();
		module2.exports = new Type('tag:yaml.org,2002:str', {
			kind: 'scalar',
			construct: function (data2) {
				return data2 !== null ? data2 : '';
			}
		});
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/seq.js
var require_seq = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/seq.js'(exports, module2) {
		'use strict';
		var Type = require_type();
		module2.exports = new Type('tag:yaml.org,2002:seq', {
			kind: 'sequence',
			construct: function (data2) {
				return data2 !== null ? data2 : [];
			}
		});
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/map.js
var require_map = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/map.js'(exports, module2) {
		'use strict';
		var Type = require_type();
		module2.exports = new Type('tag:yaml.org,2002:map', {
			kind: 'mapping',
			construct: function (data2) {
				return data2 !== null ? data2 : {};
			}
		});
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/failsafe.js
var require_failsafe = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/failsafe.js'(
		exports,
		module2
	) {
		'use strict';
		var Schema3 = require_schema();
		module2.exports = new Schema3({
			explicit: [require_str(), require_seq(), require_map()]
		});
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/null.js
var require_null = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/null.js'(exports, module2) {
		'use strict';
		var Type = require_type();
		function resolveYamlNull(data2) {
			if (data2 === null) return true;
			var max = data2.length;
			return (
				(max === 1 && data2 === '~') ||
				(max === 4 && (data2 === 'null' || data2 === 'Null' || data2 === 'NULL'))
			);
		}
		function constructYamlNull() {
			return null;
		}
		function isNull(object) {
			return object === null;
		}
		module2.exports = new Type('tag:yaml.org,2002:null', {
			kind: 'scalar',
			resolve: resolveYamlNull,
			construct: constructYamlNull,
			predicate: isNull,
			represent: {
				canonical: function () {
					return '~';
				},
				lowercase: function () {
					return 'null';
				},
				uppercase: function () {
					return 'NULL';
				},
				camelcase: function () {
					return 'Null';
				}
			},
			defaultStyle: 'lowercase'
		});
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/bool.js
var require_bool = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/bool.js'(exports, module2) {
		'use strict';
		var Type = require_type();
		function resolveYamlBoolean(data2) {
			if (data2 === null) return false;
			var max = data2.length;
			return (
				(max === 4 && (data2 === 'true' || data2 === 'True' || data2 === 'TRUE')) ||
				(max === 5 && (data2 === 'false' || data2 === 'False' || data2 === 'FALSE'))
			);
		}
		function constructYamlBoolean(data2) {
			return data2 === 'true' || data2 === 'True' || data2 === 'TRUE';
		}
		function isBoolean(object) {
			return Object.prototype.toString.call(object) === '[object Boolean]';
		}
		module2.exports = new Type('tag:yaml.org,2002:bool', {
			kind: 'scalar',
			resolve: resolveYamlBoolean,
			construct: constructYamlBoolean,
			predicate: isBoolean,
			represent: {
				lowercase: function (object) {
					return object ? 'true' : 'false';
				},
				uppercase: function (object) {
					return object ? 'TRUE' : 'FALSE';
				},
				camelcase: function (object) {
					return object ? 'True' : 'False';
				}
			},
			defaultStyle: 'lowercase'
		});
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/int.js
var require_int = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/int.js'(exports, module2) {
		'use strict';
		var common = require_common2();
		var Type = require_type();
		function isHexCode(c) {
			return (48 <= c && c <= 57) || (65 <= c && c <= 70) || (97 <= c && c <= 102);
		}
		function isOctCode(c) {
			return 48 <= c && c <= 55;
		}
		function isDecCode(c) {
			return 48 <= c && c <= 57;
		}
		function resolveYamlInteger(data2) {
			if (data2 === null) return false;
			var max = data2.length,
				index6 = 0,
				hasDigits = false,
				ch;
			if (!max) return false;
			ch = data2[index6];
			if (ch === '-' || ch === '+') {
				ch = data2[++index6];
			}
			if (ch === '0') {
				if (index6 + 1 === max) return true;
				ch = data2[++index6];
				if (ch === 'b') {
					index6++;
					for (; index6 < max; index6++) {
						ch = data2[index6];
						if (ch === '_') continue;
						if (ch !== '0' && ch !== '1') return false;
						hasDigits = true;
					}
					return hasDigits && ch !== '_';
				}
				if (ch === 'x') {
					index6++;
					for (; index6 < max; index6++) {
						ch = data2[index6];
						if (ch === '_') continue;
						if (!isHexCode(data2.charCodeAt(index6))) return false;
						hasDigits = true;
					}
					return hasDigits && ch !== '_';
				}
				for (; index6 < max; index6++) {
					ch = data2[index6];
					if (ch === '_') continue;
					if (!isOctCode(data2.charCodeAt(index6))) return false;
					hasDigits = true;
				}
				return hasDigits && ch !== '_';
			}
			if (ch === '_') return false;
			for (; index6 < max; index6++) {
				ch = data2[index6];
				if (ch === '_') continue;
				if (ch === ':') break;
				if (!isDecCode(data2.charCodeAt(index6))) {
					return false;
				}
				hasDigits = true;
			}
			if (!hasDigits || ch === '_') return false;
			if (ch !== ':') return true;
			return /^(:[0-5]?[0-9])+$/.test(data2.slice(index6));
		}
		function constructYamlInteger(data2) {
			var value = data2,
				sign = 1,
				ch,
				base4,
				digits = [];
			if (value.indexOf('_') !== -1) {
				value = value.replace(/_/g, '');
			}
			ch = value[0];
			if (ch === '-' || ch === '+') {
				if (ch === '-') sign = -1;
				value = value.slice(1);
				ch = value[0];
			}
			if (value === '0') return 0;
			if (ch === '0') {
				if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
				if (value[1] === 'x') return sign * parseInt(value, 16);
				return sign * parseInt(value, 8);
			}
			if (value.indexOf(':') !== -1) {
				value.split(':').forEach(function (v) {
					digits.unshift(parseInt(v, 10));
				});
				value = 0;
				base4 = 1;
				digits.forEach(function (d) {
					value += d * base4;
					base4 *= 60;
				});
				return sign * value;
			}
			return sign * parseInt(value, 10);
		}
		function isInteger(object) {
			return (
				Object.prototype.toString.call(object) === '[object Number]' &&
				object % 1 === 0 &&
				!common.isNegativeZero(object)
			);
		}
		module2.exports = new Type('tag:yaml.org,2002:int', {
			kind: 'scalar',
			resolve: resolveYamlInteger,
			construct: constructYamlInteger,
			predicate: isInteger,
			represent: {
				binary: function (obj) {
					return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1);
				},
				octal: function (obj) {
					return obj >= 0 ? '0' + obj.toString(8) : '-0' + obj.toString(8).slice(1);
				},
				decimal: function (obj) {
					return obj.toString(10);
				},
				hexadecimal: function (obj) {
					return obj >= 0
						? '0x' + obj.toString(16).toUpperCase()
						: '-0x' + obj.toString(16).toUpperCase().slice(1);
				}
			},
			defaultStyle: 'decimal',
			styleAliases: {
				binary: [2, 'bin'],
				octal: [8, 'oct'],
				decimal: [10, 'dec'],
				hexadecimal: [16, 'hex']
			}
		});
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/float.js
var require_float = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/float.js'(exports, module2) {
		'use strict';
		var common = require_common2();
		var Type = require_type();
		var YAML_FLOAT_PATTERN = new RegExp(
			'^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$'
		);
		function resolveYamlFloat(data2) {
			if (data2 === null) return false;
			if (!YAML_FLOAT_PATTERN.test(data2) || data2[data2.length - 1] === '_') {
				return false;
			}
			return true;
		}
		function constructYamlFloat(data2) {
			var value, sign, base4, digits;
			value = data2.replace(/_/g, '').toLowerCase();
			sign = value[0] === '-' ? -1 : 1;
			digits = [];
			if ('+-'.indexOf(value[0]) >= 0) {
				value = value.slice(1);
			}
			if (value === '.inf') {
				return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
			} else if (value === '.nan') {
				return NaN;
			} else if (value.indexOf(':') >= 0) {
				value.split(':').forEach(function (v) {
					digits.unshift(parseFloat(v, 10));
				});
				value = 0;
				base4 = 1;
				digits.forEach(function (d) {
					value += d * base4;
					base4 *= 60;
				});
				return sign * value;
			}
			return sign * parseFloat(value, 10);
		}
		var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;
		function representYamlFloat(object, style2) {
			var res;
			if (isNaN(object)) {
				switch (style2) {
					case 'lowercase':
						return '.nan';
					case 'uppercase':
						return '.NAN';
					case 'camelcase':
						return '.NaN';
				}
			} else if (Number.POSITIVE_INFINITY === object) {
				switch (style2) {
					case 'lowercase':
						return '.inf';
					case 'uppercase':
						return '.INF';
					case 'camelcase':
						return '.Inf';
				}
			} else if (Number.NEGATIVE_INFINITY === object) {
				switch (style2) {
					case 'lowercase':
						return '-.inf';
					case 'uppercase':
						return '-.INF';
					case 'camelcase':
						return '-.Inf';
				}
			} else if (common.isNegativeZero(object)) {
				return '-0.0';
			}
			res = object.toString(10);
			return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
		}
		function isFloat(object) {
			return (
				Object.prototype.toString.call(object) === '[object Number]' &&
				(object % 1 !== 0 || common.isNegativeZero(object))
			);
		}
		module2.exports = new Type('tag:yaml.org,2002:float', {
			kind: 'scalar',
			resolve: resolveYamlFloat,
			construct: constructYamlFloat,
			predicate: isFloat,
			represent: representYamlFloat,
			defaultStyle: 'lowercase'
		});
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/json.js
var require_json = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/json.js'(exports, module2) {
		'use strict';
		var Schema3 = require_schema();
		module2.exports = new Schema3({
			include: [require_failsafe()],
			implicit: [require_null(), require_bool(), require_int(), require_float()]
		});
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/core.js
var require_core = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/core.js'(exports, module2) {
		'use strict';
		var Schema3 = require_schema();
		module2.exports = new Schema3({
			include: [require_json()]
		});
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/timestamp.js
var require_timestamp = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/timestamp.js'(exports, module2) {
		'use strict';
		var Type = require_type();
		var YAML_DATE_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$');
		var YAML_TIMESTAMP_REGEXP = new RegExp(
			'^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$'
		);
		function resolveYamlTimestamp(data2) {
			if (data2 === null) return false;
			if (YAML_DATE_REGEXP.exec(data2) !== null) return true;
			if (YAML_TIMESTAMP_REGEXP.exec(data2) !== null) return true;
			return false;
		}
		function constructYamlTimestamp(data2) {
			var match,
				year,
				month,
				day,
				hour,
				minute,
				second,
				fraction = 0,
				delta = null,
				tz_hour,
				tz_minute,
				date;
			match = YAML_DATE_REGEXP.exec(data2);
			if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data2);
			if (match === null) throw new Error('Date resolve error');
			year = +match[1];
			month = +match[2] - 1;
			day = +match[3];
			if (!match[4]) {
				return new Date(Date.UTC(year, month, day));
			}
			hour = +match[4];
			minute = +match[5];
			second = +match[6];
			if (match[7]) {
				fraction = match[7].slice(0, 3);
				while (fraction.length < 3) {
					fraction += '0';
				}
				fraction = +fraction;
			}
			if (match[9]) {
				tz_hour = +match[10];
				tz_minute = +(match[11] || 0);
				delta = (tz_hour * 60 + tz_minute) * 6e4;
				if (match[9] === '-') delta = -delta;
			}
			date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
			if (delta) date.setTime(date.getTime() - delta);
			return date;
		}
		function representYamlTimestamp(object) {
			return object.toISOString();
		}
		module2.exports = new Type('tag:yaml.org,2002:timestamp', {
			kind: 'scalar',
			resolve: resolveYamlTimestamp,
			construct: constructYamlTimestamp,
			instanceOf: Date,
			represent: representYamlTimestamp
		});
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/merge.js
var require_merge = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/merge.js'(exports, module2) {
		'use strict';
		var Type = require_type();
		function resolveYamlMerge(data2) {
			return data2 === '<<' || data2 === null;
		}
		module2.exports = new Type('tag:yaml.org,2002:merge', {
			kind: 'scalar',
			resolve: resolveYamlMerge
		});
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/binary.js
var require_binary = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/binary.js'(exports, module2) {
		'use strict';
		var NodeBuffer;
		try {
			_require = require;
			NodeBuffer = _require('buffer').Buffer;
		} catch (__) {}
		var _require;
		var Type = require_type();
		var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';
		function resolveYamlBinary(data2) {
			if (data2 === null) return false;
			var code3,
				idx,
				bitlen = 0,
				max = data2.length,
				map4 = BASE64_MAP;
			for (idx = 0; idx < max; idx++) {
				code3 = map4.indexOf(data2.charAt(idx));
				if (code3 > 64) continue;
				if (code3 < 0) return false;
				bitlen += 6;
			}
			return bitlen % 8 === 0;
		}
		function constructYamlBinary(data2) {
			var idx,
				tailbits,
				input = data2.replace(/[\r\n=]/g, ''),
				max = input.length,
				map4 = BASE64_MAP,
				bits = 0,
				result = [];
			for (idx = 0; idx < max; idx++) {
				if (idx % 4 === 0 && idx) {
					result.push((bits >> 16) & 255);
					result.push((bits >> 8) & 255);
					result.push(bits & 255);
				}
				bits = (bits << 6) | map4.indexOf(input.charAt(idx));
			}
			tailbits = (max % 4) * 6;
			if (tailbits === 0) {
				result.push((bits >> 16) & 255);
				result.push((bits >> 8) & 255);
				result.push(bits & 255);
			} else if (tailbits === 18) {
				result.push((bits >> 10) & 255);
				result.push((bits >> 2) & 255);
			} else if (tailbits === 12) {
				result.push((bits >> 4) & 255);
			}
			if (NodeBuffer) {
				return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
			}
			return result;
		}
		function representYamlBinary(object) {
			var result = '',
				bits = 0,
				idx,
				tail,
				max = object.length,
				map4 = BASE64_MAP;
			for (idx = 0; idx < max; idx++) {
				if (idx % 3 === 0 && idx) {
					result += map4[(bits >> 18) & 63];
					result += map4[(bits >> 12) & 63];
					result += map4[(bits >> 6) & 63];
					result += map4[bits & 63];
				}
				bits = (bits << 8) + object[idx];
			}
			tail = max % 3;
			if (tail === 0) {
				result += map4[(bits >> 18) & 63];
				result += map4[(bits >> 12) & 63];
				result += map4[(bits >> 6) & 63];
				result += map4[bits & 63];
			} else if (tail === 2) {
				result += map4[(bits >> 10) & 63];
				result += map4[(bits >> 4) & 63];
				result += map4[(bits << 2) & 63];
				result += map4[64];
			} else if (tail === 1) {
				result += map4[(bits >> 2) & 63];
				result += map4[(bits << 4) & 63];
				result += map4[64];
				result += map4[64];
			}
			return result;
		}
		function isBinary(object) {
			return NodeBuffer && NodeBuffer.isBuffer(object);
		}
		module2.exports = new Type('tag:yaml.org,2002:binary', {
			kind: 'scalar',
			resolve: resolveYamlBinary,
			construct: constructYamlBinary,
			predicate: isBinary,
			represent: representYamlBinary
		});
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/omap.js
var require_omap = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/omap.js'(exports, module2) {
		'use strict';
		var Type = require_type();
		var _hasOwnProperty = Object.prototype.hasOwnProperty;
		var _toString = Object.prototype.toString;
		function resolveYamlOmap(data2) {
			if (data2 === null) return true;
			var objectKeys = [],
				index6,
				length,
				pair,
				pairKey,
				pairHasKey,
				object = data2;
			for (index6 = 0, length = object.length; index6 < length; index6 += 1) {
				pair = object[index6];
				pairHasKey = false;
				if (_toString.call(pair) !== '[object Object]') return false;
				for (pairKey in pair) {
					if (_hasOwnProperty.call(pair, pairKey)) {
						if (!pairHasKey) pairHasKey = true;
						else return false;
					}
				}
				if (!pairHasKey) return false;
				if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
				else return false;
			}
			return true;
		}
		function constructYamlOmap(data2) {
			return data2 !== null ? data2 : [];
		}
		module2.exports = new Type('tag:yaml.org,2002:omap', {
			kind: 'sequence',
			resolve: resolveYamlOmap,
			construct: constructYamlOmap
		});
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/pairs.js
var require_pairs = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/pairs.js'(exports, module2) {
		'use strict';
		var Type = require_type();
		var _toString = Object.prototype.toString;
		function resolveYamlPairs(data2) {
			if (data2 === null) return true;
			var index6,
				length,
				pair,
				keys2,
				result,
				object = data2;
			result = new Array(object.length);
			for (index6 = 0, length = object.length; index6 < length; index6 += 1) {
				pair = object[index6];
				if (_toString.call(pair) !== '[object Object]') return false;
				keys2 = Object.keys(pair);
				if (keys2.length !== 1) return false;
				result[index6] = [keys2[0], pair[keys2[0]]];
			}
			return true;
		}
		function constructYamlPairs(data2) {
			if (data2 === null) return [];
			var index6,
				length,
				pair,
				keys2,
				result,
				object = data2;
			result = new Array(object.length);
			for (index6 = 0, length = object.length; index6 < length; index6 += 1) {
				pair = object[index6];
				keys2 = Object.keys(pair);
				result[index6] = [keys2[0], pair[keys2[0]]];
			}
			return result;
		}
		module2.exports = new Type('tag:yaml.org,2002:pairs', {
			kind: 'sequence',
			resolve: resolveYamlPairs,
			construct: constructYamlPairs
		});
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/set.js
var require_set = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/set.js'(exports, module2) {
		'use strict';
		var Type = require_type();
		var _hasOwnProperty = Object.prototype.hasOwnProperty;
		function resolveYamlSet(data2) {
			if (data2 === null) return true;
			var key3,
				object = data2;
			for (key3 in object) {
				if (_hasOwnProperty.call(object, key3)) {
					if (object[key3] !== null) return false;
				}
			}
			return true;
		}
		function constructYamlSet(data2) {
			return data2 !== null ? data2 : {};
		}
		module2.exports = new Type('tag:yaml.org,2002:set', {
			kind: 'mapping',
			resolve: resolveYamlSet,
			construct: constructYamlSet
		});
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/default_safe.js
var require_default_safe = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/default_safe.js'(
		exports,
		module2
	) {
		'use strict';
		var Schema3 = require_schema();
		module2.exports = new Schema3({
			include: [require_core()],
			implicit: [require_timestamp(), require_merge()],
			explicit: [require_binary(), require_omap(), require_pairs(), require_set()]
		});
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/js/undefined.js
var require_undefined = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/js/undefined.js'(
		exports,
		module2
	) {
		'use strict';
		var Type = require_type();
		function resolveJavascriptUndefined() {
			return true;
		}
		function constructJavascriptUndefined() {
			return void 0;
		}
		function representJavascriptUndefined() {
			return '';
		}
		function isUndefined(object) {
			return typeof object === 'undefined';
		}
		module2.exports = new Type('tag:yaml.org,2002:js/undefined', {
			kind: 'scalar',
			resolve: resolveJavascriptUndefined,
			construct: constructJavascriptUndefined,
			predicate: isUndefined,
			represent: representJavascriptUndefined
		});
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/js/regexp.js
var require_regexp = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/js/regexp.js'(exports, module2) {
		'use strict';
		var Type = require_type();
		function resolveJavascriptRegExp(data2) {
			if (data2 === null) return false;
			if (data2.length === 0) return false;
			var regexp = data2,
				tail = /\/([gim]*)$/.exec(data2),
				modifiers = '';
			if (regexp[0] === '/') {
				if (tail) modifiers = tail[1];
				if (modifiers.length > 3) return false;
				if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
			}
			return true;
		}
		function constructJavascriptRegExp(data2) {
			var regexp = data2,
				tail = /\/([gim]*)$/.exec(data2),
				modifiers = '';
			if (regexp[0] === '/') {
				if (tail) modifiers = tail[1];
				regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
			}
			return new RegExp(regexp, modifiers);
		}
		function representJavascriptRegExp(object) {
			var result = '/' + object.source + '/';
			if (object.global) result += 'g';
			if (object.multiline) result += 'm';
			if (object.ignoreCase) result += 'i';
			return result;
		}
		function isRegExp(object) {
			return Object.prototype.toString.call(object) === '[object RegExp]';
		}
		module2.exports = new Type('tag:yaml.org,2002:js/regexp', {
			kind: 'scalar',
			resolve: resolveJavascriptRegExp,
			construct: constructJavascriptRegExp,
			predicate: isRegExp,
			represent: representJavascriptRegExp
		});
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/js/function.js
var require_function = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/type/js/function.js'(
		exports,
		module2
	) {
		'use strict';
		var esprima;
		try {
			_require = require;
			esprima = _require('esprima');
		} catch (_) {
			if (typeof window !== 'undefined') esprima = window.esprima;
		}
		var _require;
		var Type = require_type();
		function resolveJavascriptFunction(data2) {
			if (data2 === null) return false;
			try {
				var source = '(' + data2 + ')',
					ast = esprima.parse(source, { range: true });
				if (
					ast.type !== 'Program' ||
					ast.body.length !== 1 ||
					ast.body[0].type !== 'ExpressionStatement' ||
					(ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
						ast.body[0].expression.type !== 'FunctionExpression')
				) {
					return false;
				}
				return true;
			} catch (err) {
				return false;
			}
		}
		function constructJavascriptFunction(data2) {
			var source = '(' + data2 + ')',
				ast = esprima.parse(source, { range: true }),
				params = [],
				body4;
			if (
				ast.type !== 'Program' ||
				ast.body.length !== 1 ||
				ast.body[0].type !== 'ExpressionStatement' ||
				(ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
					ast.body[0].expression.type !== 'FunctionExpression')
			) {
				throw new Error('Failed to resolve function');
			}
			ast.body[0].expression.params.forEach(function (param) {
				params.push(param.name);
			});
			body4 = ast.body[0].expression.body.range;
			if (ast.body[0].expression.body.type === 'BlockStatement') {
				return new Function(params, source.slice(body4[0] + 1, body4[1] - 1));
			}
			return new Function(params, 'return ' + source.slice(body4[0], body4[1]));
		}
		function representJavascriptFunction(object) {
			return object.toString();
		}
		function isFunction(object) {
			return Object.prototype.toString.call(object) === '[object Function]';
		}
		module2.exports = new Type('tag:yaml.org,2002:js/function', {
			kind: 'scalar',
			resolve: resolveJavascriptFunction,
			construct: constructJavascriptFunction,
			predicate: isFunction,
			represent: representJavascriptFunction
		});
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/default_full.js
var require_default_full = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/schema/default_full.js'(
		exports,
		module2
	) {
		'use strict';
		var Schema3 = require_schema();
		module2.exports = Schema3.DEFAULT = new Schema3({
			include: [require_default_safe()],
			explicit: [require_undefined(), require_regexp(), require_function()]
		});
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/loader.js
var require_loader = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/loader.js'(exports, module2) {
		'use strict';
		var common = require_common2();
		var YAMLException = require_exception();
		var Mark = require_mark();
		var DEFAULT_SAFE_SCHEMA = require_default_safe();
		var DEFAULT_FULL_SCHEMA = require_default_full();
		var _hasOwnProperty = Object.prototype.hasOwnProperty;
		var CONTEXT_FLOW_IN = 1;
		var CONTEXT_FLOW_OUT = 2;
		var CONTEXT_BLOCK_IN = 3;
		var CONTEXT_BLOCK_OUT = 4;
		var CHOMPING_CLIP = 1;
		var CHOMPING_STRIP = 2;
		var CHOMPING_KEEP = 3;
		var PATTERN_NON_PRINTABLE =
			/[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
		var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
		var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
		var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
		var PATTERN_TAG_URI =
			/^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
		function _class(obj) {
			return Object.prototype.toString.call(obj);
		}
		function is_EOL(c) {
			return c === 10 || c === 13;
		}
		function is_WHITE_SPACE(c) {
			return c === 9 || c === 32;
		}
		function is_WS_OR_EOL(c) {
			return c === 9 || c === 32 || c === 10 || c === 13;
		}
		function is_FLOW_INDICATOR(c) {
			return c === 44 || c === 91 || c === 93 || c === 123 || c === 125;
		}
		function fromHexCode(c) {
			var lc;
			if (48 <= c && c <= 57) {
				return c - 48;
			}
			lc = c | 32;
			if (97 <= lc && lc <= 102) {
				return lc - 97 + 10;
			}
			return -1;
		}
		function escapedHexLen(c) {
			if (c === 120) {
				return 2;
			}
			if (c === 117) {
				return 4;
			}
			if (c === 85) {
				return 8;
			}
			return 0;
		}
		function fromDecimalCode(c) {
			if (48 <= c && c <= 57) {
				return c - 48;
			}
			return -1;
		}
		function simpleEscapeSequence(c) {
			return c === 48
				? '\0'
				: c === 97
				? '\x07'
				: c === 98
				? '\b'
				: c === 116
				? '	'
				: c === 9
				? '	'
				: c === 110
				? '\n'
				: c === 118
				? '\v'
				: c === 102
				? '\f'
				: c === 114
				? '\r'
				: c === 101
				? '\x1B'
				: c === 32
				? ' '
				: c === 34
				? '"'
				: c === 47
				? '/'
				: c === 92
				? '\\'
				: c === 78
				? '\x85'
				: c === 95
				? '\xA0'
				: c === 76
				? '\u2028'
				: c === 80
				? '\u2029'
				: '';
		}
		function charFromCodepoint(c) {
			if (c <= 65535) {
				return String.fromCharCode(c);
			}
			return String.fromCharCode(((c - 65536) >> 10) + 55296, ((c - 65536) & 1023) + 56320);
		}
		var simpleEscapeCheck = new Array(256);
		var simpleEscapeMap = new Array(256);
		for (i2 = 0; i2 < 256; i2++) {
			simpleEscapeCheck[i2] = simpleEscapeSequence(i2) ? 1 : 0;
			simpleEscapeMap[i2] = simpleEscapeSequence(i2);
		}
		var i2;
		function State(input, options) {
			this.input = input;
			this.filename = options['filename'] || null;
			this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;
			this.onWarning = options['onWarning'] || null;
			this.legacy = options['legacy'] || false;
			this.json = options['json'] || false;
			this.listener = options['listener'] || null;
			this.implicitTypes = this.schema.compiledImplicit;
			this.typeMap = this.schema.compiledTypeMap;
			this.length = input.length;
			this.position = 0;
			this.line = 0;
			this.lineStart = 0;
			this.lineIndent = 0;
			this.documents = [];
		}
		function generateError(state, message) {
			return new YAMLException(
				message,
				new Mark(
					state.filename,
					state.input,
					state.position,
					state.line,
					state.position - state.lineStart
				)
			);
		}
		function throwError(state, message) {
			throw generateError(state, message);
		}
		function throwWarning(state, message) {
			if (state.onWarning) {
				state.onWarning.call(null, generateError(state, message));
			}
		}
		var directiveHandlers = {
			YAML: function handleYamlDirective(state, name, args) {
				var match, major, minor;
				if (state.version !== null) {
					throwError(state, 'duplication of %YAML directive');
				}
				if (args.length !== 1) {
					throwError(state, 'YAML directive accepts exactly one argument');
				}
				match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
				if (match === null) {
					throwError(state, 'ill-formed argument of the YAML directive');
				}
				major = parseInt(match[1], 10);
				minor = parseInt(match[2], 10);
				if (major !== 1) {
					throwError(state, 'unacceptable YAML version of the document');
				}
				state.version = args[0];
				state.checkLineBreaks = minor < 2;
				if (minor !== 1 && minor !== 2) {
					throwWarning(state, 'unsupported YAML version of the document');
				}
			},
			TAG: function handleTagDirective(state, name, args) {
				var handle2, prefix;
				if (args.length !== 2) {
					throwError(state, 'TAG directive accepts exactly two arguments');
				}
				handle2 = args[0];
				prefix = args[1];
				if (!PATTERN_TAG_HANDLE.test(handle2)) {
					throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
				}
				if (_hasOwnProperty.call(state.tagMap, handle2)) {
					throwError(
						state,
						'there is a previously declared suffix for "' + handle2 + '" tag handle'
					);
				}
				if (!PATTERN_TAG_URI.test(prefix)) {
					throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
				}
				state.tagMap[handle2] = prefix;
			}
		};
		function captureSegment(state, start, end, checkJson) {
			var _position, _length, _character, _result;
			if (start < end) {
				_result = state.input.slice(start, end);
				if (checkJson) {
					for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
						_character = _result.charCodeAt(_position);
						if (!(_character === 9 || (32 <= _character && _character <= 1114111))) {
							throwError(state, 'expected valid JSON character');
						}
					}
				} else if (PATTERN_NON_PRINTABLE.test(_result)) {
					throwError(state, 'the stream contains non-printable characters');
				}
				state.result += _result;
			}
		}
		function mergeMappings(state, destination, source, overridableKeys) {
			var sourceKeys, key3, index6, quantity;
			if (!common.isObject(source)) {
				throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
			}
			sourceKeys = Object.keys(source);
			for (index6 = 0, quantity = sourceKeys.length; index6 < quantity; index6 += 1) {
				key3 = sourceKeys[index6];
				if (!_hasOwnProperty.call(destination, key3)) {
					destination[key3] = source[key3];
					overridableKeys[key3] = true;
				}
			}
		}
		function storeMappingPair(
			state,
			_result,
			overridableKeys,
			keyTag,
			keyNode,
			valueNode,
			startLine,
			startPos
		) {
			var index6, quantity;
			if (Array.isArray(keyNode)) {
				keyNode = Array.prototype.slice.call(keyNode);
				for (index6 = 0, quantity = keyNode.length; index6 < quantity; index6 += 1) {
					if (Array.isArray(keyNode[index6])) {
						throwError(state, 'nested arrays are not supported inside keys');
					}
					if (typeof keyNode === 'object' && _class(keyNode[index6]) === '[object Object]') {
						keyNode[index6] = '[object Object]';
					}
				}
			}
			if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
				keyNode = '[object Object]';
			}
			keyNode = String(keyNode);
			if (_result === null) {
				_result = {};
			}
			if (keyTag === 'tag:yaml.org,2002:merge') {
				if (Array.isArray(valueNode)) {
					for (index6 = 0, quantity = valueNode.length; index6 < quantity; index6 += 1) {
						mergeMappings(state, _result, valueNode[index6], overridableKeys);
					}
				} else {
					mergeMappings(state, _result, valueNode, overridableKeys);
				}
			} else {
				if (
					!state.json &&
					!_hasOwnProperty.call(overridableKeys, keyNode) &&
					_hasOwnProperty.call(_result, keyNode)
				) {
					state.line = startLine || state.line;
					state.position = startPos || state.position;
					throwError(state, 'duplicated mapping key');
				}
				_result[keyNode] = valueNode;
				delete overridableKeys[keyNode];
			}
			return _result;
		}
		function readLineBreak(state) {
			var ch;
			ch = state.input.charCodeAt(state.position);
			if (ch === 10) {
				state.position++;
			} else if (ch === 13) {
				state.position++;
				if (state.input.charCodeAt(state.position) === 10) {
					state.position++;
				}
			} else {
				throwError(state, 'a line break is expected');
			}
			state.line += 1;
			state.lineStart = state.position;
		}
		function skipSeparationSpace(state, allowComments, checkIndent) {
			var lineBreaks = 0,
				ch = state.input.charCodeAt(state.position);
			while (ch !== 0) {
				while (is_WHITE_SPACE(ch)) {
					ch = state.input.charCodeAt(++state.position);
				}
				if (allowComments && ch === 35) {
					do {
						ch = state.input.charCodeAt(++state.position);
					} while (ch !== 10 && ch !== 13 && ch !== 0);
				}
				if (is_EOL(ch)) {
					readLineBreak(state);
					ch = state.input.charCodeAt(state.position);
					lineBreaks++;
					state.lineIndent = 0;
					while (ch === 32) {
						state.lineIndent++;
						ch = state.input.charCodeAt(++state.position);
					}
				} else {
					break;
				}
			}
			if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
				throwWarning(state, 'deficient indentation');
			}
			return lineBreaks;
		}
		function testDocumentSeparator(state) {
			var _position = state.position,
				ch;
			ch = state.input.charCodeAt(_position);
			if (
				(ch === 45 || ch === 46) &&
				ch === state.input.charCodeAt(_position + 1) &&
				ch === state.input.charCodeAt(_position + 2)
			) {
				_position += 3;
				ch = state.input.charCodeAt(_position);
				if (ch === 0 || is_WS_OR_EOL(ch)) {
					return true;
				}
			}
			return false;
		}
		function writeFoldedLines(state, count) {
			if (count === 1) {
				state.result += ' ';
			} else if (count > 1) {
				state.result += common.repeat('\n', count - 1);
			}
		}
		function readPlainScalar(state, nodeIndent, withinFlowCollection) {
			var preceding,
				following,
				captureStart,
				captureEnd,
				hasPendingContent,
				_line,
				_lineStart,
				_lineIndent,
				_kind = state.kind,
				_result = state.result,
				ch;
			ch = state.input.charCodeAt(state.position);
			if (
				is_WS_OR_EOL(ch) ||
				is_FLOW_INDICATOR(ch) ||
				ch === 35 ||
				ch === 38 ||
				ch === 42 ||
				ch === 33 ||
				ch === 124 ||
				ch === 62 ||
				ch === 39 ||
				ch === 34 ||
				ch === 37 ||
				ch === 64 ||
				ch === 96
			) {
				return false;
			}
			if (ch === 63 || ch === 45) {
				following = state.input.charCodeAt(state.position + 1);
				if (is_WS_OR_EOL(following) || (withinFlowCollection && is_FLOW_INDICATOR(following))) {
					return false;
				}
			}
			state.kind = 'scalar';
			state.result = '';
			captureStart = captureEnd = state.position;
			hasPendingContent = false;
			while (ch !== 0) {
				if (ch === 58) {
					following = state.input.charCodeAt(state.position + 1);
					if (is_WS_OR_EOL(following) || (withinFlowCollection && is_FLOW_INDICATOR(following))) {
						break;
					}
				} else if (ch === 35) {
					preceding = state.input.charCodeAt(state.position - 1);
					if (is_WS_OR_EOL(preceding)) {
						break;
					}
				} else if (
					(state.position === state.lineStart && testDocumentSeparator(state)) ||
					(withinFlowCollection && is_FLOW_INDICATOR(ch))
				) {
					break;
				} else if (is_EOL(ch)) {
					_line = state.line;
					_lineStart = state.lineStart;
					_lineIndent = state.lineIndent;
					skipSeparationSpace(state, false, -1);
					if (state.lineIndent >= nodeIndent) {
						hasPendingContent = true;
						ch = state.input.charCodeAt(state.position);
						continue;
					} else {
						state.position = captureEnd;
						state.line = _line;
						state.lineStart = _lineStart;
						state.lineIndent = _lineIndent;
						break;
					}
				}
				if (hasPendingContent) {
					captureSegment(state, captureStart, captureEnd, false);
					writeFoldedLines(state, state.line - _line);
					captureStart = captureEnd = state.position;
					hasPendingContent = false;
				}
				if (!is_WHITE_SPACE(ch)) {
					captureEnd = state.position + 1;
				}
				ch = state.input.charCodeAt(++state.position);
			}
			captureSegment(state, captureStart, captureEnd, false);
			if (state.result) {
				return true;
			}
			state.kind = _kind;
			state.result = _result;
			return false;
		}
		function readSingleQuotedScalar(state, nodeIndent) {
			var ch, captureStart, captureEnd;
			ch = state.input.charCodeAt(state.position);
			if (ch !== 39) {
				return false;
			}
			state.kind = 'scalar';
			state.result = '';
			state.position++;
			captureStart = captureEnd = state.position;
			while ((ch = state.input.charCodeAt(state.position)) !== 0) {
				if (ch === 39) {
					captureSegment(state, captureStart, state.position, true);
					ch = state.input.charCodeAt(++state.position);
					if (ch === 39) {
						captureStart = state.position;
						state.position++;
						captureEnd = state.position;
					} else {
						return true;
					}
				} else if (is_EOL(ch)) {
					captureSegment(state, captureStart, captureEnd, true);
					writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
					captureStart = captureEnd = state.position;
				} else if (state.position === state.lineStart && testDocumentSeparator(state)) {
					throwError(state, 'unexpected end of the document within a single quoted scalar');
				} else {
					state.position++;
					captureEnd = state.position;
				}
			}
			throwError(state, 'unexpected end of the stream within a single quoted scalar');
		}
		function readDoubleQuotedScalar(state, nodeIndent) {
			var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
			ch = state.input.charCodeAt(state.position);
			if (ch !== 34) {
				return false;
			}
			state.kind = 'scalar';
			state.result = '';
			state.position++;
			captureStart = captureEnd = state.position;
			while ((ch = state.input.charCodeAt(state.position)) !== 0) {
				if (ch === 34) {
					captureSegment(state, captureStart, state.position, true);
					state.position++;
					return true;
				} else if (ch === 92) {
					captureSegment(state, captureStart, state.position, true);
					ch = state.input.charCodeAt(++state.position);
					if (is_EOL(ch)) {
						skipSeparationSpace(state, false, nodeIndent);
					} else if (ch < 256 && simpleEscapeCheck[ch]) {
						state.result += simpleEscapeMap[ch];
						state.position++;
					} else if ((tmp = escapedHexLen(ch)) > 0) {
						hexLength = tmp;
						hexResult = 0;
						for (; hexLength > 0; hexLength--) {
							ch = state.input.charCodeAt(++state.position);
							if ((tmp = fromHexCode(ch)) >= 0) {
								hexResult = (hexResult << 4) + tmp;
							} else {
								throwError(state, 'expected hexadecimal character');
							}
						}
						state.result += charFromCodepoint(hexResult);
						state.position++;
					} else {
						throwError(state, 'unknown escape sequence');
					}
					captureStart = captureEnd = state.position;
				} else if (is_EOL(ch)) {
					captureSegment(state, captureStart, captureEnd, true);
					writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
					captureStart = captureEnd = state.position;
				} else if (state.position === state.lineStart && testDocumentSeparator(state)) {
					throwError(state, 'unexpected end of the document within a double quoted scalar');
				} else {
					state.position++;
					captureEnd = state.position;
				}
			}
			throwError(state, 'unexpected end of the stream within a double quoted scalar');
		}
		function readFlowCollection(state, nodeIndent) {
			var readNext = true,
				_line,
				_tag = state.tag,
				_result,
				_anchor = state.anchor,
				following,
				terminator,
				isPair,
				isExplicitPair,
				isMapping,
				overridableKeys = {},
				keyNode,
				keyTag,
				valueNode,
				ch;
			ch = state.input.charCodeAt(state.position);
			if (ch === 91) {
				terminator = 93;
				isMapping = false;
				_result = [];
			} else if (ch === 123) {
				terminator = 125;
				isMapping = true;
				_result = {};
			} else {
				return false;
			}
			if (state.anchor !== null) {
				state.anchorMap[state.anchor] = _result;
			}
			ch = state.input.charCodeAt(++state.position);
			while (ch !== 0) {
				skipSeparationSpace(state, true, nodeIndent);
				ch = state.input.charCodeAt(state.position);
				if (ch === terminator) {
					state.position++;
					state.tag = _tag;
					state.anchor = _anchor;
					state.kind = isMapping ? 'mapping' : 'sequence';
					state.result = _result;
					return true;
				} else if (!readNext) {
					throwError(state, 'missed comma between flow collection entries');
				}
				keyTag = keyNode = valueNode = null;
				isPair = isExplicitPair = false;
				if (ch === 63) {
					following = state.input.charCodeAt(state.position + 1);
					if (is_WS_OR_EOL(following)) {
						isPair = isExplicitPair = true;
						state.position++;
						skipSeparationSpace(state, true, nodeIndent);
					}
				}
				_line = state.line;
				composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
				keyTag = state.tag;
				keyNode = state.result;
				skipSeparationSpace(state, true, nodeIndent);
				ch = state.input.charCodeAt(state.position);
				if ((isExplicitPair || state.line === _line) && ch === 58) {
					isPair = true;
					ch = state.input.charCodeAt(++state.position);
					skipSeparationSpace(state, true, nodeIndent);
					composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
					valueNode = state.result;
				}
				if (isMapping) {
					storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
				} else if (isPair) {
					_result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
				} else {
					_result.push(keyNode);
				}
				skipSeparationSpace(state, true, nodeIndent);
				ch = state.input.charCodeAt(state.position);
				if (ch === 44) {
					readNext = true;
					ch = state.input.charCodeAt(++state.position);
				} else {
					readNext = false;
				}
			}
			throwError(state, 'unexpected end of the stream within a flow collection');
		}
		function readBlockScalar(state, nodeIndent) {
			var captureStart,
				folding,
				chomping = CHOMPING_CLIP,
				didReadContent = false,
				detectedIndent = false,
				textIndent = nodeIndent,
				emptyLines = 0,
				atMoreIndented = false,
				tmp,
				ch;
			ch = state.input.charCodeAt(state.position);
			if (ch === 124) {
				folding = false;
			} else if (ch === 62) {
				folding = true;
			} else {
				return false;
			}
			state.kind = 'scalar';
			state.result = '';
			while (ch !== 0) {
				ch = state.input.charCodeAt(++state.position);
				if (ch === 43 || ch === 45) {
					if (CHOMPING_CLIP === chomping) {
						chomping = ch === 43 ? CHOMPING_KEEP : CHOMPING_STRIP;
					} else {
						throwError(state, 'repeat of a chomping mode identifier');
					}
				} else if ((tmp = fromDecimalCode(ch)) >= 0) {
					if (tmp === 0) {
						throwError(
							state,
							'bad explicit indentation width of a block scalar; it cannot be less than one'
						);
					} else if (!detectedIndent) {
						textIndent = nodeIndent + tmp - 1;
						detectedIndent = true;
					} else {
						throwError(state, 'repeat of an indentation width identifier');
					}
				} else {
					break;
				}
			}
			if (is_WHITE_SPACE(ch)) {
				do {
					ch = state.input.charCodeAt(++state.position);
				} while (is_WHITE_SPACE(ch));
				if (ch === 35) {
					do {
						ch = state.input.charCodeAt(++state.position);
					} while (!is_EOL(ch) && ch !== 0);
				}
			}
			while (ch !== 0) {
				readLineBreak(state);
				state.lineIndent = 0;
				ch = state.input.charCodeAt(state.position);
				while ((!detectedIndent || state.lineIndent < textIndent) && ch === 32) {
					state.lineIndent++;
					ch = state.input.charCodeAt(++state.position);
				}
				if (!detectedIndent && state.lineIndent > textIndent) {
					textIndent = state.lineIndent;
				}
				if (is_EOL(ch)) {
					emptyLines++;
					continue;
				}
				if (state.lineIndent < textIndent) {
					if (chomping === CHOMPING_KEEP) {
						state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
					} else if (chomping === CHOMPING_CLIP) {
						if (didReadContent) {
							state.result += '\n';
						}
					}
					break;
				}
				if (folding) {
					if (is_WHITE_SPACE(ch)) {
						atMoreIndented = true;
						state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
					} else if (atMoreIndented) {
						atMoreIndented = false;
						state.result += common.repeat('\n', emptyLines + 1);
					} else if (emptyLines === 0) {
						if (didReadContent) {
							state.result += ' ';
						}
					} else {
						state.result += common.repeat('\n', emptyLines);
					}
				} else {
					state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
				}
				didReadContent = true;
				detectedIndent = true;
				emptyLines = 0;
				captureStart = state.position;
				while (!is_EOL(ch) && ch !== 0) {
					ch = state.input.charCodeAt(++state.position);
				}
				captureSegment(state, captureStart, state.position, false);
			}
			return true;
		}
		function readBlockSequence(state, nodeIndent) {
			var _line,
				_tag = state.tag,
				_anchor = state.anchor,
				_result = [],
				following,
				detected = false,
				ch;
			if (state.anchor !== null) {
				state.anchorMap[state.anchor] = _result;
			}
			ch = state.input.charCodeAt(state.position);
			while (ch !== 0) {
				if (ch !== 45) {
					break;
				}
				following = state.input.charCodeAt(state.position + 1);
				if (!is_WS_OR_EOL(following)) {
					break;
				}
				detected = true;
				state.position++;
				if (skipSeparationSpace(state, true, -1)) {
					if (state.lineIndent <= nodeIndent) {
						_result.push(null);
						ch = state.input.charCodeAt(state.position);
						continue;
					}
				}
				_line = state.line;
				composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
				_result.push(state.result);
				skipSeparationSpace(state, true, -1);
				ch = state.input.charCodeAt(state.position);
				if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
					throwError(state, 'bad indentation of a sequence entry');
				} else if (state.lineIndent < nodeIndent) {
					break;
				}
			}
			if (detected) {
				state.tag = _tag;
				state.anchor = _anchor;
				state.kind = 'sequence';
				state.result = _result;
				return true;
			}
			return false;
		}
		function readBlockMapping(state, nodeIndent, flowIndent) {
			var following,
				allowCompact,
				_line,
				_pos,
				_tag = state.tag,
				_anchor = state.anchor,
				_result = {},
				overridableKeys = {},
				keyTag = null,
				keyNode = null,
				valueNode = null,
				atExplicitKey = false,
				detected = false,
				ch;
			if (state.anchor !== null) {
				state.anchorMap[state.anchor] = _result;
			}
			ch = state.input.charCodeAt(state.position);
			while (ch !== 0) {
				following = state.input.charCodeAt(state.position + 1);
				_line = state.line;
				_pos = state.position;
				if ((ch === 63 || ch === 58) && is_WS_OR_EOL(following)) {
					if (ch === 63) {
						if (atExplicitKey) {
							storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
							keyTag = keyNode = valueNode = null;
						}
						detected = true;
						atExplicitKey = true;
						allowCompact = true;
					} else if (atExplicitKey) {
						atExplicitKey = false;
						allowCompact = true;
					} else {
						throwError(
							state,
							'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line'
						);
					}
					state.position += 1;
					ch = following;
				} else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
					if (state.line === _line) {
						ch = state.input.charCodeAt(state.position);
						while (is_WHITE_SPACE(ch)) {
							ch = state.input.charCodeAt(++state.position);
						}
						if (ch === 58) {
							ch = state.input.charCodeAt(++state.position);
							if (!is_WS_OR_EOL(ch)) {
								throwError(
									state,
									'a whitespace character is expected after the key-value separator within a block mapping'
								);
							}
							if (atExplicitKey) {
								storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
								keyTag = keyNode = valueNode = null;
							}
							detected = true;
							atExplicitKey = false;
							allowCompact = false;
							keyTag = state.tag;
							keyNode = state.result;
						} else if (detected) {
							throwError(state, 'can not read an implicit mapping pair; a colon is missed');
						} else {
							state.tag = _tag;
							state.anchor = _anchor;
							return true;
						}
					} else if (detected) {
						throwError(
							state,
							'can not read a block mapping entry; a multiline key may not be an implicit key'
						);
					} else {
						state.tag = _tag;
						state.anchor = _anchor;
						return true;
					}
				} else {
					break;
				}
				if (state.line === _line || state.lineIndent > nodeIndent) {
					if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
						if (atExplicitKey) {
							keyNode = state.result;
						} else {
							valueNode = state.result;
						}
					}
					if (!atExplicitKey) {
						storeMappingPair(
							state,
							_result,
							overridableKeys,
							keyTag,
							keyNode,
							valueNode,
							_line,
							_pos
						);
						keyTag = keyNode = valueNode = null;
					}
					skipSeparationSpace(state, true, -1);
					ch = state.input.charCodeAt(state.position);
				}
				if (state.lineIndent > nodeIndent && ch !== 0) {
					throwError(state, 'bad indentation of a mapping entry');
				} else if (state.lineIndent < nodeIndent) {
					break;
				}
			}
			if (atExplicitKey) {
				storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
			}
			if (detected) {
				state.tag = _tag;
				state.anchor = _anchor;
				state.kind = 'mapping';
				state.result = _result;
			}
			return detected;
		}
		function readTagProperty(state) {
			var _position,
				isVerbatim = false,
				isNamed = false,
				tagHandle,
				tagName,
				ch;
			ch = state.input.charCodeAt(state.position);
			if (ch !== 33) return false;
			if (state.tag !== null) {
				throwError(state, 'duplication of a tag property');
			}
			ch = state.input.charCodeAt(++state.position);
			if (ch === 60) {
				isVerbatim = true;
				ch = state.input.charCodeAt(++state.position);
			} else if (ch === 33) {
				isNamed = true;
				tagHandle = '!!';
				ch = state.input.charCodeAt(++state.position);
			} else {
				tagHandle = '!';
			}
			_position = state.position;
			if (isVerbatim) {
				do {
					ch = state.input.charCodeAt(++state.position);
				} while (ch !== 0 && ch !== 62);
				if (state.position < state.length) {
					tagName = state.input.slice(_position, state.position);
					ch = state.input.charCodeAt(++state.position);
				} else {
					throwError(state, 'unexpected end of the stream within a verbatim tag');
				}
			} else {
				while (ch !== 0 && !is_WS_OR_EOL(ch)) {
					if (ch === 33) {
						if (!isNamed) {
							tagHandle = state.input.slice(_position - 1, state.position + 1);
							if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
								throwError(state, 'named tag handle cannot contain such characters');
							}
							isNamed = true;
							_position = state.position + 1;
						} else {
							throwError(state, 'tag suffix cannot contain exclamation marks');
						}
					}
					ch = state.input.charCodeAt(++state.position);
				}
				tagName = state.input.slice(_position, state.position);
				if (PATTERN_FLOW_INDICATORS.test(tagName)) {
					throwError(state, 'tag suffix cannot contain flow indicator characters');
				}
			}
			if (tagName && !PATTERN_TAG_URI.test(tagName)) {
				throwError(state, 'tag name cannot contain such characters: ' + tagName);
			}
			if (isVerbatim) {
				state.tag = tagName;
			} else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
				state.tag = state.tagMap[tagHandle] + tagName;
			} else if (tagHandle === '!') {
				state.tag = '!' + tagName;
			} else if (tagHandle === '!!') {
				state.tag = 'tag:yaml.org,2002:' + tagName;
			} else {
				throwError(state, 'undeclared tag handle "' + tagHandle + '"');
			}
			return true;
		}
		function readAnchorProperty(state) {
			var _position, ch;
			ch = state.input.charCodeAt(state.position);
			if (ch !== 38) return false;
			if (state.anchor !== null) {
				throwError(state, 'duplication of an anchor property');
			}
			ch = state.input.charCodeAt(++state.position);
			_position = state.position;
			while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
				ch = state.input.charCodeAt(++state.position);
			}
			if (state.position === _position) {
				throwError(state, 'name of an anchor node must contain at least one character');
			}
			state.anchor = state.input.slice(_position, state.position);
			return true;
		}
		function readAlias(state) {
			var _position, alias, ch;
			ch = state.input.charCodeAt(state.position);
			if (ch !== 42) return false;
			ch = state.input.charCodeAt(++state.position);
			_position = state.position;
			while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
				ch = state.input.charCodeAt(++state.position);
			}
			if (state.position === _position) {
				throwError(state, 'name of an alias node must contain at least one character');
			}
			alias = state.input.slice(_position, state.position);
			if (!_hasOwnProperty.call(state.anchorMap, alias)) {
				throwError(state, 'unidentified alias "' + alias + '"');
			}
			state.result = state.anchorMap[alias];
			skipSeparationSpace(state, true, -1);
			return true;
		}
		function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
			var allowBlockStyles,
				allowBlockScalars,
				allowBlockCollections,
				indentStatus = 1,
				atNewLine = false,
				hasContent = false,
				typeIndex,
				typeQuantity,
				type,
				flowIndent,
				blockIndent;
			if (state.listener !== null) {
				state.listener('open', state);
			}
			state.tag = null;
			state.anchor = null;
			state.kind = null;
			state.result = null;
			allowBlockStyles =
				allowBlockScalars =
				allowBlockCollections =
					CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
			if (allowToSeek) {
				if (skipSeparationSpace(state, true, -1)) {
					atNewLine = true;
					if (state.lineIndent > parentIndent) {
						indentStatus = 1;
					} else if (state.lineIndent === parentIndent) {
						indentStatus = 0;
					} else if (state.lineIndent < parentIndent) {
						indentStatus = -1;
					}
				}
			}
			if (indentStatus === 1) {
				while (readTagProperty(state) || readAnchorProperty(state)) {
					if (skipSeparationSpace(state, true, -1)) {
						atNewLine = true;
						allowBlockCollections = allowBlockStyles;
						if (state.lineIndent > parentIndent) {
							indentStatus = 1;
						} else if (state.lineIndent === parentIndent) {
							indentStatus = 0;
						} else if (state.lineIndent < parentIndent) {
							indentStatus = -1;
						}
					} else {
						allowBlockCollections = false;
					}
				}
			}
			if (allowBlockCollections) {
				allowBlockCollections = atNewLine || allowCompact;
			}
			if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
				if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
					flowIndent = parentIndent;
				} else {
					flowIndent = parentIndent + 1;
				}
				blockIndent = state.position - state.lineStart;
				if (indentStatus === 1) {
					if (
						(allowBlockCollections &&
							(readBlockSequence(state, blockIndent) ||
								readBlockMapping(state, blockIndent, flowIndent))) ||
						readFlowCollection(state, flowIndent)
					) {
						hasContent = true;
					} else {
						if (
							(allowBlockScalars && readBlockScalar(state, flowIndent)) ||
							readSingleQuotedScalar(state, flowIndent) ||
							readDoubleQuotedScalar(state, flowIndent)
						) {
							hasContent = true;
						} else if (readAlias(state)) {
							hasContent = true;
							if (state.tag !== null || state.anchor !== null) {
								throwError(state, 'alias node should not have any properties');
							}
						} else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
							hasContent = true;
							if (state.tag === null) {
								state.tag = '?';
							}
						}
						if (state.anchor !== null) {
							state.anchorMap[state.anchor] = state.result;
						}
					}
				} else if (indentStatus === 0) {
					hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
				}
			}
			if (state.tag !== null && state.tag !== '!') {
				if (state.tag === '?') {
					if (state.result !== null && state.kind !== 'scalar') {
						throwError(
							state,
							'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"'
						);
					}
					for (
						typeIndex = 0, typeQuantity = state.implicitTypes.length;
						typeIndex < typeQuantity;
						typeIndex += 1
					) {
						type = state.implicitTypes[typeIndex];
						if (type.resolve(state.result)) {
							state.result = type.construct(state.result);
							state.tag = type.tag;
							if (state.anchor !== null) {
								state.anchorMap[state.anchor] = state.result;
							}
							break;
						}
					}
				} else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
					type = state.typeMap[state.kind || 'fallback'][state.tag];
					if (state.result !== null && type.kind !== state.kind) {
						throwError(
							state,
							'unacceptable node kind for !<' +
								state.tag +
								'> tag; it should be "' +
								type.kind +
								'", not "' +
								state.kind +
								'"'
						);
					}
					if (!type.resolve(state.result)) {
						throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
					} else {
						state.result = type.construct(state.result);
						if (state.anchor !== null) {
							state.anchorMap[state.anchor] = state.result;
						}
					}
				} else {
					throwError(state, 'unknown tag !<' + state.tag + '>');
				}
			}
			if (state.listener !== null) {
				state.listener('close', state);
			}
			return state.tag !== null || state.anchor !== null || hasContent;
		}
		function readDocument(state) {
			var documentStart = state.position,
				_position,
				directiveName,
				directiveArgs,
				hasDirectives = false,
				ch;
			state.version = null;
			state.checkLineBreaks = state.legacy;
			state.tagMap = {};
			state.anchorMap = {};
			while ((ch = state.input.charCodeAt(state.position)) !== 0) {
				skipSeparationSpace(state, true, -1);
				ch = state.input.charCodeAt(state.position);
				if (state.lineIndent > 0 || ch !== 37) {
					break;
				}
				hasDirectives = true;
				ch = state.input.charCodeAt(++state.position);
				_position = state.position;
				while (ch !== 0 && !is_WS_OR_EOL(ch)) {
					ch = state.input.charCodeAt(++state.position);
				}
				directiveName = state.input.slice(_position, state.position);
				directiveArgs = [];
				if (directiveName.length < 1) {
					throwError(state, 'directive name must not be less than one character in length');
				}
				while (ch !== 0) {
					while (is_WHITE_SPACE(ch)) {
						ch = state.input.charCodeAt(++state.position);
					}
					if (ch === 35) {
						do {
							ch = state.input.charCodeAt(++state.position);
						} while (ch !== 0 && !is_EOL(ch));
						break;
					}
					if (is_EOL(ch)) break;
					_position = state.position;
					while (ch !== 0 && !is_WS_OR_EOL(ch)) {
						ch = state.input.charCodeAt(++state.position);
					}
					directiveArgs.push(state.input.slice(_position, state.position));
				}
				if (ch !== 0) readLineBreak(state);
				if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
					directiveHandlers[directiveName](state, directiveName, directiveArgs);
				} else {
					throwWarning(state, 'unknown document directive "' + directiveName + '"');
				}
			}
			skipSeparationSpace(state, true, -1);
			if (
				state.lineIndent === 0 &&
				state.input.charCodeAt(state.position) === 45 &&
				state.input.charCodeAt(state.position + 1) === 45 &&
				state.input.charCodeAt(state.position + 2) === 45
			) {
				state.position += 3;
				skipSeparationSpace(state, true, -1);
			} else if (hasDirectives) {
				throwError(state, 'directives end mark is expected');
			}
			composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
			skipSeparationSpace(state, true, -1);
			if (
				state.checkLineBreaks &&
				PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))
			) {
				throwWarning(state, 'non-ASCII line breaks are interpreted as content');
			}
			state.documents.push(state.result);
			if (state.position === state.lineStart && testDocumentSeparator(state)) {
				if (state.input.charCodeAt(state.position) === 46) {
					state.position += 3;
					skipSeparationSpace(state, true, -1);
				}
				return;
			}
			if (state.position < state.length - 1) {
				throwError(state, 'end of the stream or a document separator is expected');
			} else {
				return;
			}
		}
		function loadDocuments(input, options) {
			input = String(input);
			options = options || {};
			if (input.length !== 0) {
				if (
					input.charCodeAt(input.length - 1) !== 10 &&
					input.charCodeAt(input.length - 1) !== 13
				) {
					input += '\n';
				}
				if (input.charCodeAt(0) === 65279) {
					input = input.slice(1);
				}
			}
			var state = new State(input, options);
			var nullpos = input.indexOf('\0');
			if (nullpos !== -1) {
				state.position = nullpos;
				throwError(state, 'null byte is not allowed in input');
			}
			state.input += '\0';
			while (state.input.charCodeAt(state.position) === 32) {
				state.lineIndent += 1;
				state.position += 1;
			}
			while (state.position < state.length - 1) {
				readDocument(state);
			}
			return state.documents;
		}
		function loadAll(input, iterator, options) {
			if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
				options = iterator;
				iterator = null;
			}
			var documents = loadDocuments(input, options);
			if (typeof iterator !== 'function') {
				return documents;
			}
			for (var index6 = 0, length = documents.length; index6 < length; index6 += 1) {
				iterator(documents[index6]);
			}
		}
		function load4(input, options) {
			var documents = loadDocuments(input, options);
			if (documents.length === 0) {
				return void 0;
			} else if (documents.length === 1) {
				return documents[0];
			}
			throw new YAMLException('expected a single document in the stream, but found more');
		}
		function safeLoadAll(input, iterator, options) {
			if (typeof iterator === 'object' && iterator !== null && typeof options === 'undefined') {
				options = iterator;
				iterator = null;
			}
			return loadAll(input, iterator, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
		}
		function safeLoad(input, options) {
			return load4(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
		}
		module2.exports.loadAll = loadAll;
		module2.exports.load = load4;
		module2.exports.safeLoadAll = safeLoadAll;
		module2.exports.safeLoad = safeLoad;
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/dumper.js
var require_dumper = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml/dumper.js'(exports, module2) {
		'use strict';
		var common = require_common2();
		var YAMLException = require_exception();
		var DEFAULT_FULL_SCHEMA = require_default_full();
		var DEFAULT_SAFE_SCHEMA = require_default_safe();
		var _toString = Object.prototype.toString;
		var _hasOwnProperty = Object.prototype.hasOwnProperty;
		var CHAR_TAB = 9;
		var CHAR_LINE_FEED = 10;
		var CHAR_CARRIAGE_RETURN = 13;
		var CHAR_SPACE = 32;
		var CHAR_EXCLAMATION = 33;
		var CHAR_DOUBLE_QUOTE = 34;
		var CHAR_SHARP = 35;
		var CHAR_PERCENT = 37;
		var CHAR_AMPERSAND = 38;
		var CHAR_SINGLE_QUOTE = 39;
		var CHAR_ASTERISK = 42;
		var CHAR_COMMA = 44;
		var CHAR_MINUS = 45;
		var CHAR_COLON = 58;
		var CHAR_EQUALS = 61;
		var CHAR_GREATER_THAN = 62;
		var CHAR_QUESTION = 63;
		var CHAR_COMMERCIAL_AT = 64;
		var CHAR_LEFT_SQUARE_BRACKET = 91;
		var CHAR_RIGHT_SQUARE_BRACKET = 93;
		var CHAR_GRAVE_ACCENT = 96;
		var CHAR_LEFT_CURLY_BRACKET = 123;
		var CHAR_VERTICAL_LINE = 124;
		var CHAR_RIGHT_CURLY_BRACKET = 125;
		var ESCAPE_SEQUENCES = {};
		ESCAPE_SEQUENCES[0] = '\\0';
		ESCAPE_SEQUENCES[7] = '\\a';
		ESCAPE_SEQUENCES[8] = '\\b';
		ESCAPE_SEQUENCES[9] = '\\t';
		ESCAPE_SEQUENCES[10] = '\\n';
		ESCAPE_SEQUENCES[11] = '\\v';
		ESCAPE_SEQUENCES[12] = '\\f';
		ESCAPE_SEQUENCES[13] = '\\r';
		ESCAPE_SEQUENCES[27] = '\\e';
		ESCAPE_SEQUENCES[34] = '\\"';
		ESCAPE_SEQUENCES[92] = '\\\\';
		ESCAPE_SEQUENCES[133] = '\\N';
		ESCAPE_SEQUENCES[160] = '\\_';
		ESCAPE_SEQUENCES[8232] = '\\L';
		ESCAPE_SEQUENCES[8233] = '\\P';
		var DEPRECATED_BOOLEANS_SYNTAX = [
			'y',
			'Y',
			'yes',
			'Yes',
			'YES',
			'on',
			'On',
			'ON',
			'n',
			'N',
			'no',
			'No',
			'NO',
			'off',
			'Off',
			'OFF'
		];
		function compileStyleMap(schema, map4) {
			var result, keys2, index6, length, tag, style2, type;
			if (map4 === null) return {};
			result = {};
			keys2 = Object.keys(map4);
			for (index6 = 0, length = keys2.length; index6 < length; index6 += 1) {
				tag = keys2[index6];
				style2 = String(map4[tag]);
				if (tag.slice(0, 2) === '!!') {
					tag = 'tag:yaml.org,2002:' + tag.slice(2);
				}
				type = schema.compiledTypeMap['fallback'][tag];
				if (type && _hasOwnProperty.call(type.styleAliases, style2)) {
					style2 = type.styleAliases[style2];
				}
				result[tag] = style2;
			}
			return result;
		}
		function encodeHex(character) {
			var string3, handle2, length;
			string3 = character.toString(16).toUpperCase();
			if (character <= 255) {
				handle2 = 'x';
				length = 2;
			} else if (character <= 65535) {
				handle2 = 'u';
				length = 4;
			} else if (character <= 4294967295) {
				handle2 = 'U';
				length = 8;
			} else {
				throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
			}
			return '\\' + handle2 + common.repeat('0', length - string3.length) + string3;
		}
		function State(options) {
			this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;
			this.indent = Math.max(1, options['indent'] || 2);
			this.noArrayIndent = options['noArrayIndent'] || false;
			this.skipInvalid = options['skipInvalid'] || false;
			this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];
			this.styleMap = compileStyleMap(this.schema, options['styles'] || null);
			this.sortKeys = options['sortKeys'] || false;
			this.lineWidth = options['lineWidth'] || 80;
			this.noRefs = options['noRefs'] || false;
			this.noCompatMode = options['noCompatMode'] || false;
			this.condenseFlow = options['condenseFlow'] || false;
			this.implicitTypes = this.schema.compiledImplicit;
			this.explicitTypes = this.schema.compiledExplicit;
			this.tag = null;
			this.result = '';
			this.duplicates = [];
			this.usedDuplicates = null;
		}
		function indentString(string3, spaces) {
			var ind = common.repeat(' ', spaces),
				position3 = 0,
				next = -1,
				result = '',
				line,
				length = string3.length;
			while (position3 < length) {
				next = string3.indexOf('\n', position3);
				if (next === -1) {
					line = string3.slice(position3);
					position3 = length;
				} else {
					line = string3.slice(position3, next + 1);
					position3 = next + 1;
				}
				if (line.length && line !== '\n') result += ind;
				result += line;
			}
			return result;
		}
		function generateNextLine(state, level) {
			return '\n' + common.repeat(' ', state.indent * level);
		}
		function testImplicitResolving(state, str) {
			var index6, length, type;
			for (index6 = 0, length = state.implicitTypes.length; index6 < length; index6 += 1) {
				type = state.implicitTypes[index6];
				if (type.resolve(str)) {
					return true;
				}
			}
			return false;
		}
		function isWhitespace(c) {
			return c === CHAR_SPACE || c === CHAR_TAB;
		}
		function isPrintable(c) {
			return (
				(32 <= c && c <= 126) ||
				(161 <= c && c <= 55295 && c !== 8232 && c !== 8233) ||
				(57344 <= c && c <= 65533 && c !== 65279) ||
				(65536 <= c && c <= 1114111)
			);
		}
		function isNsChar(c) {
			return (
				isPrintable(c) &&
				!isWhitespace(c) &&
				c !== 65279 &&
				c !== CHAR_CARRIAGE_RETURN &&
				c !== CHAR_LINE_FEED
			);
		}
		function isPlainSafe(c, prev) {
			return (
				isPrintable(c) &&
				c !== 65279 &&
				c !== CHAR_COMMA &&
				c !== CHAR_LEFT_SQUARE_BRACKET &&
				c !== CHAR_RIGHT_SQUARE_BRACKET &&
				c !== CHAR_LEFT_CURLY_BRACKET &&
				c !== CHAR_RIGHT_CURLY_BRACKET &&
				c !== CHAR_COLON &&
				(c !== CHAR_SHARP || (prev && isNsChar(prev)))
			);
		}
		function isPlainSafeFirst(c) {
			return (
				isPrintable(c) &&
				c !== 65279 &&
				!isWhitespace(c) &&
				c !== CHAR_MINUS &&
				c !== CHAR_QUESTION &&
				c !== CHAR_COLON &&
				c !== CHAR_COMMA &&
				c !== CHAR_LEFT_SQUARE_BRACKET &&
				c !== CHAR_RIGHT_SQUARE_BRACKET &&
				c !== CHAR_LEFT_CURLY_BRACKET &&
				c !== CHAR_RIGHT_CURLY_BRACKET &&
				c !== CHAR_SHARP &&
				c !== CHAR_AMPERSAND &&
				c !== CHAR_ASTERISK &&
				c !== CHAR_EXCLAMATION &&
				c !== CHAR_VERTICAL_LINE &&
				c !== CHAR_EQUALS &&
				c !== CHAR_GREATER_THAN &&
				c !== CHAR_SINGLE_QUOTE &&
				c !== CHAR_DOUBLE_QUOTE &&
				c !== CHAR_PERCENT &&
				c !== CHAR_COMMERCIAL_AT &&
				c !== CHAR_GRAVE_ACCENT
			);
		}
		function needIndentIndicator(string3) {
			var leadingSpaceRe = /^\n* /;
			return leadingSpaceRe.test(string3);
		}
		var STYLE_PLAIN = 1;
		var STYLE_SINGLE = 2;
		var STYLE_LITERAL = 3;
		var STYLE_FOLDED = 4;
		var STYLE_DOUBLE = 5;
		function chooseScalarStyle(
			string3,
			singleLineOnly,
			indentPerLevel,
			lineWidth,
			testAmbiguousType
		) {
			var i2;
			var char, prev_char;
			var hasLineBreak = false;
			var hasFoldableLine = false;
			var shouldTrackWidth = lineWidth !== -1;
			var previousLineBreak = -1;
			var plain =
				isPlainSafeFirst(string3.charCodeAt(0)) &&
				!isWhitespace(string3.charCodeAt(string3.length - 1));
			if (singleLineOnly) {
				for (i2 = 0; i2 < string3.length; i2++) {
					char = string3.charCodeAt(i2);
					if (!isPrintable(char)) {
						return STYLE_DOUBLE;
					}
					prev_char = i2 > 0 ? string3.charCodeAt(i2 - 1) : null;
					plain = plain && isPlainSafe(char, prev_char);
				}
			} else {
				for (i2 = 0; i2 < string3.length; i2++) {
					char = string3.charCodeAt(i2);
					if (char === CHAR_LINE_FEED) {
						hasLineBreak = true;
						if (shouldTrackWidth) {
							hasFoldableLine =
								hasFoldableLine ||
								(i2 - previousLineBreak - 1 > lineWidth && string3[previousLineBreak + 1] !== ' ');
							previousLineBreak = i2;
						}
					} else if (!isPrintable(char)) {
						return STYLE_DOUBLE;
					}
					prev_char = i2 > 0 ? string3.charCodeAt(i2 - 1) : null;
					plain = plain && isPlainSafe(char, prev_char);
				}
				hasFoldableLine =
					hasFoldableLine ||
					(shouldTrackWidth &&
						i2 - previousLineBreak - 1 > lineWidth &&
						string3[previousLineBreak + 1] !== ' ');
			}
			if (!hasLineBreak && !hasFoldableLine) {
				return plain && !testAmbiguousType(string3) ? STYLE_PLAIN : STYLE_SINGLE;
			}
			if (indentPerLevel > 9 && needIndentIndicator(string3)) {
				return STYLE_DOUBLE;
			}
			return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
		}
		function writeScalar(state, string3, level, iskey) {
			state.dump = (function () {
				if (string3.length === 0) {
					return "''";
				}
				if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string3) !== -1) {
					return "'" + string3 + "'";
				}
				var indent = state.indent * Math.max(1, level);
				var lineWidth =
					state.lineWidth === -1
						? -1
						: Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);
				var singleLineOnly = iskey || (state.flowLevel > -1 && level >= state.flowLevel);
				function testAmbiguity(string4) {
					return testImplicitResolving(state, string4);
				}
				switch (
					chooseScalarStyle(string3, singleLineOnly, state.indent, lineWidth, testAmbiguity)
				) {
					case STYLE_PLAIN:
						return string3;
					case STYLE_SINGLE:
						return "'" + string3.replace(/'/g, "''") + "'";
					case STYLE_LITERAL:
						return (
							'|' +
							blockHeader(string3, state.indent) +
							dropEndingNewline(indentString(string3, indent))
						);
					case STYLE_FOLDED:
						return (
							'>' +
							blockHeader(string3, state.indent) +
							dropEndingNewline(indentString(foldString(string3, lineWidth), indent))
						);
					case STYLE_DOUBLE:
						return '"' + escapeString(string3, lineWidth) + '"';
					default:
						throw new YAMLException('impossible error: invalid scalar style');
				}
			})();
		}
		function blockHeader(string3, indentPerLevel) {
			var indentIndicator = needIndentIndicator(string3) ? String(indentPerLevel) : '';
			var clip = string3[string3.length - 1] === '\n';
			var keep = clip && (string3[string3.length - 2] === '\n' || string3 === '\n');
			var chomp = keep ? '+' : clip ? '' : '-';
			return indentIndicator + chomp + '\n';
		}
		function dropEndingNewline(string3) {
			return string3[string3.length - 1] === '\n' ? string3.slice(0, -1) : string3;
		}
		function foldString(string3, width) {
			var lineRe = /(\n+)([^\n]*)/g;
			var result = (function () {
				var nextLF = string3.indexOf('\n');
				nextLF = nextLF !== -1 ? nextLF : string3.length;
				lineRe.lastIndex = nextLF;
				return foldLine(string3.slice(0, nextLF), width);
			})();
			var prevMoreIndented = string3[0] === '\n' || string3[0] === ' ';
			var moreIndented;
			var match;
			while ((match = lineRe.exec(string3))) {
				var prefix = match[1],
					line = match[2];
				moreIndented = line[0] === ' ';
				result +=
					prefix +
					(!prevMoreIndented && !moreIndented && line !== '' ? '\n' : '') +
					foldLine(line, width);
				prevMoreIndented = moreIndented;
			}
			return result;
		}
		function foldLine(line, width) {
			if (line === '' || line[0] === ' ') return line;
			var breakRe = / [^ ]/g;
			var match;
			var start = 0,
				end,
				curr = 0,
				next = 0;
			var result = '';
			while ((match = breakRe.exec(line))) {
				next = match.index;
				if (next - start > width) {
					end = curr > start ? curr : next;
					result += '\n' + line.slice(start, end);
					start = end + 1;
				}
				curr = next;
			}
			result += '\n';
			if (line.length - start > width && curr > start) {
				result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
			} else {
				result += line.slice(start);
			}
			return result.slice(1);
		}
		function escapeString(string3) {
			var result = '';
			var char, nextChar;
			var escapeSeq;
			for (var i2 = 0; i2 < string3.length; i2++) {
				char = string3.charCodeAt(i2);
				if (char >= 55296 && char <= 56319) {
					nextChar = string3.charCodeAt(i2 + 1);
					if (nextChar >= 56320 && nextChar <= 57343) {
						result += encodeHex((char - 55296) * 1024 + nextChar - 56320 + 65536);
						i2++;
						continue;
					}
				}
				escapeSeq = ESCAPE_SEQUENCES[char];
				result += !escapeSeq && isPrintable(char) ? string3[i2] : escapeSeq || encodeHex(char);
			}
			return result;
		}
		function writeFlowSequence(state, level, object) {
			var _result = '',
				_tag = state.tag,
				index6,
				length;
			for (index6 = 0, length = object.length; index6 < length; index6 += 1) {
				if (writeNode(state, level, object[index6], false, false)) {
					if (index6 !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
					_result += state.dump;
				}
			}
			state.tag = _tag;
			state.dump = '[' + _result + ']';
		}
		function writeBlockSequence(state, level, object, compact) {
			var _result = '',
				_tag = state.tag,
				index6,
				length;
			for (index6 = 0, length = object.length; index6 < length; index6 += 1) {
				if (writeNode(state, level + 1, object[index6], true, true)) {
					if (!compact || index6 !== 0) {
						_result += generateNextLine(state, level);
					}
					if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
						_result += '-';
					} else {
						_result += '- ';
					}
					_result += state.dump;
				}
			}
			state.tag = _tag;
			state.dump = _result || '[]';
		}
		function writeFlowMapping(state, level, object) {
			var _result = '',
				_tag = state.tag,
				objectKeyList = Object.keys(object),
				index6,
				length,
				objectKey,
				objectValue,
				pairBuffer;
			for (index6 = 0, length = objectKeyList.length; index6 < length; index6 += 1) {
				pairBuffer = '';
				if (index6 !== 0) pairBuffer += ', ';
				if (state.condenseFlow) pairBuffer += '"';
				objectKey = objectKeyList[index6];
				objectValue = object[objectKey];
				if (!writeNode(state, level, objectKey, false, false)) {
					continue;
				}
				if (state.dump.length > 1024) pairBuffer += '? ';
				pairBuffer +=
					state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');
				if (!writeNode(state, level, objectValue, false, false)) {
					continue;
				}
				pairBuffer += state.dump;
				_result += pairBuffer;
			}
			state.tag = _tag;
			state.dump = '{' + _result + '}';
		}
		function writeBlockMapping(state, level, object, compact) {
			var _result = '',
				_tag = state.tag,
				objectKeyList = Object.keys(object),
				index6,
				length,
				objectKey,
				objectValue,
				explicitPair,
				pairBuffer;
			if (state.sortKeys === true) {
				objectKeyList.sort();
			} else if (typeof state.sortKeys === 'function') {
				objectKeyList.sort(state.sortKeys);
			} else if (state.sortKeys) {
				throw new YAMLException('sortKeys must be a boolean or a function');
			}
			for (index6 = 0, length = objectKeyList.length; index6 < length; index6 += 1) {
				pairBuffer = '';
				if (!compact || index6 !== 0) {
					pairBuffer += generateNextLine(state, level);
				}
				objectKey = objectKeyList[index6];
				objectValue = object[objectKey];
				if (!writeNode(state, level + 1, objectKey, true, true, true)) {
					continue;
				}
				explicitPair =
					(state.tag !== null && state.tag !== '?') || (state.dump && state.dump.length > 1024);
				if (explicitPair) {
					if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
						pairBuffer += '?';
					} else {
						pairBuffer += '? ';
					}
				}
				pairBuffer += state.dump;
				if (explicitPair) {
					pairBuffer += generateNextLine(state, level);
				}
				if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
					continue;
				}
				if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
					pairBuffer += ':';
				} else {
					pairBuffer += ': ';
				}
				pairBuffer += state.dump;
				_result += pairBuffer;
			}
			state.tag = _tag;
			state.dump = _result || '{}';
		}
		function detectType(state, object, explicit) {
			var _result, typeList, index6, length, type, style2;
			typeList = explicit ? state.explicitTypes : state.implicitTypes;
			for (index6 = 0, length = typeList.length; index6 < length; index6 += 1) {
				type = typeList[index6];
				if (
					(type.instanceOf || type.predicate) &&
					(!type.instanceOf || (typeof object === 'object' && object instanceof type.instanceOf)) &&
					(!type.predicate || type.predicate(object))
				) {
					state.tag = explicit ? type.tag : '?';
					if (type.represent) {
						style2 = state.styleMap[type.tag] || type.defaultStyle;
						if (_toString.call(type.represent) === '[object Function]') {
							_result = type.represent(object, style2);
						} else if (_hasOwnProperty.call(type.represent, style2)) {
							_result = type.represent[style2](object, style2);
						} else {
							throw new YAMLException(
								'!<' + type.tag + '> tag resolver accepts not "' + style2 + '" style'
							);
						}
						state.dump = _result;
					}
					return true;
				}
			}
			return false;
		}
		function writeNode(state, level, object, block, compact, iskey) {
			state.tag = null;
			state.dump = object;
			if (!detectType(state, object, false)) {
				detectType(state, object, true);
			}
			var type = _toString.call(state.dump);
			if (block) {
				block = state.flowLevel < 0 || state.flowLevel > level;
			}
			var objectOrArray = type === '[object Object]' || type === '[object Array]',
				duplicateIndex,
				duplicate;
			if (objectOrArray) {
				duplicateIndex = state.duplicates.indexOf(object);
				duplicate = duplicateIndex !== -1;
			}
			if (
				(state.tag !== null && state.tag !== '?') ||
				duplicate ||
				(state.indent !== 2 && level > 0)
			) {
				compact = false;
			}
			if (duplicate && state.usedDuplicates[duplicateIndex]) {
				state.dump = '*ref_' + duplicateIndex;
			} else {
				if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
					state.usedDuplicates[duplicateIndex] = true;
				}
				if (type === '[object Object]') {
					if (block && Object.keys(state.dump).length !== 0) {
						writeBlockMapping(state, level, state.dump, compact);
						if (duplicate) {
							state.dump = '&ref_' + duplicateIndex + state.dump;
						}
					} else {
						writeFlowMapping(state, level, state.dump);
						if (duplicate) {
							state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
						}
					}
				} else if (type === '[object Array]') {
					var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;
					if (block && state.dump.length !== 0) {
						writeBlockSequence(state, arrayLevel, state.dump, compact);
						if (duplicate) {
							state.dump = '&ref_' + duplicateIndex + state.dump;
						}
					} else {
						writeFlowSequence(state, arrayLevel, state.dump);
						if (duplicate) {
							state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
						}
					}
				} else if (type === '[object String]') {
					if (state.tag !== '?') {
						writeScalar(state, state.dump, level, iskey);
					}
				} else {
					if (state.skipInvalid) return false;
					throw new YAMLException('unacceptable kind of an object to dump ' + type);
				}
				if (state.tag !== null && state.tag !== '?') {
					state.dump = '!<' + state.tag + '> ' + state.dump;
				}
			}
			return true;
		}
		function getDuplicateReferences(object, state) {
			var objects = [],
				duplicatesIndexes = [],
				index6,
				length;
			inspectNode(object, objects, duplicatesIndexes);
			for (index6 = 0, length = duplicatesIndexes.length; index6 < length; index6 += 1) {
				state.duplicates.push(objects[duplicatesIndexes[index6]]);
			}
			state.usedDuplicates = new Array(length);
		}
		function inspectNode(object, objects, duplicatesIndexes) {
			var objectKeyList, index6, length;
			if (object !== null && typeof object === 'object') {
				index6 = objects.indexOf(object);
				if (index6 !== -1) {
					if (duplicatesIndexes.indexOf(index6) === -1) {
						duplicatesIndexes.push(index6);
					}
				} else {
					objects.push(object);
					if (Array.isArray(object)) {
						for (index6 = 0, length = object.length; index6 < length; index6 += 1) {
							inspectNode(object[index6], objects, duplicatesIndexes);
						}
					} else {
						objectKeyList = Object.keys(object);
						for (index6 = 0, length = objectKeyList.length; index6 < length; index6 += 1) {
							inspectNode(object[objectKeyList[index6]], objects, duplicatesIndexes);
						}
					}
				}
			}
		}
		function dump(input, options) {
			options = options || {};
			var state = new State(options);
			if (!state.noRefs) getDuplicateReferences(input, state);
			if (writeNode(state, 0, input, true, true)) return state.dump + '\n';
			return '';
		}
		function safeDump(input, options) {
			return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
		}
		module2.exports.dump = dump;
		module2.exports.safeDump = safeDump;
	}
});

// node_modules/front-matter/node_modules/js-yaml/lib/js-yaml.js
var require_js_yaml = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/lib/js-yaml.js'(exports, module2) {
		'use strict';
		var loader = require_loader();
		var dumper = require_dumper();
		function deprecated(name) {
			return function () {
				throw new Error('Function ' + name + ' is deprecated and cannot be used.');
			};
		}
		module2.exports.Type = require_type();
		module2.exports.Schema = require_schema();
		module2.exports.FAILSAFE_SCHEMA = require_failsafe();
		module2.exports.JSON_SCHEMA = require_json();
		module2.exports.CORE_SCHEMA = require_core();
		module2.exports.DEFAULT_SAFE_SCHEMA = require_default_safe();
		module2.exports.DEFAULT_FULL_SCHEMA = require_default_full();
		module2.exports.load = loader.load;
		module2.exports.loadAll = loader.loadAll;
		module2.exports.safeLoad = loader.safeLoad;
		module2.exports.safeLoadAll = loader.safeLoadAll;
		module2.exports.dump = dumper.dump;
		module2.exports.safeDump = dumper.safeDump;
		module2.exports.YAMLException = require_exception();
		module2.exports.MINIMAL_SCHEMA = require_failsafe();
		module2.exports.SAFE_SCHEMA = require_default_safe();
		module2.exports.DEFAULT_SCHEMA = require_default_full();
		module2.exports.scan = deprecated('scan');
		module2.exports.parse = deprecated('parse');
		module2.exports.compose = deprecated('compose');
		module2.exports.addConstructor = deprecated('addConstructor');
	}
});

// node_modules/front-matter/node_modules/js-yaml/index.js
var require_js_yaml2 = __commonJS({
	'node_modules/front-matter/node_modules/js-yaml/index.js'(exports, module2) {
		'use strict';
		var yaml = require_js_yaml();
		module2.exports = yaml;
	}
});

// node_modules/front-matter/index.js
var require_front_matter = __commonJS({
	'node_modules/front-matter/index.js'(exports, module2) {
		var parser = require_js_yaml2();
		var optionalByteOrderMark = '\\ufeff?';
		var platform = typeof process !== 'undefined' ? process.platform : '';
		var pattern =
			'^(' +
			optionalByteOrderMark +
			'(= yaml =|---)$([\\s\\S]*?)^(?:\\2|\\.\\.\\.)\\s*$' +
			(platform === 'win32' ? '\\r?' : '') +
			'(?:\\n)?)';
		var regex = new RegExp(pattern, 'm');
		module2.exports = extractor;
		module2.exports.test = test;
		function extractor(string3, options) {
			string3 = string3 || '';
			var defaultOptions = { allowUnsafe: false };
			options = options instanceof Object ? { ...defaultOptions, ...options } : defaultOptions;
			options.allowUnsafe = Boolean(options.allowUnsafe);
			var lines = string3.split(/(\r?\n)/);
			if (lines[0] && /= yaml =|---/.test(lines[0])) {
				return parse6(string3, options.allowUnsafe);
			} else {
				return {
					attributes: {},
					body: string3,
					bodyBegin: 1
				};
			}
		}
		function computeLocation(match, body4) {
			var line = 1;
			var pos = body4.indexOf('\n');
			var offset = match.index + match[0].length;
			while (pos !== -1) {
				if (pos >= offset) {
					return line;
				}
				line++;
				pos = body4.indexOf('\n', pos + 1);
			}
			return line;
		}
		function parse6(string3, allowUnsafe) {
			var match = regex.exec(string3);
			if (!match) {
				return {
					attributes: {},
					body: string3,
					bodyBegin: 1
				};
			}
			var loader = allowUnsafe ? parser.load : parser.safeLoad;
			var yaml = match[match.length - 1].replace(/^\s+|\s+$/g, '');
			var attributes = loader(yaml) || {};
			var body4 = string3.replace(match[0], '');
			var line = computeLocation(match, string3);
			return {
				attributes,
				body: body4,
				bodyBegin: line,
				frontmatter: yaml
			};
		}
		function test(string3) {
			string3 = string3 || '';
			return regex.test(string3);
		}
	}
});

// node_modules/bail/index.js
function bail(error2) {
	if (error2) {
		throw error2;
	}
}
var init_bail = __esm({
	'node_modules/bail/index.js'() {}
});

// node_modules/is-buffer/index.js
var require_is_buffer = __commonJS({
	'node_modules/is-buffer/index.js'(exports, module2) {
		module2.exports = function isBuffer3(obj) {
			return (
				obj != null &&
				obj.constructor != null &&
				typeof obj.constructor.isBuffer === 'function' &&
				obj.constructor.isBuffer(obj)
			);
		};
	}
});

// node_modules/extend/index.js
var require_extend = __commonJS({
	'node_modules/extend/index.js'(exports, module2) {
		'use strict';
		var hasOwn = Object.prototype.hasOwnProperty;
		var toStr = Object.prototype.toString;
		var defineProperty = Object.defineProperty;
		var gOPD = Object.getOwnPropertyDescriptor;
		var isArray = function isArray2(arr) {
			if (typeof Array.isArray === 'function') {
				return Array.isArray(arr);
			}
			return toStr.call(arr) === '[object Array]';
		};
		var isPlainObject2 = function isPlainObject3(obj) {
			if (!obj || toStr.call(obj) !== '[object Object]') {
				return false;
			}
			var hasOwnConstructor = hasOwn.call(obj, 'constructor');
			var hasIsPrototypeOf =
				obj.constructor &&
				obj.constructor.prototype &&
				hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
			if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
				return false;
			}
			var key3;
			for (key3 in obj) {
			}
			return typeof key3 === 'undefined' || hasOwn.call(obj, key3);
		};
		var setProperty = function setProperty2(target, options) {
			if (defineProperty && options.name === '__proto__') {
				defineProperty(target, options.name, {
					enumerable: true,
					configurable: true,
					value: options.newValue,
					writable: true
				});
			} else {
				target[options.name] = options.newValue;
			}
		};
		var getProperty = function getProperty2(obj, name) {
			if (name === '__proto__') {
				if (!hasOwn.call(obj, name)) {
					return void 0;
				} else if (gOPD) {
					return gOPD(obj, name).value;
				}
			}
			return obj[name];
		};
		module2.exports = function extend2() {
			var options, name, src, copy, copyIsArray, clone2;
			var target = arguments[0];
			var i2 = 1;
			var length = arguments.length;
			var deep = false;
			if (typeof target === 'boolean') {
				deep = target;
				target = arguments[1] || {};
				i2 = 2;
			}
			if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
				target = {};
			}
			for (; i2 < length; ++i2) {
				options = arguments[i2];
				if (options != null) {
					for (name in options) {
						src = getProperty(target, name);
						copy = getProperty(options, name);
						if (target !== copy) {
							if (deep && copy && (isPlainObject2(copy) || (copyIsArray = isArray(copy)))) {
								if (copyIsArray) {
									copyIsArray = false;
									clone2 = src && isArray(src) ? src : [];
								} else {
									clone2 = src && isPlainObject2(src) ? src : {};
								}
								setProperty(target, { name, newValue: extend2(deep, clone2, copy) });
							} else if (typeof copy !== 'undefined') {
								setProperty(target, { name, newValue: copy });
							}
						}
					}
				}
			}
			return target;
		};
	}
});

// node_modules/is-plain-obj/index.js
function isPlainObject(value) {
	if (typeof value !== 'object' || value === null) {
		return false;
	}
	const prototype = Object.getPrototypeOf(value);
	return (
		(prototype === null ||
			prototype === Object.prototype ||
			Object.getPrototypeOf(prototype) === null) &&
		!(Symbol.toStringTag in value) &&
		!(Symbol.iterator in value)
	);
}
var init_is_plain_obj = __esm({
	'node_modules/is-plain-obj/index.js'() {}
});

// node_modules/trough/index.js
function trough() {
	const fns = [];
	const pipeline2 = { run: run2, use };
	return pipeline2;
	function run2(...values) {
		let middlewareIndex = -1;
		const callback = values.pop();
		if (typeof callback !== 'function') {
			throw new TypeError('Expected function as last argument, not ' + callback);
		}
		next(null, ...values);
		function next(error2, ...output) {
			const fn = fns[++middlewareIndex];
			let index6 = -1;
			if (error2) {
				callback(error2);
				return;
			}
			while (++index6 < values.length) {
				if (output[index6] === null || output[index6] === void 0) {
					output[index6] = values[index6];
				}
			}
			values = output;
			if (fn) {
				wrap(fn, next)(...output);
			} else {
				callback(null, ...output);
			}
		}
	}
	function use(middelware) {
		if (typeof middelware !== 'function') {
			throw new TypeError('Expected `middelware` to be a function, not ' + middelware);
		}
		fns.push(middelware);
		return pipeline2;
	}
}
function wrap(middleware, callback) {
	let called;
	return wrapped;
	function wrapped(...parameters) {
		const fnExpectsCallback = middleware.length > parameters.length;
		let result;
		if (fnExpectsCallback) {
			parameters.push(done);
		}
		try {
			result = middleware.apply(this, parameters);
		} catch (error2) {
			const exception = error2;
			if (fnExpectsCallback && called) {
				throw exception;
			}
			return done(exception);
		}
		if (!fnExpectsCallback) {
			if (result instanceof Promise) {
				result.then(then, done);
			} else if (result instanceof Error) {
				done(result);
			} else {
				then(result);
			}
		}
	}
	function done(error2, ...output) {
		if (!called) {
			called = true;
			callback(error2, ...output);
		}
	}
	function then(value) {
		done(null, value);
	}
}
var init_trough = __esm({
	'node_modules/trough/index.js'() {}
});

// node_modules/unist-util-stringify-position/index.js
function stringifyPosition(value) {
	if (!value || typeof value !== 'object') {
		return '';
	}
	if ('position' in value || 'type' in value) {
		return position(value.position);
	}
	if ('start' in value || 'end' in value) {
		return position(value);
	}
	if ('line' in value || 'column' in value) {
		return point(value);
	}
	return '';
}
function point(point4) {
	return index5(point4 && point4.line) + ':' + index5(point4 && point4.column);
}
function position(pos) {
	return point(pos && pos.start) + '-' + point(pos && pos.end);
}
function index5(value) {
	return value && typeof value === 'number' ? value : 1;
}
var init_unist_util_stringify_position = __esm({
	'node_modules/unist-util-stringify-position/index.js'() {}
});

// node_modules/vfile-message/index.js
var VFileMessage;
var init_vfile_message = __esm({
	'node_modules/vfile-message/index.js'() {
		init_unist_util_stringify_position();
		VFileMessage = class extends Error {
			constructor(reason, place, origin) {
				const parts = [null, null];
				let position3 = {
					start: { line: null, column: null },
					end: { line: null, column: null }
				};
				super();
				if (typeof place === 'string') {
					origin = place;
					place = void 0;
				}
				if (typeof origin === 'string') {
					const index6 = origin.indexOf(':');
					if (index6 === -1) {
						parts[1] = origin;
					} else {
						parts[0] = origin.slice(0, index6);
						parts[1] = origin.slice(index6 + 1);
					}
				}
				if (place) {
					if ('type' in place || 'position' in place) {
						if (place.position) {
							position3 = place.position;
						}
					} else if ('start' in place || 'end' in place) {
						position3 = place;
					} else if ('line' in place || 'column' in place) {
						position3.start = place;
					}
				}
				this.name = stringifyPosition(place) || '1:1';
				this.message = typeof reason === 'object' ? reason.message : reason;
				this.stack = typeof reason === 'object' ? reason.stack : '';
				this.reason = this.message;
				this.fatal;
				this.line = position3.start.line;
				this.column = position3.start.column;
				this.source = parts[0];
				this.ruleId = parts[1];
				this.position = position3;
				this.actual;
				this.expected;
				this.file;
				this.url;
				this.note;
			}
		};
		VFileMessage.prototype.file = '';
		VFileMessage.prototype.name = '';
		VFileMessage.prototype.reason = '';
		VFileMessage.prototype.message = '';
		VFileMessage.prototype.stack = '';
		VFileMessage.prototype.fatal = null;
		VFileMessage.prototype.column = null;
		VFileMessage.prototype.line = null;
		VFileMessage.prototype.source = null;
		VFileMessage.prototype.ruleId = null;
		VFileMessage.prototype.position = null;
	}
});

// node_modules/vfile/lib/minpath.js
var import_path;
var init_minpath = __esm({
	'node_modules/vfile/lib/minpath.js'() {
		import_path = __toESM(require('path'), 1);
	}
});

// node_modules/vfile/lib/minproc.js
var import_process;
var init_minproc = __esm({
	'node_modules/vfile/lib/minproc.js'() {
		import_process = __toESM(require('process'), 1);
	}
});

// node_modules/vfile/lib/minurl.shared.js
function isUrl(fileURLOrPath) {
	return (
		fileURLOrPath !== null &&
		typeof fileURLOrPath === 'object' &&
		fileURLOrPath.href &&
		fileURLOrPath.origin
	);
}
var init_minurl_shared = __esm({
	'node_modules/vfile/lib/minurl.shared.js'() {}
});

// node_modules/vfile/lib/minurl.js
var import_url;
var init_minurl = __esm({
	'node_modules/vfile/lib/minurl.js'() {
		import_url = require('url');
		init_minurl_shared();
	}
});

// node_modules/vfile/lib/index.js
function assertPart(part, name) {
	if (part && part.includes(import_path.default.sep)) {
		throw new Error(
			'`' + name + '` cannot be a path: did not expect `' + import_path.default.sep + '`'
		);
	}
}
function assertNonEmpty(part, name) {
	if (!part) {
		throw new Error('`' + name + '` cannot be empty');
	}
}
function assertPath(path, name) {
	if (!path) {
		throw new Error('Setting `' + name + '` requires `path` to be set too');
	}
}
var import_is_buffer, order, VFile;
var init_lib = __esm({
	'node_modules/vfile/lib/index.js'() {
		import_is_buffer = __toESM(require_is_buffer(), 1);
		init_vfile_message();
		init_minpath();
		init_minproc();
		init_minurl();
		order = ['history', 'path', 'basename', 'stem', 'extname', 'dirname'];
		VFile = class {
			constructor(value) {
				let options;
				if (!value) {
					options = {};
				} else if (typeof value === 'string' || (0, import_is_buffer.default)(value)) {
					options = { value };
				} else if (isUrl(value)) {
					options = { path: value };
				} else {
					options = value;
				}
				this.data = {};
				this.messages = [];
				this.history = [];
				this.cwd = import_process.default.cwd();
				this.value;
				this.stored;
				this.result;
				this.map;
				let index6 = -1;
				while (++index6 < order.length) {
					const prop2 = order[index6];
					if (prop2 in options && options[prop2] !== void 0) {
						this[prop2] = prop2 === 'history' ? [...options[prop2]] : options[prop2];
					}
				}
				let prop;
				for (prop in options) {
					if (!order.includes(prop)) this[prop] = options[prop];
				}
			}
			get path() {
				return this.history[this.history.length - 1];
			}
			set path(path) {
				if (isUrl(path)) {
					path = (0, import_url.fileURLToPath)(path);
				}
				assertNonEmpty(path, 'path');
				if (this.path !== path) {
					this.history.push(path);
				}
			}
			get dirname() {
				return typeof this.path === 'string' ? import_path.default.dirname(this.path) : void 0;
			}
			set dirname(dirname) {
				assertPath(this.basename, 'dirname');
				this.path = import_path.default.join(dirname || '', this.basename);
			}
			get basename() {
				return typeof this.path === 'string' ? import_path.default.basename(this.path) : void 0;
			}
			set basename(basename) {
				assertNonEmpty(basename, 'basename');
				assertPart(basename, 'basename');
				this.path = import_path.default.join(this.dirname || '', basename);
			}
			get extname() {
				return typeof this.path === 'string' ? import_path.default.extname(this.path) : void 0;
			}
			set extname(extname) {
				assertPart(extname, 'extname');
				assertPath(this.dirname, 'extname');
				if (extname) {
					if (extname.charCodeAt(0) !== 46) {
						throw new Error('`extname` must start with `.`');
					}
					if (extname.includes('.', 1)) {
						throw new Error('`extname` cannot contain multiple dots');
					}
				}
				this.path = import_path.default.join(this.dirname, this.stem + (extname || ''));
			}
			get stem() {
				return typeof this.path === 'string'
					? import_path.default.basename(this.path, this.extname)
					: void 0;
			}
			set stem(stem) {
				assertNonEmpty(stem, 'stem');
				assertPart(stem, 'stem');
				this.path = import_path.default.join(this.dirname || '', stem + (this.extname || ''));
			}
			toString(encoding) {
				return (this.value || '').toString(encoding);
			}
			message(reason, place, origin) {
				const message = new VFileMessage(reason, place, origin);
				if (this.path) {
					message.name = this.path + ':' + message.name;
					message.file = this.path;
				}
				message.fatal = false;
				this.messages.push(message);
				return message;
			}
			info(reason, place, origin) {
				const message = this.message(reason, place, origin);
				message.fatal = null;
				return message;
			}
			fail(reason, place, origin) {
				const message = this.message(reason, place, origin);
				message.fatal = true;
				throw message;
			}
		};
	}
});

// node_modules/vfile/index.js
var init_vfile = __esm({
	'node_modules/vfile/index.js'() {
		init_lib();
	}
});

// node_modules/unified/lib/index.js
function base2() {
	const transformers = trough();
	const attachers = [];
	let namespace = {};
	let frozen;
	let freezeIndex = -1;
	processor.data = data2;
	processor.Parser = void 0;
	processor.Compiler = void 0;
	processor.freeze = freeze;
	processor.attachers = attachers;
	processor.use = use;
	processor.parse = parse6;
	processor.stringify = stringify3;
	processor.run = run2;
	processor.runSync = runSync;
	processor.process = process2;
	processor.processSync = processSync;
	return processor;
	function processor() {
		const destination = base2();
		let index6 = -1;
		while (++index6 < attachers.length) {
			destination.use(...attachers[index6]);
		}
		destination.data((0, import_extend.default)(true, {}, namespace));
		return destination;
	}
	function data2(key3, value) {
		if (typeof key3 === 'string') {
			if (arguments.length === 2) {
				assertUnfrozen('data', frozen);
				namespace[key3] = value;
				return processor;
			}
			return (own.call(namespace, key3) && namespace[key3]) || null;
		}
		if (key3) {
			assertUnfrozen('data', frozen);
			namespace = key3;
			return processor;
		}
		return namespace;
	}
	function freeze() {
		if (frozen) {
			return processor;
		}
		while (++freezeIndex < attachers.length) {
			const [attacher, ...options] = attachers[freezeIndex];
			if (options[0] === false) {
				continue;
			}
			if (options[0] === true) {
				options[0] = void 0;
			}
			const transformer = attacher.call(processor, ...options);
			if (typeof transformer === 'function') {
				transformers.use(transformer);
			}
		}
		frozen = true;
		freezeIndex = Number.POSITIVE_INFINITY;
		return processor;
	}
	function use(value, ...options) {
		let settings;
		assertUnfrozen('use', frozen);
		if (value === null || value === void 0) {
		} else if (typeof value === 'function') {
			addPlugin(value, ...options);
		} else if (typeof value === 'object') {
			if (Array.isArray(value)) {
				addList(value);
			} else {
				addPreset(value);
			}
		} else {
			throw new TypeError('Expected usable value, not `' + value + '`');
		}
		if (settings) {
			namespace.settings = Object.assign(namespace.settings || {}, settings);
		}
		return processor;
		function add(value2) {
			if (typeof value2 === 'function') {
				addPlugin(value2);
			} else if (typeof value2 === 'object') {
				if (Array.isArray(value2)) {
					const [plugin, ...options2] = value2;
					addPlugin(plugin, ...options2);
				} else {
					addPreset(value2);
				}
			} else {
				throw new TypeError('Expected usable value, not `' + value2 + '`');
			}
		}
		function addPreset(result) {
			addList(result.plugins);
			if (result.settings) {
				settings = Object.assign(settings || {}, result.settings);
			}
		}
		function addList(plugins) {
			let index6 = -1;
			if (plugins === null || plugins === void 0) {
			} else if (Array.isArray(plugins)) {
				while (++index6 < plugins.length) {
					const thing = plugins[index6];
					add(thing);
				}
			} else {
				throw new TypeError('Expected a list of plugins, not `' + plugins + '`');
			}
		}
		function addPlugin(plugin, value2) {
			let index6 = -1;
			let entry5;
			while (++index6 < attachers.length) {
				if (attachers[index6][0] === plugin) {
					entry5 = attachers[index6];
					break;
				}
			}
			if (entry5) {
				if (isPlainObject(entry5[1]) && isPlainObject(value2)) {
					value2 = (0, import_extend.default)(true, entry5[1], value2);
				}
				entry5[1] = value2;
			} else {
				attachers.push([...arguments]);
			}
		}
	}
	function parse6(doc) {
		processor.freeze();
		const file2 = vfile(doc);
		const Parser2 = processor.Parser;
		assertParser('parse', Parser2);
		if (newable(Parser2, 'parse')) {
			return new Parser2(String(file2), file2).parse();
		}
		return Parser2(String(file2), file2);
	}
	function stringify3(node, doc) {
		processor.freeze();
		const file2 = vfile(doc);
		const Compiler = processor.Compiler;
		assertCompiler('stringify', Compiler);
		assertNode(node);
		if (newable(Compiler, 'compile')) {
			return new Compiler(node, file2).compile();
		}
		return Compiler(node, file2);
	}
	function run2(node, doc, callback) {
		assertNode(node);
		processor.freeze();
		if (!callback && typeof doc === 'function') {
			callback = doc;
			doc = void 0;
		}
		if (!callback) {
			return new Promise(executor);
		}
		executor(null, callback);
		function executor(resolve2, reject) {
			transformers.run(node, vfile(doc), done);
			function done(error2, tree, file2) {
				tree = tree || node;
				if (error2) {
					reject(error2);
				} else if (resolve2) {
					resolve2(tree);
				} else {
					callback(null, tree, file2);
				}
			}
		}
	}
	function runSync(node, file2) {
		let result;
		let complete;
		processor.run(node, file2, done);
		assertDone('runSync', 'run', complete);
		return result;
		function done(error2, tree) {
			bail(error2);
			result = tree;
			complete = true;
		}
	}
	function process2(doc, callback) {
		processor.freeze();
		assertParser('process', processor.Parser);
		assertCompiler('process', processor.Compiler);
		if (!callback) {
			return new Promise(executor);
		}
		executor(null, callback);
		function executor(resolve2, reject) {
			const file2 = vfile(doc);
			processor.run(processor.parse(file2), file2, (error2, tree, file3) => {
				if (error2 || !tree || !file3) {
					done(error2);
				} else {
					const result = processor.stringify(tree, file3);
					if (result === void 0 || result === null) {
					} else if (looksLikeAVFileValue(result)) {
						file3.value = result;
					} else {
						file3.result = result;
					}
					done(error2, file3);
				}
			});
			function done(error2, file3) {
				if (error2 || !file3) {
					reject(error2);
				} else if (resolve2) {
					resolve2(file3);
				} else {
					callback(null, file3);
				}
			}
		}
	}
	function processSync(doc) {
		let complete;
		processor.freeze();
		assertParser('processSync', processor.Parser);
		assertCompiler('processSync', processor.Compiler);
		const file2 = vfile(doc);
		processor.process(file2, done);
		assertDone('processSync', 'process', complete);
		return file2;
		function done(error2) {
			complete = true;
			bail(error2);
		}
	}
}
function newable(value, name) {
	return (
		typeof value === 'function' &&
		value.prototype &&
		(keys(value.prototype) || name in value.prototype)
	);
}
function keys(value) {
	let key3;
	for (key3 in value) {
		if (own.call(value, key3)) {
			return true;
		}
	}
	return false;
}
function assertParser(name, value) {
	if (typeof value !== 'function') {
		throw new TypeError('Cannot `' + name + '` without `Parser`');
	}
}
function assertCompiler(name, value) {
	if (typeof value !== 'function') {
		throw new TypeError('Cannot `' + name + '` without `Compiler`');
	}
}
function assertUnfrozen(name, frozen) {
	if (frozen) {
		throw new Error(
			'Cannot call `' +
				name +
				'` on a frozen processor.\nCreate a new processor first, by calling it: use `processor()` instead of `processor`.'
		);
	}
}
function assertNode(node) {
	if (!isPlainObject(node) || typeof node.type !== 'string') {
		throw new TypeError('Expected node, got `' + node + '`');
	}
}
function assertDone(name, asyncName, complete) {
	if (!complete) {
		throw new Error('`' + name + '` finished async. Use `' + asyncName + '` instead');
	}
}
function vfile(value) {
	return looksLikeAVFile(value) ? value : new VFile(value);
}
function looksLikeAVFile(value) {
	return Boolean(value && typeof value === 'object' && 'message' in value && 'messages' in value);
}
function looksLikeAVFileValue(value) {
	return typeof value === 'string' || (0, import_is_buffer2.default)(value);
}
var import_is_buffer2, import_extend, unified, own;
var init_lib2 = __esm({
	'node_modules/unified/lib/index.js'() {
		init_bail();
		import_is_buffer2 = __toESM(require_is_buffer(), 1);
		import_extend = __toESM(require_extend(), 1);
		init_is_plain_obj();
		init_trough();
		init_vfile();
		unified = base2().freeze();
		own = {}.hasOwnProperty;
	}
});

// node_modules/unified/index.js
var init_unified = __esm({
	'node_modules/unified/index.js'() {
		init_lib2();
	}
});

// node_modules/mdast-util-to-string/index.js
function toString(node, options) {
	var { includeImageAlt = true } = options || {};
	return one(node, includeImageAlt);
}
function one(node, includeImageAlt) {
	return (
		(node &&
			typeof node === 'object' &&
			(node.value ||
				(includeImageAlt ? node.alt : '') ||
				('children' in node && all(node.children, includeImageAlt)) ||
				(Array.isArray(node) && all(node, includeImageAlt)))) ||
		''
	);
}
function all(values, includeImageAlt) {
	var result = [];
	var index6 = -1;
	while (++index6 < values.length) {
		result[index6] = one(values[index6], includeImageAlt);
	}
	return result.join('');
}
var init_mdast_util_to_string = __esm({
	'node_modules/mdast-util-to-string/index.js'() {}
});

// node_modules/micromark-util-chunked/index.js
function splice(list4, start, remove, items) {
	const end = list4.length;
	let chunkStart = 0;
	let parameters;
	if (start < 0) {
		start = -start > end ? 0 : end + start;
	} else {
		start = start > end ? end : start;
	}
	remove = remove > 0 ? remove : 0;
	if (items.length < 1e4) {
		parameters = Array.from(items);
		parameters.unshift(start, remove);
		[].splice.apply(list4, parameters);
	} else {
		if (remove) [].splice.apply(list4, [start, remove]);
		while (chunkStart < items.length) {
			parameters = items.slice(chunkStart, chunkStart + 1e4);
			parameters.unshift(start, 0);
			[].splice.apply(list4, parameters);
			chunkStart += 1e4;
			start += 1e4;
		}
	}
}
function push(list4, items) {
	if (list4.length > 0) {
		splice(list4, list4.length, 0, items);
		return list4;
	}
	return items;
}
var init_micromark_util_chunked = __esm({
	'node_modules/micromark-util-chunked/index.js'() {}
});

// node_modules/micromark-util-combine-extensions/index.js
function combineExtensions(extensions) {
	const all5 = {};
	let index6 = -1;
	while (++index6 < extensions.length) {
		syntaxExtension(all5, extensions[index6]);
	}
	return all5;
}
function syntaxExtension(all5, extension2) {
	let hook;
	for (hook in extension2) {
		const maybe = hasOwnProperty.call(all5, hook) ? all5[hook] : void 0;
		const left = maybe || (all5[hook] = {});
		const right = extension2[hook];
		let code3;
		for (code3 in right) {
			if (!hasOwnProperty.call(left, code3)) left[code3] = [];
			const value = right[code3];
			constructs(left[code3], Array.isArray(value) ? value : value ? [value] : []);
		}
	}
}
function constructs(existing, list4) {
	let index6 = -1;
	const before = [];
	while (++index6 < list4.length) {
		(list4[index6].add === 'after' ? existing : before).push(list4[index6]);
	}
	splice(existing, 0, 0, before);
}
var hasOwnProperty;
var init_micromark_util_combine_extensions = __esm({
	'node_modules/micromark-util-combine-extensions/index.js'() {
		init_micromark_util_chunked();
		hasOwnProperty = {}.hasOwnProperty;
	}
});

// node_modules/micromark-util-character/lib/unicode-punctuation-regex.js
var unicodePunctuationRegex;
var init_unicode_punctuation_regex = __esm({
	'node_modules/micromark-util-character/lib/unicode-punctuation-regex.js'() {
		unicodePunctuationRegex =
			/[!-/:-@[-`{-~\u00A1\u00A7\u00AB\u00B6\u00B7\u00BB\u00BF\u037E\u0387\u055A-\u055F\u0589\u058A\u05BE\u05C0\u05C3\u05C6\u05F3\u05F4\u0609\u060A\u060C\u060D\u061B\u061E\u061F\u066A-\u066D\u06D4\u0700-\u070D\u07F7-\u07F9\u0830-\u083E\u085E\u0964\u0965\u0970\u09FD\u0A76\u0AF0\u0C77\u0C84\u0DF4\u0E4F\u0E5A\u0E5B\u0F04-\u0F12\u0F14\u0F3A-\u0F3D\u0F85\u0FD0-\u0FD4\u0FD9\u0FDA\u104A-\u104F\u10FB\u1360-\u1368\u1400\u166E\u169B\u169C\u16EB-\u16ED\u1735\u1736\u17D4-\u17D6\u17D8-\u17DA\u1800-\u180A\u1944\u1945\u1A1E\u1A1F\u1AA0-\u1AA6\u1AA8-\u1AAD\u1B5A-\u1B60\u1BFC-\u1BFF\u1C3B-\u1C3F\u1C7E\u1C7F\u1CC0-\u1CC7\u1CD3\u2010-\u2027\u2030-\u2043\u2045-\u2051\u2053-\u205E\u207D\u207E\u208D\u208E\u2308-\u230B\u2329\u232A\u2768-\u2775\u27C5\u27C6\u27E6-\u27EF\u2983-\u2998\u29D8-\u29DB\u29FC\u29FD\u2CF9-\u2CFC\u2CFE\u2CFF\u2D70\u2E00-\u2E2E\u2E30-\u2E4F\u2E52\u3001-\u3003\u3008-\u3011\u3014-\u301F\u3030\u303D\u30A0\u30FB\uA4FE\uA4FF\uA60D-\uA60F\uA673\uA67E\uA6F2-\uA6F7\uA874-\uA877\uA8CE\uA8CF\uA8F8-\uA8FA\uA8FC\uA92E\uA92F\uA95F\uA9C1-\uA9CD\uA9DE\uA9DF\uAA5C-\uAA5F\uAADE\uAADF\uAAF0\uAAF1\uABEB\uFD3E\uFD3F\uFE10-\uFE19\uFE30-\uFE52\uFE54-\uFE61\uFE63\uFE68\uFE6A\uFE6B\uFF01-\uFF03\uFF05-\uFF0A\uFF0C-\uFF0F\uFF1A\uFF1B\uFF1F\uFF20\uFF3B-\uFF3D\uFF3F\uFF5B\uFF5D\uFF5F-\uFF65]/;
	}
});

// node_modules/micromark-util-character/index.js
function asciiControl(code3) {
	return code3 !== null && (code3 < 32 || code3 === 127);
}
function markdownLineEndingOrSpace(code3) {
	return code3 !== null && (code3 < 0 || code3 === 32);
}
function markdownLineEnding(code3) {
	return code3 !== null && code3 < -2;
}
function markdownSpace(code3) {
	return code3 === -2 || code3 === -1 || code3 === 32;
}
function regexCheck(regex) {
	return check;
	function check(code3) {
		return code3 !== null && regex.test(String.fromCharCode(code3));
	}
}
var asciiAlpha,
	asciiDigit,
	asciiHexDigit,
	asciiAlphanumeric,
	asciiPunctuation,
	asciiAtext,
	unicodeWhitespace,
	unicodePunctuation;
var init_micromark_util_character = __esm({
	'node_modules/micromark-util-character/index.js'() {
		init_unicode_punctuation_regex();
		asciiAlpha = regexCheck(/[A-Za-z]/);
		asciiDigit = regexCheck(/\d/);
		asciiHexDigit = regexCheck(/[\dA-Fa-f]/);
		asciiAlphanumeric = regexCheck(/[\dA-Za-z]/);
		asciiPunctuation = regexCheck(/[!-/:-@[-`{-~]/);
		asciiAtext = regexCheck(/[#-'*+\--9=?A-Z^-~]/);
		unicodeWhitespace = regexCheck(/\s/);
		unicodePunctuation = regexCheck(unicodePunctuationRegex);
	}
});

// node_modules/micromark-factory-space/index.js
function factorySpace(effects, ok2, type, max) {
	const limit = max ? max - 1 : Number.POSITIVE_INFINITY;
	let size = 0;
	return start;
	function start(code3) {
		if (markdownSpace(code3)) {
			effects.enter(type);
			return prefix(code3);
		}
		return ok2(code3);
	}
	function prefix(code3) {
		if (markdownSpace(code3) && size++ < limit) {
			effects.consume(code3);
			return prefix;
		}
		effects.exit(type);
		return ok2(code3);
	}
}
var init_micromark_factory_space = __esm({
	'node_modules/micromark-factory-space/index.js'() {
		init_micromark_util_character();
	}
});

// node_modules/micromark/lib/initialize/content.js
function initializeContent(effects) {
	const contentStart = effects.attempt(
		this.parser.constructs.contentInitial,
		afterContentStartConstruct,
		paragraphInitial
	);
	let previous2;
	return contentStart;
	function afterContentStartConstruct(code3) {
		if (code3 === null) {
			effects.consume(code3);
			return;
		}
		effects.enter('lineEnding');
		effects.consume(code3);
		effects.exit('lineEnding');
		return factorySpace(effects, contentStart, 'linePrefix');
	}
	function paragraphInitial(code3) {
		effects.enter('paragraph');
		return lineStart(code3);
	}
	function lineStart(code3) {
		const token = effects.enter('chunkText', {
			contentType: 'text',
			previous: previous2
		});
		if (previous2) {
			previous2.next = token;
		}
		previous2 = token;
		return data2(code3);
	}
	function data2(code3) {
		if (code3 === null) {
			effects.exit('chunkText');
			effects.exit('paragraph');
			effects.consume(code3);
			return;
		}
		if (markdownLineEnding(code3)) {
			effects.consume(code3);
			effects.exit('chunkText');
			return lineStart;
		}
		effects.consume(code3);
		return data2;
	}
}
var content;
var init_content = __esm({
	'node_modules/micromark/lib/initialize/content.js'() {
		init_micromark_factory_space();
		init_micromark_util_character();
		content = {
			tokenize: initializeContent
		};
	}
});

// node_modules/micromark/lib/initialize/document.js
function initializeDocument(effects) {
	const self2 = this;
	const stack = [];
	let continued = 0;
	let childFlow;
	let childToken;
	let lineStartOffset;
	return start;
	function start(code3) {
		if (continued < stack.length) {
			const item = stack[continued];
			self2.containerState = item[1];
			return effects.attempt(item[0].continuation, documentContinue, checkNewContainers)(code3);
		}
		return checkNewContainers(code3);
	}
	function documentContinue(code3) {
		continued++;
		if (self2.containerState._closeFlow) {
			self2.containerState._closeFlow = void 0;
			if (childFlow) {
				closeFlow();
			}
			const indexBeforeExits = self2.events.length;
			let indexBeforeFlow = indexBeforeExits;
			let point4;
			while (indexBeforeFlow--) {
				if (
					self2.events[indexBeforeFlow][0] === 'exit' &&
					self2.events[indexBeforeFlow][1].type === 'chunkFlow'
				) {
					point4 = self2.events[indexBeforeFlow][1].end;
					break;
				}
			}
			exitContainers(continued);
			let index6 = indexBeforeExits;
			while (index6 < self2.events.length) {
				self2.events[index6][1].end = Object.assign({}, point4);
				index6++;
			}
			splice(self2.events, indexBeforeFlow + 1, 0, self2.events.slice(indexBeforeExits));
			self2.events.length = index6;
			return checkNewContainers(code3);
		}
		return start(code3);
	}
	function checkNewContainers(code3) {
		if (continued === stack.length) {
			if (!childFlow) {
				return documentContinued(code3);
			}
			if (childFlow.currentConstruct && childFlow.currentConstruct.concrete) {
				return flowStart(code3);
			}
			self2.interrupt = Boolean(
				childFlow.currentConstruct && !childFlow._gfmTableDynamicInterruptHack
			);
		}
		self2.containerState = {};
		return effects.check(containerConstruct, thereIsANewContainer, thereIsNoNewContainer)(code3);
	}
	function thereIsANewContainer(code3) {
		if (childFlow) closeFlow();
		exitContainers(continued);
		return documentContinued(code3);
	}
	function thereIsNoNewContainer(code3) {
		self2.parser.lazy[self2.now().line] = continued !== stack.length;
		lineStartOffset = self2.now().offset;
		return flowStart(code3);
	}
	function documentContinued(code3) {
		self2.containerState = {};
		return effects.attempt(containerConstruct, containerContinue, flowStart)(code3);
	}
	function containerContinue(code3) {
		continued++;
		stack.push([self2.currentConstruct, self2.containerState]);
		return documentContinued(code3);
	}
	function flowStart(code3) {
		if (code3 === null) {
			if (childFlow) closeFlow();
			exitContainers(0);
			effects.consume(code3);
			return;
		}
		childFlow = childFlow || self2.parser.flow(self2.now());
		effects.enter('chunkFlow', {
			contentType: 'flow',
			previous: childToken,
			_tokenizer: childFlow
		});
		return flowContinue(code3);
	}
	function flowContinue(code3) {
		if (code3 === null) {
			writeToChild(effects.exit('chunkFlow'), true);
			exitContainers(0);
			effects.consume(code3);
			return;
		}
		if (markdownLineEnding(code3)) {
			effects.consume(code3);
			writeToChild(effects.exit('chunkFlow'));
			continued = 0;
			self2.interrupt = void 0;
			return start;
		}
		effects.consume(code3);
		return flowContinue;
	}
	function writeToChild(token, eof) {
		const stream2 = self2.sliceStream(token);
		if (eof) stream2.push(null);
		token.previous = childToken;
		if (childToken) childToken.next = token;
		childToken = token;
		childFlow.defineSkip(token.start);
		childFlow.write(stream2);
		if (self2.parser.lazy[token.start.line]) {
			let index6 = childFlow.events.length;
			while (index6--) {
				if (
					childFlow.events[index6][1].start.offset < lineStartOffset &&
					(!childFlow.events[index6][1].end ||
						childFlow.events[index6][1].end.offset > lineStartOffset)
				) {
					return;
				}
			}
			const indexBeforeExits = self2.events.length;
			let indexBeforeFlow = indexBeforeExits;
			let seen;
			let point4;
			while (indexBeforeFlow--) {
				if (
					self2.events[indexBeforeFlow][0] === 'exit' &&
					self2.events[indexBeforeFlow][1].type === 'chunkFlow'
				) {
					if (seen) {
						point4 = self2.events[indexBeforeFlow][1].end;
						break;
					}
					seen = true;
				}
			}
			exitContainers(continued);
			index6 = indexBeforeExits;
			while (index6 < self2.events.length) {
				self2.events[index6][1].end = Object.assign({}, point4);
				index6++;
			}
			splice(self2.events, indexBeforeFlow + 1, 0, self2.events.slice(indexBeforeExits));
			self2.events.length = index6;
		}
	}
	function exitContainers(size) {
		let index6 = stack.length;
		while (index6-- > size) {
			const entry5 = stack[index6];
			self2.containerState = entry5[1];
			entry5[0].exit.call(self2, effects);
		}
		stack.length = size;
	}
	function closeFlow() {
		childFlow.write([null]);
		childToken = void 0;
		childFlow = void 0;
		self2.containerState._closeFlow = void 0;
	}
}
function tokenizeContainer(effects, ok2, nok) {
	return factorySpace(
		effects,
		effects.attempt(this.parser.constructs.document, ok2, nok),
		'linePrefix',
		this.parser.constructs.disable.null.includes('codeIndented') ? void 0 : 4
	);
}
var document2, containerConstruct;
var init_document = __esm({
	'node_modules/micromark/lib/initialize/document.js'() {
		init_micromark_factory_space();
		init_micromark_util_character();
		init_micromark_util_chunked();
		document2 = {
			tokenize: initializeDocument
		};
		containerConstruct = {
			tokenize: tokenizeContainer
		};
	}
});

// node_modules/micromark-util-classify-character/index.js
function classifyCharacter(code3) {
	if (code3 === null || markdownLineEndingOrSpace(code3) || unicodeWhitespace(code3)) {
		return 1;
	}
	if (unicodePunctuation(code3)) {
		return 2;
	}
}
var init_micromark_util_classify_character = __esm({
	'node_modules/micromark-util-classify-character/index.js'() {
		init_micromark_util_character();
	}
});

// node_modules/micromark-util-resolve-all/index.js
function resolveAll(constructs2, events, context) {
	const called = [];
	let index6 = -1;
	while (++index6 < constructs2.length) {
		const resolve2 = constructs2[index6].resolveAll;
		if (resolve2 && !called.includes(resolve2)) {
			events = resolve2(events, context);
			called.push(resolve2);
		}
	}
	return events;
}
var init_micromark_util_resolve_all = __esm({
	'node_modules/micromark-util-resolve-all/index.js'() {}
});

// node_modules/micromark-core-commonmark/lib/attention.js
function resolveAllAttention(events, context) {
	let index6 = -1;
	let open;
	let group;
	let text7;
	let openingSequence;
	let closingSequence;
	let use;
	let nextEvents;
	let offset;
	while (++index6 < events.length) {
		if (
			events[index6][0] === 'enter' &&
			events[index6][1].type === 'attentionSequence' &&
			events[index6][1]._close
		) {
			open = index6;
			while (open--) {
				if (
					events[open][0] === 'exit' &&
					events[open][1].type === 'attentionSequence' &&
					events[open][1]._open &&
					context.sliceSerialize(events[open][1]).charCodeAt(0) ===
						context.sliceSerialize(events[index6][1]).charCodeAt(0)
				) {
					if (
						(events[open][1]._close || events[index6][1]._open) &&
						(events[index6][1].end.offset - events[index6][1].start.offset) % 3 &&
						!(
							(events[open][1].end.offset -
								events[open][1].start.offset +
								events[index6][1].end.offset -
								events[index6][1].start.offset) %
							3
						)
					) {
						continue;
					}
					use =
						events[open][1].end.offset - events[open][1].start.offset > 1 &&
						events[index6][1].end.offset - events[index6][1].start.offset > 1
							? 2
							: 1;
					const start = Object.assign({}, events[open][1].end);
					const end = Object.assign({}, events[index6][1].start);
					movePoint(start, -use);
					movePoint(end, use);
					openingSequence = {
						type: use > 1 ? 'strongSequence' : 'emphasisSequence',
						start,
						end: Object.assign({}, events[open][1].end)
					};
					closingSequence = {
						type: use > 1 ? 'strongSequence' : 'emphasisSequence',
						start: Object.assign({}, events[index6][1].start),
						end
					};
					text7 = {
						type: use > 1 ? 'strongText' : 'emphasisText',
						start: Object.assign({}, events[open][1].end),
						end: Object.assign({}, events[index6][1].start)
					};
					group = {
						type: use > 1 ? 'strong' : 'emphasis',
						start: Object.assign({}, openingSequence.start),
						end: Object.assign({}, closingSequence.end)
					};
					events[open][1].end = Object.assign({}, openingSequence.start);
					events[index6][1].start = Object.assign({}, closingSequence.end);
					nextEvents = [];
					if (events[open][1].end.offset - events[open][1].start.offset) {
						nextEvents = push(nextEvents, [
							['enter', events[open][1], context],
							['exit', events[open][1], context]
						]);
					}
					nextEvents = push(nextEvents, [
						['enter', group, context],
						['enter', openingSequence, context],
						['exit', openingSequence, context],
						['enter', text7, context]
					]);
					nextEvents = push(
						nextEvents,
						resolveAll(
							context.parser.constructs.insideSpan.null,
							events.slice(open + 1, index6),
							context
						)
					);
					nextEvents = push(nextEvents, [
						['exit', text7, context],
						['enter', closingSequence, context],
						['exit', closingSequence, context],
						['exit', group, context]
					]);
					if (events[index6][1].end.offset - events[index6][1].start.offset) {
						offset = 2;
						nextEvents = push(nextEvents, [
							['enter', events[index6][1], context],
							['exit', events[index6][1], context]
						]);
					} else {
						offset = 0;
					}
					splice(events, open - 1, index6 - open + 3, nextEvents);
					index6 = open + nextEvents.length - offset - 2;
					break;
				}
			}
		}
	}
	index6 = -1;
	while (++index6 < events.length) {
		if (events[index6][1].type === 'attentionSequence') {
			events[index6][1].type = 'data';
		}
	}
	return events;
}
function tokenizeAttention(effects, ok2) {
	const attentionMarkers2 = this.parser.constructs.attentionMarkers.null;
	const previous2 = this.previous;
	const before = classifyCharacter(previous2);
	let marker;
	return start;
	function start(code3) {
		effects.enter('attentionSequence');
		marker = code3;
		return sequence(code3);
	}
	function sequence(code3) {
		if (code3 === marker) {
			effects.consume(code3);
			return sequence;
		}
		const token = effects.exit('attentionSequence');
		const after = classifyCharacter(code3);
		const open = !after || (after === 2 && before) || attentionMarkers2.includes(code3);
		const close = !before || (before === 2 && after) || attentionMarkers2.includes(previous2);
		token._open = Boolean(marker === 42 ? open : open && (before || !close));
		token._close = Boolean(marker === 42 ? close : close && (after || !open));
		return ok2(code3);
	}
}
function movePoint(point4, offset) {
	point4.column += offset;
	point4.offset += offset;
	point4._bufferIndex += offset;
}
var attention;
var init_attention = __esm({
	'node_modules/micromark-core-commonmark/lib/attention.js'() {
		init_micromark_util_chunked();
		init_micromark_util_classify_character();
		init_micromark_util_resolve_all();
		attention = {
			name: 'attention',
			tokenize: tokenizeAttention,
			resolveAll: resolveAllAttention
		};
	}
});

// node_modules/micromark-core-commonmark/lib/autolink.js
function tokenizeAutolink(effects, ok2, nok) {
	let size = 1;
	return start;
	function start(code3) {
		effects.enter('autolink');
		effects.enter('autolinkMarker');
		effects.consume(code3);
		effects.exit('autolinkMarker');
		effects.enter('autolinkProtocol');
		return open;
	}
	function open(code3) {
		if (asciiAlpha(code3)) {
			effects.consume(code3);
			return schemeOrEmailAtext;
		}
		return asciiAtext(code3) ? emailAtext(code3) : nok(code3);
	}
	function schemeOrEmailAtext(code3) {
		return code3 === 43 || code3 === 45 || code3 === 46 || asciiAlphanumeric(code3)
			? schemeInsideOrEmailAtext(code3)
			: emailAtext(code3);
	}
	function schemeInsideOrEmailAtext(code3) {
		if (code3 === 58) {
			effects.consume(code3);
			return urlInside;
		}
		if ((code3 === 43 || code3 === 45 || code3 === 46 || asciiAlphanumeric(code3)) && size++ < 32) {
			effects.consume(code3);
			return schemeInsideOrEmailAtext;
		}
		return emailAtext(code3);
	}
	function urlInside(code3) {
		if (code3 === 62) {
			effects.exit('autolinkProtocol');
			return end(code3);
		}
		if (code3 === null || code3 === 32 || code3 === 60 || asciiControl(code3)) {
			return nok(code3);
		}
		effects.consume(code3);
		return urlInside;
	}
	function emailAtext(code3) {
		if (code3 === 64) {
			effects.consume(code3);
			size = 0;
			return emailAtSignOrDot;
		}
		if (asciiAtext(code3)) {
			effects.consume(code3);
			return emailAtext;
		}
		return nok(code3);
	}
	function emailAtSignOrDot(code3) {
		return asciiAlphanumeric(code3) ? emailLabel(code3) : nok(code3);
	}
	function emailLabel(code3) {
		if (code3 === 46) {
			effects.consume(code3);
			size = 0;
			return emailAtSignOrDot;
		}
		if (code3 === 62) {
			effects.exit('autolinkProtocol').type = 'autolinkEmail';
			return end(code3);
		}
		return emailValue(code3);
	}
	function emailValue(code3) {
		if ((code3 === 45 || asciiAlphanumeric(code3)) && size++ < 63) {
			effects.consume(code3);
			return code3 === 45 ? emailValue : emailLabel;
		}
		return nok(code3);
	}
	function end(code3) {
		effects.enter('autolinkMarker');
		effects.consume(code3);
		effects.exit('autolinkMarker');
		effects.exit('autolink');
		return ok2;
	}
}
var autolink;
var init_autolink = __esm({
	'node_modules/micromark-core-commonmark/lib/autolink.js'() {
		init_micromark_util_character();
		autolink = {
			name: 'autolink',
			tokenize: tokenizeAutolink
		};
	}
});

// node_modules/micromark-core-commonmark/lib/blank-line.js
function tokenizeBlankLine(effects, ok2, nok) {
	return factorySpace(effects, afterWhitespace, 'linePrefix');
	function afterWhitespace(code3) {
		return code3 === null || markdownLineEnding(code3) ? ok2(code3) : nok(code3);
	}
}
var blankLine;
var init_blank_line = __esm({
	'node_modules/micromark-core-commonmark/lib/blank-line.js'() {
		init_micromark_factory_space();
		init_micromark_util_character();
		blankLine = {
			tokenize: tokenizeBlankLine,
			partial: true
		};
	}
});

// node_modules/micromark-core-commonmark/lib/block-quote.js
function tokenizeBlockQuoteStart(effects, ok2, nok) {
	const self2 = this;
	return start;
	function start(code3) {
		if (code3 === 62) {
			const state = self2.containerState;
			if (!state.open) {
				effects.enter('blockQuote', {
					_container: true
				});
				state.open = true;
			}
			effects.enter('blockQuotePrefix');
			effects.enter('blockQuoteMarker');
			effects.consume(code3);
			effects.exit('blockQuoteMarker');
			return after;
		}
		return nok(code3);
	}
	function after(code3) {
		if (markdownSpace(code3)) {
			effects.enter('blockQuotePrefixWhitespace');
			effects.consume(code3);
			effects.exit('blockQuotePrefixWhitespace');
			effects.exit('blockQuotePrefix');
			return ok2;
		}
		effects.exit('blockQuotePrefix');
		return ok2(code3);
	}
}
function tokenizeBlockQuoteContinuation(effects, ok2, nok) {
	return factorySpace(
		effects,
		effects.attempt(blockQuote, ok2, nok),
		'linePrefix',
		this.parser.constructs.disable.null.includes('codeIndented') ? void 0 : 4
	);
}
function exit(effects) {
	effects.exit('blockQuote');
}
var blockQuote;
var init_block_quote = __esm({
	'node_modules/micromark-core-commonmark/lib/block-quote.js'() {
		init_micromark_factory_space();
		init_micromark_util_character();
		blockQuote = {
			name: 'blockQuote',
			tokenize: tokenizeBlockQuoteStart,
			continuation: {
				tokenize: tokenizeBlockQuoteContinuation
			},
			exit
		};
	}
});

// node_modules/micromark-core-commonmark/lib/character-escape.js
function tokenizeCharacterEscape(effects, ok2, nok) {
	return start;
	function start(code3) {
		effects.enter('characterEscape');
		effects.enter('escapeMarker');
		effects.consume(code3);
		effects.exit('escapeMarker');
		return open;
	}
	function open(code3) {
		if (asciiPunctuation(code3)) {
			effects.enter('characterEscapeValue');
			effects.consume(code3);
			effects.exit('characterEscapeValue');
			effects.exit('characterEscape');
			return ok2;
		}
		return nok(code3);
	}
}
var characterEscape;
var init_character_escape = __esm({
	'node_modules/micromark-core-commonmark/lib/character-escape.js'() {
		init_micromark_util_character();
		characterEscape = {
			name: 'characterEscape',
			tokenize: tokenizeCharacterEscape
		};
	}
});

// node_modules/decode-named-character-reference/node_modules/character-entities/index.js
var characterEntities;
var init_character_entities = __esm({
	'node_modules/decode-named-character-reference/node_modules/character-entities/index.js'() {
		characterEntities = {
			AElig: '\xC6',
			AMP: '&',
			Aacute: '\xC1',
			Abreve: '\u0102',
			Acirc: '\xC2',
			Acy: '\u0410',
			Afr: '\u{1D504}',
			Agrave: '\xC0',
			Alpha: '\u0391',
			Amacr: '\u0100',
			And: '\u2A53',
			Aogon: '\u0104',
			Aopf: '\u{1D538}',
			ApplyFunction: '\u2061',
			Aring: '\xC5',
			Ascr: '\u{1D49C}',
			Assign: '\u2254',
			Atilde: '\xC3',
			Auml: '\xC4',
			Backslash: '\u2216',
			Barv: '\u2AE7',
			Barwed: '\u2306',
			Bcy: '\u0411',
			Because: '\u2235',
			Bernoullis: '\u212C',
			Beta: '\u0392',
			Bfr: '\u{1D505}',
			Bopf: '\u{1D539}',
			Breve: '\u02D8',
			Bscr: '\u212C',
			Bumpeq: '\u224E',
			CHcy: '\u0427',
			COPY: '\xA9',
			Cacute: '\u0106',
			Cap: '\u22D2',
			CapitalDifferentialD: '\u2145',
			Cayleys: '\u212D',
			Ccaron: '\u010C',
			Ccedil: '\xC7',
			Ccirc: '\u0108',
			Cconint: '\u2230',
			Cdot: '\u010A',
			Cedilla: '\xB8',
			CenterDot: '\xB7',
			Cfr: '\u212D',
			Chi: '\u03A7',
			CircleDot: '\u2299',
			CircleMinus: '\u2296',
			CirclePlus: '\u2295',
			CircleTimes: '\u2297',
			ClockwiseContourIntegral: '\u2232',
			CloseCurlyDoubleQuote: '\u201D',
			CloseCurlyQuote: '\u2019',
			Colon: '\u2237',
			Colone: '\u2A74',
			Congruent: '\u2261',
			Conint: '\u222F',
			ContourIntegral: '\u222E',
			Copf: '\u2102',
			Coproduct: '\u2210',
			CounterClockwiseContourIntegral: '\u2233',
			Cross: '\u2A2F',
			Cscr: '\u{1D49E}',
			Cup: '\u22D3',
			CupCap: '\u224D',
			DD: '\u2145',
			DDotrahd: '\u2911',
			DJcy: '\u0402',
			DScy: '\u0405',
			DZcy: '\u040F',
			Dagger: '\u2021',
			Darr: '\u21A1',
			Dashv: '\u2AE4',
			Dcaron: '\u010E',
			Dcy: '\u0414',
			Del: '\u2207',
			Delta: '\u0394',
			Dfr: '\u{1D507}',
			DiacriticalAcute: '\xB4',
			DiacriticalDot: '\u02D9',
			DiacriticalDoubleAcute: '\u02DD',
			DiacriticalGrave: '`',
			DiacriticalTilde: '\u02DC',
			Diamond: '\u22C4',
			DifferentialD: '\u2146',
			Dopf: '\u{1D53B}',
			Dot: '\xA8',
			DotDot: '\u20DC',
			DotEqual: '\u2250',
			DoubleContourIntegral: '\u222F',
			DoubleDot: '\xA8',
			DoubleDownArrow: '\u21D3',
			DoubleLeftArrow: '\u21D0',
			DoubleLeftRightArrow: '\u21D4',
			DoubleLeftTee: '\u2AE4',
			DoubleLongLeftArrow: '\u27F8',
			DoubleLongLeftRightArrow: '\u27FA',
			DoubleLongRightArrow: '\u27F9',
			DoubleRightArrow: '\u21D2',
			DoubleRightTee: '\u22A8',
			DoubleUpArrow: '\u21D1',
			DoubleUpDownArrow: '\u21D5',
			DoubleVerticalBar: '\u2225',
			DownArrow: '\u2193',
			DownArrowBar: '\u2913',
			DownArrowUpArrow: '\u21F5',
			DownBreve: '\u0311',
			DownLeftRightVector: '\u2950',
			DownLeftTeeVector: '\u295E',
			DownLeftVector: '\u21BD',
			DownLeftVectorBar: '\u2956',
			DownRightTeeVector: '\u295F',
			DownRightVector: '\u21C1',
			DownRightVectorBar: '\u2957',
			DownTee: '\u22A4',
			DownTeeArrow: '\u21A7',
			Downarrow: '\u21D3',
			Dscr: '\u{1D49F}',
			Dstrok: '\u0110',
			ENG: '\u014A',
			ETH: '\xD0',
			Eacute: '\xC9',
			Ecaron: '\u011A',
			Ecirc: '\xCA',
			Ecy: '\u042D',
			Edot: '\u0116',
			Efr: '\u{1D508}',
			Egrave: '\xC8',
			Element: '\u2208',
			Emacr: '\u0112',
			EmptySmallSquare: '\u25FB',
			EmptyVerySmallSquare: '\u25AB',
			Eogon: '\u0118',
			Eopf: '\u{1D53C}',
			Epsilon: '\u0395',
			Equal: '\u2A75',
			EqualTilde: '\u2242',
			Equilibrium: '\u21CC',
			Escr: '\u2130',
			Esim: '\u2A73',
			Eta: '\u0397',
			Euml: '\xCB',
			Exists: '\u2203',
			ExponentialE: '\u2147',
			Fcy: '\u0424',
			Ffr: '\u{1D509}',
			FilledSmallSquare: '\u25FC',
			FilledVerySmallSquare: '\u25AA',
			Fopf: '\u{1D53D}',
			ForAll: '\u2200',
			Fouriertrf: '\u2131',
			Fscr: '\u2131',
			GJcy: '\u0403',
			GT: '>',
			Gamma: '\u0393',
			Gammad: '\u03DC',
			Gbreve: '\u011E',
			Gcedil: '\u0122',
			Gcirc: '\u011C',
			Gcy: '\u0413',
			Gdot: '\u0120',
			Gfr: '\u{1D50A}',
			Gg: '\u22D9',
			Gopf: '\u{1D53E}',
			GreaterEqual: '\u2265',
			GreaterEqualLess: '\u22DB',
			GreaterFullEqual: '\u2267',
			GreaterGreater: '\u2AA2',
			GreaterLess: '\u2277',
			GreaterSlantEqual: '\u2A7E',
			GreaterTilde: '\u2273',
			Gscr: '\u{1D4A2}',
			Gt: '\u226B',
			HARDcy: '\u042A',
			Hacek: '\u02C7',
			Hat: '^',
			Hcirc: '\u0124',
			Hfr: '\u210C',
			HilbertSpace: '\u210B',
			Hopf: '\u210D',
			HorizontalLine: '\u2500',
			Hscr: '\u210B',
			Hstrok: '\u0126',
			HumpDownHump: '\u224E',
			HumpEqual: '\u224F',
			IEcy: '\u0415',
			IJlig: '\u0132',
			IOcy: '\u0401',
			Iacute: '\xCD',
			Icirc: '\xCE',
			Icy: '\u0418',
			Idot: '\u0130',
			Ifr: '\u2111',
			Igrave: '\xCC',
			Im: '\u2111',
			Imacr: '\u012A',
			ImaginaryI: '\u2148',
			Implies: '\u21D2',
			Int: '\u222C',
			Integral: '\u222B',
			Intersection: '\u22C2',
			InvisibleComma: '\u2063',
			InvisibleTimes: '\u2062',
			Iogon: '\u012E',
			Iopf: '\u{1D540}',
			Iota: '\u0399',
			Iscr: '\u2110',
			Itilde: '\u0128',
			Iukcy: '\u0406',
			Iuml: '\xCF',
			Jcirc: '\u0134',
			Jcy: '\u0419',
			Jfr: '\u{1D50D}',
			Jopf: '\u{1D541}',
			Jscr: '\u{1D4A5}',
			Jsercy: '\u0408',
			Jukcy: '\u0404',
			KHcy: '\u0425',
			KJcy: '\u040C',
			Kappa: '\u039A',
			Kcedil: '\u0136',
			Kcy: '\u041A',
			Kfr: '\u{1D50E}',
			Kopf: '\u{1D542}',
			Kscr: '\u{1D4A6}',
			LJcy: '\u0409',
			LT: '<',
			Lacute: '\u0139',
			Lambda: '\u039B',
			Lang: '\u27EA',
			Laplacetrf: '\u2112',
			Larr: '\u219E',
			Lcaron: '\u013D',
			Lcedil: '\u013B',
			Lcy: '\u041B',
			LeftAngleBracket: '\u27E8',
			LeftArrow: '\u2190',
			LeftArrowBar: '\u21E4',
			LeftArrowRightArrow: '\u21C6',
			LeftCeiling: '\u2308',
			LeftDoubleBracket: '\u27E6',
			LeftDownTeeVector: '\u2961',
			LeftDownVector: '\u21C3',
			LeftDownVectorBar: '\u2959',
			LeftFloor: '\u230A',
			LeftRightArrow: '\u2194',
			LeftRightVector: '\u294E',
			LeftTee: '\u22A3',
			LeftTeeArrow: '\u21A4',
			LeftTeeVector: '\u295A',
			LeftTriangle: '\u22B2',
			LeftTriangleBar: '\u29CF',
			LeftTriangleEqual: '\u22B4',
			LeftUpDownVector: '\u2951',
			LeftUpTeeVector: '\u2960',
			LeftUpVector: '\u21BF',
			LeftUpVectorBar: '\u2958',
			LeftVector: '\u21BC',
			LeftVectorBar: '\u2952',
			Leftarrow: '\u21D0',
			Leftrightarrow: '\u21D4',
			LessEqualGreater: '\u22DA',
			LessFullEqual: '\u2266',
			LessGreater: '\u2276',
			LessLess: '\u2AA1',
			LessSlantEqual: '\u2A7D',
			LessTilde: '\u2272',
			Lfr: '\u{1D50F}',
			Ll: '\u22D8',
			Lleftarrow: '\u21DA',
			Lmidot: '\u013F',
			LongLeftArrow: '\u27F5',
			LongLeftRightArrow: '\u27F7',
			LongRightArrow: '\u27F6',
			Longleftarrow: '\u27F8',
			Longleftrightarrow: '\u27FA',
			Longrightarrow: '\u27F9',
			Lopf: '\u{1D543}',
			LowerLeftArrow: '\u2199',
			LowerRightArrow: '\u2198',
			Lscr: '\u2112',
			Lsh: '\u21B0',
			Lstrok: '\u0141',
			Lt: '\u226A',
			Map: '\u2905',
			Mcy: '\u041C',
			MediumSpace: '\u205F',
			Mellintrf: '\u2133',
			Mfr: '\u{1D510}',
			MinusPlus: '\u2213',
			Mopf: '\u{1D544}',
			Mscr: '\u2133',
			Mu: '\u039C',
			NJcy: '\u040A',
			Nacute: '\u0143',
			Ncaron: '\u0147',
			Ncedil: '\u0145',
			Ncy: '\u041D',
			NegativeMediumSpace: '\u200B',
			NegativeThickSpace: '\u200B',
			NegativeThinSpace: '\u200B',
			NegativeVeryThinSpace: '\u200B',
			NestedGreaterGreater: '\u226B',
			NestedLessLess: '\u226A',
			NewLine: '\n',
			Nfr: '\u{1D511}',
			NoBreak: '\u2060',
			NonBreakingSpace: '\xA0',
			Nopf: '\u2115',
			Not: '\u2AEC',
			NotCongruent: '\u2262',
			NotCupCap: '\u226D',
			NotDoubleVerticalBar: '\u2226',
			NotElement: '\u2209',
			NotEqual: '\u2260',
			NotEqualTilde: '\u2242\u0338',
			NotExists: '\u2204',
			NotGreater: '\u226F',
			NotGreaterEqual: '\u2271',
			NotGreaterFullEqual: '\u2267\u0338',
			NotGreaterGreater: '\u226B\u0338',
			NotGreaterLess: '\u2279',
			NotGreaterSlantEqual: '\u2A7E\u0338',
			NotGreaterTilde: '\u2275',
			NotHumpDownHump: '\u224E\u0338',
			NotHumpEqual: '\u224F\u0338',
			NotLeftTriangle: '\u22EA',
			NotLeftTriangleBar: '\u29CF\u0338',
			NotLeftTriangleEqual: '\u22EC',
			NotLess: '\u226E',
			NotLessEqual: '\u2270',
			NotLessGreater: '\u2278',
			NotLessLess: '\u226A\u0338',
			NotLessSlantEqual: '\u2A7D\u0338',
			NotLessTilde: '\u2274',
			NotNestedGreaterGreater: '\u2AA2\u0338',
			NotNestedLessLess: '\u2AA1\u0338',
			NotPrecedes: '\u2280',
			NotPrecedesEqual: '\u2AAF\u0338',
			NotPrecedesSlantEqual: '\u22E0',
			NotReverseElement: '\u220C',
			NotRightTriangle: '\u22EB',
			NotRightTriangleBar: '\u29D0\u0338',
			NotRightTriangleEqual: '\u22ED',
			NotSquareSubset: '\u228F\u0338',
			NotSquareSubsetEqual: '\u22E2',
			NotSquareSuperset: '\u2290\u0338',
			NotSquareSupersetEqual: '\u22E3',
			NotSubset: '\u2282\u20D2',
			NotSubsetEqual: '\u2288',
			NotSucceeds: '\u2281',
			NotSucceedsEqual: '\u2AB0\u0338',
			NotSucceedsSlantEqual: '\u22E1',
			NotSucceedsTilde: '\u227F\u0338',
			NotSuperset: '\u2283\u20D2',
			NotSupersetEqual: '\u2289',
			NotTilde: '\u2241',
			NotTildeEqual: '\u2244',
			NotTildeFullEqual: '\u2247',
			NotTildeTilde: '\u2249',
			NotVerticalBar: '\u2224',
			Nscr: '\u{1D4A9}',
			Ntilde: '\xD1',
			Nu: '\u039D',
			OElig: '\u0152',
			Oacute: '\xD3',
			Ocirc: '\xD4',
			Ocy: '\u041E',
			Odblac: '\u0150',
			Ofr: '\u{1D512}',
			Ograve: '\xD2',
			Omacr: '\u014C',
			Omega: '\u03A9',
			Omicron: '\u039F',
			Oopf: '\u{1D546}',
			OpenCurlyDoubleQuote: '\u201C',
			OpenCurlyQuote: '\u2018',
			Or: '\u2A54',
			Oscr: '\u{1D4AA}',
			Oslash: '\xD8',
			Otilde: '\xD5',
			Otimes: '\u2A37',
			Ouml: '\xD6',
			OverBar: '\u203E',
			OverBrace: '\u23DE',
			OverBracket: '\u23B4',
			OverParenthesis: '\u23DC',
			PartialD: '\u2202',
			Pcy: '\u041F',
			Pfr: '\u{1D513}',
			Phi: '\u03A6',
			Pi: '\u03A0',
			PlusMinus: '\xB1',
			Poincareplane: '\u210C',
			Popf: '\u2119',
			Pr: '\u2ABB',
			Precedes: '\u227A',
			PrecedesEqual: '\u2AAF',
			PrecedesSlantEqual: '\u227C',
			PrecedesTilde: '\u227E',
			Prime: '\u2033',
			Product: '\u220F',
			Proportion: '\u2237',
			Proportional: '\u221D',
			Pscr: '\u{1D4AB}',
			Psi: '\u03A8',
			QUOT: '"',
			Qfr: '\u{1D514}',
			Qopf: '\u211A',
			Qscr: '\u{1D4AC}',
			RBarr: '\u2910',
			REG: '\xAE',
			Racute: '\u0154',
			Rang: '\u27EB',
			Rarr: '\u21A0',
			Rarrtl: '\u2916',
			Rcaron: '\u0158',
			Rcedil: '\u0156',
			Rcy: '\u0420',
			Re: '\u211C',
			ReverseElement: '\u220B',
			ReverseEquilibrium: '\u21CB',
			ReverseUpEquilibrium: '\u296F',
			Rfr: '\u211C',
			Rho: '\u03A1',
			RightAngleBracket: '\u27E9',
			RightArrow: '\u2192',
			RightArrowBar: '\u21E5',
			RightArrowLeftArrow: '\u21C4',
			RightCeiling: '\u2309',
			RightDoubleBracket: '\u27E7',
			RightDownTeeVector: '\u295D',
			RightDownVector: '\u21C2',
			RightDownVectorBar: '\u2955',
			RightFloor: '\u230B',
			RightTee: '\u22A2',
			RightTeeArrow: '\u21A6',
			RightTeeVector: '\u295B',
			RightTriangle: '\u22B3',
			RightTriangleBar: '\u29D0',
			RightTriangleEqual: '\u22B5',
			RightUpDownVector: '\u294F',
			RightUpTeeVector: '\u295C',
			RightUpVector: '\u21BE',
			RightUpVectorBar: '\u2954',
			RightVector: '\u21C0',
			RightVectorBar: '\u2953',
			Rightarrow: '\u21D2',
			Ropf: '\u211D',
			RoundImplies: '\u2970',
			Rrightarrow: '\u21DB',
			Rscr: '\u211B',
			Rsh: '\u21B1',
			RuleDelayed: '\u29F4',
			SHCHcy: '\u0429',
			SHcy: '\u0428',
			SOFTcy: '\u042C',
			Sacute: '\u015A',
			Sc: '\u2ABC',
			Scaron: '\u0160',
			Scedil: '\u015E',
			Scirc: '\u015C',
			Scy: '\u0421',
			Sfr: '\u{1D516}',
			ShortDownArrow: '\u2193',
			ShortLeftArrow: '\u2190',
			ShortRightArrow: '\u2192',
			ShortUpArrow: '\u2191',
			Sigma: '\u03A3',
			SmallCircle: '\u2218',
			Sopf: '\u{1D54A}',
			Sqrt: '\u221A',
			Square: '\u25A1',
			SquareIntersection: '\u2293',
			SquareSubset: '\u228F',
			SquareSubsetEqual: '\u2291',
			SquareSuperset: '\u2290',
			SquareSupersetEqual: '\u2292',
			SquareUnion: '\u2294',
			Sscr: '\u{1D4AE}',
			Star: '\u22C6',
			Sub: '\u22D0',
			Subset: '\u22D0',
			SubsetEqual: '\u2286',
			Succeeds: '\u227B',
			SucceedsEqual: '\u2AB0',
			SucceedsSlantEqual: '\u227D',
			SucceedsTilde: '\u227F',
			SuchThat: '\u220B',
			Sum: '\u2211',
			Sup: '\u22D1',
			Superset: '\u2283',
			SupersetEqual: '\u2287',
			Supset: '\u22D1',
			THORN: '\xDE',
			TRADE: '\u2122',
			TSHcy: '\u040B',
			TScy: '\u0426',
			Tab: '	',
			Tau: '\u03A4',
			Tcaron: '\u0164',
			Tcedil: '\u0162',
			Tcy: '\u0422',
			Tfr: '\u{1D517}',
			Therefore: '\u2234',
			Theta: '\u0398',
			ThickSpace: '\u205F\u200A',
			ThinSpace: '\u2009',
			Tilde: '\u223C',
			TildeEqual: '\u2243',
			TildeFullEqual: '\u2245',
			TildeTilde: '\u2248',
			Topf: '\u{1D54B}',
			TripleDot: '\u20DB',
			Tscr: '\u{1D4AF}',
			Tstrok: '\u0166',
			Uacute: '\xDA',
			Uarr: '\u219F',
			Uarrocir: '\u2949',
			Ubrcy: '\u040E',
			Ubreve: '\u016C',
			Ucirc: '\xDB',
			Ucy: '\u0423',
			Udblac: '\u0170',
			Ufr: '\u{1D518}',
			Ugrave: '\xD9',
			Umacr: '\u016A',
			UnderBar: '_',
			UnderBrace: '\u23DF',
			UnderBracket: '\u23B5',
			UnderParenthesis: '\u23DD',
			Union: '\u22C3',
			UnionPlus: '\u228E',
			Uogon: '\u0172',
			Uopf: '\u{1D54C}',
			UpArrow: '\u2191',
			UpArrowBar: '\u2912',
			UpArrowDownArrow: '\u21C5',
			UpDownArrow: '\u2195',
			UpEquilibrium: '\u296E',
			UpTee: '\u22A5',
			UpTeeArrow: '\u21A5',
			Uparrow: '\u21D1',
			Updownarrow: '\u21D5',
			UpperLeftArrow: '\u2196',
			UpperRightArrow: '\u2197',
			Upsi: '\u03D2',
			Upsilon: '\u03A5',
			Uring: '\u016E',
			Uscr: '\u{1D4B0}',
			Utilde: '\u0168',
			Uuml: '\xDC',
			VDash: '\u22AB',
			Vbar: '\u2AEB',
			Vcy: '\u0412',
			Vdash: '\u22A9',
			Vdashl: '\u2AE6',
			Vee: '\u22C1',
			Verbar: '\u2016',
			Vert: '\u2016',
			VerticalBar: '\u2223',
			VerticalLine: '|',
			VerticalSeparator: '\u2758',
			VerticalTilde: '\u2240',
			VeryThinSpace: '\u200A',
			Vfr: '\u{1D519}',
			Vopf: '\u{1D54D}',
			Vscr: '\u{1D4B1}',
			Vvdash: '\u22AA',
			Wcirc: '\u0174',
			Wedge: '\u22C0',
			Wfr: '\u{1D51A}',
			Wopf: '\u{1D54E}',
			Wscr: '\u{1D4B2}',
			Xfr: '\u{1D51B}',
			Xi: '\u039E',
			Xopf: '\u{1D54F}',
			Xscr: '\u{1D4B3}',
			YAcy: '\u042F',
			YIcy: '\u0407',
			YUcy: '\u042E',
			Yacute: '\xDD',
			Ycirc: '\u0176',
			Ycy: '\u042B',
			Yfr: '\u{1D51C}',
			Yopf: '\u{1D550}',
			Yscr: '\u{1D4B4}',
			Yuml: '\u0178',
			ZHcy: '\u0416',
			Zacute: '\u0179',
			Zcaron: '\u017D',
			Zcy: '\u0417',
			Zdot: '\u017B',
			ZeroWidthSpace: '\u200B',
			Zeta: '\u0396',
			Zfr: '\u2128',
			Zopf: '\u2124',
			Zscr: '\u{1D4B5}',
			aacute: '\xE1',
			abreve: '\u0103',
			ac: '\u223E',
			acE: '\u223E\u0333',
			acd: '\u223F',
			acirc: '\xE2',
			acute: '\xB4',
			acy: '\u0430',
			aelig: '\xE6',
			af: '\u2061',
			afr: '\u{1D51E}',
			agrave: '\xE0',
			alefsym: '\u2135',
			aleph: '\u2135',
			alpha: '\u03B1',
			amacr: '\u0101',
			amalg: '\u2A3F',
			amp: '&',
			and: '\u2227',
			andand: '\u2A55',
			andd: '\u2A5C',
			andslope: '\u2A58',
			andv: '\u2A5A',
			ang: '\u2220',
			ange: '\u29A4',
			angle: '\u2220',
			angmsd: '\u2221',
			angmsdaa: '\u29A8',
			angmsdab: '\u29A9',
			angmsdac: '\u29AA',
			angmsdad: '\u29AB',
			angmsdae: '\u29AC',
			angmsdaf: '\u29AD',
			angmsdag: '\u29AE',
			angmsdah: '\u29AF',
			angrt: '\u221F',
			angrtvb: '\u22BE',
			angrtvbd: '\u299D',
			angsph: '\u2222',
			angst: '\xC5',
			angzarr: '\u237C',
			aogon: '\u0105',
			aopf: '\u{1D552}',
			ap: '\u2248',
			apE: '\u2A70',
			apacir: '\u2A6F',
			ape: '\u224A',
			apid: '\u224B',
			apos: "'",
			approx: '\u2248',
			approxeq: '\u224A',
			aring: '\xE5',
			ascr: '\u{1D4B6}',
			ast: '*',
			asymp: '\u2248',
			asympeq: '\u224D',
			atilde: '\xE3',
			auml: '\xE4',
			awconint: '\u2233',
			awint: '\u2A11',
			bNot: '\u2AED',
			backcong: '\u224C',
			backepsilon: '\u03F6',
			backprime: '\u2035',
			backsim: '\u223D',
			backsimeq: '\u22CD',
			barvee: '\u22BD',
			barwed: '\u2305',
			barwedge: '\u2305',
			bbrk: '\u23B5',
			bbrktbrk: '\u23B6',
			bcong: '\u224C',
			bcy: '\u0431',
			bdquo: '\u201E',
			becaus: '\u2235',
			because: '\u2235',
			bemptyv: '\u29B0',
			bepsi: '\u03F6',
			bernou: '\u212C',
			beta: '\u03B2',
			beth: '\u2136',
			between: '\u226C',
			bfr: '\u{1D51F}',
			bigcap: '\u22C2',
			bigcirc: '\u25EF',
			bigcup: '\u22C3',
			bigodot: '\u2A00',
			bigoplus: '\u2A01',
			bigotimes: '\u2A02',
			bigsqcup: '\u2A06',
			bigstar: '\u2605',
			bigtriangledown: '\u25BD',
			bigtriangleup: '\u25B3',
			biguplus: '\u2A04',
			bigvee: '\u22C1',
			bigwedge: '\u22C0',
			bkarow: '\u290D',
			blacklozenge: '\u29EB',
			blacksquare: '\u25AA',
			blacktriangle: '\u25B4',
			blacktriangledown: '\u25BE',
			blacktriangleleft: '\u25C2',
			blacktriangleright: '\u25B8',
			blank: '\u2423',
			blk12: '\u2592',
			blk14: '\u2591',
			blk34: '\u2593',
			block: '\u2588',
			bne: '=\u20E5',
			bnequiv: '\u2261\u20E5',
			bnot: '\u2310',
			bopf: '\u{1D553}',
			bot: '\u22A5',
			bottom: '\u22A5',
			bowtie: '\u22C8',
			boxDL: '\u2557',
			boxDR: '\u2554',
			boxDl: '\u2556',
			boxDr: '\u2553',
			boxH: '\u2550',
			boxHD: '\u2566',
			boxHU: '\u2569',
			boxHd: '\u2564',
			boxHu: '\u2567',
			boxUL: '\u255D',
			boxUR: '\u255A',
			boxUl: '\u255C',
			boxUr: '\u2559',
			boxV: '\u2551',
			boxVH: '\u256C',
			boxVL: '\u2563',
			boxVR: '\u2560',
			boxVh: '\u256B',
			boxVl: '\u2562',
			boxVr: '\u255F',
			boxbox: '\u29C9',
			boxdL: '\u2555',
			boxdR: '\u2552',
			boxdl: '\u2510',
			boxdr: '\u250C',
			boxh: '\u2500',
			boxhD: '\u2565',
			boxhU: '\u2568',
			boxhd: '\u252C',
			boxhu: '\u2534',
			boxminus: '\u229F',
			boxplus: '\u229E',
			boxtimes: '\u22A0',
			boxuL: '\u255B',
			boxuR: '\u2558',
			boxul: '\u2518',
			boxur: '\u2514',
			boxv: '\u2502',
			boxvH: '\u256A',
			boxvL: '\u2561',
			boxvR: '\u255E',
			boxvh: '\u253C',
			boxvl: '\u2524',
			boxvr: '\u251C',
			bprime: '\u2035',
			breve: '\u02D8',
			brvbar: '\xA6',
			bscr: '\u{1D4B7}',
			bsemi: '\u204F',
			bsim: '\u223D',
			bsime: '\u22CD',
			bsol: '\\',
			bsolb: '\u29C5',
			bsolhsub: '\u27C8',
			bull: '\u2022',
			bullet: '\u2022',
			bump: '\u224E',
			bumpE: '\u2AAE',
			bumpe: '\u224F',
			bumpeq: '\u224F',
			cacute: '\u0107',
			cap: '\u2229',
			capand: '\u2A44',
			capbrcup: '\u2A49',
			capcap: '\u2A4B',
			capcup: '\u2A47',
			capdot: '\u2A40',
			caps: '\u2229\uFE00',
			caret: '\u2041',
			caron: '\u02C7',
			ccaps: '\u2A4D',
			ccaron: '\u010D',
			ccedil: '\xE7',
			ccirc: '\u0109',
			ccups: '\u2A4C',
			ccupssm: '\u2A50',
			cdot: '\u010B',
			cedil: '\xB8',
			cemptyv: '\u29B2',
			cent: '\xA2',
			centerdot: '\xB7',
			cfr: '\u{1D520}',
			chcy: '\u0447',
			check: '\u2713',
			checkmark: '\u2713',
			chi: '\u03C7',
			cir: '\u25CB',
			cirE: '\u29C3',
			circ: '\u02C6',
			circeq: '\u2257',
			circlearrowleft: '\u21BA',
			circlearrowright: '\u21BB',
			circledR: '\xAE',
			circledS: '\u24C8',
			circledast: '\u229B',
			circledcirc: '\u229A',
			circleddash: '\u229D',
			cire: '\u2257',
			cirfnint: '\u2A10',
			cirmid: '\u2AEF',
			cirscir: '\u29C2',
			clubs: '\u2663',
			clubsuit: '\u2663',
			colon: ':',
			colone: '\u2254',
			coloneq: '\u2254',
			comma: ',',
			commat: '@',
			comp: '\u2201',
			compfn: '\u2218',
			complement: '\u2201',
			complexes: '\u2102',
			cong: '\u2245',
			congdot: '\u2A6D',
			conint: '\u222E',
			copf: '\u{1D554}',
			coprod: '\u2210',
			copy: '\xA9',
			copysr: '\u2117',
			crarr: '\u21B5',
			cross: '\u2717',
			cscr: '\u{1D4B8}',
			csub: '\u2ACF',
			csube: '\u2AD1',
			csup: '\u2AD0',
			csupe: '\u2AD2',
			ctdot: '\u22EF',
			cudarrl: '\u2938',
			cudarrr: '\u2935',
			cuepr: '\u22DE',
			cuesc: '\u22DF',
			cularr: '\u21B6',
			cularrp: '\u293D',
			cup: '\u222A',
			cupbrcap: '\u2A48',
			cupcap: '\u2A46',
			cupcup: '\u2A4A',
			cupdot: '\u228D',
			cupor: '\u2A45',
			cups: '\u222A\uFE00',
			curarr: '\u21B7',
			curarrm: '\u293C',
			curlyeqprec: '\u22DE',
			curlyeqsucc: '\u22DF',
			curlyvee: '\u22CE',
			curlywedge: '\u22CF',
			curren: '\xA4',
			curvearrowleft: '\u21B6',
			curvearrowright: '\u21B7',
			cuvee: '\u22CE',
			cuwed: '\u22CF',
			cwconint: '\u2232',
			cwint: '\u2231',
			cylcty: '\u232D',
			dArr: '\u21D3',
			dHar: '\u2965',
			dagger: '\u2020',
			daleth: '\u2138',
			darr: '\u2193',
			dash: '\u2010',
			dashv: '\u22A3',
			dbkarow: '\u290F',
			dblac: '\u02DD',
			dcaron: '\u010F',
			dcy: '\u0434',
			dd: '\u2146',
			ddagger: '\u2021',
			ddarr: '\u21CA',
			ddotseq: '\u2A77',
			deg: '\xB0',
			delta: '\u03B4',
			demptyv: '\u29B1',
			dfisht: '\u297F',
			dfr: '\u{1D521}',
			dharl: '\u21C3',
			dharr: '\u21C2',
			diam: '\u22C4',
			diamond: '\u22C4',
			diamondsuit: '\u2666',
			diams: '\u2666',
			die: '\xA8',
			digamma: '\u03DD',
			disin: '\u22F2',
			div: '\xF7',
			divide: '\xF7',
			divideontimes: '\u22C7',
			divonx: '\u22C7',
			djcy: '\u0452',
			dlcorn: '\u231E',
			dlcrop: '\u230D',
			dollar: '$',
			dopf: '\u{1D555}',
			dot: '\u02D9',
			doteq: '\u2250',
			doteqdot: '\u2251',
			dotminus: '\u2238',
			dotplus: '\u2214',
			dotsquare: '\u22A1',
			doublebarwedge: '\u2306',
			downarrow: '\u2193',
			downdownarrows: '\u21CA',
			downharpoonleft: '\u21C3',
			downharpoonright: '\u21C2',
			drbkarow: '\u2910',
			drcorn: '\u231F',
			drcrop: '\u230C',
			dscr: '\u{1D4B9}',
			dscy: '\u0455',
			dsol: '\u29F6',
			dstrok: '\u0111',
			dtdot: '\u22F1',
			dtri: '\u25BF',
			dtrif: '\u25BE',
			duarr: '\u21F5',
			duhar: '\u296F',
			dwangle: '\u29A6',
			dzcy: '\u045F',
			dzigrarr: '\u27FF',
			eDDot: '\u2A77',
			eDot: '\u2251',
			eacute: '\xE9',
			easter: '\u2A6E',
			ecaron: '\u011B',
			ecir: '\u2256',
			ecirc: '\xEA',
			ecolon: '\u2255',
			ecy: '\u044D',
			edot: '\u0117',
			ee: '\u2147',
			efDot: '\u2252',
			efr: '\u{1D522}',
			eg: '\u2A9A',
			egrave: '\xE8',
			egs: '\u2A96',
			egsdot: '\u2A98',
			el: '\u2A99',
			elinters: '\u23E7',
			ell: '\u2113',
			els: '\u2A95',
			elsdot: '\u2A97',
			emacr: '\u0113',
			empty: '\u2205',
			emptyset: '\u2205',
			emptyv: '\u2205',
			emsp13: '\u2004',
			emsp14: '\u2005',
			emsp: '\u2003',
			eng: '\u014B',
			ensp: '\u2002',
			eogon: '\u0119',
			eopf: '\u{1D556}',
			epar: '\u22D5',
			eparsl: '\u29E3',
			eplus: '\u2A71',
			epsi: '\u03B5',
			epsilon: '\u03B5',
			epsiv: '\u03F5',
			eqcirc: '\u2256',
			eqcolon: '\u2255',
			eqsim: '\u2242',
			eqslantgtr: '\u2A96',
			eqslantless: '\u2A95',
			equals: '=',
			equest: '\u225F',
			equiv: '\u2261',
			equivDD: '\u2A78',
			eqvparsl: '\u29E5',
			erDot: '\u2253',
			erarr: '\u2971',
			escr: '\u212F',
			esdot: '\u2250',
			esim: '\u2242',
			eta: '\u03B7',
			eth: '\xF0',
			euml: '\xEB',
			euro: '\u20AC',
			excl: '!',
			exist: '\u2203',
			expectation: '\u2130',
			exponentiale: '\u2147',
			fallingdotseq: '\u2252',
			fcy: '\u0444',
			female: '\u2640',
			ffilig: '\uFB03',
			fflig: '\uFB00',
			ffllig: '\uFB04',
			ffr: '\u{1D523}',
			filig: '\uFB01',
			fjlig: 'fj',
			flat: '\u266D',
			fllig: '\uFB02',
			fltns: '\u25B1',
			fnof: '\u0192',
			fopf: '\u{1D557}',
			forall: '\u2200',
			fork: '\u22D4',
			forkv: '\u2AD9',
			fpartint: '\u2A0D',
			frac12: '\xBD',
			frac13: '\u2153',
			frac14: '\xBC',
			frac15: '\u2155',
			frac16: '\u2159',
			frac18: '\u215B',
			frac23: '\u2154',
			frac25: '\u2156',
			frac34: '\xBE',
			frac35: '\u2157',
			frac38: '\u215C',
			frac45: '\u2158',
			frac56: '\u215A',
			frac58: '\u215D',
			frac78: '\u215E',
			frasl: '\u2044',
			frown: '\u2322',
			fscr: '\u{1D4BB}',
			gE: '\u2267',
			gEl: '\u2A8C',
			gacute: '\u01F5',
			gamma: '\u03B3',
			gammad: '\u03DD',
			gap: '\u2A86',
			gbreve: '\u011F',
			gcirc: '\u011D',
			gcy: '\u0433',
			gdot: '\u0121',
			ge: '\u2265',
			gel: '\u22DB',
			geq: '\u2265',
			geqq: '\u2267',
			geqslant: '\u2A7E',
			ges: '\u2A7E',
			gescc: '\u2AA9',
			gesdot: '\u2A80',
			gesdoto: '\u2A82',
			gesdotol: '\u2A84',
			gesl: '\u22DB\uFE00',
			gesles: '\u2A94',
			gfr: '\u{1D524}',
			gg: '\u226B',
			ggg: '\u22D9',
			gimel: '\u2137',
			gjcy: '\u0453',
			gl: '\u2277',
			glE: '\u2A92',
			gla: '\u2AA5',
			glj: '\u2AA4',
			gnE: '\u2269',
			gnap: '\u2A8A',
			gnapprox: '\u2A8A',
			gne: '\u2A88',
			gneq: '\u2A88',
			gneqq: '\u2269',
			gnsim: '\u22E7',
			gopf: '\u{1D558}',
			grave: '`',
			gscr: '\u210A',
			gsim: '\u2273',
			gsime: '\u2A8E',
			gsiml: '\u2A90',
			gt: '>',
			gtcc: '\u2AA7',
			gtcir: '\u2A7A',
			gtdot: '\u22D7',
			gtlPar: '\u2995',
			gtquest: '\u2A7C',
			gtrapprox: '\u2A86',
			gtrarr: '\u2978',
			gtrdot: '\u22D7',
			gtreqless: '\u22DB',
			gtreqqless: '\u2A8C',
			gtrless: '\u2277',
			gtrsim: '\u2273',
			gvertneqq: '\u2269\uFE00',
			gvnE: '\u2269\uFE00',
			hArr: '\u21D4',
			hairsp: '\u200A',
			half: '\xBD',
			hamilt: '\u210B',
			hardcy: '\u044A',
			harr: '\u2194',
			harrcir: '\u2948',
			harrw: '\u21AD',
			hbar: '\u210F',
			hcirc: '\u0125',
			hearts: '\u2665',
			heartsuit: '\u2665',
			hellip: '\u2026',
			hercon: '\u22B9',
			hfr: '\u{1D525}',
			hksearow: '\u2925',
			hkswarow: '\u2926',
			hoarr: '\u21FF',
			homtht: '\u223B',
			hookleftarrow: '\u21A9',
			hookrightarrow: '\u21AA',
			hopf: '\u{1D559}',
			horbar: '\u2015',
			hscr: '\u{1D4BD}',
			hslash: '\u210F',
			hstrok: '\u0127',
			hybull: '\u2043',
			hyphen: '\u2010',
			iacute: '\xED',
			ic: '\u2063',
			icirc: '\xEE',
			icy: '\u0438',
			iecy: '\u0435',
			iexcl: '\xA1',
			iff: '\u21D4',
			ifr: '\u{1D526}',
			igrave: '\xEC',
			ii: '\u2148',
			iiiint: '\u2A0C',
			iiint: '\u222D',
			iinfin: '\u29DC',
			iiota: '\u2129',
			ijlig: '\u0133',
			imacr: '\u012B',
			image: '\u2111',
			imagline: '\u2110',
			imagpart: '\u2111',
			imath: '\u0131',
			imof: '\u22B7',
			imped: '\u01B5',
			in: '\u2208',
			incare: '\u2105',
			infin: '\u221E',
			infintie: '\u29DD',
			inodot: '\u0131',
			int: '\u222B',
			intcal: '\u22BA',
			integers: '\u2124',
			intercal: '\u22BA',
			intlarhk: '\u2A17',
			intprod: '\u2A3C',
			iocy: '\u0451',
			iogon: '\u012F',
			iopf: '\u{1D55A}',
			iota: '\u03B9',
			iprod: '\u2A3C',
			iquest: '\xBF',
			iscr: '\u{1D4BE}',
			isin: '\u2208',
			isinE: '\u22F9',
			isindot: '\u22F5',
			isins: '\u22F4',
			isinsv: '\u22F3',
			isinv: '\u2208',
			it: '\u2062',
			itilde: '\u0129',
			iukcy: '\u0456',
			iuml: '\xEF',
			jcirc: '\u0135',
			jcy: '\u0439',
			jfr: '\u{1D527}',
			jmath: '\u0237',
			jopf: '\u{1D55B}',
			jscr: '\u{1D4BF}',
			jsercy: '\u0458',
			jukcy: '\u0454',
			kappa: '\u03BA',
			kappav: '\u03F0',
			kcedil: '\u0137',
			kcy: '\u043A',
			kfr: '\u{1D528}',
			kgreen: '\u0138',
			khcy: '\u0445',
			kjcy: '\u045C',
			kopf: '\u{1D55C}',
			kscr: '\u{1D4C0}',
			lAarr: '\u21DA',
			lArr: '\u21D0',
			lAtail: '\u291B',
			lBarr: '\u290E',
			lE: '\u2266',
			lEg: '\u2A8B',
			lHar: '\u2962',
			lacute: '\u013A',
			laemptyv: '\u29B4',
			lagran: '\u2112',
			lambda: '\u03BB',
			lang: '\u27E8',
			langd: '\u2991',
			langle: '\u27E8',
			lap: '\u2A85',
			laquo: '\xAB',
			larr: '\u2190',
			larrb: '\u21E4',
			larrbfs: '\u291F',
			larrfs: '\u291D',
			larrhk: '\u21A9',
			larrlp: '\u21AB',
			larrpl: '\u2939',
			larrsim: '\u2973',
			larrtl: '\u21A2',
			lat: '\u2AAB',
			latail: '\u2919',
			late: '\u2AAD',
			lates: '\u2AAD\uFE00',
			lbarr: '\u290C',
			lbbrk: '\u2772',
			lbrace: '{',
			lbrack: '[',
			lbrke: '\u298B',
			lbrksld: '\u298F',
			lbrkslu: '\u298D',
			lcaron: '\u013E',
			lcedil: '\u013C',
			lceil: '\u2308',
			lcub: '{',
			lcy: '\u043B',
			ldca: '\u2936',
			ldquo: '\u201C',
			ldquor: '\u201E',
			ldrdhar: '\u2967',
			ldrushar: '\u294B',
			ldsh: '\u21B2',
			le: '\u2264',
			leftarrow: '\u2190',
			leftarrowtail: '\u21A2',
			leftharpoondown: '\u21BD',
			leftharpoonup: '\u21BC',
			leftleftarrows: '\u21C7',
			leftrightarrow: '\u2194',
			leftrightarrows: '\u21C6',
			leftrightharpoons: '\u21CB',
			leftrightsquigarrow: '\u21AD',
			leftthreetimes: '\u22CB',
			leg: '\u22DA',
			leq: '\u2264',
			leqq: '\u2266',
			leqslant: '\u2A7D',
			les: '\u2A7D',
			lescc: '\u2AA8',
			lesdot: '\u2A7F',
			lesdoto: '\u2A81',
			lesdotor: '\u2A83',
			lesg: '\u22DA\uFE00',
			lesges: '\u2A93',
			lessapprox: '\u2A85',
			lessdot: '\u22D6',
			lesseqgtr: '\u22DA',
			lesseqqgtr: '\u2A8B',
			lessgtr: '\u2276',
			lesssim: '\u2272',
			lfisht: '\u297C',
			lfloor: '\u230A',
			lfr: '\u{1D529}',
			lg: '\u2276',
			lgE: '\u2A91',
			lhard: '\u21BD',
			lharu: '\u21BC',
			lharul: '\u296A',
			lhblk: '\u2584',
			ljcy: '\u0459',
			ll: '\u226A',
			llarr: '\u21C7',
			llcorner: '\u231E',
			llhard: '\u296B',
			lltri: '\u25FA',
			lmidot: '\u0140',
			lmoust: '\u23B0',
			lmoustache: '\u23B0',
			lnE: '\u2268',
			lnap: '\u2A89',
			lnapprox: '\u2A89',
			lne: '\u2A87',
			lneq: '\u2A87',
			lneqq: '\u2268',
			lnsim: '\u22E6',
			loang: '\u27EC',
			loarr: '\u21FD',
			lobrk: '\u27E6',
			longleftarrow: '\u27F5',
			longleftrightarrow: '\u27F7',
			longmapsto: '\u27FC',
			longrightarrow: '\u27F6',
			looparrowleft: '\u21AB',
			looparrowright: '\u21AC',
			lopar: '\u2985',
			lopf: '\u{1D55D}',
			loplus: '\u2A2D',
			lotimes: '\u2A34',
			lowast: '\u2217',
			lowbar: '_',
			loz: '\u25CA',
			lozenge: '\u25CA',
			lozf: '\u29EB',
			lpar: '(',
			lparlt: '\u2993',
			lrarr: '\u21C6',
			lrcorner: '\u231F',
			lrhar: '\u21CB',
			lrhard: '\u296D',
			lrm: '\u200E',
			lrtri: '\u22BF',
			lsaquo: '\u2039',
			lscr: '\u{1D4C1}',
			lsh: '\u21B0',
			lsim: '\u2272',
			lsime: '\u2A8D',
			lsimg: '\u2A8F',
			lsqb: '[',
			lsquo: '\u2018',
			lsquor: '\u201A',
			lstrok: '\u0142',
			lt: '<',
			ltcc: '\u2AA6',
			ltcir: '\u2A79',
			ltdot: '\u22D6',
			lthree: '\u22CB',
			ltimes: '\u22C9',
			ltlarr: '\u2976',
			ltquest: '\u2A7B',
			ltrPar: '\u2996',
			ltri: '\u25C3',
			ltrie: '\u22B4',
			ltrif: '\u25C2',
			lurdshar: '\u294A',
			luruhar: '\u2966',
			lvertneqq: '\u2268\uFE00',
			lvnE: '\u2268\uFE00',
			mDDot: '\u223A',
			macr: '\xAF',
			male: '\u2642',
			malt: '\u2720',
			maltese: '\u2720',
			map: '\u21A6',
			mapsto: '\u21A6',
			mapstodown: '\u21A7',
			mapstoleft: '\u21A4',
			mapstoup: '\u21A5',
			marker: '\u25AE',
			mcomma: '\u2A29',
			mcy: '\u043C',
			mdash: '\u2014',
			measuredangle: '\u2221',
			mfr: '\u{1D52A}',
			mho: '\u2127',
			micro: '\xB5',
			mid: '\u2223',
			midast: '*',
			midcir: '\u2AF0',
			middot: '\xB7',
			minus: '\u2212',
			minusb: '\u229F',
			minusd: '\u2238',
			minusdu: '\u2A2A',
			mlcp: '\u2ADB',
			mldr: '\u2026',
			mnplus: '\u2213',
			models: '\u22A7',
			mopf: '\u{1D55E}',
			mp: '\u2213',
			mscr: '\u{1D4C2}',
			mstpos: '\u223E',
			mu: '\u03BC',
			multimap: '\u22B8',
			mumap: '\u22B8',
			nGg: '\u22D9\u0338',
			nGt: '\u226B\u20D2',
			nGtv: '\u226B\u0338',
			nLeftarrow: '\u21CD',
			nLeftrightarrow: '\u21CE',
			nLl: '\u22D8\u0338',
			nLt: '\u226A\u20D2',
			nLtv: '\u226A\u0338',
			nRightarrow: '\u21CF',
			nVDash: '\u22AF',
			nVdash: '\u22AE',
			nabla: '\u2207',
			nacute: '\u0144',
			nang: '\u2220\u20D2',
			nap: '\u2249',
			napE: '\u2A70\u0338',
			napid: '\u224B\u0338',
			napos: '\u0149',
			napprox: '\u2249',
			natur: '\u266E',
			natural: '\u266E',
			naturals: '\u2115',
			nbsp: '\xA0',
			nbump: '\u224E\u0338',
			nbumpe: '\u224F\u0338',
			ncap: '\u2A43',
			ncaron: '\u0148',
			ncedil: '\u0146',
			ncong: '\u2247',
			ncongdot: '\u2A6D\u0338',
			ncup: '\u2A42',
			ncy: '\u043D',
			ndash: '\u2013',
			ne: '\u2260',
			neArr: '\u21D7',
			nearhk: '\u2924',
			nearr: '\u2197',
			nearrow: '\u2197',
			nedot: '\u2250\u0338',
			nequiv: '\u2262',
			nesear: '\u2928',
			nesim: '\u2242\u0338',
			nexist: '\u2204',
			nexists: '\u2204',
			nfr: '\u{1D52B}',
			ngE: '\u2267\u0338',
			nge: '\u2271',
			ngeq: '\u2271',
			ngeqq: '\u2267\u0338',
			ngeqslant: '\u2A7E\u0338',
			nges: '\u2A7E\u0338',
			ngsim: '\u2275',
			ngt: '\u226F',
			ngtr: '\u226F',
			nhArr: '\u21CE',
			nharr: '\u21AE',
			nhpar: '\u2AF2',
			ni: '\u220B',
			nis: '\u22FC',
			nisd: '\u22FA',
			niv: '\u220B',
			njcy: '\u045A',
			nlArr: '\u21CD',
			nlE: '\u2266\u0338',
			nlarr: '\u219A',
			nldr: '\u2025',
			nle: '\u2270',
			nleftarrow: '\u219A',
			nleftrightarrow: '\u21AE',
			nleq: '\u2270',
			nleqq: '\u2266\u0338',
			nleqslant: '\u2A7D\u0338',
			nles: '\u2A7D\u0338',
			nless: '\u226E',
			nlsim: '\u2274',
			nlt: '\u226E',
			nltri: '\u22EA',
			nltrie: '\u22EC',
			nmid: '\u2224',
			nopf: '\u{1D55F}',
			not: '\xAC',
			notin: '\u2209',
			notinE: '\u22F9\u0338',
			notindot: '\u22F5\u0338',
			notinva: '\u2209',
			notinvb: '\u22F7',
			notinvc: '\u22F6',
			notni: '\u220C',
			notniva: '\u220C',
			notnivb: '\u22FE',
			notnivc: '\u22FD',
			npar: '\u2226',
			nparallel: '\u2226',
			nparsl: '\u2AFD\u20E5',
			npart: '\u2202\u0338',
			npolint: '\u2A14',
			npr: '\u2280',
			nprcue: '\u22E0',
			npre: '\u2AAF\u0338',
			nprec: '\u2280',
			npreceq: '\u2AAF\u0338',
			nrArr: '\u21CF',
			nrarr: '\u219B',
			nrarrc: '\u2933\u0338',
			nrarrw: '\u219D\u0338',
			nrightarrow: '\u219B',
			nrtri: '\u22EB',
			nrtrie: '\u22ED',
			nsc: '\u2281',
			nsccue: '\u22E1',
			nsce: '\u2AB0\u0338',
			nscr: '\u{1D4C3}',
			nshortmid: '\u2224',
			nshortparallel: '\u2226',
			nsim: '\u2241',
			nsime: '\u2244',
			nsimeq: '\u2244',
			nsmid: '\u2224',
			nspar: '\u2226',
			nsqsube: '\u22E2',
			nsqsupe: '\u22E3',
			nsub: '\u2284',
			nsubE: '\u2AC5\u0338',
			nsube: '\u2288',
			nsubset: '\u2282\u20D2',
			nsubseteq: '\u2288',
			nsubseteqq: '\u2AC5\u0338',
			nsucc: '\u2281',
			nsucceq: '\u2AB0\u0338',
			nsup: '\u2285',
			nsupE: '\u2AC6\u0338',
			nsupe: '\u2289',
			nsupset: '\u2283\u20D2',
			nsupseteq: '\u2289',
			nsupseteqq: '\u2AC6\u0338',
			ntgl: '\u2279',
			ntilde: '\xF1',
			ntlg: '\u2278',
			ntriangleleft: '\u22EA',
			ntrianglelefteq: '\u22EC',
			ntriangleright: '\u22EB',
			ntrianglerighteq: '\u22ED',
			nu: '\u03BD',
			num: '#',
			numero: '\u2116',
			numsp: '\u2007',
			nvDash: '\u22AD',
			nvHarr: '\u2904',
			nvap: '\u224D\u20D2',
			nvdash: '\u22AC',
			nvge: '\u2265\u20D2',
			nvgt: '>\u20D2',
			nvinfin: '\u29DE',
			nvlArr: '\u2902',
			nvle: '\u2264\u20D2',
			nvlt: '<\u20D2',
			nvltrie: '\u22B4\u20D2',
			nvrArr: '\u2903',
			nvrtrie: '\u22B5\u20D2',
			nvsim: '\u223C\u20D2',
			nwArr: '\u21D6',
			nwarhk: '\u2923',
			nwarr: '\u2196',
			nwarrow: '\u2196',
			nwnear: '\u2927',
			oS: '\u24C8',
			oacute: '\xF3',
			oast: '\u229B',
			ocir: '\u229A',
			ocirc: '\xF4',
			ocy: '\u043E',
			odash: '\u229D',
			odblac: '\u0151',
			odiv: '\u2A38',
			odot: '\u2299',
			odsold: '\u29BC',
			oelig: '\u0153',
			ofcir: '\u29BF',
			ofr: '\u{1D52C}',
			ogon: '\u02DB',
			ograve: '\xF2',
			ogt: '\u29C1',
			ohbar: '\u29B5',
			ohm: '\u03A9',
			oint: '\u222E',
			olarr: '\u21BA',
			olcir: '\u29BE',
			olcross: '\u29BB',
			oline: '\u203E',
			olt: '\u29C0',
			omacr: '\u014D',
			omega: '\u03C9',
			omicron: '\u03BF',
			omid: '\u29B6',
			ominus: '\u2296',
			oopf: '\u{1D560}',
			opar: '\u29B7',
			operp: '\u29B9',
			oplus: '\u2295',
			or: '\u2228',
			orarr: '\u21BB',
			ord: '\u2A5D',
			order: '\u2134',
			orderof: '\u2134',
			ordf: '\xAA',
			ordm: '\xBA',
			origof: '\u22B6',
			oror: '\u2A56',
			orslope: '\u2A57',
			orv: '\u2A5B',
			oscr: '\u2134',
			oslash: '\xF8',
			osol: '\u2298',
			otilde: '\xF5',
			otimes: '\u2297',
			otimesas: '\u2A36',
			ouml: '\xF6',
			ovbar: '\u233D',
			par: '\u2225',
			para: '\xB6',
			parallel: '\u2225',
			parsim: '\u2AF3',
			parsl: '\u2AFD',
			part: '\u2202',
			pcy: '\u043F',
			percnt: '%',
			period: '.',
			permil: '\u2030',
			perp: '\u22A5',
			pertenk: '\u2031',
			pfr: '\u{1D52D}',
			phi: '\u03C6',
			phiv: '\u03D5',
			phmmat: '\u2133',
			phone: '\u260E',
			pi: '\u03C0',
			pitchfork: '\u22D4',
			piv: '\u03D6',
			planck: '\u210F',
			planckh: '\u210E',
			plankv: '\u210F',
			plus: '+',
			plusacir: '\u2A23',
			plusb: '\u229E',
			pluscir: '\u2A22',
			plusdo: '\u2214',
			plusdu: '\u2A25',
			pluse: '\u2A72',
			plusmn: '\xB1',
			plussim: '\u2A26',
			plustwo: '\u2A27',
			pm: '\xB1',
			pointint: '\u2A15',
			popf: '\u{1D561}',
			pound: '\xA3',
			pr: '\u227A',
			prE: '\u2AB3',
			prap: '\u2AB7',
			prcue: '\u227C',
			pre: '\u2AAF',
			prec: '\u227A',
			precapprox: '\u2AB7',
			preccurlyeq: '\u227C',
			preceq: '\u2AAF',
			precnapprox: '\u2AB9',
			precneqq: '\u2AB5',
			precnsim: '\u22E8',
			precsim: '\u227E',
			prime: '\u2032',
			primes: '\u2119',
			prnE: '\u2AB5',
			prnap: '\u2AB9',
			prnsim: '\u22E8',
			prod: '\u220F',
			profalar: '\u232E',
			profline: '\u2312',
			profsurf: '\u2313',
			prop: '\u221D',
			propto: '\u221D',
			prsim: '\u227E',
			prurel: '\u22B0',
			pscr: '\u{1D4C5}',
			psi: '\u03C8',
			puncsp: '\u2008',
			qfr: '\u{1D52E}',
			qint: '\u2A0C',
			qopf: '\u{1D562}',
			qprime: '\u2057',
			qscr: '\u{1D4C6}',
			quaternions: '\u210D',
			quatint: '\u2A16',
			quest: '?',
			questeq: '\u225F',
			quot: '"',
			rAarr: '\u21DB',
			rArr: '\u21D2',
			rAtail: '\u291C',
			rBarr: '\u290F',
			rHar: '\u2964',
			race: '\u223D\u0331',
			racute: '\u0155',
			radic: '\u221A',
			raemptyv: '\u29B3',
			rang: '\u27E9',
			rangd: '\u2992',
			range: '\u29A5',
			rangle: '\u27E9',
			raquo: '\xBB',
			rarr: '\u2192',
			rarrap: '\u2975',
			rarrb: '\u21E5',
			rarrbfs: '\u2920',
			rarrc: '\u2933',
			rarrfs: '\u291E',
			rarrhk: '\u21AA',
			rarrlp: '\u21AC',
			rarrpl: '\u2945',
			rarrsim: '\u2974',
			rarrtl: '\u21A3',
			rarrw: '\u219D',
			ratail: '\u291A',
			ratio: '\u2236',
			rationals: '\u211A',
			rbarr: '\u290D',
			rbbrk: '\u2773',
			rbrace: '}',
			rbrack: ']',
			rbrke: '\u298C',
			rbrksld: '\u298E',
			rbrkslu: '\u2990',
			rcaron: '\u0159',
			rcedil: '\u0157',
			rceil: '\u2309',
			rcub: '}',
			rcy: '\u0440',
			rdca: '\u2937',
			rdldhar: '\u2969',
			rdquo: '\u201D',
			rdquor: '\u201D',
			rdsh: '\u21B3',
			real: '\u211C',
			realine: '\u211B',
			realpart: '\u211C',
			reals: '\u211D',
			rect: '\u25AD',
			reg: '\xAE',
			rfisht: '\u297D',
			rfloor: '\u230B',
			rfr: '\u{1D52F}',
			rhard: '\u21C1',
			rharu: '\u21C0',
			rharul: '\u296C',
			rho: '\u03C1',
			rhov: '\u03F1',
			rightarrow: '\u2192',
			rightarrowtail: '\u21A3',
			rightharpoondown: '\u21C1',
			rightharpoonup: '\u21C0',
			rightleftarrows: '\u21C4',
			rightleftharpoons: '\u21CC',
			rightrightarrows: '\u21C9',
			rightsquigarrow: '\u219D',
			rightthreetimes: '\u22CC',
			ring: '\u02DA',
			risingdotseq: '\u2253',
			rlarr: '\u21C4',
			rlhar: '\u21CC',
			rlm: '\u200F',
			rmoust: '\u23B1',
			rmoustache: '\u23B1',
			rnmid: '\u2AEE',
			roang: '\u27ED',
			roarr: '\u21FE',
			robrk: '\u27E7',
			ropar: '\u2986',
			ropf: '\u{1D563}',
			roplus: '\u2A2E',
			rotimes: '\u2A35',
			rpar: ')',
			rpargt: '\u2994',
			rppolint: '\u2A12',
			rrarr: '\u21C9',
			rsaquo: '\u203A',
			rscr: '\u{1D4C7}',
			rsh: '\u21B1',
			rsqb: ']',
			rsquo: '\u2019',
			rsquor: '\u2019',
			rthree: '\u22CC',
			rtimes: '\u22CA',
			rtri: '\u25B9',
			rtrie: '\u22B5',
			rtrif: '\u25B8',
			rtriltri: '\u29CE',
			ruluhar: '\u2968',
			rx: '\u211E',
			sacute: '\u015B',
			sbquo: '\u201A',
			sc: '\u227B',
			scE: '\u2AB4',
			scap: '\u2AB8',
			scaron: '\u0161',
			sccue: '\u227D',
			sce: '\u2AB0',
			scedil: '\u015F',
			scirc: '\u015D',
			scnE: '\u2AB6',
			scnap: '\u2ABA',
			scnsim: '\u22E9',
			scpolint: '\u2A13',
			scsim: '\u227F',
			scy: '\u0441',
			sdot: '\u22C5',
			sdotb: '\u22A1',
			sdote: '\u2A66',
			seArr: '\u21D8',
			searhk: '\u2925',
			searr: '\u2198',
			searrow: '\u2198',
			sect: '\xA7',
			semi: ';',
			seswar: '\u2929',
			setminus: '\u2216',
			setmn: '\u2216',
			sext: '\u2736',
			sfr: '\u{1D530}',
			sfrown: '\u2322',
			sharp: '\u266F',
			shchcy: '\u0449',
			shcy: '\u0448',
			shortmid: '\u2223',
			shortparallel: '\u2225',
			shy: '\xAD',
			sigma: '\u03C3',
			sigmaf: '\u03C2',
			sigmav: '\u03C2',
			sim: '\u223C',
			simdot: '\u2A6A',
			sime: '\u2243',
			simeq: '\u2243',
			simg: '\u2A9E',
			simgE: '\u2AA0',
			siml: '\u2A9D',
			simlE: '\u2A9F',
			simne: '\u2246',
			simplus: '\u2A24',
			simrarr: '\u2972',
			slarr: '\u2190',
			smallsetminus: '\u2216',
			smashp: '\u2A33',
			smeparsl: '\u29E4',
			smid: '\u2223',
			smile: '\u2323',
			smt: '\u2AAA',
			smte: '\u2AAC',
			smtes: '\u2AAC\uFE00',
			softcy: '\u044C',
			sol: '/',
			solb: '\u29C4',
			solbar: '\u233F',
			sopf: '\u{1D564}',
			spades: '\u2660',
			spadesuit: '\u2660',
			spar: '\u2225',
			sqcap: '\u2293',
			sqcaps: '\u2293\uFE00',
			sqcup: '\u2294',
			sqcups: '\u2294\uFE00',
			sqsub: '\u228F',
			sqsube: '\u2291',
			sqsubset: '\u228F',
			sqsubseteq: '\u2291',
			sqsup: '\u2290',
			sqsupe: '\u2292',
			sqsupset: '\u2290',
			sqsupseteq: '\u2292',
			squ: '\u25A1',
			square: '\u25A1',
			squarf: '\u25AA',
			squf: '\u25AA',
			srarr: '\u2192',
			sscr: '\u{1D4C8}',
			ssetmn: '\u2216',
			ssmile: '\u2323',
			sstarf: '\u22C6',
			star: '\u2606',
			starf: '\u2605',
			straightepsilon: '\u03F5',
			straightphi: '\u03D5',
			strns: '\xAF',
			sub: '\u2282',
			subE: '\u2AC5',
			subdot: '\u2ABD',
			sube: '\u2286',
			subedot: '\u2AC3',
			submult: '\u2AC1',
			subnE: '\u2ACB',
			subne: '\u228A',
			subplus: '\u2ABF',
			subrarr: '\u2979',
			subset: '\u2282',
			subseteq: '\u2286',
			subseteqq: '\u2AC5',
			subsetneq: '\u228A',
			subsetneqq: '\u2ACB',
			subsim: '\u2AC7',
			subsub: '\u2AD5',
			subsup: '\u2AD3',
			succ: '\u227B',
			succapprox: '\u2AB8',
			succcurlyeq: '\u227D',
			succeq: '\u2AB0',
			succnapprox: '\u2ABA',
			succneqq: '\u2AB6',
			succnsim: '\u22E9',
			succsim: '\u227F',
			sum: '\u2211',
			sung: '\u266A',
			sup1: '\xB9',
			sup2: '\xB2',
			sup3: '\xB3',
			sup: '\u2283',
			supE: '\u2AC6',
			supdot: '\u2ABE',
			supdsub: '\u2AD8',
			supe: '\u2287',
			supedot: '\u2AC4',
			suphsol: '\u27C9',
			suphsub: '\u2AD7',
			suplarr: '\u297B',
			supmult: '\u2AC2',
			supnE: '\u2ACC',
			supne: '\u228B',
			supplus: '\u2AC0',
			supset: '\u2283',
			supseteq: '\u2287',
			supseteqq: '\u2AC6',
			supsetneq: '\u228B',
			supsetneqq: '\u2ACC',
			supsim: '\u2AC8',
			supsub: '\u2AD4',
			supsup: '\u2AD6',
			swArr: '\u21D9',
			swarhk: '\u2926',
			swarr: '\u2199',
			swarrow: '\u2199',
			swnwar: '\u292A',
			szlig: '\xDF',
			target: '\u2316',
			tau: '\u03C4',
			tbrk: '\u23B4',
			tcaron: '\u0165',
			tcedil: '\u0163',
			tcy: '\u0442',
			tdot: '\u20DB',
			telrec: '\u2315',
			tfr: '\u{1D531}',
			there4: '\u2234',
			therefore: '\u2234',
			theta: '\u03B8',
			thetasym: '\u03D1',
			thetav: '\u03D1',
			thickapprox: '\u2248',
			thicksim: '\u223C',
			thinsp: '\u2009',
			thkap: '\u2248',
			thksim: '\u223C',
			thorn: '\xFE',
			tilde: '\u02DC',
			times: '\xD7',
			timesb: '\u22A0',
			timesbar: '\u2A31',
			timesd: '\u2A30',
			tint: '\u222D',
			toea: '\u2928',
			top: '\u22A4',
			topbot: '\u2336',
			topcir: '\u2AF1',
			topf: '\u{1D565}',
			topfork: '\u2ADA',
			tosa: '\u2929',
			tprime: '\u2034',
			trade: '\u2122',
			triangle: '\u25B5',
			triangledown: '\u25BF',
			triangleleft: '\u25C3',
			trianglelefteq: '\u22B4',
			triangleq: '\u225C',
			triangleright: '\u25B9',
			trianglerighteq: '\u22B5',
			tridot: '\u25EC',
			trie: '\u225C',
			triminus: '\u2A3A',
			triplus: '\u2A39',
			trisb: '\u29CD',
			tritime: '\u2A3B',
			trpezium: '\u23E2',
			tscr: '\u{1D4C9}',
			tscy: '\u0446',
			tshcy: '\u045B',
			tstrok: '\u0167',
			twixt: '\u226C',
			twoheadleftarrow: '\u219E',
			twoheadrightarrow: '\u21A0',
			uArr: '\u21D1',
			uHar: '\u2963',
			uacute: '\xFA',
			uarr: '\u2191',
			ubrcy: '\u045E',
			ubreve: '\u016D',
			ucirc: '\xFB',
			ucy: '\u0443',
			udarr: '\u21C5',
			udblac: '\u0171',
			udhar: '\u296E',
			ufisht: '\u297E',
			ufr: '\u{1D532}',
			ugrave: '\xF9',
			uharl: '\u21BF',
			uharr: '\u21BE',
			uhblk: '\u2580',
			ulcorn: '\u231C',
			ulcorner: '\u231C',
			ulcrop: '\u230F',
			ultri: '\u25F8',
			umacr: '\u016B',
			uml: '\xA8',
			uogon: '\u0173',
			uopf: '\u{1D566}',
			uparrow: '\u2191',
			updownarrow: '\u2195',
			upharpoonleft: '\u21BF',
			upharpoonright: '\u21BE',
			uplus: '\u228E',
			upsi: '\u03C5',
			upsih: '\u03D2',
			upsilon: '\u03C5',
			upuparrows: '\u21C8',
			urcorn: '\u231D',
			urcorner: '\u231D',
			urcrop: '\u230E',
			uring: '\u016F',
			urtri: '\u25F9',
			uscr: '\u{1D4CA}',
			utdot: '\u22F0',
			utilde: '\u0169',
			utri: '\u25B5',
			utrif: '\u25B4',
			uuarr: '\u21C8',
			uuml: '\xFC',
			uwangle: '\u29A7',
			vArr: '\u21D5',
			vBar: '\u2AE8',
			vBarv: '\u2AE9',
			vDash: '\u22A8',
			vangrt: '\u299C',
			varepsilon: '\u03F5',
			varkappa: '\u03F0',
			varnothing: '\u2205',
			varphi: '\u03D5',
			varpi: '\u03D6',
			varpropto: '\u221D',
			varr: '\u2195',
			varrho: '\u03F1',
			varsigma: '\u03C2',
			varsubsetneq: '\u228A\uFE00',
			varsubsetneqq: '\u2ACB\uFE00',
			varsupsetneq: '\u228B\uFE00',
			varsupsetneqq: '\u2ACC\uFE00',
			vartheta: '\u03D1',
			vartriangleleft: '\u22B2',
			vartriangleright: '\u22B3',
			vcy: '\u0432',
			vdash: '\u22A2',
			vee: '\u2228',
			veebar: '\u22BB',
			veeeq: '\u225A',
			vellip: '\u22EE',
			verbar: '|',
			vert: '|',
			vfr: '\u{1D533}',
			vltri: '\u22B2',
			vnsub: '\u2282\u20D2',
			vnsup: '\u2283\u20D2',
			vopf: '\u{1D567}',
			vprop: '\u221D',
			vrtri: '\u22B3',
			vscr: '\u{1D4CB}',
			vsubnE: '\u2ACB\uFE00',
			vsubne: '\u228A\uFE00',
			vsupnE: '\u2ACC\uFE00',
			vsupne: '\u228B\uFE00',
			vzigzag: '\u299A',
			wcirc: '\u0175',
			wedbar: '\u2A5F',
			wedge: '\u2227',
			wedgeq: '\u2259',
			weierp: '\u2118',
			wfr: '\u{1D534}',
			wopf: '\u{1D568}',
			wp: '\u2118',
			wr: '\u2240',
			wreath: '\u2240',
			wscr: '\u{1D4CC}',
			xcap: '\u22C2',
			xcirc: '\u25EF',
			xcup: '\u22C3',
			xdtri: '\u25BD',
			xfr: '\u{1D535}',
			xhArr: '\u27FA',
			xharr: '\u27F7',
			xi: '\u03BE',
			xlArr: '\u27F8',
			xlarr: '\u27F5',
			xmap: '\u27FC',
			xnis: '\u22FB',
			xodot: '\u2A00',
			xopf: '\u{1D569}',
			xoplus: '\u2A01',
			xotime: '\u2A02',
			xrArr: '\u27F9',
			xrarr: '\u27F6',
			xscr: '\u{1D4CD}',
			xsqcup: '\u2A06',
			xuplus: '\u2A04',
			xutri: '\u25B3',
			xvee: '\u22C1',
			xwedge: '\u22C0',
			yacute: '\xFD',
			yacy: '\u044F',
			ycirc: '\u0177',
			ycy: '\u044B',
			yen: '\xA5',
			yfr: '\u{1D536}',
			yicy: '\u0457',
			yopf: '\u{1D56A}',
			yscr: '\u{1D4CE}',
			yucy: '\u044E',
			yuml: '\xFF',
			zacute: '\u017A',
			zcaron: '\u017E',
			zcy: '\u0437',
			zdot: '\u017C',
			zeetrf: '\u2128',
			zeta: '\u03B6',
			zfr: '\u{1D537}',
			zhcy: '\u0436',
			zigrarr: '\u21DD',
			zopf: '\u{1D56B}',
			zscr: '\u{1D4CF}',
			zwj: '\u200D',
			zwnj: '\u200C'
		};
	}
});

// node_modules/decode-named-character-reference/index.js
function decodeNamedCharacterReference(value) {
	return own2.call(characterEntities, value) ? characterEntities[value] : false;
}
var own2;
var init_decode_named_character_reference = __esm({
	'node_modules/decode-named-character-reference/index.js'() {
		init_character_entities();
		own2 = {}.hasOwnProperty;
	}
});

// node_modules/micromark-core-commonmark/lib/character-reference.js
function tokenizeCharacterReference(effects, ok2, nok) {
	const self2 = this;
	let size = 0;
	let max;
	let test;
	return start;
	function start(code3) {
		effects.enter('characterReference');
		effects.enter('characterReferenceMarker');
		effects.consume(code3);
		effects.exit('characterReferenceMarker');
		return open;
	}
	function open(code3) {
		if (code3 === 35) {
			effects.enter('characterReferenceMarkerNumeric');
			effects.consume(code3);
			effects.exit('characterReferenceMarkerNumeric');
			return numeric;
		}
		effects.enter('characterReferenceValue');
		max = 31;
		test = asciiAlphanumeric;
		return value(code3);
	}
	function numeric(code3) {
		if (code3 === 88 || code3 === 120) {
			effects.enter('characterReferenceMarkerHexadecimal');
			effects.consume(code3);
			effects.exit('characterReferenceMarkerHexadecimal');
			effects.enter('characterReferenceValue');
			max = 6;
			test = asciiHexDigit;
			return value;
		}
		effects.enter('characterReferenceValue');
		max = 7;
		test = asciiDigit;
		return value(code3);
	}
	function value(code3) {
		let token;
		if (code3 === 59 && size) {
			token = effects.exit('characterReferenceValue');
			if (
				test === asciiAlphanumeric &&
				!decodeNamedCharacterReference(self2.sliceSerialize(token))
			) {
				return nok(code3);
			}
			effects.enter('characterReferenceMarker');
			effects.consume(code3);
			effects.exit('characterReferenceMarker');
			effects.exit('characterReference');
			return ok2;
		}
		if (test(code3) && size++ < max) {
			effects.consume(code3);
			return value;
		}
		return nok(code3);
	}
}
var characterReference;
var init_character_reference = __esm({
	'node_modules/micromark-core-commonmark/lib/character-reference.js'() {
		init_decode_named_character_reference();
		init_micromark_util_character();
		characterReference = {
			name: 'characterReference',
			tokenize: tokenizeCharacterReference
		};
	}
});

// node_modules/micromark-core-commonmark/lib/code-fenced.js
function tokenizeCodeFenced(effects, ok2, nok) {
	const self2 = this;
	const closingFenceConstruct = {
		tokenize: tokenizeClosingFence,
		partial: true
	};
	const nonLazyLine = {
		tokenize: tokenizeNonLazyLine,
		partial: true
	};
	const tail = this.events[this.events.length - 1];
	const initialPrefix =
		tail && tail[1].type === 'linePrefix' ? tail[2].sliceSerialize(tail[1], true).length : 0;
	let sizeOpen = 0;
	let marker;
	return start;
	function start(code3) {
		effects.enter('codeFenced');
		effects.enter('codeFencedFence');
		effects.enter('codeFencedFenceSequence');
		marker = code3;
		return sequenceOpen(code3);
	}
	function sequenceOpen(code3) {
		if (code3 === marker) {
			effects.consume(code3);
			sizeOpen++;
			return sequenceOpen;
		}
		effects.exit('codeFencedFenceSequence');
		return sizeOpen < 3 ? nok(code3) : factorySpace(effects, infoOpen, 'whitespace')(code3);
	}
	function infoOpen(code3) {
		if (code3 === null || markdownLineEnding(code3)) {
			return openAfter(code3);
		}
		effects.enter('codeFencedFenceInfo');
		effects.enter('chunkString', {
			contentType: 'string'
		});
		return info(code3);
	}
	function info(code3) {
		if (code3 === null || markdownLineEndingOrSpace(code3)) {
			effects.exit('chunkString');
			effects.exit('codeFencedFenceInfo');
			return factorySpace(effects, infoAfter, 'whitespace')(code3);
		}
		if (code3 === 96 && code3 === marker) return nok(code3);
		effects.consume(code3);
		return info;
	}
	function infoAfter(code3) {
		if (code3 === null || markdownLineEnding(code3)) {
			return openAfter(code3);
		}
		effects.enter('codeFencedFenceMeta');
		effects.enter('chunkString', {
			contentType: 'string'
		});
		return meta(code3);
	}
	function meta(code3) {
		if (code3 === null || markdownLineEnding(code3)) {
			effects.exit('chunkString');
			effects.exit('codeFencedFenceMeta');
			return openAfter(code3);
		}
		if (code3 === 96 && code3 === marker) return nok(code3);
		effects.consume(code3);
		return meta;
	}
	function openAfter(code3) {
		effects.exit('codeFencedFence');
		return self2.interrupt ? ok2(code3) : contentStart(code3);
	}
	function contentStart(code3) {
		if (code3 === null) {
			return after(code3);
		}
		if (markdownLineEnding(code3)) {
			return effects.attempt(
				nonLazyLine,
				effects.attempt(
					closingFenceConstruct,
					after,
					initialPrefix
						? factorySpace(effects, contentStart, 'linePrefix', initialPrefix + 1)
						: contentStart
				),
				after
			)(code3);
		}
		effects.enter('codeFlowValue');
		return contentContinue(code3);
	}
	function contentContinue(code3) {
		if (code3 === null || markdownLineEnding(code3)) {
			effects.exit('codeFlowValue');
			return contentStart(code3);
		}
		effects.consume(code3);
		return contentContinue;
	}
	function after(code3) {
		effects.exit('codeFenced');
		return ok2(code3);
	}
	function tokenizeNonLazyLine(effects2, ok3, nok2) {
		const self3 = this;
		return start2;
		function start2(code3) {
			effects2.enter('lineEnding');
			effects2.consume(code3);
			effects2.exit('lineEnding');
			return lineStart;
		}
		function lineStart(code3) {
			return self3.parser.lazy[self3.now().line] ? nok2(code3) : ok3(code3);
		}
	}
	function tokenizeClosingFence(effects2, ok3, nok2) {
		let size = 0;
		return factorySpace(
			effects2,
			closingSequenceStart,
			'linePrefix',
			this.parser.constructs.disable.null.includes('codeIndented') ? void 0 : 4
		);
		function closingSequenceStart(code3) {
			effects2.enter('codeFencedFence');
			effects2.enter('codeFencedFenceSequence');
			return closingSequence(code3);
		}
		function closingSequence(code3) {
			if (code3 === marker) {
				effects2.consume(code3);
				size++;
				return closingSequence;
			}
			if (size < sizeOpen) return nok2(code3);
			effects2.exit('codeFencedFenceSequence');
			return factorySpace(effects2, closingSequenceEnd, 'whitespace')(code3);
		}
		function closingSequenceEnd(code3) {
			if (code3 === null || markdownLineEnding(code3)) {
				effects2.exit('codeFencedFence');
				return ok3(code3);
			}
			return nok2(code3);
		}
	}
}
var codeFenced;
var init_code_fenced = __esm({
	'node_modules/micromark-core-commonmark/lib/code-fenced.js'() {
		init_micromark_factory_space();
		init_micromark_util_character();
		codeFenced = {
			name: 'codeFenced',
			tokenize: tokenizeCodeFenced,
			concrete: true
		};
	}
});

// node_modules/micromark-core-commonmark/lib/code-indented.js
function tokenizeCodeIndented(effects, ok2, nok) {
	const self2 = this;
	return start;
	function start(code3) {
		effects.enter('codeIndented');
		return factorySpace(effects, afterStartPrefix, 'linePrefix', 4 + 1)(code3);
	}
	function afterStartPrefix(code3) {
		const tail = self2.events[self2.events.length - 1];
		return tail &&
			tail[1].type === 'linePrefix' &&
			tail[2].sliceSerialize(tail[1], true).length >= 4
			? afterPrefix(code3)
			: nok(code3);
	}
	function afterPrefix(code3) {
		if (code3 === null) {
			return after(code3);
		}
		if (markdownLineEnding(code3)) {
			return effects.attempt(indentedContent, afterPrefix, after)(code3);
		}
		effects.enter('codeFlowValue');
		return content3(code3);
	}
	function content3(code3) {
		if (code3 === null || markdownLineEnding(code3)) {
			effects.exit('codeFlowValue');
			return afterPrefix(code3);
		}
		effects.consume(code3);
		return content3;
	}
	function after(code3) {
		effects.exit('codeIndented');
		return ok2(code3);
	}
}
function tokenizeIndentedContent(effects, ok2, nok) {
	const self2 = this;
	return start;
	function start(code3) {
		if (self2.parser.lazy[self2.now().line]) {
			return nok(code3);
		}
		if (markdownLineEnding(code3)) {
			effects.enter('lineEnding');
			effects.consume(code3);
			effects.exit('lineEnding');
			return start;
		}
		return factorySpace(effects, afterPrefix, 'linePrefix', 4 + 1)(code3);
	}
	function afterPrefix(code3) {
		const tail = self2.events[self2.events.length - 1];
		return tail &&
			tail[1].type === 'linePrefix' &&
			tail[2].sliceSerialize(tail[1], true).length >= 4
			? ok2(code3)
			: markdownLineEnding(code3)
			? start(code3)
			: nok(code3);
	}
}
var codeIndented, indentedContent;
var init_code_indented = __esm({
	'node_modules/micromark-core-commonmark/lib/code-indented.js'() {
		init_micromark_factory_space();
		init_micromark_util_character();
		codeIndented = {
			name: 'codeIndented',
			tokenize: tokenizeCodeIndented
		};
		indentedContent = {
			tokenize: tokenizeIndentedContent,
			partial: true
		};
	}
});

// node_modules/micromark-core-commonmark/lib/code-text.js
function resolveCodeText(events) {
	let tailExitIndex = events.length - 4;
	let headEnterIndex = 3;
	let index6;
	let enter;
	if (
		(events[headEnterIndex][1].type === 'lineEnding' ||
			events[headEnterIndex][1].type === 'space') &&
		(events[tailExitIndex][1].type === 'lineEnding' || events[tailExitIndex][1].type === 'space')
	) {
		index6 = headEnterIndex;
		while (++index6 < tailExitIndex) {
			if (events[index6][1].type === 'codeTextData') {
				events[headEnterIndex][1].type = 'codeTextPadding';
				events[tailExitIndex][1].type = 'codeTextPadding';
				headEnterIndex += 2;
				tailExitIndex -= 2;
				break;
			}
		}
	}
	index6 = headEnterIndex - 1;
	tailExitIndex++;
	while (++index6 <= tailExitIndex) {
		if (enter === void 0) {
			if (index6 !== tailExitIndex && events[index6][1].type !== 'lineEnding') {
				enter = index6;
			}
		} else if (index6 === tailExitIndex || events[index6][1].type === 'lineEnding') {
			events[enter][1].type = 'codeTextData';
			if (index6 !== enter + 2) {
				events[enter][1].end = events[index6 - 1][1].end;
				events.splice(enter + 2, index6 - enter - 2);
				tailExitIndex -= index6 - enter - 2;
				index6 = enter + 2;
			}
			enter = void 0;
		}
	}
	return events;
}
function previous(code3) {
	return code3 !== 96 || this.events[this.events.length - 1][1].type === 'characterEscape';
}
function tokenizeCodeText(effects, ok2, nok) {
	const self2 = this;
	let sizeOpen = 0;
	let size;
	let token;
	return start;
	function start(code3) {
		effects.enter('codeText');
		effects.enter('codeTextSequence');
		return openingSequence(code3);
	}
	function openingSequence(code3) {
		if (code3 === 96) {
			effects.consume(code3);
			sizeOpen++;
			return openingSequence;
		}
		effects.exit('codeTextSequence');
		return gap(code3);
	}
	function gap(code3) {
		if (code3 === null) {
			return nok(code3);
		}
		if (code3 === 96) {
			token = effects.enter('codeTextSequence');
			size = 0;
			return closingSequence(code3);
		}
		if (code3 === 32) {
			effects.enter('space');
			effects.consume(code3);
			effects.exit('space');
			return gap;
		}
		if (markdownLineEnding(code3)) {
			effects.enter('lineEnding');
			effects.consume(code3);
			effects.exit('lineEnding');
			return gap;
		}
		effects.enter('codeTextData');
		return data2(code3);
	}
	function data2(code3) {
		if (code3 === null || code3 === 32 || code3 === 96 || markdownLineEnding(code3)) {
			effects.exit('codeTextData');
			return gap(code3);
		}
		effects.consume(code3);
		return data2;
	}
	function closingSequence(code3) {
		if (code3 === 96) {
			effects.consume(code3);
			size++;
			return closingSequence;
		}
		if (size === sizeOpen) {
			effects.exit('codeTextSequence');
			effects.exit('codeText');
			return ok2(code3);
		}
		token.type = 'codeTextData';
		return data2(code3);
	}
}
var codeText;
var init_code_text = __esm({
	'node_modules/micromark-core-commonmark/lib/code-text.js'() {
		init_micromark_util_character();
		codeText = {
			name: 'codeText',
			tokenize: tokenizeCodeText,
			resolve: resolveCodeText,
			previous
		};
	}
});

// node_modules/micromark-util-subtokenize/index.js
function subtokenize(events) {
	const jumps = {};
	let index6 = -1;
	let event;
	let lineIndex;
	let otherIndex;
	let otherEvent;
	let parameters;
	let subevents;
	let more;
	while (++index6 < events.length) {
		while (index6 in jumps) {
			index6 = jumps[index6];
		}
		event = events[index6];
		if (
			index6 &&
			event[1].type === 'chunkFlow' &&
			events[index6 - 1][1].type === 'listItemPrefix'
		) {
			subevents = event[1]._tokenizer.events;
			otherIndex = 0;
			if (otherIndex < subevents.length && subevents[otherIndex][1].type === 'lineEndingBlank') {
				otherIndex += 2;
			}
			if (otherIndex < subevents.length && subevents[otherIndex][1].type === 'content') {
				while (++otherIndex < subevents.length) {
					if (subevents[otherIndex][1].type === 'content') {
						break;
					}
					if (subevents[otherIndex][1].type === 'chunkText') {
						subevents[otherIndex][1]._isInFirstContentOfListItem = true;
						otherIndex++;
					}
				}
			}
		}
		if (event[0] === 'enter') {
			if (event[1].contentType) {
				Object.assign(jumps, subcontent(events, index6));
				index6 = jumps[index6];
				more = true;
			}
		} else if (event[1]._container) {
			otherIndex = index6;
			lineIndex = void 0;
			while (otherIndex--) {
				otherEvent = events[otherIndex];
				if (otherEvent[1].type === 'lineEnding' || otherEvent[1].type === 'lineEndingBlank') {
					if (otherEvent[0] === 'enter') {
						if (lineIndex) {
							events[lineIndex][1].type = 'lineEndingBlank';
						}
						otherEvent[1].type = 'lineEnding';
						lineIndex = otherIndex;
					}
				} else {
					break;
				}
			}
			if (lineIndex) {
				event[1].end = Object.assign({}, events[lineIndex][1].start);
				parameters = events.slice(lineIndex, index6);
				parameters.unshift(event);
				splice(events, lineIndex, index6 - lineIndex + 1, parameters);
			}
		}
	}
	return !more;
}
function subcontent(events, eventIndex) {
	const token = events[eventIndex][1];
	const context = events[eventIndex][2];
	let startPosition = eventIndex - 1;
	const startPositions = [];
	const tokenizer = token._tokenizer || context.parser[token.contentType](token.start);
	const childEvents = tokenizer.events;
	const jumps = [];
	const gaps = {};
	let stream2;
	let previous2;
	let index6 = -1;
	let current = token;
	let adjust = 0;
	let start = 0;
	const breaks = [start];
	while (current) {
		while (events[++startPosition][1] !== current) {}
		startPositions.push(startPosition);
		if (!current._tokenizer) {
			stream2 = context.sliceStream(current);
			if (!current.next) {
				stream2.push(null);
			}
			if (previous2) {
				tokenizer.defineSkip(current.start);
			}
			if (current._isInFirstContentOfListItem) {
				tokenizer._gfmTasklistFirstContentOfListItem = true;
			}
			tokenizer.write(stream2);
			if (current._isInFirstContentOfListItem) {
				tokenizer._gfmTasklistFirstContentOfListItem = void 0;
			}
		}
		previous2 = current;
		current = current.next;
	}
	current = token;
	while (++index6 < childEvents.length) {
		if (
			childEvents[index6][0] === 'exit' &&
			childEvents[index6 - 1][0] === 'enter' &&
			childEvents[index6][1].type === childEvents[index6 - 1][1].type &&
			childEvents[index6][1].start.line !== childEvents[index6][1].end.line
		) {
			start = index6 + 1;
			breaks.push(start);
			current._tokenizer = void 0;
			current.previous = void 0;
			current = current.next;
		}
	}
	tokenizer.events = [];
	if (current) {
		current._tokenizer = void 0;
		current.previous = void 0;
	} else {
		breaks.pop();
	}
	index6 = breaks.length;
	while (index6--) {
		const slice = childEvents.slice(breaks[index6], breaks[index6 + 1]);
		const start2 = startPositions.pop();
		jumps.unshift([start2, start2 + slice.length - 1]);
		splice(events, start2, 2, slice);
	}
	index6 = -1;
	while (++index6 < jumps.length) {
		gaps[adjust + jumps[index6][0]] = adjust + jumps[index6][1];
		adjust += jumps[index6][1] - jumps[index6][0] - 1;
	}
	return gaps;
}
var init_micromark_util_subtokenize = __esm({
	'node_modules/micromark-util-subtokenize/index.js'() {
		init_micromark_util_chunked();
	}
});

// node_modules/micromark-core-commonmark/lib/content.js
function resolveContent(events) {
	subtokenize(events);
	return events;
}
function tokenizeContent(effects, ok2) {
	let previous2;
	return start;
	function start(code3) {
		effects.enter('content');
		previous2 = effects.enter('chunkContent', {
			contentType: 'content'
		});
		return data2(code3);
	}
	function data2(code3) {
		if (code3 === null) {
			return contentEnd(code3);
		}
		if (markdownLineEnding(code3)) {
			return effects.check(continuationConstruct, contentContinue, contentEnd)(code3);
		}
		effects.consume(code3);
		return data2;
	}
	function contentEnd(code3) {
		effects.exit('chunkContent');
		effects.exit('content');
		return ok2(code3);
	}
	function contentContinue(code3) {
		effects.consume(code3);
		effects.exit('chunkContent');
		previous2.next = effects.enter('chunkContent', {
			contentType: 'content',
			previous: previous2
		});
		previous2 = previous2.next;
		return data2;
	}
}
function tokenizeContinuation(effects, ok2, nok) {
	const self2 = this;
	return startLookahead;
	function startLookahead(code3) {
		effects.exit('chunkContent');
		effects.enter('lineEnding');
		effects.consume(code3);
		effects.exit('lineEnding');
		return factorySpace(effects, prefixed, 'linePrefix');
	}
	function prefixed(code3) {
		if (code3 === null || markdownLineEnding(code3)) {
			return nok(code3);
		}
		const tail = self2.events[self2.events.length - 1];
		if (
			!self2.parser.constructs.disable.null.includes('codeIndented') &&
			tail &&
			tail[1].type === 'linePrefix' &&
			tail[2].sliceSerialize(tail[1], true).length >= 4
		) {
			return ok2(code3);
		}
		return effects.interrupt(self2.parser.constructs.flow, nok, ok2)(code3);
	}
}
var content2, continuationConstruct;
var init_content2 = __esm({
	'node_modules/micromark-core-commonmark/lib/content.js'() {
		init_micromark_factory_space();
		init_micromark_util_character();
		init_micromark_util_subtokenize();
		content2 = {
			tokenize: tokenizeContent,
			resolve: resolveContent
		};
		continuationConstruct = {
			tokenize: tokenizeContinuation,
			partial: true
		};
	}
});

// node_modules/micromark-factory-destination/index.js
function factoryDestination(
	effects,
	ok2,
	nok,
	type,
	literalType,
	literalMarkerType,
	rawType,
	stringType,
	max
) {
	const limit = max || Number.POSITIVE_INFINITY;
	let balance = 0;
	return start;
	function start(code3) {
		if (code3 === 60) {
			effects.enter(type);
			effects.enter(literalType);
			effects.enter(literalMarkerType);
			effects.consume(code3);
			effects.exit(literalMarkerType);
			return destinationEnclosedBefore;
		}
		if (code3 === null || code3 === 41 || asciiControl(code3)) {
			return nok(code3);
		}
		effects.enter(type);
		effects.enter(rawType);
		effects.enter(stringType);
		effects.enter('chunkString', {
			contentType: 'string'
		});
		return destinationRaw(code3);
	}
	function destinationEnclosedBefore(code3) {
		if (code3 === 62) {
			effects.enter(literalMarkerType);
			effects.consume(code3);
			effects.exit(literalMarkerType);
			effects.exit(literalType);
			effects.exit(type);
			return ok2;
		}
		effects.enter(stringType);
		effects.enter('chunkString', {
			contentType: 'string'
		});
		return destinationEnclosed(code3);
	}
	function destinationEnclosed(code3) {
		if (code3 === 62) {
			effects.exit('chunkString');
			effects.exit(stringType);
			return destinationEnclosedBefore(code3);
		}
		if (code3 === null || code3 === 60 || markdownLineEnding(code3)) {
			return nok(code3);
		}
		effects.consume(code3);
		return code3 === 92 ? destinationEnclosedEscape : destinationEnclosed;
	}
	function destinationEnclosedEscape(code3) {
		if (code3 === 60 || code3 === 62 || code3 === 92) {
			effects.consume(code3);
			return destinationEnclosed;
		}
		return destinationEnclosed(code3);
	}
	function destinationRaw(code3) {
		if (code3 === 40) {
			if (++balance > limit) return nok(code3);
			effects.consume(code3);
			return destinationRaw;
		}
		if (code3 === 41) {
			if (!balance--) {
				effects.exit('chunkString');
				effects.exit(stringType);
				effects.exit(rawType);
				effects.exit(type);
				return ok2(code3);
			}
			effects.consume(code3);
			return destinationRaw;
		}
		if (code3 === null || markdownLineEndingOrSpace(code3)) {
			if (balance) return nok(code3);
			effects.exit('chunkString');
			effects.exit(stringType);
			effects.exit(rawType);
			effects.exit(type);
			return ok2(code3);
		}
		if (asciiControl(code3)) return nok(code3);
		effects.consume(code3);
		return code3 === 92 ? destinationRawEscape : destinationRaw;
	}
	function destinationRawEscape(code3) {
		if (code3 === 40 || code3 === 41 || code3 === 92) {
			effects.consume(code3);
			return destinationRaw;
		}
		return destinationRaw(code3);
	}
}
var init_micromark_factory_destination = __esm({
	'node_modules/micromark-factory-destination/index.js'() {
		init_micromark_util_character();
	}
});

// node_modules/micromark-factory-label/index.js
function factoryLabel(effects, ok2, nok, type, markerType, stringType) {
	const self2 = this;
	let size = 0;
	let data2;
	return start;
	function start(code3) {
		effects.enter(type);
		effects.enter(markerType);
		effects.consume(code3);
		effects.exit(markerType);
		effects.enter(stringType);
		return atBreak;
	}
	function atBreak(code3) {
		if (
			code3 === null ||
			code3 === 91 ||
			(code3 === 93 && !data2) ||
			(code3 === 94 && !size && '_hiddenFootnoteSupport' in self2.parser.constructs) ||
			size > 999
		) {
			return nok(code3);
		}
		if (code3 === 93) {
			effects.exit(stringType);
			effects.enter(markerType);
			effects.consume(code3);
			effects.exit(markerType);
			effects.exit(type);
			return ok2;
		}
		if (markdownLineEnding(code3)) {
			effects.enter('lineEnding');
			effects.consume(code3);
			effects.exit('lineEnding');
			return atBreak;
		}
		effects.enter('chunkString', {
			contentType: 'string'
		});
		return label(code3);
	}
	function label(code3) {
		if (
			code3 === null ||
			code3 === 91 ||
			code3 === 93 ||
			markdownLineEnding(code3) ||
			size++ > 999
		) {
			effects.exit('chunkString');
			return atBreak(code3);
		}
		effects.consume(code3);
		data2 = data2 || !markdownSpace(code3);
		return code3 === 92 ? labelEscape : label;
	}
	function labelEscape(code3) {
		if (code3 === 91 || code3 === 92 || code3 === 93) {
			effects.consume(code3);
			size++;
			return label;
		}
		return label(code3);
	}
}
var init_micromark_factory_label = __esm({
	'node_modules/micromark-factory-label/index.js'() {
		init_micromark_util_character();
	}
});

// node_modules/micromark-factory-title/index.js
function factoryTitle(effects, ok2, nok, type, markerType, stringType) {
	let marker;
	return start;
	function start(code3) {
		effects.enter(type);
		effects.enter(markerType);
		effects.consume(code3);
		effects.exit(markerType);
		marker = code3 === 40 ? 41 : code3;
		return atFirstTitleBreak;
	}
	function atFirstTitleBreak(code3) {
		if (code3 === marker) {
			effects.enter(markerType);
			effects.consume(code3);
			effects.exit(markerType);
			effects.exit(type);
			return ok2;
		}
		effects.enter(stringType);
		return atTitleBreak(code3);
	}
	function atTitleBreak(code3) {
		if (code3 === marker) {
			effects.exit(stringType);
			return atFirstTitleBreak(marker);
		}
		if (code3 === null) {
			return nok(code3);
		}
		if (markdownLineEnding(code3)) {
			effects.enter('lineEnding');
			effects.consume(code3);
			effects.exit('lineEnding');
			return factorySpace(effects, atTitleBreak, 'linePrefix');
		}
		effects.enter('chunkString', {
			contentType: 'string'
		});
		return title(code3);
	}
	function title(code3) {
		if (code3 === marker || code3 === null || markdownLineEnding(code3)) {
			effects.exit('chunkString');
			return atTitleBreak(code3);
		}
		effects.consume(code3);
		return code3 === 92 ? titleEscape : title;
	}
	function titleEscape(code3) {
		if (code3 === marker || code3 === 92) {
			effects.consume(code3);
			return title;
		}
		return title(code3);
	}
}
var init_micromark_factory_title = __esm({
	'node_modules/micromark-factory-title/index.js'() {
		init_micromark_factory_space();
		init_micromark_util_character();
	}
});

// node_modules/micromark-factory-whitespace/index.js
function factoryWhitespace(effects, ok2) {
	let seen;
	return start;
	function start(code3) {
		if (markdownLineEnding(code3)) {
			effects.enter('lineEnding');
			effects.consume(code3);
			effects.exit('lineEnding');
			seen = true;
			return start;
		}
		if (markdownSpace(code3)) {
			return factorySpace(effects, start, seen ? 'linePrefix' : 'lineSuffix')(code3);
		}
		return ok2(code3);
	}
}
var init_micromark_factory_whitespace = __esm({
	'node_modules/micromark-factory-whitespace/index.js'() {
		init_micromark_factory_space();
		init_micromark_util_character();
	}
});

// node_modules/micromark-util-normalize-identifier/index.js
function normalizeIdentifier(value) {
	return value
		.replace(/[\t\n\r ]+/g, ' ')
		.replace(/^ | $/g, '')
		.toLowerCase()
		.toUpperCase();
}
var init_micromark_util_normalize_identifier = __esm({
	'node_modules/micromark-util-normalize-identifier/index.js'() {}
});

// node_modules/micromark-core-commonmark/lib/definition.js
function tokenizeDefinition(effects, ok2, nok) {
	const self2 = this;
	let identifier;
	return start;
	function start(code3) {
		effects.enter('definition');
		return factoryLabel.call(
			self2,
			effects,
			labelAfter,
			nok,
			'definitionLabel',
			'definitionLabelMarker',
			'definitionLabelString'
		)(code3);
	}
	function labelAfter(code3) {
		identifier = normalizeIdentifier(
			self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
		);
		if (code3 === 58) {
			effects.enter('definitionMarker');
			effects.consume(code3);
			effects.exit('definitionMarker');
			return factoryWhitespace(
				effects,
				factoryDestination(
					effects,
					effects.attempt(
						titleConstruct,
						factorySpace(effects, after, 'whitespace'),
						factorySpace(effects, after, 'whitespace')
					),
					nok,
					'definitionDestination',
					'definitionDestinationLiteral',
					'definitionDestinationLiteralMarker',
					'definitionDestinationRaw',
					'definitionDestinationString'
				)
			);
		}
		return nok(code3);
	}
	function after(code3) {
		if (code3 === null || markdownLineEnding(code3)) {
			effects.exit('definition');
			if (!self2.parser.defined.includes(identifier)) {
				self2.parser.defined.push(identifier);
			}
			return ok2(code3);
		}
		return nok(code3);
	}
}
function tokenizeTitle(effects, ok2, nok) {
	return start;
	function start(code3) {
		return markdownLineEndingOrSpace(code3)
			? factoryWhitespace(effects, before)(code3)
			: nok(code3);
	}
	function before(code3) {
		if (code3 === 34 || code3 === 39 || code3 === 40) {
			return factoryTitle(
				effects,
				factorySpace(effects, after, 'whitespace'),
				nok,
				'definitionTitle',
				'definitionTitleMarker',
				'definitionTitleString'
			)(code3);
		}
		return nok(code3);
	}
	function after(code3) {
		return code3 === null || markdownLineEnding(code3) ? ok2(code3) : nok(code3);
	}
}
var definition, titleConstruct;
var init_definition = __esm({
	'node_modules/micromark-core-commonmark/lib/definition.js'() {
		init_micromark_factory_destination();
		init_micromark_factory_label();
		init_micromark_factory_space();
		init_micromark_factory_title();
		init_micromark_factory_whitespace();
		init_micromark_util_normalize_identifier();
		init_micromark_util_character();
		definition = {
			name: 'definition',
			tokenize: tokenizeDefinition
		};
		titleConstruct = {
			tokenize: tokenizeTitle,
			partial: true
		};
	}
});

// node_modules/micromark-core-commonmark/lib/hard-break-escape.js
function tokenizeHardBreakEscape(effects, ok2, nok) {
	return start;
	function start(code3) {
		effects.enter('hardBreakEscape');
		effects.enter('escapeMarker');
		effects.consume(code3);
		return open;
	}
	function open(code3) {
		if (markdownLineEnding(code3)) {
			effects.exit('escapeMarker');
			effects.exit('hardBreakEscape');
			return ok2(code3);
		}
		return nok(code3);
	}
}
var hardBreakEscape;
var init_hard_break_escape = __esm({
	'node_modules/micromark-core-commonmark/lib/hard-break-escape.js'() {
		init_micromark_util_character();
		hardBreakEscape = {
			name: 'hardBreakEscape',
			tokenize: tokenizeHardBreakEscape
		};
	}
});

// node_modules/micromark-core-commonmark/lib/heading-atx.js
function resolveHeadingAtx(events, context) {
	let contentEnd = events.length - 2;
	let contentStart = 3;
	let content3;
	let text7;
	if (events[contentStart][1].type === 'whitespace') {
		contentStart += 2;
	}
	if (contentEnd - 2 > contentStart && events[contentEnd][1].type === 'whitespace') {
		contentEnd -= 2;
	}
	if (
		events[contentEnd][1].type === 'atxHeadingSequence' &&
		(contentStart === contentEnd - 1 ||
			(contentEnd - 4 > contentStart && events[contentEnd - 2][1].type === 'whitespace'))
	) {
		contentEnd -= contentStart + 1 === contentEnd ? 2 : 4;
	}
	if (contentEnd > contentStart) {
		content3 = {
			type: 'atxHeadingText',
			start: events[contentStart][1].start,
			end: events[contentEnd][1].end
		};
		text7 = {
			type: 'chunkText',
			start: events[contentStart][1].start,
			end: events[contentEnd][1].end,
			contentType: 'text'
		};
		splice(events, contentStart, contentEnd - contentStart + 1, [
			['enter', content3, context],
			['enter', text7, context],
			['exit', text7, context],
			['exit', content3, context]
		]);
	}
	return events;
}
function tokenizeHeadingAtx(effects, ok2, nok) {
	const self2 = this;
	let size = 0;
	return start;
	function start(code3) {
		effects.enter('atxHeading');
		effects.enter('atxHeadingSequence');
		return fenceOpenInside(code3);
	}
	function fenceOpenInside(code3) {
		if (code3 === 35 && size++ < 6) {
			effects.consume(code3);
			return fenceOpenInside;
		}
		if (code3 === null || markdownLineEndingOrSpace(code3)) {
			effects.exit('atxHeadingSequence');
			return self2.interrupt ? ok2(code3) : headingBreak(code3);
		}
		return nok(code3);
	}
	function headingBreak(code3) {
		if (code3 === 35) {
			effects.enter('atxHeadingSequence');
			return sequence(code3);
		}
		if (code3 === null || markdownLineEnding(code3)) {
			effects.exit('atxHeading');
			return ok2(code3);
		}
		if (markdownSpace(code3)) {
			return factorySpace(effects, headingBreak, 'whitespace')(code3);
		}
		effects.enter('atxHeadingText');
		return data2(code3);
	}
	function sequence(code3) {
		if (code3 === 35) {
			effects.consume(code3);
			return sequence;
		}
		effects.exit('atxHeadingSequence');
		return headingBreak(code3);
	}
	function data2(code3) {
		if (code3 === null || code3 === 35 || markdownLineEndingOrSpace(code3)) {
			effects.exit('atxHeadingText');
			return headingBreak(code3);
		}
		effects.consume(code3);
		return data2;
	}
}
var headingAtx;
var init_heading_atx = __esm({
	'node_modules/micromark-core-commonmark/lib/heading-atx.js'() {
		init_micromark_factory_space();
		init_micromark_util_character();
		init_micromark_util_chunked();
		headingAtx = {
			name: 'headingAtx',
			tokenize: tokenizeHeadingAtx,
			resolve: resolveHeadingAtx
		};
	}
});

// node_modules/micromark-util-html-tag-name/index.js
var htmlBlockNames, htmlRawNames;
var init_micromark_util_html_tag_name = __esm({
	'node_modules/micromark-util-html-tag-name/index.js'() {
		htmlBlockNames = [
			'address',
			'article',
			'aside',
			'base',
			'basefont',
			'blockquote',
			'body',
			'caption',
			'center',
			'col',
			'colgroup',
			'dd',
			'details',
			'dialog',
			'dir',
			'div',
			'dl',
			'dt',
			'fieldset',
			'figcaption',
			'figure',
			'footer',
			'form',
			'frame',
			'frameset',
			'h1',
			'h2',
			'h3',
			'h4',
			'h5',
			'h6',
			'head',
			'header',
			'hr',
			'html',
			'iframe',
			'legend',
			'li',
			'link',
			'main',
			'menu',
			'menuitem',
			'nav',
			'noframes',
			'ol',
			'optgroup',
			'option',
			'p',
			'param',
			'section',
			'summary',
			'table',
			'tbody',
			'td',
			'tfoot',
			'th',
			'thead',
			'title',
			'tr',
			'track',
			'ul'
		];
		htmlRawNames = ['pre', 'script', 'style', 'textarea'];
	}
});

// node_modules/micromark-core-commonmark/lib/html-flow.js
function resolveToHtmlFlow(events) {
	let index6 = events.length;
	while (index6--) {
		if (events[index6][0] === 'enter' && events[index6][1].type === 'htmlFlow') {
			break;
		}
	}
	if (index6 > 1 && events[index6 - 2][1].type === 'linePrefix') {
		events[index6][1].start = events[index6 - 2][1].start;
		events[index6 + 1][1].start = events[index6 - 2][1].start;
		events.splice(index6 - 2, 2);
	}
	return events;
}
function tokenizeHtmlFlow(effects, ok2, nok) {
	const self2 = this;
	let kind;
	let startTag;
	let buffer2;
	let index6;
	let marker;
	return start;
	function start(code3) {
		effects.enter('htmlFlow');
		effects.enter('htmlFlowData');
		effects.consume(code3);
		return open;
	}
	function open(code3) {
		if (code3 === 33) {
			effects.consume(code3);
			return declarationStart;
		}
		if (code3 === 47) {
			effects.consume(code3);
			return tagCloseStart;
		}
		if (code3 === 63) {
			effects.consume(code3);
			kind = 3;
			return self2.interrupt ? ok2 : continuationDeclarationInside;
		}
		if (asciiAlpha(code3)) {
			effects.consume(code3);
			buffer2 = String.fromCharCode(code3);
			startTag = true;
			return tagName;
		}
		return nok(code3);
	}
	function declarationStart(code3) {
		if (code3 === 45) {
			effects.consume(code3);
			kind = 2;
			return commentOpenInside;
		}
		if (code3 === 91) {
			effects.consume(code3);
			kind = 5;
			buffer2 = 'CDATA[';
			index6 = 0;
			return cdataOpenInside;
		}
		if (asciiAlpha(code3)) {
			effects.consume(code3);
			kind = 4;
			return self2.interrupt ? ok2 : continuationDeclarationInside;
		}
		return nok(code3);
	}
	function commentOpenInside(code3) {
		if (code3 === 45) {
			effects.consume(code3);
			return self2.interrupt ? ok2 : continuationDeclarationInside;
		}
		return nok(code3);
	}
	function cdataOpenInside(code3) {
		if (code3 === buffer2.charCodeAt(index6++)) {
			effects.consume(code3);
			return index6 === buffer2.length ? (self2.interrupt ? ok2 : continuation) : cdataOpenInside;
		}
		return nok(code3);
	}
	function tagCloseStart(code3) {
		if (asciiAlpha(code3)) {
			effects.consume(code3);
			buffer2 = String.fromCharCode(code3);
			return tagName;
		}
		return nok(code3);
	}
	function tagName(code3) {
		if (code3 === null || code3 === 47 || code3 === 62 || markdownLineEndingOrSpace(code3)) {
			if (code3 !== 47 && startTag && htmlRawNames.includes(buffer2.toLowerCase())) {
				kind = 1;
				return self2.interrupt ? ok2(code3) : continuation(code3);
			}
			if (htmlBlockNames.includes(buffer2.toLowerCase())) {
				kind = 6;
				if (code3 === 47) {
					effects.consume(code3);
					return basicSelfClosing;
				}
				return self2.interrupt ? ok2(code3) : continuation(code3);
			}
			kind = 7;
			return self2.interrupt && !self2.parser.lazy[self2.now().line]
				? nok(code3)
				: startTag
				? completeAttributeNameBefore(code3)
				: completeClosingTagAfter(code3);
		}
		if (code3 === 45 || asciiAlphanumeric(code3)) {
			effects.consume(code3);
			buffer2 += String.fromCharCode(code3);
			return tagName;
		}
		return nok(code3);
	}
	function basicSelfClosing(code3) {
		if (code3 === 62) {
			effects.consume(code3);
			return self2.interrupt ? ok2 : continuation;
		}
		return nok(code3);
	}
	function completeClosingTagAfter(code3) {
		if (markdownSpace(code3)) {
			effects.consume(code3);
			return completeClosingTagAfter;
		}
		return completeEnd(code3);
	}
	function completeAttributeNameBefore(code3) {
		if (code3 === 47) {
			effects.consume(code3);
			return completeEnd;
		}
		if (code3 === 58 || code3 === 95 || asciiAlpha(code3)) {
			effects.consume(code3);
			return completeAttributeName;
		}
		if (markdownSpace(code3)) {
			effects.consume(code3);
			return completeAttributeNameBefore;
		}
		return completeEnd(code3);
	}
	function completeAttributeName(code3) {
		if (code3 === 45 || code3 === 46 || code3 === 58 || code3 === 95 || asciiAlphanumeric(code3)) {
			effects.consume(code3);
			return completeAttributeName;
		}
		return completeAttributeNameAfter(code3);
	}
	function completeAttributeNameAfter(code3) {
		if (code3 === 61) {
			effects.consume(code3);
			return completeAttributeValueBefore;
		}
		if (markdownSpace(code3)) {
			effects.consume(code3);
			return completeAttributeNameAfter;
		}
		return completeAttributeNameBefore(code3);
	}
	function completeAttributeValueBefore(code3) {
		if (code3 === null || code3 === 60 || code3 === 61 || code3 === 62 || code3 === 96) {
			return nok(code3);
		}
		if (code3 === 34 || code3 === 39) {
			effects.consume(code3);
			marker = code3;
			return completeAttributeValueQuoted;
		}
		if (markdownSpace(code3)) {
			effects.consume(code3);
			return completeAttributeValueBefore;
		}
		marker = null;
		return completeAttributeValueUnquoted(code3);
	}
	function completeAttributeValueQuoted(code3) {
		if (code3 === null || markdownLineEnding(code3)) {
			return nok(code3);
		}
		if (code3 === marker) {
			effects.consume(code3);
			return completeAttributeValueQuotedAfter;
		}
		effects.consume(code3);
		return completeAttributeValueQuoted;
	}
	function completeAttributeValueUnquoted(code3) {
		if (
			code3 === null ||
			code3 === 34 ||
			code3 === 39 ||
			code3 === 60 ||
			code3 === 61 ||
			code3 === 62 ||
			code3 === 96 ||
			markdownLineEndingOrSpace(code3)
		) {
			return completeAttributeNameAfter(code3);
		}
		effects.consume(code3);
		return completeAttributeValueUnquoted;
	}
	function completeAttributeValueQuotedAfter(code3) {
		if (code3 === 47 || code3 === 62 || markdownSpace(code3)) {
			return completeAttributeNameBefore(code3);
		}
		return nok(code3);
	}
	function completeEnd(code3) {
		if (code3 === 62) {
			effects.consume(code3);
			return completeAfter;
		}
		return nok(code3);
	}
	function completeAfter(code3) {
		if (markdownSpace(code3)) {
			effects.consume(code3);
			return completeAfter;
		}
		return code3 === null || markdownLineEnding(code3) ? continuation(code3) : nok(code3);
	}
	function continuation(code3) {
		if (code3 === 45 && kind === 2) {
			effects.consume(code3);
			return continuationCommentInside;
		}
		if (code3 === 60 && kind === 1) {
			effects.consume(code3);
			return continuationRawTagOpen;
		}
		if (code3 === 62 && kind === 4) {
			effects.consume(code3);
			return continuationClose;
		}
		if (code3 === 63 && kind === 3) {
			effects.consume(code3);
			return continuationDeclarationInside;
		}
		if (code3 === 93 && kind === 5) {
			effects.consume(code3);
			return continuationCharacterDataInside;
		}
		if (markdownLineEnding(code3) && (kind === 6 || kind === 7)) {
			return effects.check(nextBlankConstruct, continuationClose, continuationAtLineEnding)(code3);
		}
		if (code3 === null || markdownLineEnding(code3)) {
			return continuationAtLineEnding(code3);
		}
		effects.consume(code3);
		return continuation;
	}
	function continuationAtLineEnding(code3) {
		effects.exit('htmlFlowData');
		return htmlContinueStart(code3);
	}
	function htmlContinueStart(code3) {
		if (code3 === null) {
			return done(code3);
		}
		if (markdownLineEnding(code3)) {
			return effects.attempt(
				{
					tokenize: htmlLineEnd,
					partial: true
				},
				htmlContinueStart,
				done
			)(code3);
		}
		effects.enter('htmlFlowData');
		return continuation(code3);
	}
	function htmlLineEnd(effects2, ok3, nok2) {
		return start2;
		function start2(code3) {
			effects2.enter('lineEnding');
			effects2.consume(code3);
			effects2.exit('lineEnding');
			return lineStart;
		}
		function lineStart(code3) {
			return self2.parser.lazy[self2.now().line] ? nok2(code3) : ok3(code3);
		}
	}
	function continuationCommentInside(code3) {
		if (code3 === 45) {
			effects.consume(code3);
			return continuationDeclarationInside;
		}
		return continuation(code3);
	}
	function continuationRawTagOpen(code3) {
		if (code3 === 47) {
			effects.consume(code3);
			buffer2 = '';
			return continuationRawEndTag;
		}
		return continuation(code3);
	}
	function continuationRawEndTag(code3) {
		if (code3 === 62 && htmlRawNames.includes(buffer2.toLowerCase())) {
			effects.consume(code3);
			return continuationClose;
		}
		if (asciiAlpha(code3) && buffer2.length < 8) {
			effects.consume(code3);
			buffer2 += String.fromCharCode(code3);
			return continuationRawEndTag;
		}
		return continuation(code3);
	}
	function continuationCharacterDataInside(code3) {
		if (code3 === 93) {
			effects.consume(code3);
			return continuationDeclarationInside;
		}
		return continuation(code3);
	}
	function continuationDeclarationInside(code3) {
		if (code3 === 62) {
			effects.consume(code3);
			return continuationClose;
		}
		if (code3 === 45 && kind === 2) {
			effects.consume(code3);
			return continuationDeclarationInside;
		}
		return continuation(code3);
	}
	function continuationClose(code3) {
		if (code3 === null || markdownLineEnding(code3)) {
			effects.exit('htmlFlowData');
			return done(code3);
		}
		effects.consume(code3);
		return continuationClose;
	}
	function done(code3) {
		effects.exit('htmlFlow');
		return ok2(code3);
	}
}
function tokenizeNextBlank(effects, ok2, nok) {
	return start;
	function start(code3) {
		effects.exit('htmlFlowData');
		effects.enter('lineEndingBlank');
		effects.consume(code3);
		effects.exit('lineEndingBlank');
		return effects.attempt(blankLine, ok2, nok);
	}
}
var htmlFlow, nextBlankConstruct;
var init_html_flow = __esm({
	'node_modules/micromark-core-commonmark/lib/html-flow.js'() {
		init_micromark_util_character();
		init_micromark_util_html_tag_name();
		init_blank_line();
		htmlFlow = {
			name: 'htmlFlow',
			tokenize: tokenizeHtmlFlow,
			resolveTo: resolveToHtmlFlow,
			concrete: true
		};
		nextBlankConstruct = {
			tokenize: tokenizeNextBlank,
			partial: true
		};
	}
});

// node_modules/micromark-core-commonmark/lib/html-text.js
function tokenizeHtmlText(effects, ok2, nok) {
	const self2 = this;
	let marker;
	let buffer2;
	let index6;
	let returnState;
	return start;
	function start(code3) {
		effects.enter('htmlText');
		effects.enter('htmlTextData');
		effects.consume(code3);
		return open;
	}
	function open(code3) {
		if (code3 === 33) {
			effects.consume(code3);
			return declarationOpen;
		}
		if (code3 === 47) {
			effects.consume(code3);
			return tagCloseStart;
		}
		if (code3 === 63) {
			effects.consume(code3);
			return instruction;
		}
		if (asciiAlpha(code3)) {
			effects.consume(code3);
			return tagOpen;
		}
		return nok(code3);
	}
	function declarationOpen(code3) {
		if (code3 === 45) {
			effects.consume(code3);
			return commentOpen;
		}
		if (code3 === 91) {
			effects.consume(code3);
			buffer2 = 'CDATA[';
			index6 = 0;
			return cdataOpen;
		}
		if (asciiAlpha(code3)) {
			effects.consume(code3);
			return declaration;
		}
		return nok(code3);
	}
	function commentOpen(code3) {
		if (code3 === 45) {
			effects.consume(code3);
			return commentStart;
		}
		return nok(code3);
	}
	function commentStart(code3) {
		if (code3 === null || code3 === 62) {
			return nok(code3);
		}
		if (code3 === 45) {
			effects.consume(code3);
			return commentStartDash;
		}
		return comment4(code3);
	}
	function commentStartDash(code3) {
		if (code3 === null || code3 === 62) {
			return nok(code3);
		}
		return comment4(code3);
	}
	function comment4(code3) {
		if (code3 === null) {
			return nok(code3);
		}
		if (code3 === 45) {
			effects.consume(code3);
			return commentClose;
		}
		if (markdownLineEnding(code3)) {
			returnState = comment4;
			return atLineEnding(code3);
		}
		effects.consume(code3);
		return comment4;
	}
	function commentClose(code3) {
		if (code3 === 45) {
			effects.consume(code3);
			return end;
		}
		return comment4(code3);
	}
	function cdataOpen(code3) {
		if (code3 === buffer2.charCodeAt(index6++)) {
			effects.consume(code3);
			return index6 === buffer2.length ? cdata : cdataOpen;
		}
		return nok(code3);
	}
	function cdata(code3) {
		if (code3 === null) {
			return nok(code3);
		}
		if (code3 === 93) {
			effects.consume(code3);
			return cdataClose;
		}
		if (markdownLineEnding(code3)) {
			returnState = cdata;
			return atLineEnding(code3);
		}
		effects.consume(code3);
		return cdata;
	}
	function cdataClose(code3) {
		if (code3 === 93) {
			effects.consume(code3);
			return cdataEnd;
		}
		return cdata(code3);
	}
	function cdataEnd(code3) {
		if (code3 === 62) {
			return end(code3);
		}
		if (code3 === 93) {
			effects.consume(code3);
			return cdataEnd;
		}
		return cdata(code3);
	}
	function declaration(code3) {
		if (code3 === null || code3 === 62) {
			return end(code3);
		}
		if (markdownLineEnding(code3)) {
			returnState = declaration;
			return atLineEnding(code3);
		}
		effects.consume(code3);
		return declaration;
	}
	function instruction(code3) {
		if (code3 === null) {
			return nok(code3);
		}
		if (code3 === 63) {
			effects.consume(code3);
			return instructionClose;
		}
		if (markdownLineEnding(code3)) {
			returnState = instruction;
			return atLineEnding(code3);
		}
		effects.consume(code3);
		return instruction;
	}
	function instructionClose(code3) {
		return code3 === 62 ? end(code3) : instruction(code3);
	}
	function tagCloseStart(code3) {
		if (asciiAlpha(code3)) {
			effects.consume(code3);
			return tagClose;
		}
		return nok(code3);
	}
	function tagClose(code3) {
		if (code3 === 45 || asciiAlphanumeric(code3)) {
			effects.consume(code3);
			return tagClose;
		}
		return tagCloseBetween(code3);
	}
	function tagCloseBetween(code3) {
		if (markdownLineEnding(code3)) {
			returnState = tagCloseBetween;
			return atLineEnding(code3);
		}
		if (markdownSpace(code3)) {
			effects.consume(code3);
			return tagCloseBetween;
		}
		return end(code3);
	}
	function tagOpen(code3) {
		if (code3 === 45 || asciiAlphanumeric(code3)) {
			effects.consume(code3);
			return tagOpen;
		}
		if (code3 === 47 || code3 === 62 || markdownLineEndingOrSpace(code3)) {
			return tagOpenBetween(code3);
		}
		return nok(code3);
	}
	function tagOpenBetween(code3) {
		if (code3 === 47) {
			effects.consume(code3);
			return end;
		}
		if (code3 === 58 || code3 === 95 || asciiAlpha(code3)) {
			effects.consume(code3);
			return tagOpenAttributeName;
		}
		if (markdownLineEnding(code3)) {
			returnState = tagOpenBetween;
			return atLineEnding(code3);
		}
		if (markdownSpace(code3)) {
			effects.consume(code3);
			return tagOpenBetween;
		}
		return end(code3);
	}
	function tagOpenAttributeName(code3) {
		if (code3 === 45 || code3 === 46 || code3 === 58 || code3 === 95 || asciiAlphanumeric(code3)) {
			effects.consume(code3);
			return tagOpenAttributeName;
		}
		return tagOpenAttributeNameAfter(code3);
	}
	function tagOpenAttributeNameAfter(code3) {
		if (code3 === 61) {
			effects.consume(code3);
			return tagOpenAttributeValueBefore;
		}
		if (markdownLineEnding(code3)) {
			returnState = tagOpenAttributeNameAfter;
			return atLineEnding(code3);
		}
		if (markdownSpace(code3)) {
			effects.consume(code3);
			return tagOpenAttributeNameAfter;
		}
		return tagOpenBetween(code3);
	}
	function tagOpenAttributeValueBefore(code3) {
		if (code3 === null || code3 === 60 || code3 === 61 || code3 === 62 || code3 === 96) {
			return nok(code3);
		}
		if (code3 === 34 || code3 === 39) {
			effects.consume(code3);
			marker = code3;
			return tagOpenAttributeValueQuoted;
		}
		if (markdownLineEnding(code3)) {
			returnState = tagOpenAttributeValueBefore;
			return atLineEnding(code3);
		}
		if (markdownSpace(code3)) {
			effects.consume(code3);
			return tagOpenAttributeValueBefore;
		}
		effects.consume(code3);
		marker = void 0;
		return tagOpenAttributeValueUnquoted;
	}
	function tagOpenAttributeValueQuoted(code3) {
		if (code3 === marker) {
			effects.consume(code3);
			return tagOpenAttributeValueQuotedAfter;
		}
		if (code3 === null) {
			return nok(code3);
		}
		if (markdownLineEnding(code3)) {
			returnState = tagOpenAttributeValueQuoted;
			return atLineEnding(code3);
		}
		effects.consume(code3);
		return tagOpenAttributeValueQuoted;
	}
	function tagOpenAttributeValueQuotedAfter(code3) {
		if (code3 === 62 || code3 === 47 || markdownLineEndingOrSpace(code3)) {
			return tagOpenBetween(code3);
		}
		return nok(code3);
	}
	function tagOpenAttributeValueUnquoted(code3) {
		if (
			code3 === null ||
			code3 === 34 ||
			code3 === 39 ||
			code3 === 60 ||
			code3 === 61 ||
			code3 === 96
		) {
			return nok(code3);
		}
		if (code3 === 62 || markdownLineEndingOrSpace(code3)) {
			return tagOpenBetween(code3);
		}
		effects.consume(code3);
		return tagOpenAttributeValueUnquoted;
	}
	function atLineEnding(code3) {
		effects.exit('htmlTextData');
		effects.enter('lineEnding');
		effects.consume(code3);
		effects.exit('lineEnding');
		return factorySpace(
			effects,
			afterPrefix,
			'linePrefix',
			self2.parser.constructs.disable.null.includes('codeIndented') ? void 0 : 4
		);
	}
	function afterPrefix(code3) {
		effects.enter('htmlTextData');
		return returnState(code3);
	}
	function end(code3) {
		if (code3 === 62) {
			effects.consume(code3);
			effects.exit('htmlTextData');
			effects.exit('htmlText');
			return ok2;
		}
		return nok(code3);
	}
}
var htmlText;
var init_html_text = __esm({
	'node_modules/micromark-core-commonmark/lib/html-text.js'() {
		init_micromark_factory_space();
		init_micromark_util_character();
		htmlText = {
			name: 'htmlText',
			tokenize: tokenizeHtmlText
		};
	}
});

// node_modules/micromark-core-commonmark/lib/label-end.js
function resolveAllLabelEnd(events) {
	let index6 = -1;
	let token;
	while (++index6 < events.length) {
		token = events[index6][1];
		if (token.type === 'labelImage' || token.type === 'labelLink' || token.type === 'labelEnd') {
			events.splice(index6 + 1, token.type === 'labelImage' ? 4 : 2);
			token.type = 'data';
			index6++;
		}
	}
	return events;
}
function resolveToLabelEnd(events, context) {
	let index6 = events.length;
	let offset = 0;
	let token;
	let open;
	let close;
	let media;
	while (index6--) {
		token = events[index6][1];
		if (open) {
			if (token.type === 'link' || (token.type === 'labelLink' && token._inactive)) {
				break;
			}
			if (events[index6][0] === 'enter' && token.type === 'labelLink') {
				token._inactive = true;
			}
		} else if (close) {
			if (
				events[index6][0] === 'enter' &&
				(token.type === 'labelImage' || token.type === 'labelLink') &&
				!token._balanced
			) {
				open = index6;
				if (token.type !== 'labelLink') {
					offset = 2;
					break;
				}
			}
		} else if (token.type === 'labelEnd') {
			close = index6;
		}
	}
	const group = {
		type: events[open][1].type === 'labelLink' ? 'link' : 'image',
		start: Object.assign({}, events[open][1].start),
		end: Object.assign({}, events[events.length - 1][1].end)
	};
	const label = {
		type: 'label',
		start: Object.assign({}, events[open][1].start),
		end: Object.assign({}, events[close][1].end)
	};
	const text7 = {
		type: 'labelText',
		start: Object.assign({}, events[open + offset + 2][1].end),
		end: Object.assign({}, events[close - 2][1].start)
	};
	media = [
		['enter', group, context],
		['enter', label, context]
	];
	media = push(media, events.slice(open + 1, open + offset + 3));
	media = push(media, [['enter', text7, context]]);
	media = push(
		media,
		resolveAll(
			context.parser.constructs.insideSpan.null,
			events.slice(open + offset + 4, close - 3),
			context
		)
	);
	media = push(media, [
		['exit', text7, context],
		events[close - 2],
		events[close - 1],
		['exit', label, context]
	]);
	media = push(media, events.slice(close + 1));
	media = push(media, [['exit', group, context]]);
	splice(events, open, events.length, media);
	return events;
}
function tokenizeLabelEnd(effects, ok2, nok) {
	const self2 = this;
	let index6 = self2.events.length;
	let labelStart;
	let defined;
	while (index6--) {
		if (
			(self2.events[index6][1].type === 'labelImage' ||
				self2.events[index6][1].type === 'labelLink') &&
			!self2.events[index6][1]._balanced
		) {
			labelStart = self2.events[index6][1];
			break;
		}
	}
	return start;
	function start(code3) {
		if (!labelStart) {
			return nok(code3);
		}
		if (labelStart._inactive) return balanced(code3);
		defined = self2.parser.defined.includes(
			normalizeIdentifier(
				self2.sliceSerialize({
					start: labelStart.end,
					end: self2.now()
				})
			)
		);
		effects.enter('labelEnd');
		effects.enter('labelMarker');
		effects.consume(code3);
		effects.exit('labelMarker');
		effects.exit('labelEnd');
		return afterLabelEnd;
	}
	function afterLabelEnd(code3) {
		if (code3 === 40) {
			return effects.attempt(resourceConstruct, ok2, defined ? ok2 : balanced)(code3);
		}
		if (code3 === 91) {
			return effects.attempt(
				fullReferenceConstruct,
				ok2,
				defined ? effects.attempt(collapsedReferenceConstruct, ok2, balanced) : balanced
			)(code3);
		}
		return defined ? ok2(code3) : balanced(code3);
	}
	function balanced(code3) {
		labelStart._balanced = true;
		return nok(code3);
	}
}
function tokenizeResource(effects, ok2, nok) {
	return start;
	function start(code3) {
		effects.enter('resource');
		effects.enter('resourceMarker');
		effects.consume(code3);
		effects.exit('resourceMarker');
		return factoryWhitespace(effects, open);
	}
	function open(code3) {
		if (code3 === 41) {
			return end(code3);
		}
		return factoryDestination(
			effects,
			destinationAfter,
			nok,
			'resourceDestination',
			'resourceDestinationLiteral',
			'resourceDestinationLiteralMarker',
			'resourceDestinationRaw',
			'resourceDestinationString',
			32
		)(code3);
	}
	function destinationAfter(code3) {
		return markdownLineEndingOrSpace(code3)
			? factoryWhitespace(effects, between)(code3)
			: end(code3);
	}
	function between(code3) {
		if (code3 === 34 || code3 === 39 || code3 === 40) {
			return factoryTitle(
				effects,
				factoryWhitespace(effects, end),
				nok,
				'resourceTitle',
				'resourceTitleMarker',
				'resourceTitleString'
			)(code3);
		}
		return end(code3);
	}
	function end(code3) {
		if (code3 === 41) {
			effects.enter('resourceMarker');
			effects.consume(code3);
			effects.exit('resourceMarker');
			effects.exit('resource');
			return ok2;
		}
		return nok(code3);
	}
}
function tokenizeFullReference(effects, ok2, nok) {
	const self2 = this;
	return start;
	function start(code3) {
		return factoryLabel.call(
			self2,
			effects,
			afterLabel,
			nok,
			'reference',
			'referenceMarker',
			'referenceString'
		)(code3);
	}
	function afterLabel(code3) {
		return self2.parser.defined.includes(
			normalizeIdentifier(
				self2.sliceSerialize(self2.events[self2.events.length - 1][1]).slice(1, -1)
			)
		)
			? ok2(code3)
			: nok(code3);
	}
}
function tokenizeCollapsedReference(effects, ok2, nok) {
	return start;
	function start(code3) {
		effects.enter('reference');
		effects.enter('referenceMarker');
		effects.consume(code3);
		effects.exit('referenceMarker');
		return open;
	}
	function open(code3) {
		if (code3 === 93) {
			effects.enter('referenceMarker');
			effects.consume(code3);
			effects.exit('referenceMarker');
			effects.exit('reference');
			return ok2;
		}
		return nok(code3);
	}
}
var labelEnd, resourceConstruct, fullReferenceConstruct, collapsedReferenceConstruct;
var init_label_end = __esm({
	'node_modules/micromark-core-commonmark/lib/label-end.js'() {
		init_micromark_factory_destination();
		init_micromark_factory_label();
		init_micromark_factory_title();
		init_micromark_factory_whitespace();
		init_micromark_util_character();
		init_micromark_util_chunked();
		init_micromark_util_normalize_identifier();
		init_micromark_util_resolve_all();
		labelEnd = {
			name: 'labelEnd',
			tokenize: tokenizeLabelEnd,
			resolveTo: resolveToLabelEnd,
			resolveAll: resolveAllLabelEnd
		};
		resourceConstruct = {
			tokenize: tokenizeResource
		};
		fullReferenceConstruct = {
			tokenize: tokenizeFullReference
		};
		collapsedReferenceConstruct = {
			tokenize: tokenizeCollapsedReference
		};
	}
});

// node_modules/micromark-core-commonmark/lib/label-start-image.js
function tokenizeLabelStartImage(effects, ok2, nok) {
	const self2 = this;
	return start;
	function start(code3) {
		effects.enter('labelImage');
		effects.enter('labelImageMarker');
		effects.consume(code3);
		effects.exit('labelImageMarker');
		return open;
	}
	function open(code3) {
		if (code3 === 91) {
			effects.enter('labelMarker');
			effects.consume(code3);
			effects.exit('labelMarker');
			effects.exit('labelImage');
			return after;
		}
		return nok(code3);
	}
	function after(code3) {
		return code3 === 94 && '_hiddenFootnoteSupport' in self2.parser.constructs
			? nok(code3)
			: ok2(code3);
	}
}
var labelStartImage;
var init_label_start_image = __esm({
	'node_modules/micromark-core-commonmark/lib/label-start-image.js'() {
		init_label_end();
		labelStartImage = {
			name: 'labelStartImage',
			tokenize: tokenizeLabelStartImage,
			resolveAll: labelEnd.resolveAll
		};
	}
});

// node_modules/micromark-core-commonmark/lib/label-start-link.js
function tokenizeLabelStartLink(effects, ok2, nok) {
	const self2 = this;
	return start;
	function start(code3) {
		effects.enter('labelLink');
		effects.enter('labelMarker');
		effects.consume(code3);
		effects.exit('labelMarker');
		effects.exit('labelLink');
		return after;
	}
	function after(code3) {
		return code3 === 94 && '_hiddenFootnoteSupport' in self2.parser.constructs
			? nok(code3)
			: ok2(code3);
	}
}
var labelStartLink;
var init_label_start_link = __esm({
	'node_modules/micromark-core-commonmark/lib/label-start-link.js'() {
		init_label_end();
		labelStartLink = {
			name: 'labelStartLink',
			tokenize: tokenizeLabelStartLink,
			resolveAll: labelEnd.resolveAll
		};
	}
});

// node_modules/micromark-core-commonmark/lib/line-ending.js
function tokenizeLineEnding(effects, ok2) {
	return start;
	function start(code3) {
		effects.enter('lineEnding');
		effects.consume(code3);
		effects.exit('lineEnding');
		return factorySpace(effects, ok2, 'linePrefix');
	}
}
var lineEnding;
var init_line_ending = __esm({
	'node_modules/micromark-core-commonmark/lib/line-ending.js'() {
		init_micromark_factory_space();
		lineEnding = {
			name: 'lineEnding',
			tokenize: tokenizeLineEnding
		};
	}
});

// node_modules/micromark-core-commonmark/lib/thematic-break.js
function tokenizeThematicBreak(effects, ok2, nok) {
	let size = 0;
	let marker;
	return start;
	function start(code3) {
		effects.enter('thematicBreak');
		marker = code3;
		return atBreak(code3);
	}
	function atBreak(code3) {
		if (code3 === marker) {
			effects.enter('thematicBreakSequence');
			return sequence(code3);
		}
		if (markdownSpace(code3)) {
			return factorySpace(effects, atBreak, 'whitespace')(code3);
		}
		if (size < 3 || (code3 !== null && !markdownLineEnding(code3))) {
			return nok(code3);
		}
		effects.exit('thematicBreak');
		return ok2(code3);
	}
	function sequence(code3) {
		if (code3 === marker) {
			effects.consume(code3);
			size++;
			return sequence;
		}
		effects.exit('thematicBreakSequence');
		return atBreak(code3);
	}
}
var thematicBreak;
var init_thematic_break = __esm({
	'node_modules/micromark-core-commonmark/lib/thematic-break.js'() {
		init_micromark_factory_space();
		init_micromark_util_character();
		thematicBreak = {
			name: 'thematicBreak',
			tokenize: tokenizeThematicBreak
		};
	}
});

// node_modules/micromark-core-commonmark/lib/list.js
function tokenizeListStart(effects, ok2, nok) {
	const self2 = this;
	const tail = self2.events[self2.events.length - 1];
	let initialSize =
		tail && tail[1].type === 'linePrefix' ? tail[2].sliceSerialize(tail[1], true).length : 0;
	let size = 0;
	return start;
	function start(code3) {
		const kind =
			self2.containerState.type ||
			(code3 === 42 || code3 === 43 || code3 === 45 ? 'listUnordered' : 'listOrdered');
		if (
			kind === 'listUnordered'
				? !self2.containerState.marker || code3 === self2.containerState.marker
				: asciiDigit(code3)
		) {
			if (!self2.containerState.type) {
				self2.containerState.type = kind;
				effects.enter(kind, {
					_container: true
				});
			}
			if (kind === 'listUnordered') {
				effects.enter('listItemPrefix');
				return code3 === 42 || code3 === 45
					? effects.check(thematicBreak, nok, atMarker)(code3)
					: atMarker(code3);
			}
			if (!self2.interrupt || code3 === 49) {
				effects.enter('listItemPrefix');
				effects.enter('listItemValue');
				return inside(code3);
			}
		}
		return nok(code3);
	}
	function inside(code3) {
		if (asciiDigit(code3) && ++size < 10) {
			effects.consume(code3);
			return inside;
		}
		if (
			(!self2.interrupt || size < 2) &&
			(self2.containerState.marker
				? code3 === self2.containerState.marker
				: code3 === 41 || code3 === 46)
		) {
			effects.exit('listItemValue');
			return atMarker(code3);
		}
		return nok(code3);
	}
	function atMarker(code3) {
		effects.enter('listItemMarker');
		effects.consume(code3);
		effects.exit('listItemMarker');
		self2.containerState.marker = self2.containerState.marker || code3;
		return effects.check(
			blankLine,
			self2.interrupt ? nok : onBlank,
			effects.attempt(listItemPrefixWhitespaceConstruct, endOfPrefix, otherPrefix)
		);
	}
	function onBlank(code3) {
		self2.containerState.initialBlankLine = true;
		initialSize++;
		return endOfPrefix(code3);
	}
	function otherPrefix(code3) {
		if (markdownSpace(code3)) {
			effects.enter('listItemPrefixWhitespace');
			effects.consume(code3);
			effects.exit('listItemPrefixWhitespace');
			return endOfPrefix;
		}
		return nok(code3);
	}
	function endOfPrefix(code3) {
		self2.containerState.size =
			initialSize + self2.sliceSerialize(effects.exit('listItemPrefix'), true).length;
		return ok2(code3);
	}
}
function tokenizeListContinuation(effects, ok2, nok) {
	const self2 = this;
	self2.containerState._closeFlow = void 0;
	return effects.check(blankLine, onBlank, notBlank);
	function onBlank(code3) {
		self2.containerState.furtherBlankLines =
			self2.containerState.furtherBlankLines || self2.containerState.initialBlankLine;
		return factorySpace(effects, ok2, 'listItemIndent', self2.containerState.size + 1)(code3);
	}
	function notBlank(code3) {
		if (self2.containerState.furtherBlankLines || !markdownSpace(code3)) {
			self2.containerState.furtherBlankLines = void 0;
			self2.containerState.initialBlankLine = void 0;
			return notInCurrentItem(code3);
		}
		self2.containerState.furtherBlankLines = void 0;
		self2.containerState.initialBlankLine = void 0;
		return effects.attempt(indentConstruct, ok2, notInCurrentItem)(code3);
	}
	function notInCurrentItem(code3) {
		self2.containerState._closeFlow = true;
		self2.interrupt = void 0;
		return factorySpace(
			effects,
			effects.attempt(list, ok2, nok),
			'linePrefix',
			self2.parser.constructs.disable.null.includes('codeIndented') ? void 0 : 4
		)(code3);
	}
}
function tokenizeIndent(effects, ok2, nok) {
	const self2 = this;
	return factorySpace(effects, afterPrefix, 'listItemIndent', self2.containerState.size + 1);
	function afterPrefix(code3) {
		const tail = self2.events[self2.events.length - 1];
		return tail &&
			tail[1].type === 'listItemIndent' &&
			tail[2].sliceSerialize(tail[1], true).length === self2.containerState.size
			? ok2(code3)
			: nok(code3);
	}
}
function tokenizeListEnd(effects) {
	effects.exit(this.containerState.type);
}
function tokenizeListItemPrefixWhitespace(effects, ok2, nok) {
	const self2 = this;
	return factorySpace(
		effects,
		afterPrefix,
		'listItemPrefixWhitespace',
		self2.parser.constructs.disable.null.includes('codeIndented') ? void 0 : 4 + 1
	);
	function afterPrefix(code3) {
		const tail = self2.events[self2.events.length - 1];
		return !markdownSpace(code3) && tail && tail[1].type === 'listItemPrefixWhitespace'
			? ok2(code3)
			: nok(code3);
	}
}
var list, listItemPrefixWhitespaceConstruct, indentConstruct;
var init_list = __esm({
	'node_modules/micromark-core-commonmark/lib/list.js'() {
		init_micromark_factory_space();
		init_micromark_util_character();
		init_blank_line();
		init_thematic_break();
		list = {
			name: 'list',
			tokenize: tokenizeListStart,
			continuation: {
				tokenize: tokenizeListContinuation
			},
			exit: tokenizeListEnd
		};
		listItemPrefixWhitespaceConstruct = {
			tokenize: tokenizeListItemPrefixWhitespace,
			partial: true
		};
		indentConstruct = {
			tokenize: tokenizeIndent,
			partial: true
		};
	}
});

// node_modules/micromark-core-commonmark/lib/setext-underline.js
function resolveToSetextUnderline(events, context) {
	let index6 = events.length;
	let content3;
	let text7;
	let definition3;
	while (index6--) {
		if (events[index6][0] === 'enter') {
			if (events[index6][1].type === 'content') {
				content3 = index6;
				break;
			}
			if (events[index6][1].type === 'paragraph') {
				text7 = index6;
			}
		} else {
			if (events[index6][1].type === 'content') {
				events.splice(index6, 1);
			}
			if (!definition3 && events[index6][1].type === 'definition') {
				definition3 = index6;
			}
		}
	}
	const heading3 = {
		type: 'setextHeading',
		start: Object.assign({}, events[text7][1].start),
		end: Object.assign({}, events[events.length - 1][1].end)
	};
	events[text7][1].type = 'setextHeadingText';
	if (definition3) {
		events.splice(text7, 0, ['enter', heading3, context]);
		events.splice(definition3 + 1, 0, ['exit', events[content3][1], context]);
		events[content3][1].end = Object.assign({}, events[definition3][1].end);
	} else {
		events[content3][1] = heading3;
	}
	events.push(['exit', heading3, context]);
	return events;
}
function tokenizeSetextUnderline(effects, ok2, nok) {
	const self2 = this;
	let index6 = self2.events.length;
	let marker;
	let paragraph3;
	while (index6--) {
		if (
			self2.events[index6][1].type !== 'lineEnding' &&
			self2.events[index6][1].type !== 'linePrefix' &&
			self2.events[index6][1].type !== 'content'
		) {
			paragraph3 = self2.events[index6][1].type === 'paragraph';
			break;
		}
	}
	return start;
	function start(code3) {
		if (!self2.parser.lazy[self2.now().line] && (self2.interrupt || paragraph3)) {
			effects.enter('setextHeadingLine');
			effects.enter('setextHeadingLineSequence');
			marker = code3;
			return closingSequence(code3);
		}
		return nok(code3);
	}
	function closingSequence(code3) {
		if (code3 === marker) {
			effects.consume(code3);
			return closingSequence;
		}
		effects.exit('setextHeadingLineSequence');
		return factorySpace(effects, closingSequenceEnd, 'lineSuffix')(code3);
	}
	function closingSequenceEnd(code3) {
		if (code3 === null || markdownLineEnding(code3)) {
			effects.exit('setextHeadingLine');
			return ok2(code3);
		}
		return nok(code3);
	}
}
var setextUnderline;
var init_setext_underline = __esm({
	'node_modules/micromark-core-commonmark/lib/setext-underline.js'() {
		init_micromark_factory_space();
		init_micromark_util_character();
		setextUnderline = {
			name: 'setextUnderline',
			tokenize: tokenizeSetextUnderline,
			resolveTo: resolveToSetextUnderline
		};
	}
});

// node_modules/micromark-core-commonmark/index.js
var init_micromark_core_commonmark = __esm({
	'node_modules/micromark-core-commonmark/index.js'() {
		init_attention();
		init_autolink();
		init_blank_line();
		init_block_quote();
		init_character_escape();
		init_character_reference();
		init_code_fenced();
		init_code_indented();
		init_code_text();
		init_content2();
		init_definition();
		init_hard_break_escape();
		init_heading_atx();
		init_html_flow();
		init_html_text();
		init_label_end();
		init_label_start_image();
		init_label_start_link();
		init_line_ending();
		init_list();
		init_setext_underline();
		init_thematic_break();
	}
});

// node_modules/micromark/lib/initialize/flow.js
function initializeFlow(effects) {
	const self2 = this;
	const initial = effects.attempt(
		blankLine,
		atBlankEnding,
		effects.attempt(
			this.parser.constructs.flowInitial,
			afterConstruct,
			factorySpace(
				effects,
				effects.attempt(
					this.parser.constructs.flow,
					afterConstruct,
					effects.attempt(content2, afterConstruct)
				),
				'linePrefix'
			)
		)
	);
	return initial;
	function atBlankEnding(code3) {
		if (code3 === null) {
			effects.consume(code3);
			return;
		}
		effects.enter('lineEndingBlank');
		effects.consume(code3);
		effects.exit('lineEndingBlank');
		self2.currentConstruct = void 0;
		return initial;
	}
	function afterConstruct(code3) {
		if (code3 === null) {
			effects.consume(code3);
			return;
		}
		effects.enter('lineEnding');
		effects.consume(code3);
		effects.exit('lineEnding');
		self2.currentConstruct = void 0;
		return initial;
	}
}
var flow;
var init_flow = __esm({
	'node_modules/micromark/lib/initialize/flow.js'() {
		init_micromark_core_commonmark();
		init_micromark_factory_space();
		flow = {
			tokenize: initializeFlow
		};
	}
});

// node_modules/micromark/lib/initialize/text.js
function initializeFactory(field) {
	return {
		tokenize: initializeText,
		resolveAll: createResolver(field === 'text' ? resolveAllLineSuffixes : void 0)
	};
	function initializeText(effects) {
		const self2 = this;
		const constructs2 = this.parser.constructs[field];
		const text7 = effects.attempt(constructs2, start, notText);
		return start;
		function start(code3) {
			return atBreak(code3) ? text7(code3) : notText(code3);
		}
		function notText(code3) {
			if (code3 === null) {
				effects.consume(code3);
				return;
			}
			effects.enter('data');
			effects.consume(code3);
			return data2;
		}
		function data2(code3) {
			if (atBreak(code3)) {
				effects.exit('data');
				return text7(code3);
			}
			effects.consume(code3);
			return data2;
		}
		function atBreak(code3) {
			if (code3 === null) {
				return true;
			}
			const list4 = constructs2[code3];
			let index6 = -1;
			if (list4) {
				while (++index6 < list4.length) {
					const item = list4[index6];
					if (!item.previous || item.previous.call(self2, self2.previous)) {
						return true;
					}
				}
			}
			return false;
		}
	}
}
function createResolver(extraResolver) {
	return resolveAllText;
	function resolveAllText(events, context) {
		let index6 = -1;
		let enter;
		while (++index6 <= events.length) {
			if (enter === void 0) {
				if (events[index6] && events[index6][1].type === 'data') {
					enter = index6;
					index6++;
				}
			} else if (!events[index6] || events[index6][1].type !== 'data') {
				if (index6 !== enter + 2) {
					events[enter][1].end = events[index6 - 1][1].end;
					events.splice(enter + 2, index6 - enter - 2);
					index6 = enter + 2;
				}
				enter = void 0;
			}
		}
		return extraResolver ? extraResolver(events, context) : events;
	}
}
function resolveAllLineSuffixes(events, context) {
	let eventIndex = 0;
	while (++eventIndex <= events.length) {
		if (
			(eventIndex === events.length || events[eventIndex][1].type === 'lineEnding') &&
			events[eventIndex - 1][1].type === 'data'
		) {
			const data2 = events[eventIndex - 1][1];
			const chunks = context.sliceStream(data2);
			let index6 = chunks.length;
			let bufferIndex = -1;
			let size = 0;
			let tabs;
			while (index6--) {
				const chunk = chunks[index6];
				if (typeof chunk === 'string') {
					bufferIndex = chunk.length;
					while (chunk.charCodeAt(bufferIndex - 1) === 32) {
						size++;
						bufferIndex--;
					}
					if (bufferIndex) break;
					bufferIndex = -1;
				} else if (chunk === -2) {
					tabs = true;
					size++;
				} else if (chunk === -1) {
				} else {
					index6++;
					break;
				}
			}
			if (size) {
				const token = {
					type:
						eventIndex === events.length || tabs || size < 2 ? 'lineSuffix' : 'hardBreakTrailing',
					start: {
						line: data2.end.line,
						column: data2.end.column - size,
						offset: data2.end.offset - size,
						_index: data2.start._index + index6,
						_bufferIndex: index6 ? bufferIndex : data2.start._bufferIndex + bufferIndex
					},
					end: Object.assign({}, data2.end)
				};
				data2.end = Object.assign({}, token.start);
				if (data2.start.offset === data2.end.offset) {
					Object.assign(data2, token);
				} else {
					events.splice(eventIndex, 0, ['enter', token, context], ['exit', token, context]);
					eventIndex += 2;
				}
			}
			eventIndex++;
		}
	}
	return events;
}
var resolver, string, text;
var init_text = __esm({
	'node_modules/micromark/lib/initialize/text.js'() {
		resolver = {
			resolveAll: createResolver()
		};
		string = initializeFactory('string');
		text = initializeFactory('text');
	}
});

// node_modules/micromark/lib/create-tokenizer.js
function createTokenizer(parser, initialize, from) {
	let point4 = Object.assign(
		from
			? Object.assign({}, from)
			: {
					line: 1,
					column: 1,
					offset: 0
			  },
		{
			_index: 0,
			_bufferIndex: -1
		}
	);
	const columnStart = {};
	const resolveAllConstructs = [];
	let chunks = [];
	let stack = [];
	let consumed = true;
	const effects = {
		consume: consume2,
		enter,
		exit: exit2,
		attempt: constructFactory(onsuccessfulconstruct),
		check: constructFactory(onsuccessfulcheck),
		interrupt: constructFactory(onsuccessfulcheck, {
			interrupt: true
		})
	};
	const context = {
		previous: null,
		code: null,
		containerState: {},
		events: [],
		parser,
		sliceStream,
		sliceSerialize,
		now,
		defineSkip,
		write: write2
	};
	let state = initialize.tokenize.call(context, effects);
	let expectedCode;
	if (initialize.resolveAll) {
		resolveAllConstructs.push(initialize);
	}
	return context;
	function write2(slice) {
		chunks = push(chunks, slice);
		main();
		if (chunks[chunks.length - 1] !== null) {
			return [];
		}
		addResult(initialize, 0);
		context.events = resolveAll(resolveAllConstructs, context.events, context);
		return context.events;
	}
	function sliceSerialize(token, expandTabs) {
		return serializeChunks(sliceStream(token), expandTabs);
	}
	function sliceStream(token) {
		return sliceChunks(chunks, token);
	}
	function now() {
		return Object.assign({}, point4);
	}
	function defineSkip(value) {
		columnStart[value.line] = value.column;
		accountForPotentialSkip();
	}
	function main() {
		let chunkIndex;
		while (point4._index < chunks.length) {
			const chunk = chunks[point4._index];
			if (typeof chunk === 'string') {
				chunkIndex = point4._index;
				if (point4._bufferIndex < 0) {
					point4._bufferIndex = 0;
				}
				while (point4._index === chunkIndex && point4._bufferIndex < chunk.length) {
					go(chunk.charCodeAt(point4._bufferIndex));
				}
			} else {
				go(chunk);
			}
		}
	}
	function go(code3) {
		consumed = void 0;
		expectedCode = code3;
		state = state(code3);
	}
	function consume2(code3) {
		if (markdownLineEnding(code3)) {
			point4.line++;
			point4.column = 1;
			point4.offset += code3 === -3 ? 2 : 1;
			accountForPotentialSkip();
		} else if (code3 !== -1) {
			point4.column++;
			point4.offset++;
		}
		if (point4._bufferIndex < 0) {
			point4._index++;
		} else {
			point4._bufferIndex++;
			if (point4._bufferIndex === chunks[point4._index].length) {
				point4._bufferIndex = -1;
				point4._index++;
			}
		}
		context.previous = code3;
		consumed = true;
	}
	function enter(type, fields) {
		const token = fields || {};
		token.type = type;
		token.start = now();
		context.events.push(['enter', token, context]);
		stack.push(token);
		return token;
	}
	function exit2(type) {
		const token = stack.pop();
		token.end = now();
		context.events.push(['exit', token, context]);
		return token;
	}
	function onsuccessfulconstruct(construct, info) {
		addResult(construct, info.from);
	}
	function onsuccessfulcheck(_, info) {
		info.restore();
	}
	function constructFactory(onreturn, fields) {
		return hook;
		function hook(constructs2, returnState, bogusState) {
			let listOfConstructs;
			let constructIndex;
			let currentConstruct;
			let info;
			return Array.isArray(constructs2)
				? handleListOfConstructs(constructs2)
				: 'tokenize' in constructs2
				? handleListOfConstructs([constructs2])
				: handleMapOfConstructs(constructs2);
			function handleMapOfConstructs(map4) {
				return start;
				function start(code3) {
					const def = code3 !== null && map4[code3];
					const all5 = code3 !== null && map4.null;
					const list4 = [
						...(Array.isArray(def) ? def : def ? [def] : []),
						...(Array.isArray(all5) ? all5 : all5 ? [all5] : [])
					];
					return handleListOfConstructs(list4)(code3);
				}
			}
			function handleListOfConstructs(list4) {
				listOfConstructs = list4;
				constructIndex = 0;
				if (list4.length === 0) {
					return bogusState;
				}
				return handleConstruct(list4[constructIndex]);
			}
			function handleConstruct(construct) {
				return start;
				function start(code3) {
					info = store();
					currentConstruct = construct;
					if (!construct.partial) {
						context.currentConstruct = construct;
					}
					if (construct.name && context.parser.constructs.disable.null.includes(construct.name)) {
						return nok(code3);
					}
					return construct.tokenize.call(
						fields ? Object.assign(Object.create(context), fields) : context,
						effects,
						ok2,
						nok
					)(code3);
				}
			}
			function ok2(code3) {
				consumed = true;
				onreturn(currentConstruct, info);
				return returnState;
			}
			function nok(code3) {
				consumed = true;
				info.restore();
				if (++constructIndex < listOfConstructs.length) {
					return handleConstruct(listOfConstructs[constructIndex]);
				}
				return bogusState;
			}
		}
	}
	function addResult(construct, from2) {
		if (construct.resolveAll && !resolveAllConstructs.includes(construct)) {
			resolveAllConstructs.push(construct);
		}
		if (construct.resolve) {
			splice(
				context.events,
				from2,
				context.events.length - from2,
				construct.resolve(context.events.slice(from2), context)
			);
		}
		if (construct.resolveTo) {
			context.events = construct.resolveTo(context.events, context);
		}
	}
	function store() {
		const startPoint = now();
		const startPrevious = context.previous;
		const startCurrentConstruct = context.currentConstruct;
		const startEventsIndex = context.events.length;
		const startStack = Array.from(stack);
		return {
			restore,
			from: startEventsIndex
		};
		function restore() {
			point4 = startPoint;
			context.previous = startPrevious;
			context.currentConstruct = startCurrentConstruct;
			context.events.length = startEventsIndex;
			stack = startStack;
			accountForPotentialSkip();
		}
	}
	function accountForPotentialSkip() {
		if (point4.line in columnStart && point4.column < 2) {
			point4.column = columnStart[point4.line];
			point4.offset += columnStart[point4.line] - 1;
		}
	}
}
function sliceChunks(chunks, token) {
	const startIndex = token.start._index;
	const startBufferIndex = token.start._bufferIndex;
	const endIndex = token.end._index;
	const endBufferIndex = token.end._bufferIndex;
	let view;
	if (startIndex === endIndex) {
		view = [chunks[startIndex].slice(startBufferIndex, endBufferIndex)];
	} else {
		view = chunks.slice(startIndex, endIndex);
		if (startBufferIndex > -1) {
			view[0] = view[0].slice(startBufferIndex);
		}
		if (endBufferIndex > 0) {
			view.push(chunks[endIndex].slice(0, endBufferIndex));
		}
	}
	return view;
}
function serializeChunks(chunks, expandTabs) {
	let index6 = -1;
	const result = [];
	let atTab;
	while (++index6 < chunks.length) {
		const chunk = chunks[index6];
		let value;
		if (typeof chunk === 'string') {
			value = chunk;
		} else
			switch (chunk) {
				case -5: {
					value = '\r';
					break;
				}
				case -4: {
					value = '\n';
					break;
				}
				case -3: {
					value = '\r\n';
					break;
				}
				case -2: {
					value = expandTabs ? ' ' : '	';
					break;
				}
				case -1: {
					if (!expandTabs && atTab) continue;
					value = ' ';
					break;
				}
				default: {
					value = String.fromCharCode(chunk);
				}
			}
		atTab = chunk === -2;
		result.push(value);
	}
	return result.join('');
}
var init_create_tokenizer = __esm({
	'node_modules/micromark/lib/create-tokenizer.js'() {
		init_micromark_util_character();
		init_micromark_util_chunked();
		init_micromark_util_resolve_all();
	}
});

// node_modules/micromark/lib/constructs.js
var constructs_exports = {};
__export(constructs_exports, {
	attentionMarkers: () => attentionMarkers,
	contentInitial: () => contentInitial,
	disable: () => disable,
	document: () => document3,
	flow: () => flow2,
	flowInitial: () => flowInitial,
	insideSpan: () => insideSpan,
	string: () => string2,
	text: () => text2
});
var document3,
	contentInitial,
	flowInitial,
	flow2,
	string2,
	text2,
	insideSpan,
	attentionMarkers,
	disable;
var init_constructs = __esm({
	'node_modules/micromark/lib/constructs.js'() {
		init_micromark_core_commonmark();
		init_text();
		document3 = {
			[42]: list,
			[43]: list,
			[45]: list,
			[48]: list,
			[49]: list,
			[50]: list,
			[51]: list,
			[52]: list,
			[53]: list,
			[54]: list,
			[55]: list,
			[56]: list,
			[57]: list,
			[62]: blockQuote
		};
		contentInitial = {
			[91]: definition
		};
		flowInitial = {
			[-2]: codeIndented,
			[-1]: codeIndented,
			[32]: codeIndented
		};
		flow2 = {
			[35]: headingAtx,
			[42]: thematicBreak,
			[45]: [setextUnderline, thematicBreak],
			[60]: htmlFlow,
			[61]: setextUnderline,
			[95]: thematicBreak,
			[96]: codeFenced,
			[126]: codeFenced
		};
		string2 = {
			[38]: characterReference,
			[92]: characterEscape
		};
		text2 = {
			[-5]: lineEnding,
			[-4]: lineEnding,
			[-3]: lineEnding,
			[33]: labelStartImage,
			[38]: characterReference,
			[42]: attention,
			[60]: [autolink, htmlText],
			[91]: labelStartLink,
			[92]: [hardBreakEscape, characterEscape],
			[93]: labelEnd,
			[95]: attention,
			[96]: codeText
		};
		insideSpan = {
			null: [attention, resolver]
		};
		attentionMarkers = {
			null: [42, 95]
		};
		disable = {
			null: []
		};
	}
});

// node_modules/micromark/lib/parse.js
function parse3(options = {}) {
	const constructs2 = combineExtensions([constructs_exports].concat(options.extensions || []));
	const parser = {
		defined: [],
		lazy: {},
		constructs: constructs2,
		content: create3(content),
		document: create3(document2),
		flow: create3(flow),
		string: create3(string),
		text: create3(text)
	};
	return parser;
	function create3(initial) {
		return creator;
		function creator(from) {
			return createTokenizer(parser, initial, from);
		}
	}
}
var init_parse = __esm({
	'node_modules/micromark/lib/parse.js'() {
		init_micromark_util_combine_extensions();
		init_content();
		init_document();
		init_flow();
		init_text();
		init_create_tokenizer();
		init_constructs();
	}
});

// node_modules/micromark/lib/preprocess.js
function preprocess() {
	let column = 1;
	let buffer2 = '';
	let start = true;
	let atCarriageReturn;
	return preprocessor;
	function preprocessor(value, encoding, end) {
		const chunks = [];
		let match;
		let next;
		let startPosition;
		let endPosition;
		let code3;
		value = buffer2 + value.toString(encoding);
		startPosition = 0;
		buffer2 = '';
		if (start) {
			if (value.charCodeAt(0) === 65279) {
				startPosition++;
			}
			start = void 0;
		}
		while (startPosition < value.length) {
			search.lastIndex = startPosition;
			match = search.exec(value);
			endPosition = match && match.index !== void 0 ? match.index : value.length;
			code3 = value.charCodeAt(endPosition);
			if (!match) {
				buffer2 = value.slice(startPosition);
				break;
			}
			if (code3 === 10 && startPosition === endPosition && atCarriageReturn) {
				chunks.push(-3);
				atCarriageReturn = void 0;
			} else {
				if (atCarriageReturn) {
					chunks.push(-5);
					atCarriageReturn = void 0;
				}
				if (startPosition < endPosition) {
					chunks.push(value.slice(startPosition, endPosition));
					column += endPosition - startPosition;
				}
				switch (code3) {
					case 0: {
						chunks.push(65533);
						column++;
						break;
					}
					case 9: {
						next = Math.ceil(column / 4) * 4;
						chunks.push(-2);
						while (column++ < next) chunks.push(-1);
						break;
					}
					case 10: {
						chunks.push(-4);
						column = 1;
						break;
					}
					default: {
						atCarriageReturn = true;
						column = 1;
					}
				}
			}
			startPosition = endPosition + 1;
		}
		if (end) {
			if (atCarriageReturn) chunks.push(-5);
			if (buffer2) chunks.push(buffer2);
			chunks.push(null);
		}
		return chunks;
	}
}
var search;
var init_preprocess = __esm({
	'node_modules/micromark/lib/preprocess.js'() {
		search = /[\0\t\n\r]/g;
	}
});

// node_modules/micromark/lib/postprocess.js
function postprocess(events) {
	while (!subtokenize(events)) {}
	return events;
}
var init_postprocess = __esm({
	'node_modules/micromark/lib/postprocess.js'() {
		init_micromark_util_subtokenize();
	}
});

// node_modules/micromark-util-decode-numeric-character-reference/index.js
function decodeNumericCharacterReference(value, base4) {
	const code3 = Number.parseInt(value, base4);
	if (
		code3 < 9 ||
		code3 === 11 ||
		(code3 > 13 && code3 < 32) ||
		(code3 > 126 && code3 < 160) ||
		(code3 > 55295 && code3 < 57344) ||
		(code3 > 64975 && code3 < 65008) ||
		(code3 & 65535) === 65535 ||
		(code3 & 65535) === 65534 ||
		code3 > 1114111
	) {
		return '\uFFFD';
	}
	return String.fromCharCode(code3);
}
var init_micromark_util_decode_numeric_character_reference = __esm({
	'node_modules/micromark-util-decode-numeric-character-reference/index.js'() {}
});

// node_modules/micromark-util-decode-string/index.js
function decodeString(value) {
	return value.replace(characterEscapeOrReference, decode2);
}
function decode2($0, $1, $2) {
	if ($1) {
		return $1;
	}
	const head2 = $2.charCodeAt(0);
	if (head2 === 35) {
		const head3 = $2.charCodeAt(1);
		const hex = head3 === 120 || head3 === 88;
		return decodeNumericCharacterReference($2.slice(hex ? 2 : 1), hex ? 16 : 10);
	}
	return decodeNamedCharacterReference($2) || $0;
}
var characterEscapeOrReference;
var init_micromark_util_decode_string = __esm({
	'node_modules/micromark-util-decode-string/index.js'() {
		init_decode_named_character_reference();
		init_micromark_util_decode_numeric_character_reference();
		characterEscapeOrReference =
			/\\([!-/:-@[-`{-~])|&(#(?:\d{1,7}|x[\da-f]{1,6})|[\da-z]{1,31});/gi;
	}
});

// node_modules/mdast-util-from-markdown/lib/index.js
function compiler(options = {}) {
	const config = configure(
		{
			transforms: [],
			canContainEols: ['emphasis', 'fragment', 'heading', 'paragraph', 'strong'],
			enter: {
				autolink: opener(link3),
				autolinkProtocol: onenterdata,
				autolinkEmail: onenterdata,
				atxHeading: opener(heading3),
				blockQuote: opener(blockQuote2),
				characterEscape: onenterdata,
				characterReference: onenterdata,
				codeFenced: opener(codeFlow),
				codeFencedFenceInfo: buffer2,
				codeFencedFenceMeta: buffer2,
				codeIndented: opener(codeFlow, buffer2),
				codeText: opener(codeText2, buffer2),
				codeTextData: onenterdata,
				data: onenterdata,
				codeFlowValue: onenterdata,
				definition: opener(definition3),
				definitionDestinationString: buffer2,
				definitionLabelString: buffer2,
				definitionTitleString: buffer2,
				emphasis: opener(emphasis3),
				hardBreakEscape: opener(hardBreak3),
				hardBreakTrailing: opener(hardBreak3),
				htmlFlow: opener(html9, buffer2),
				htmlFlowData: onenterdata,
				htmlText: opener(html9, buffer2),
				htmlTextData: onenterdata,
				image: opener(image3),
				label: buffer2,
				link: opener(link3),
				listItem: opener(listItem3),
				listItemValue: onenterlistitemvalue,
				listOrdered: opener(list4, onenterlistordered),
				listUnordered: opener(list4),
				paragraph: opener(paragraph3),
				reference: onenterreference,
				referenceString: buffer2,
				resourceDestinationString: buffer2,
				resourceTitleString: buffer2,
				setextHeading: opener(heading3),
				strong: opener(strong3),
				thematicBreak: opener(thematicBreak4)
			},
			exit: {
				atxHeading: closer(),
				atxHeadingSequence: onexitatxheadingsequence,
				autolink: closer(),
				autolinkEmail: onexitautolinkemail,
				autolinkProtocol: onexitautolinkprotocol,
				blockQuote: closer(),
				characterEscapeValue: onexitdata,
				characterReferenceMarkerHexadecimal: onexitcharacterreferencemarker,
				characterReferenceMarkerNumeric: onexitcharacterreferencemarker,
				characterReferenceValue: onexitcharacterreferencevalue,
				codeFenced: closer(onexitcodefenced),
				codeFencedFence: onexitcodefencedfence,
				codeFencedFenceInfo: onexitcodefencedfenceinfo,
				codeFencedFenceMeta: onexitcodefencedfencemeta,
				codeFlowValue: onexitdata,
				codeIndented: closer(onexitcodeindented),
				codeText: closer(onexitcodetext),
				codeTextData: onexitdata,
				data: onexitdata,
				definition: closer(),
				definitionDestinationString: onexitdefinitiondestinationstring,
				definitionLabelString: onexitdefinitionlabelstring,
				definitionTitleString: onexitdefinitiontitlestring,
				emphasis: closer(),
				hardBreakEscape: closer(onexithardbreak),
				hardBreakTrailing: closer(onexithardbreak),
				htmlFlow: closer(onexithtmlflow),
				htmlFlowData: onexitdata,
				htmlText: closer(onexithtmltext),
				htmlTextData: onexitdata,
				image: closer(onexitimage),
				label: onexitlabel,
				labelText: onexitlabeltext,
				lineEnding: onexitlineending,
				link: closer(onexitlink),
				listItem: closer(),
				listOrdered: closer(),
				listUnordered: closer(),
				paragraph: closer(),
				referenceString: onexitreferencestring,
				resourceDestinationString: onexitresourcedestinationstring,
				resourceTitleString: onexitresourcetitlestring,
				resource: onexitresource,
				setextHeading: closer(onexitsetextheading),
				setextHeadingLineSequence: onexitsetextheadinglinesequence,
				setextHeadingText: onexitsetextheadingtext,
				strong: closer(),
				thematicBreak: closer()
			}
		},
		options.mdastExtensions || []
	);
	const data2 = {};
	return compile;
	function compile(events) {
		let tree = {
			type: 'root',
			children: []
		};
		const stack = [tree];
		const tokenStack = [];
		const listStack = [];
		const context = {
			stack,
			tokenStack,
			config,
			enter,
			exit: exit2,
			buffer: buffer2,
			resume: resume2,
			setData,
			getData
		};
		let index6 = -1;
		while (++index6 < events.length) {
			if (events[index6][1].type === 'listOrdered' || events[index6][1].type === 'listUnordered') {
				if (events[index6][0] === 'enter') {
					listStack.push(index6);
				} else {
					const tail = listStack.pop();
					index6 = prepareList(events, tail, index6);
				}
			}
		}
		index6 = -1;
		while (++index6 < events.length) {
			const handler = config[events[index6][0]];
			if (own3.call(handler, events[index6][1].type)) {
				handler[events[index6][1].type].call(
					Object.assign(
						{
							sliceSerialize: events[index6][2].sliceSerialize
						},
						context
					),
					events[index6][1]
				);
			}
		}
		if (tokenStack.length > 0) {
			const tail = tokenStack[tokenStack.length - 1];
			const handler = tail[1] || defaultOnError;
			handler.call(context, void 0, tail[0]);
		}
		tree.position = {
			start: point4(
				events.length > 0
					? events[0][1].start
					: {
							line: 1,
							column: 1,
							offset: 0
					  }
			),
			end: point4(
				events.length > 0
					? events[events.length - 2][1].end
					: {
							line: 1,
							column: 1,
							offset: 0
					  }
			)
		};
		index6 = -1;
		while (++index6 < config.transforms.length) {
			tree = config.transforms[index6](tree) || tree;
		}
		return tree;
	}
	function prepareList(events, start, length) {
		let index6 = start - 1;
		let containerBalance = -1;
		let listSpread = false;
		let listItem4;
		let lineIndex;
		let firstBlankLineIndex;
		let atMarker;
		while (++index6 <= length) {
			const event = events[index6];
			if (
				event[1].type === 'listUnordered' ||
				event[1].type === 'listOrdered' ||
				event[1].type === 'blockQuote'
			) {
				if (event[0] === 'enter') {
					containerBalance++;
				} else {
					containerBalance--;
				}
				atMarker = void 0;
			} else if (event[1].type === 'lineEndingBlank') {
				if (event[0] === 'enter') {
					if (listItem4 && !atMarker && !containerBalance && !firstBlankLineIndex) {
						firstBlankLineIndex = index6;
					}
					atMarker = void 0;
				}
			} else if (
				event[1].type === 'linePrefix' ||
				event[1].type === 'listItemValue' ||
				event[1].type === 'listItemMarker' ||
				event[1].type === 'listItemPrefix' ||
				event[1].type === 'listItemPrefixWhitespace'
			) {
			} else {
				atMarker = void 0;
			}
			if (
				(!containerBalance && event[0] === 'enter' && event[1].type === 'listItemPrefix') ||
				(containerBalance === -1 &&
					event[0] === 'exit' &&
					(event[1].type === 'listUnordered' || event[1].type === 'listOrdered'))
			) {
				if (listItem4) {
					let tailIndex = index6;
					lineIndex = void 0;
					while (tailIndex--) {
						const tailEvent = events[tailIndex];
						if (tailEvent[1].type === 'lineEnding' || tailEvent[1].type === 'lineEndingBlank') {
							if (tailEvent[0] === 'exit') continue;
							if (lineIndex) {
								events[lineIndex][1].type = 'lineEndingBlank';
								listSpread = true;
							}
							tailEvent[1].type = 'lineEnding';
							lineIndex = tailIndex;
						} else if (
							tailEvent[1].type === 'linePrefix' ||
							tailEvent[1].type === 'blockQuotePrefix' ||
							tailEvent[1].type === 'blockQuotePrefixWhitespace' ||
							tailEvent[1].type === 'blockQuoteMarker' ||
							tailEvent[1].type === 'listItemIndent'
						) {
						} else {
							break;
						}
					}
					if (firstBlankLineIndex && (!lineIndex || firstBlankLineIndex < lineIndex)) {
						listItem4._spread = true;
					}
					listItem4.end = Object.assign({}, lineIndex ? events[lineIndex][1].start : event[1].end);
					events.splice(lineIndex || index6, 0, ['exit', listItem4, event[2]]);
					index6++;
					length++;
				}
				if (event[1].type === 'listItemPrefix') {
					listItem4 = {
						type: 'listItem',
						_spread: false,
						start: Object.assign({}, event[1].start)
					};
					events.splice(index6, 0, ['enter', listItem4, event[2]]);
					index6++;
					length++;
					firstBlankLineIndex = void 0;
					atMarker = true;
				}
			}
		}
		events[start][1]._spread = listSpread;
		return length;
	}
	function setData(key3, value) {
		data2[key3] = value;
	}
	function getData(key3) {
		return data2[key3];
	}
	function point4(d) {
		return {
			line: d.line,
			column: d.column,
			offset: d.offset
		};
	}
	function opener(create3, and) {
		return open;
		function open(token) {
			enter.call(this, create3(token), token);
			if (and) and.call(this, token);
		}
	}
	function buffer2() {
		this.stack.push({
			type: 'fragment',
			children: []
		});
	}
	function enter(node, token, errorHandler) {
		const parent = this.stack[this.stack.length - 1];
		parent.children.push(node);
		this.stack.push(node);
		this.tokenStack.push([token, errorHandler]);
		node.position = {
			start: point4(token.start)
		};
		return node;
	}
	function closer(and) {
		return close;
		function close(token) {
			if (and) and.call(this, token);
			exit2.call(this, token);
		}
	}
	function exit2(token, onExitError) {
		const node = this.stack.pop();
		const open = this.tokenStack.pop();
		if (!open) {
			throw new Error(
				'Cannot close `' +
					token.type +
					'` (' +
					stringifyPosition({
						start: token.start,
						end: token.end
					}) +
					'): it\u2019s not open'
			);
		} else if (open[0].type !== token.type) {
			if (onExitError) {
				onExitError.call(this, token, open[0]);
			} else {
				const handler = open[1] || defaultOnError;
				handler.call(this, token, open[0]);
			}
		}
		node.position.end = point4(token.end);
		return node;
	}
	function resume2() {
		return toString(this.stack.pop());
	}
	function onenterlistordered() {
		setData('expectingFirstListItemValue', true);
	}
	function onenterlistitemvalue(token) {
		if (getData('expectingFirstListItemValue')) {
			const ancestor = this.stack[this.stack.length - 2];
			ancestor.start = Number.parseInt(this.sliceSerialize(token), 10);
			setData('expectingFirstListItemValue');
		}
	}
	function onexitcodefencedfenceinfo() {
		const data3 = this.resume();
		const node = this.stack[this.stack.length - 1];
		node.lang = data3;
	}
	function onexitcodefencedfencemeta() {
		const data3 = this.resume();
		const node = this.stack[this.stack.length - 1];
		node.meta = data3;
	}
	function onexitcodefencedfence() {
		if (getData('flowCodeInside')) return;
		this.buffer();
		setData('flowCodeInside', true);
	}
	function onexitcodefenced() {
		const data3 = this.resume();
		const node = this.stack[this.stack.length - 1];
		node.value = data3.replace(/^(\r?\n|\r)|(\r?\n|\r)$/g, '');
		setData('flowCodeInside');
	}
	function onexitcodeindented() {
		const data3 = this.resume();
		const node = this.stack[this.stack.length - 1];
		node.value = data3.replace(/(\r?\n|\r)$/g, '');
	}
	function onexitdefinitionlabelstring(token) {
		const label = this.resume();
		const node = this.stack[this.stack.length - 1];
		node.label = label;
		node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
	}
	function onexitdefinitiontitlestring() {
		const data3 = this.resume();
		const node = this.stack[this.stack.length - 1];
		node.title = data3;
	}
	function onexitdefinitiondestinationstring() {
		const data3 = this.resume();
		const node = this.stack[this.stack.length - 1];
		node.url = data3;
	}
	function onexitatxheadingsequence(token) {
		const node = this.stack[this.stack.length - 1];
		if (!node.depth) {
			const depth = this.sliceSerialize(token).length;
			node.depth = depth;
		}
	}
	function onexitsetextheadingtext() {
		setData('setextHeadingSlurpLineEnding', true);
	}
	function onexitsetextheadinglinesequence(token) {
		const node = this.stack[this.stack.length - 1];
		node.depth = this.sliceSerialize(token).charCodeAt(0) === 61 ? 1 : 2;
	}
	function onexitsetextheading() {
		setData('setextHeadingSlurpLineEnding');
	}
	function onenterdata(token) {
		const parent = this.stack[this.stack.length - 1];
		let tail = parent.children[parent.children.length - 1];
		if (!tail || tail.type !== 'text') {
			tail = text7();
			tail.position = {
				start: point4(token.start)
			};
			parent.children.push(tail);
		}
		this.stack.push(tail);
	}
	function onexitdata(token) {
		const tail = this.stack.pop();
		tail.value += this.sliceSerialize(token);
		tail.position.end = point4(token.end);
	}
	function onexitlineending(token) {
		const context = this.stack[this.stack.length - 1];
		if (getData('atHardBreak')) {
			const tail = context.children[context.children.length - 1];
			tail.position.end = point4(token.end);
			setData('atHardBreak');
			return;
		}
		if (!getData('setextHeadingSlurpLineEnding') && config.canContainEols.includes(context.type)) {
			onenterdata.call(this, token);
			onexitdata.call(this, token);
		}
	}
	function onexithardbreak() {
		setData('atHardBreak', true);
	}
	function onexithtmlflow() {
		const data3 = this.resume();
		const node = this.stack[this.stack.length - 1];
		node.value = data3;
	}
	function onexithtmltext() {
		const data3 = this.resume();
		const node = this.stack[this.stack.length - 1];
		node.value = data3;
	}
	function onexitcodetext() {
		const data3 = this.resume();
		const node = this.stack[this.stack.length - 1];
		node.value = data3;
	}
	function onexitlink() {
		const context = this.stack[this.stack.length - 1];
		if (getData('inReference')) {
			context.type += 'Reference';
			context.referenceType = getData('referenceType') || 'shortcut';
			delete context.url;
			delete context.title;
		} else {
			delete context.identifier;
			delete context.label;
		}
		setData('referenceType');
	}
	function onexitimage() {
		const context = this.stack[this.stack.length - 1];
		if (getData('inReference')) {
			context.type += 'Reference';
			context.referenceType = getData('referenceType') || 'shortcut';
			delete context.url;
			delete context.title;
		} else {
			delete context.identifier;
			delete context.label;
		}
		setData('referenceType');
	}
	function onexitlabeltext(token) {
		const ancestor = this.stack[this.stack.length - 2];
		const string3 = this.sliceSerialize(token);
		ancestor.label = decodeString(string3);
		ancestor.identifier = normalizeIdentifier(string3).toLowerCase();
	}
	function onexitlabel() {
		const fragment = this.stack[this.stack.length - 1];
		const value = this.resume();
		const node = this.stack[this.stack.length - 1];
		setData('inReference', true);
		if (node.type === 'link') {
			node.children = fragment.children;
		} else {
			node.alt = value;
		}
	}
	function onexitresourcedestinationstring() {
		const data3 = this.resume();
		const node = this.stack[this.stack.length - 1];
		node.url = data3;
	}
	function onexitresourcetitlestring() {
		const data3 = this.resume();
		const node = this.stack[this.stack.length - 1];
		node.title = data3;
	}
	function onexitresource() {
		setData('inReference');
	}
	function onenterreference() {
		setData('referenceType', 'collapsed');
	}
	function onexitreferencestring(token) {
		const label = this.resume();
		const node = this.stack[this.stack.length - 1];
		node.label = label;
		node.identifier = normalizeIdentifier(this.sliceSerialize(token)).toLowerCase();
		setData('referenceType', 'full');
	}
	function onexitcharacterreferencemarker(token) {
		setData('characterReferenceType', token.type);
	}
	function onexitcharacterreferencevalue(token) {
		const data3 = this.sliceSerialize(token);
		const type = getData('characterReferenceType');
		let value;
		if (type) {
			value = decodeNumericCharacterReference(
				data3,
				type === 'characterReferenceMarkerNumeric' ? 10 : 16
			);
			setData('characterReferenceType');
		} else {
			value = decodeNamedCharacterReference(data3);
		}
		const tail = this.stack.pop();
		tail.value += value;
		tail.position.end = point4(token.end);
	}
	function onexitautolinkprotocol(token) {
		onexitdata.call(this, token);
		const node = this.stack[this.stack.length - 1];
		node.url = this.sliceSerialize(token);
	}
	function onexitautolinkemail(token) {
		onexitdata.call(this, token);
		const node = this.stack[this.stack.length - 1];
		node.url = 'mailto:' + this.sliceSerialize(token);
	}
	function blockQuote2() {
		return {
			type: 'blockquote',
			children: []
		};
	}
	function codeFlow() {
		return {
			type: 'code',
			lang: null,
			meta: null,
			value: ''
		};
	}
	function codeText2() {
		return {
			type: 'inlineCode',
			value: ''
		};
	}
	function definition3() {
		return {
			type: 'definition',
			identifier: '',
			label: null,
			title: null,
			url: ''
		};
	}
	function emphasis3() {
		return {
			type: 'emphasis',
			children: []
		};
	}
	function heading3() {
		return {
			type: 'heading',
			depth: void 0,
			children: []
		};
	}
	function hardBreak3() {
		return {
			type: 'break'
		};
	}
	function html9() {
		return {
			type: 'html',
			value: ''
		};
	}
	function image3() {
		return {
			type: 'image',
			title: null,
			url: '',
			alt: null
		};
	}
	function link3() {
		return {
			type: 'link',
			title: null,
			url: '',
			children: []
		};
	}
	function list4(token) {
		return {
			type: 'list',
			ordered: token.type === 'listOrdered',
			start: null,
			spread: token._spread,
			children: []
		};
	}
	function listItem3(token) {
		return {
			type: 'listItem',
			spread: token._spread,
			checked: null,
			children: []
		};
	}
	function paragraph3() {
		return {
			type: 'paragraph',
			children: []
		};
	}
	function strong3() {
		return {
			type: 'strong',
			children: []
		};
	}
	function text7() {
		return {
			type: 'text',
			value: ''
		};
	}
	function thematicBreak4() {
		return {
			type: 'thematicBreak'
		};
	}
}
function configure(combined, extensions) {
	let index6 = -1;
	while (++index6 < extensions.length) {
		const value = extensions[index6];
		if (Array.isArray(value)) {
			configure(combined, value);
		} else {
			extension(combined, value);
		}
	}
	return combined;
}
function extension(combined, extension2) {
	let key3;
	for (key3 in extension2) {
		if (own3.call(extension2, key3)) {
			const list4 = key3 === 'canContainEols' || key3 === 'transforms';
			const maybe = own3.call(combined, key3) ? combined[key3] : void 0;
			const left = maybe || (combined[key3] = list4 ? [] : {});
			const right = extension2[key3];
			if (right) {
				if (list4) {
					combined[key3] = [...left, ...right];
				} else {
					Object.assign(left, right);
				}
			}
		}
	}
}
function defaultOnError(left, right) {
	if (left) {
		throw new Error(
			'Cannot close `' +
				left.type +
				'` (' +
				stringifyPosition({
					start: left.start,
					end: left.end
				}) +
				'): a different token (`' +
				right.type +
				'`, ' +
				stringifyPosition({
					start: right.start,
					end: right.end
				}) +
				') is open'
		);
	} else {
		throw new Error(
			'Cannot close document, a token (`' +
				right.type +
				'`, ' +
				stringifyPosition({
					start: right.start,
					end: right.end
				}) +
				') is still open'
		);
	}
}
var own3, fromMarkdown;
var init_lib3 = __esm({
	'node_modules/mdast-util-from-markdown/lib/index.js'() {
		init_mdast_util_to_string();
		init_parse();
		init_preprocess();
		init_postprocess();
		init_micromark_util_decode_numeric_character_reference();
		init_micromark_util_decode_string();
		init_micromark_util_normalize_identifier();
		init_decode_named_character_reference();
		init_unist_util_stringify_position();
		own3 = {}.hasOwnProperty;
		fromMarkdown = function (value, encoding, options) {
			if (typeof encoding !== 'string') {
				options = encoding;
				encoding = void 0;
			}
			return compiler(options)(
				postprocess(parse3(options).document().write(preprocess()(value, encoding, true)))
			);
		};
	}
});

// node_modules/mdast-util-from-markdown/index.js
var init_mdast_util_from_markdown = __esm({
	'node_modules/mdast-util-from-markdown/index.js'() {
		init_lib3();
	}
});

// node_modules/remark-parse/lib/index.js
function remarkParse(options) {
	const parser = (doc) => {
		const settings = this.data('settings');
		return fromMarkdown(
			doc,
			Object.assign({}, settings, options, {
				extensions: this.data('micromarkExtensions') || [],
				mdastExtensions: this.data('fromMarkdownExtensions') || []
			})
		);
	};
	Object.assign(this, { Parser: parser });
}
var init_lib4 = __esm({
	'node_modules/remark-parse/lib/index.js'() {
		init_mdast_util_from_markdown();
	}
});

// node_modules/remark-parse/index.js
var remark_parse_default;
var init_remark_parse = __esm({
	'node_modules/remark-parse/index.js'() {
		init_lib4();
		remark_parse_default = remarkParse;
	}
});

// node_modules/zwitch/index.js
function zwitch(key3, options) {
	var settings = options || {};
	function one5(value) {
		var fn = one5.invalid;
		var handlers3 = one5.handlers;
		if (value && own4.call(value, key3)) {
			fn = own4.call(handlers3, value[key3]) ? handlers3[value[key3]] : one5.unknown;
		}
		if (fn) {
			return fn.apply(this, arguments);
		}
	}
	one5.handlers = settings.handlers || {};
	one5.invalid = settings.invalid;
	one5.unknown = settings.unknown;
	return one5;
}
var own4;
var init_zwitch = __esm({
	'node_modules/zwitch/index.js'() {
		own4 = {}.hasOwnProperty;
	}
});

// node_modules/mdast-util-to-markdown/lib/configure.js
function configure2(base4, extension2) {
	let index6 = -1;
	let key3;
	if (extension2.extensions) {
		while (++index6 < extension2.extensions.length) {
			configure2(base4, extension2.extensions[index6]);
		}
	}
	for (key3 in extension2) {
		if (key3 === 'extensions') {
		} else if (key3 === 'unsafe' || key3 === 'join') {
			base4[key3] = [...(base4[key3] || []), ...(extension2[key3] || [])];
		} else if (key3 === 'handlers') {
			base4[key3] = Object.assign(base4[key3], extension2[key3] || {});
		} else {
			base4.options[key3] = extension2[key3];
		}
	}
	return base4;
}
var init_configure = __esm({
	'node_modules/mdast-util-to-markdown/lib/configure.js'() {}
});

// node_modules/mdast-util-to-markdown/lib/util/track.js
function track(options_) {
	const options = options_ || {};
	const now = options.now || {};
	let lineShift = options.lineShift || 0;
	let line = now.line || 1;
	let column = now.column || 1;
	return { move, current, shift };
	function current() {
		return { now: { line, column }, lineShift };
	}
	function shift(value) {
		lineShift += value;
	}
	function move(value = '') {
		const chunks = value.split(/\r?\n|\r/g);
		const tail = chunks[chunks.length - 1];
		line += chunks.length - 1;
		column = chunks.length === 1 ? column + tail.length : 1 + tail.length + lineShift;
		return value;
	}
}
var init_track = __esm({
	'node_modules/mdast-util-to-markdown/lib/util/track.js'() {}
});

// node_modules/mdast-util-to-markdown/lib/util/container-flow.js
function containerFlow(parent, context, safeOptions) {
	const indexStack = context.indexStack;
	const children = parent.children || [];
	const tracker = track(safeOptions);
	const results = [];
	let index6 = -1;
	indexStack.push(-1);
	while (++index6 < children.length) {
		const child = children[index6];
		indexStack[indexStack.length - 1] = index6;
		results.push(
			tracker.move(
				context.handle(child, parent, context, {
					before: '\n',
					after: '\n',
					...tracker.current()
				})
			)
		);
		if (child.type !== 'list') {
			context.bulletLastUsed = void 0;
		}
		if (index6 < children.length - 1) {
			results.push(tracker.move(between(child, children[index6 + 1])));
		}
	}
	indexStack.pop();
	return results.join('');
	function between(left, right) {
		let index7 = context.join.length;
		while (index7--) {
			const result = context.join[index7](left, right, parent, context);
			if (result === true || result === 1) {
				break;
			}
			if (typeof result === 'number') {
				return '\n'.repeat(1 + result);
			}
			if (result === false) {
				return '\n\n<!---->\n\n';
			}
		}
		return '\n\n';
	}
}
var init_container_flow = __esm({
	'node_modules/mdast-util-to-markdown/lib/util/container-flow.js'() {
		init_track();
	}
});

// node_modules/mdast-util-to-markdown/lib/util/indent-lines.js
function indentLines(value, map4) {
	const result = [];
	let start = 0;
	let line = 0;
	let match;
	while ((match = eol.exec(value))) {
		one5(value.slice(start, match.index));
		result.push(match[0]);
		start = match.index + match[0].length;
		line++;
	}
	one5(value.slice(start));
	return result.join('');
	function one5(value2) {
		result.push(map4(value2, line, !value2));
	}
}
var eol;
var init_indent_lines = __esm({
	'node_modules/mdast-util-to-markdown/lib/util/indent-lines.js'() {
		eol = /\r?\n|\r/g;
	}
});

// node_modules/mdast-util-to-markdown/lib/handle/blockquote.js
function blockquote(node, _, context, safeOptions) {
	const exit2 = context.enter('blockquote');
	const tracker = track(safeOptions);
	tracker.move('> ');
	tracker.shift(2);
	const value = indentLines(containerFlow(node, context, tracker.current()), map);
	exit2();
	return value;
}
function map(line, _, blank) {
	return '>' + (blank ? '' : ' ') + line;
}
var init_blockquote = __esm({
	'node_modules/mdast-util-to-markdown/lib/handle/blockquote.js'() {
		init_container_flow();
		init_indent_lines();
		init_track();
	}
});

// node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js
function patternInScope(stack, pattern) {
	return (
		listInScope(stack, pattern.inConstruct, true) &&
		!listInScope(stack, pattern.notInConstruct, false)
	);
}
function listInScope(stack, list4, none) {
	if (!list4) {
		return none;
	}
	if (typeof list4 === 'string') {
		list4 = [list4];
	}
	let index6 = -1;
	while (++index6 < list4.length) {
		if (stack.includes(list4[index6])) {
			return true;
		}
	}
	return false;
}
var init_pattern_in_scope = __esm({
	'node_modules/mdast-util-to-markdown/lib/util/pattern-in-scope.js'() {}
});

// node_modules/mdast-util-to-markdown/lib/handle/break.js
function hardBreak(_, _1, context, safe2) {
	let index6 = -1;
	while (++index6 < context.unsafe.length) {
		if (
			context.unsafe[index6].character === '\n' &&
			patternInScope(context.stack, context.unsafe[index6])
		) {
			return /[ \t]/.test(safe2.before) ? '' : ' ';
		}
	}
	return '\\\n';
}
var init_break = __esm({
	'node_modules/mdast-util-to-markdown/lib/handle/break.js'() {
		init_pattern_in_scope();
	}
});

// node_modules/longest-streak/index.js
function longestStreak(value, character) {
	const source = String(value);
	let index6 = source.indexOf(character);
	let expected = index6;
	let count = 0;
	let max = 0;
	if (typeof character !== 'string' || character.length !== 1) {
		throw new Error('Expected character');
	}
	while (index6 !== -1) {
		if (index6 === expected) {
			if (++count > max) {
				max = count;
			}
		} else {
			count = 1;
		}
		expected = index6 + 1;
		index6 = source.indexOf(character, expected);
	}
	return max;
}
var init_longest_streak = __esm({
	'node_modules/longest-streak/index.js'() {}
});

// node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js
function formatCodeAsIndented(node, context) {
	return Boolean(
		!context.options.fences &&
			node.value &&
			!node.lang &&
			/[^ \r\n]/.test(node.value) &&
			!/^[\t ]*(?:[\r\n]|$)|(?:^|[\r\n])[\t ]*$/.test(node.value)
	);
}
var init_format_code_as_indented = __esm({
	'node_modules/mdast-util-to-markdown/lib/util/format-code-as-indented.js'() {}
});

// node_modules/mdast-util-to-markdown/lib/util/check-fence.js
function checkFence(context) {
	const marker = context.options.fence || '`';
	if (marker !== '`' && marker !== '~') {
		throw new Error(
			'Cannot serialize code with `' + marker + '` for `options.fence`, expected `` ` `` or `~`'
		);
	}
	return marker;
}
var init_check_fence = __esm({
	'node_modules/mdast-util-to-markdown/lib/util/check-fence.js'() {}
});

// node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js
function patternCompile(pattern) {
	if (!pattern._compiled) {
		const before =
			(pattern.atBreak ? '[\\r\\n][\\t ]*' : '') +
			(pattern.before ? '(?:' + pattern.before + ')' : '');
		pattern._compiled = new RegExp(
			(before ? '(' + before + ')' : '') +
				(/[|\\{}()[\]^$+*?.-]/.test(pattern.character) ? '\\' : '') +
				pattern.character +
				(pattern.after ? '(?:' + pattern.after + ')' : ''),
			'g'
		);
	}
	return pattern._compiled;
}
var init_pattern_compile = __esm({
	'node_modules/mdast-util-to-markdown/lib/util/pattern-compile.js'() {}
});

// node_modules/mdast-util-to-markdown/lib/util/safe.js
function safe(context, input, config) {
	const value = (config.before || '') + (input || '') + (config.after || '');
	const positions = [];
	const result = [];
	const infos = {};
	let index6 = -1;
	while (++index6 < context.unsafe.length) {
		const pattern = context.unsafe[index6];
		if (!patternInScope(context.stack, pattern)) {
			continue;
		}
		const expression = patternCompile(pattern);
		let match;
		while ((match = expression.exec(value))) {
			const before = 'before' in pattern || Boolean(pattern.atBreak);
			const after = 'after' in pattern;
			const position3 = match.index + (before ? match[1].length : 0);
			if (positions.includes(position3)) {
				if (infos[position3].before && !before) {
					infos[position3].before = false;
				}
				if (infos[position3].after && !after) {
					infos[position3].after = false;
				}
			} else {
				positions.push(position3);
				infos[position3] = { before, after };
			}
		}
	}
	positions.sort(numerical);
	let start = config.before ? config.before.length : 0;
	const end = value.length - (config.after ? config.after.length : 0);
	index6 = -1;
	while (++index6 < positions.length) {
		const position3 = positions[index6];
		if (position3 < start || position3 >= end) {
			continue;
		}
		if (
			(position3 + 1 < end &&
				positions[index6 + 1] === position3 + 1 &&
				infos[position3].after &&
				!infos[position3 + 1].before &&
				!infos[position3 + 1].after) ||
			(positions[index6 - 1] === position3 - 1 &&
				infos[position3].before &&
				!infos[position3 - 1].before &&
				!infos[position3 - 1].after)
		) {
			continue;
		}
		if (start !== position3) {
			result.push(escapeBackslashes(value.slice(start, position3), '\\'));
		}
		start = position3;
		if (
			/[!-/:-@[-`{-~]/.test(value.charAt(position3)) &&
			(!config.encode || !config.encode.includes(value.charAt(position3)))
		) {
			result.push('\\');
		} else {
			result.push('&#x' + value.charCodeAt(position3).toString(16).toUpperCase() + ';');
			start++;
		}
	}
	result.push(escapeBackslashes(value.slice(start, end), config.after));
	return result.join('');
}
function numerical(a, b) {
	return a - b;
}
function escapeBackslashes(value, after) {
	const expression = /\\(?=[!-/:-@[-`{-~])/g;
	const positions = [];
	const results = [];
	const whole = value + after;
	let index6 = -1;
	let start = 0;
	let match;
	while ((match = expression.exec(whole))) {
		positions.push(match.index);
	}
	while (++index6 < positions.length) {
		if (start !== positions[index6]) {
			results.push(value.slice(start, positions[index6]));
		}
		results.push('\\');
		start = positions[index6];
	}
	results.push(value.slice(start));
	return results.join('');
}
var init_safe = __esm({
	'node_modules/mdast-util-to-markdown/lib/util/safe.js'() {
		init_pattern_compile();
		init_pattern_in_scope();
	}
});

// node_modules/mdast-util-to-markdown/lib/handle/code.js
function code(node, _, context, safeOptions) {
	const marker = checkFence(context);
	const raw2 = node.value || '';
	const suffix = marker === '`' ? 'GraveAccent' : 'Tilde';
	if (formatCodeAsIndented(node, context)) {
		const exit3 = context.enter('codeIndented');
		const value2 = indentLines(raw2, map2);
		exit3();
		return value2;
	}
	const tracker = track(safeOptions);
	const sequence = marker.repeat(Math.max(longestStreak(raw2, marker) + 1, 3));
	const exit2 = context.enter('codeFenced');
	let value = tracker.move(sequence);
	if (node.lang) {
		const subexit = context.enter('codeFencedLang' + suffix);
		value += tracker.move(
			safe(context, node.lang, {
				before: value,
				after: ' ',
				encode: ['`'],
				...tracker.current()
			})
		);
		subexit();
	}
	if (node.lang && node.meta) {
		const subexit = context.enter('codeFencedMeta' + suffix);
		value += tracker.move(' ');
		value += tracker.move(
			safe(context, node.meta, {
				before: value,
				after: '\n',
				encode: ['`'],
				...tracker.current()
			})
		);
		subexit();
	}
	value += tracker.move('\n');
	if (raw2) {
		value += tracker.move(raw2 + '\n');
	}
	value += tracker.move(sequence);
	exit2();
	return value;
}
function map2(line, _, blank) {
	return (blank ? '' : '    ') + line;
}
var init_code = __esm({
	'node_modules/mdast-util-to-markdown/lib/handle/code.js'() {
		init_longest_streak();
		init_format_code_as_indented();
		init_check_fence();
		init_indent_lines();
		init_safe();
		init_track();
	}
});

// node_modules/mdast-util-to-markdown/lib/util/association.js
function association(node) {
	if (node.label || !node.identifier) {
		return node.label || '';
	}
	return decodeString(node.identifier);
}
var init_association = __esm({
	'node_modules/mdast-util-to-markdown/lib/util/association.js'() {
		init_micromark_util_decode_string();
	}
});

// node_modules/mdast-util-to-markdown/lib/util/check-quote.js
function checkQuote(context) {
	const marker = context.options.quote || '"';
	if (marker !== '"' && marker !== "'") {
		throw new Error(
			'Cannot serialize title with `' + marker + '` for `options.quote`, expected `"`, or `\'`'
		);
	}
	return marker;
}
var init_check_quote = __esm({
	'node_modules/mdast-util-to-markdown/lib/util/check-quote.js'() {}
});

// node_modules/mdast-util-to-markdown/lib/handle/definition.js
function definition2(node, _, context, safeOptions) {
	const quote = checkQuote(context);
	const suffix = quote === '"' ? 'Quote' : 'Apostrophe';
	const exit2 = context.enter('definition');
	let subexit = context.enter('label');
	const tracker = track(safeOptions);
	let value = tracker.move('[');
	value += tracker.move(
		safe(context, association(node), {
			before: value,
			after: ']',
			...tracker.current()
		})
	);
	value += tracker.move(']: ');
	subexit();
	if (!node.url || /[\0- \u007F]/.test(node.url)) {
		subexit = context.enter('destinationLiteral');
		value += tracker.move('<');
		value += tracker.move(
			safe(context, node.url, { before: value, after: '>', ...tracker.current() })
		);
		value += tracker.move('>');
	} else {
		subexit = context.enter('destinationRaw');
		value += tracker.move(
			safe(context, node.url, {
				before: value,
				after: node.title ? ' ' : '\n',
				...tracker.current()
			})
		);
	}
	subexit();
	if (node.title) {
		subexit = context.enter('title' + suffix);
		value += tracker.move(' ' + quote);
		value += tracker.move(
			safe(context, node.title, {
				before: value,
				after: quote,
				...tracker.current()
			})
		);
		value += tracker.move(quote);
		subexit();
	}
	exit2();
	return value;
}
var init_definition2 = __esm({
	'node_modules/mdast-util-to-markdown/lib/handle/definition.js'() {
		init_association();
		init_check_quote();
		init_safe();
		init_track();
	}
});

// node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js
function checkEmphasis(context) {
	const marker = context.options.emphasis || '*';
	if (marker !== '*' && marker !== '_') {
		throw new Error(
			'Cannot serialize emphasis with `' + marker + '` for `options.emphasis`, expected `*`, or `_`'
		);
	}
	return marker;
}
var init_check_emphasis = __esm({
	'node_modules/mdast-util-to-markdown/lib/util/check-emphasis.js'() {}
});

// node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js
function containerPhrasing(parent, context, safeOptions) {
	const indexStack = context.indexStack;
	const children = parent.children || [];
	const results = [];
	let index6 = -1;
	let before = safeOptions.before;
	indexStack.push(-1);
	let tracker = track(safeOptions);
	while (++index6 < children.length) {
		const child = children[index6];
		let after;
		indexStack[indexStack.length - 1] = index6;
		if (index6 + 1 < children.length) {
			let handle2 = context.handle.handlers[children[index6 + 1].type];
			if (handle2 && handle2.peek) handle2 = handle2.peek;
			after = handle2
				? handle2(children[index6 + 1], parent, context, {
						before: '',
						after: '',
						...tracker.current()
				  }).charAt(0)
				: '';
		} else {
			after = safeOptions.after;
		}
		if (results.length > 0 && (before === '\r' || before === '\n') && child.type === 'html') {
			results[results.length - 1] = results[results.length - 1].replace(/(\r?\n|\r)$/, ' ');
			before = ' ';
			tracker = track(safeOptions);
			tracker.move(results.join(''));
		}
		results.push(
			tracker.move(
				context.handle(child, parent, context, {
					...tracker.current(),
					before,
					after
				})
			)
		);
		before = results[results.length - 1].slice(-1);
	}
	indexStack.pop();
	return results.join('');
}
var init_container_phrasing = __esm({
	'node_modules/mdast-util-to-markdown/lib/util/container-phrasing.js'() {
		init_track();
	}
});

// node_modules/mdast-util-to-markdown/lib/handle/emphasis.js
function emphasis(node, _, context, safeOptions) {
	const marker = checkEmphasis(context);
	const exit2 = context.enter('emphasis');
	const tracker = track(safeOptions);
	let value = tracker.move(marker);
	value += tracker.move(
		containerPhrasing(node, context, {
			before: value,
			after: marker,
			...tracker.current()
		})
	);
	value += tracker.move(marker);
	exit2();
	return value;
}
function emphasisPeek(_, _1, context) {
	return context.options.emphasis || '*';
}
var init_emphasis = __esm({
	'node_modules/mdast-util-to-markdown/lib/handle/emphasis.js'() {
		init_check_emphasis();
		init_container_phrasing();
		init_track();
		emphasis.peek = emphasisPeek;
	}
});

// node_modules/unist-util-is/index.js
function anyFactory(tests) {
	const checks3 = [];
	let index6 = -1;
	while (++index6 < tests.length) {
		checks3[index6] = convert(tests[index6]);
	}
	return castFactory(any);
	function any(...parameters) {
		let index7 = -1;
		while (++index7 < checks3.length) {
			if (checks3[index7].call(this, ...parameters)) return true;
		}
		return false;
	}
}
function propsFactory(check) {
	return castFactory(all5);
	function all5(node) {
		let key3;
		for (key3 in check) {
			if (node[key3] !== check[key3]) return false;
		}
		return true;
	}
}
function typeFactory(check) {
	return castFactory(type);
	function type(node) {
		return node && node.type === check;
	}
}
function castFactory(check) {
	return assertion;
	function assertion(...parameters) {
		return Boolean(check.call(this, ...parameters));
	}
}
function ok() {
	return true;
}
var convert;
var init_unist_util_is = __esm({
	'node_modules/unist-util-is/index.js'() {
		convert = function (test) {
			if (test === void 0 || test === null) {
				return ok;
			}
			if (typeof test === 'string') {
				return typeFactory(test);
			}
			if (typeof test === 'object') {
				return Array.isArray(test) ? anyFactory(test) : propsFactory(test);
			}
			if (typeof test === 'function') {
				return castFactory(test);
			}
			throw new Error('Expected function, string, or object as test');
		};
	}
});

// node_modules/mdast-util-to-markdown/node_modules/unist-util-visit-parents/color.js
function color(d) {
	return '\x1B[33m' + d + '\x1B[39m';
}
var init_color = __esm({
	'node_modules/mdast-util-to-markdown/node_modules/unist-util-visit-parents/color.js'() {}
});

// node_modules/mdast-util-to-markdown/node_modules/unist-util-visit-parents/index.js
function toResult(value) {
	if (Array.isArray(value)) {
		return value;
	}
	if (typeof value === 'number') {
		return [CONTINUE, value];
	}
	return [value];
}
var CONTINUE, SKIP, EXIT, visitParents;
var init_unist_util_visit_parents = __esm({
	'node_modules/mdast-util-to-markdown/node_modules/unist-util-visit-parents/index.js'() {
		init_unist_util_is();
		init_color();
		CONTINUE = true;
		SKIP = 'skip';
		EXIT = false;
		visitParents = function (tree, test, visitor, reverse) {
			if (typeof test === 'function' && typeof visitor !== 'function') {
				reverse = visitor;
				visitor = test;
				test = null;
			}
			const is = convert(test);
			const step = reverse ? -1 : 1;
			factory2(tree, null, [])();
			function factory2(node, index6, parents) {
				const value = typeof node === 'object' && node !== null ? node : {};
				let name;
				if (typeof value.type === 'string') {
					name =
						typeof value.tagName === 'string'
							? value.tagName
							: typeof value.name === 'string'
							? value.name
							: void 0;
					Object.defineProperty(visit4, 'name', {
						value: 'node (' + color(value.type + (name ? '<' + name + '>' : '')) + ')'
					});
				}
				return visit4;
				function visit4() {
					let result = [];
					let subresult;
					let offset;
					let grandparents;
					if (!test || is(node, index6, parents[parents.length - 1] || null)) {
						result = toResult(visitor(node, parents));
						if (result[0] === EXIT) {
							return result;
						}
					}
					if (node.children && result[0] !== SKIP) {
						offset = (reverse ? node.children.length : -1) + step;
						grandparents = parents.concat(node);
						while (offset > -1 && offset < node.children.length) {
							subresult = factory2(node.children[offset], offset, grandparents)();
							if (subresult[0] === EXIT) {
								return subresult;
							}
							offset = typeof subresult[1] === 'number' ? subresult[1] : offset + step;
						}
					}
					return result;
				}
			}
		};
	}
});

// node_modules/mdast-util-to-markdown/node_modules/unist-util-visit/index.js
var visit;
var init_unist_util_visit = __esm({
	'node_modules/mdast-util-to-markdown/node_modules/unist-util-visit/index.js'() {
		init_unist_util_visit_parents();
		visit = function (tree, test, visitor, reverse) {
			if (typeof test === 'function' && typeof visitor !== 'function') {
				reverse = visitor;
				visitor = test;
				test = null;
			}
			visitParents(tree, test, overload, reverse);
			function overload(node, parents) {
				const parent = parents[parents.length - 1];
				return visitor(node, parent ? parent.children.indexOf(node) : null, parent);
			}
		};
	}
});

// node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js
function formatHeadingAsSetext(node, context) {
	let literalWithBreak = false;
	visit(node, (node2) => {
		if (('value' in node2 && /\r?\n|\r/.test(node2.value)) || node2.type === 'break') {
			literalWithBreak = true;
			return EXIT;
		}
	});
	return Boolean(
		(!node.depth || node.depth < 3) &&
			toString(node) &&
			(context.options.setext || literalWithBreak)
	);
}
var init_format_heading_as_setext = __esm({
	'node_modules/mdast-util-to-markdown/lib/util/format-heading-as-setext.js'() {
		init_unist_util_visit();
		init_mdast_util_to_string();
	}
});

// node_modules/mdast-util-to-markdown/lib/handle/heading.js
function heading(node, _, context, safeOptions) {
	const rank = Math.max(Math.min(6, node.depth || 1), 1);
	const tracker = track(safeOptions);
	if (formatHeadingAsSetext(node, context)) {
		const exit3 = context.enter('headingSetext');
		const subexit2 = context.enter('phrasing');
		const value2 = containerPhrasing(node, context, {
			...tracker.current(),
			before: '\n',
			after: '\n'
		});
		subexit2();
		exit3();
		return (
			value2 +
			'\n' +
			(rank === 1 ? '=' : '-').repeat(
				value2.length - (Math.max(value2.lastIndexOf('\r'), value2.lastIndexOf('\n')) + 1)
			)
		);
	}
	const sequence = '#'.repeat(rank);
	const exit2 = context.enter('headingAtx');
	const subexit = context.enter('phrasing');
	tracker.move(sequence + ' ');
	let value = containerPhrasing(node, context, {
		before: '# ',
		after: '\n',
		...tracker.current()
	});
	if (/^[\t ]/.test(value)) {
		value = '&#x' + value.charCodeAt(0).toString(16).toUpperCase() + ';' + value.slice(1);
	}
	value = value ? sequence + ' ' + value : sequence;
	if (context.options.closeAtx) {
		value += ' ' + sequence;
	}
	subexit();
	exit2();
	return value;
}
var init_heading = __esm({
	'node_modules/mdast-util-to-markdown/lib/handle/heading.js'() {
		init_format_heading_as_setext();
		init_container_phrasing();
		init_track();
	}
});

// node_modules/mdast-util-to-markdown/lib/handle/html.js
function html(node) {
	return node.value || '';
}
function htmlPeek() {
	return '<';
}
var init_html = __esm({
	'node_modules/mdast-util-to-markdown/lib/handle/html.js'() {
		html.peek = htmlPeek;
	}
});

// node_modules/mdast-util-to-markdown/lib/handle/image.js
function image(node, _, context, safeOptions) {
	const quote = checkQuote(context);
	const suffix = quote === '"' ? 'Quote' : 'Apostrophe';
	const exit2 = context.enter('image');
	let subexit = context.enter('label');
	const tracker = track(safeOptions);
	let value = tracker.move('![');
	value += tracker.move(
		safe(context, node.alt, { before: value, after: ']', ...tracker.current() })
	);
	value += tracker.move('](');
	subexit();
	if ((!node.url && node.title) || /[\0- \u007F]/.test(node.url)) {
		subexit = context.enter('destinationLiteral');
		value += tracker.move('<');
		value += tracker.move(
			safe(context, node.url, { before: value, after: '>', ...tracker.current() })
		);
		value += tracker.move('>');
	} else {
		subexit = context.enter('destinationRaw');
		value += tracker.move(
			safe(context, node.url, {
				before: value,
				after: node.title ? ' ' : ')',
				...tracker.current()
			})
		);
	}
	subexit();
	if (node.title) {
		subexit = context.enter('title' + suffix);
		value += tracker.move(' ' + quote);
		value += tracker.move(
			safe(context, node.title, {
				before: value,
				after: quote,
				...tracker.current()
			})
		);
		value += tracker.move(quote);
		subexit();
	}
	value += tracker.move(')');
	exit2();
	return value;
}
function imagePeek() {
	return '!';
}
var init_image = __esm({
	'node_modules/mdast-util-to-markdown/lib/handle/image.js'() {
		init_check_quote();
		init_safe();
		init_track();
		image.peek = imagePeek;
	}
});

// node_modules/mdast-util-to-markdown/lib/handle/image-reference.js
function imageReference(node, _, context, safeOptions) {
	const type = node.referenceType;
	const exit2 = context.enter('imageReference');
	let subexit = context.enter('label');
	const tracker = track(safeOptions);
	let value = tracker.move('![');
	const alt = safe(context, node.alt, {
		before: value,
		after: ']',
		...tracker.current()
	});
	value += tracker.move(alt + '][');
	subexit();
	const stack = context.stack;
	context.stack = [];
	subexit = context.enter('reference');
	const reference = safe(context, association(node), {
		before: value,
		after: ']',
		...tracker.current()
	});
	subexit();
	context.stack = stack;
	exit2();
	if (type === 'full' || !alt || alt !== reference) {
		value += tracker.move(reference + ']');
	} else if (type === 'shortcut') {
		value = value.slice(0, -1);
	} else {
		value += tracker.move(']');
	}
	return value;
}
function imageReferencePeek() {
	return '!';
}
var init_image_reference = __esm({
	'node_modules/mdast-util-to-markdown/lib/handle/image-reference.js'() {
		init_association();
		init_safe();
		init_track();
		imageReference.peek = imageReferencePeek;
	}
});

// node_modules/mdast-util-to-markdown/lib/handle/inline-code.js
function inlineCode(node, _, context) {
	let value = node.value || '';
	let sequence = '`';
	let index6 = -1;
	while (new RegExp('(^|[^`])' + sequence + '([^`]|$)').test(value)) {
		sequence += '`';
	}
	if (
		/[^ \r\n]/.test(value) &&
		((/^[ \r\n]/.test(value) && /[ \r\n]$/.test(value)) || /^`|`$/.test(value))
	) {
		value = ' ' + value + ' ';
	}
	while (++index6 < context.unsafe.length) {
		const pattern = context.unsafe[index6];
		const expression = patternCompile(pattern);
		let match;
		if (!pattern.atBreak) continue;
		while ((match = expression.exec(value))) {
			let position3 = match.index;
			if (value.charCodeAt(position3) === 10 && value.charCodeAt(position3 - 1) === 13) {
				position3--;
			}
			value = value.slice(0, position3) + ' ' + value.slice(match.index + 1);
		}
	}
	return sequence + value + sequence;
}
function inlineCodePeek() {
	return '`';
}
var init_inline_code = __esm({
	'node_modules/mdast-util-to-markdown/lib/handle/inline-code.js'() {
		init_pattern_compile();
		inlineCode.peek = inlineCodePeek;
	}
});

// node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js
function formatLinkAsAutolink(node, context) {
	const raw2 = toString(node);
	return Boolean(
		!context.options.resourceLink &&
			node.url &&
			!node.title &&
			node.children &&
			node.children.length === 1 &&
			node.children[0].type === 'text' &&
			(raw2 === node.url || 'mailto:' + raw2 === node.url) &&
			/^[a-z][a-z+.-]+:/i.test(node.url) &&
			!/[\0- <>\u007F]/.test(node.url)
	);
}
var init_format_link_as_autolink = __esm({
	'node_modules/mdast-util-to-markdown/lib/util/format-link-as-autolink.js'() {
		init_mdast_util_to_string();
	}
});

// node_modules/mdast-util-to-markdown/lib/handle/link.js
function link(node, _, context, safeOptions) {
	const quote = checkQuote(context);
	const suffix = quote === '"' ? 'Quote' : 'Apostrophe';
	const tracker = track(safeOptions);
	let exit2;
	let subexit;
	if (formatLinkAsAutolink(node, context)) {
		const stack = context.stack;
		context.stack = [];
		exit2 = context.enter('autolink');
		let value2 = tracker.move('<');
		value2 += tracker.move(
			containerPhrasing(node, context, {
				before: value2,
				after: '>',
				...tracker.current()
			})
		);
		value2 += tracker.move('>');
		exit2();
		context.stack = stack;
		return value2;
	}
	exit2 = context.enter('link');
	subexit = context.enter('label');
	let value = tracker.move('[');
	value += tracker.move(
		containerPhrasing(node, context, {
			before: value,
			after: '](',
			...tracker.current()
		})
	);
	value += tracker.move('](');
	subexit();
	if ((!node.url && node.title) || /[\0- \u007F]/.test(node.url)) {
		subexit = context.enter('destinationLiteral');
		value += tracker.move('<');
		value += tracker.move(
			safe(context, node.url, { before: value, after: '>', ...tracker.current() })
		);
		value += tracker.move('>');
	} else {
		subexit = context.enter('destinationRaw');
		value += tracker.move(
			safe(context, node.url, {
				before: value,
				after: node.title ? ' ' : ')',
				...tracker.current()
			})
		);
	}
	subexit();
	if (node.title) {
		subexit = context.enter('title' + suffix);
		value += tracker.move(' ' + quote);
		value += tracker.move(
			safe(context, node.title, {
				before: value,
				after: quote,
				...tracker.current()
			})
		);
		value += tracker.move(quote);
		subexit();
	}
	value += tracker.move(')');
	exit2();
	return value;
}
function linkPeek(node, _, context) {
	return formatLinkAsAutolink(node, context) ? '<' : '[';
}
var init_link = __esm({
	'node_modules/mdast-util-to-markdown/lib/handle/link.js'() {
		init_check_quote();
		init_format_link_as_autolink();
		init_container_phrasing();
		init_safe();
		init_track();
		link.peek = linkPeek;
	}
});

// node_modules/mdast-util-to-markdown/lib/handle/link-reference.js
function linkReference(node, _, context, safeOptions) {
	const type = node.referenceType;
	const exit2 = context.enter('linkReference');
	let subexit = context.enter('label');
	const tracker = track(safeOptions);
	let value = tracker.move('[');
	const text7 = containerPhrasing(node, context, {
		before: value,
		after: ']',
		...tracker.current()
	});
	value += tracker.move(text7 + '][');
	subexit();
	const stack = context.stack;
	context.stack = [];
	subexit = context.enter('reference');
	const reference = safe(context, association(node), {
		before: value,
		after: ']',
		...tracker.current()
	});
	subexit();
	context.stack = stack;
	exit2();
	if (type === 'full' || !text7 || text7 !== reference) {
		value += tracker.move(reference + ']');
	} else if (type === 'shortcut') {
		value = value.slice(0, -1);
	} else {
		value += tracker.move(']');
	}
	return value;
}
function linkReferencePeek() {
	return '[';
}
var init_link_reference = __esm({
	'node_modules/mdast-util-to-markdown/lib/handle/link-reference.js'() {
		init_association();
		init_container_phrasing();
		init_safe();
		init_track();
		linkReference.peek = linkReferencePeek;
	}
});

// node_modules/mdast-util-to-markdown/lib/util/check-bullet.js
function checkBullet(context) {
	const marker = context.options.bullet || '*';
	if (marker !== '*' && marker !== '+' && marker !== '-') {
		throw new Error(
			'Cannot serialize items with `' + marker + '` for `options.bullet`, expected `*`, `+`, or `-`'
		);
	}
	return marker;
}
var init_check_bullet = __esm({
	'node_modules/mdast-util-to-markdown/lib/util/check-bullet.js'() {}
});

// node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js
function checkBulletOther(context) {
	const bullet = checkBullet(context);
	const bulletOther = context.options.bulletOther;
	if (!bulletOther) {
		return bullet === '*' ? '-' : '*';
	}
	if (bulletOther !== '*' && bulletOther !== '+' && bulletOther !== '-') {
		throw new Error(
			'Cannot serialize items with `' +
				bulletOther +
				'` for `options.bulletOther`, expected `*`, `+`, or `-`'
		);
	}
	if (bulletOther === bullet) {
		throw new Error(
			'Expected `bullet` (`' +
				bullet +
				'`) and `bulletOther` (`' +
				bulletOther +
				'`) to be different'
		);
	}
	return bulletOther;
}
var init_check_bullet_other = __esm({
	'node_modules/mdast-util-to-markdown/lib/util/check-bullet-other.js'() {
		init_check_bullet();
	}
});

// node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js
function checkBulletOrdered(context) {
	const marker = context.options.bulletOrdered || '.';
	if (marker !== '.' && marker !== ')') {
		throw new Error(
			'Cannot serialize items with `' +
				marker +
				'` for `options.bulletOrdered`, expected `.` or `)`'
		);
	}
	return marker;
}
var init_check_bullet_ordered = __esm({
	'node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered.js'() {}
});

// node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered-other.js
function checkBulletOrderedOther(context) {
	const bulletOrdered = checkBulletOrdered(context);
	const bulletOrderedOther = context.options.bulletOrderedOther;
	if (!bulletOrderedOther) {
		return bulletOrdered === '.' ? ')' : '.';
	}
	if (bulletOrderedOther !== '.' && bulletOrderedOther !== ')') {
		throw new Error(
			'Cannot serialize items with `' +
				bulletOrderedOther +
				'` for `options.bulletOrderedOther`, expected `*`, `+`, or `-`'
		);
	}
	if (bulletOrderedOther === bulletOrdered) {
		throw new Error(
			'Expected `bulletOrdered` (`' +
				bulletOrdered +
				'`) and `bulletOrderedOther` (`' +
				bulletOrderedOther +
				'`) to be different'
		);
	}
	return bulletOrderedOther;
}
var init_check_bullet_ordered_other = __esm({
	'node_modules/mdast-util-to-markdown/lib/util/check-bullet-ordered-other.js'() {
		init_check_bullet_ordered();
	}
});

// node_modules/mdast-util-to-markdown/lib/util/check-rule.js
function checkRule(context) {
	const marker = context.options.rule || '*';
	if (marker !== '*' && marker !== '-' && marker !== '_') {
		throw new Error(
			'Cannot serialize rules with `' + marker + '` for `options.rule`, expected `*`, `-`, or `_`'
		);
	}
	return marker;
}
var init_check_rule = __esm({
	'node_modules/mdast-util-to-markdown/lib/util/check-rule.js'() {}
});

// node_modules/mdast-util-to-markdown/lib/handle/list.js
function list2(node, parent, context, safeOptions) {
	const exit2 = context.enter('list');
	const bulletCurrent = context.bulletCurrent;
	let bullet = node.ordered ? checkBulletOrdered(context) : checkBullet(context);
	const bulletOther = node.ordered ? checkBulletOrderedOther(context) : checkBulletOther(context);
	const bulletLastUsed = context.bulletLastUsed;
	let useDifferentMarker = false;
	if (
		parent &&
		(node.ordered ? context.options.bulletOrderedOther : context.options.bulletOther) &&
		bulletLastUsed &&
		bullet === bulletLastUsed
	) {
		useDifferentMarker = true;
	}
	if (!node.ordered) {
		const firstListItem = node.children ? node.children[0] : void 0;
		if (
			(bullet === '*' || bullet === '-') &&
			firstListItem &&
			(!firstListItem.children || !firstListItem.children[0]) &&
			context.stack[context.stack.length - 1] === 'list' &&
			context.stack[context.stack.length - 2] === 'listItem' &&
			context.stack[context.stack.length - 3] === 'list' &&
			context.stack[context.stack.length - 4] === 'listItem' &&
			context.indexStack[context.indexStack.length - 1] === 0 &&
			context.indexStack[context.indexStack.length - 2] === 0 &&
			context.indexStack[context.indexStack.length - 3] === 0
		) {
			useDifferentMarker = true;
		}
		if (checkRule(context) === bullet && firstListItem) {
			let index6 = -1;
			while (++index6 < node.children.length) {
				const item = node.children[index6];
				if (
					item &&
					item.type === 'listItem' &&
					item.children &&
					item.children[0] &&
					item.children[0].type === 'thematicBreak'
				) {
					useDifferentMarker = true;
					break;
				}
			}
		}
	}
	if (useDifferentMarker) {
		bullet = bulletOther;
	}
	context.bulletCurrent = bullet;
	const value = containerFlow(node, context, safeOptions);
	context.bulletLastUsed = bullet;
	context.bulletCurrent = bulletCurrent;
	exit2();
	return value;
}
var init_list2 = __esm({
	'node_modules/mdast-util-to-markdown/lib/handle/list.js'() {
		init_container_flow();
		init_check_bullet();
		init_check_bullet_other();
		init_check_bullet_ordered();
		init_check_bullet_ordered_other();
		init_check_rule();
	}
});

// node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js
function checkListItemIndent(context) {
	const style2 = context.options.listItemIndent || 'tab';
	if (style2 === 1 || style2 === '1') {
		return 'one';
	}
	if (style2 !== 'tab' && style2 !== 'one' && style2 !== 'mixed') {
		throw new Error(
			'Cannot serialize items with `' +
				style2 +
				'` for `options.listItemIndent`, expected `tab`, `one`, or `mixed`'
		);
	}
	return style2;
}
var init_check_list_item_indent = __esm({
	'node_modules/mdast-util-to-markdown/lib/util/check-list-item-indent.js'() {}
});

// node_modules/mdast-util-to-markdown/lib/handle/list-item.js
function listItem(node, parent, context, safeOptions) {
	const listItemIndent = checkListItemIndent(context);
	let bullet = context.bulletCurrent || checkBullet(context);
	if (parent && parent.type === 'list' && parent.ordered) {
		bullet =
			(typeof parent.start === 'number' && parent.start > -1 ? parent.start : 1) +
			(context.options.incrementListMarker === false ? 0 : parent.children.indexOf(node)) +
			bullet;
	}
	let size = bullet.length + 1;
	if (
		listItemIndent === 'tab' ||
		(listItemIndent === 'mixed' &&
			((parent && parent.type === 'list' && parent.spread) || node.spread))
	) {
		size = Math.ceil(size / 4) * 4;
	}
	const tracker = track(safeOptions);
	tracker.move(bullet + ' '.repeat(size - bullet.length));
	tracker.shift(size);
	const exit2 = context.enter('listItem');
	const value = indentLines(containerFlow(node, context, tracker.current()), map4);
	exit2();
	return value;
	function map4(line, index6, blank) {
		if (index6) {
			return (blank ? '' : ' '.repeat(size)) + line;
		}
		return (blank ? bullet : bullet + ' '.repeat(size - bullet.length)) + line;
	}
}
var init_list_item = __esm({
	'node_modules/mdast-util-to-markdown/lib/handle/list-item.js'() {
		init_check_bullet();
		init_check_list_item_indent();
		init_container_flow();
		init_indent_lines();
		init_track();
	}
});

// node_modules/mdast-util-to-markdown/lib/handle/paragraph.js
function paragraph(node, _, context, safeOptions) {
	const exit2 = context.enter('paragraph');
	const subexit = context.enter('phrasing');
	const value = containerPhrasing(node, context, safeOptions);
	subexit();
	exit2();
	return value;
}
var init_paragraph = __esm({
	'node_modules/mdast-util-to-markdown/lib/handle/paragraph.js'() {
		init_container_phrasing();
	}
});

// node_modules/mdast-util-to-markdown/lib/handle/root.js
function root(node, _, context, safeOptions) {
	return containerFlow(node, context, safeOptions);
}
var init_root = __esm({
	'node_modules/mdast-util-to-markdown/lib/handle/root.js'() {
		init_container_flow();
	}
});

// node_modules/mdast-util-to-markdown/lib/util/check-strong.js
function checkStrong(context) {
	const marker = context.options.strong || '*';
	if (marker !== '*' && marker !== '_') {
		throw new Error(
			'Cannot serialize strong with `' + marker + '` for `options.strong`, expected `*`, or `_`'
		);
	}
	return marker;
}
var init_check_strong = __esm({
	'node_modules/mdast-util-to-markdown/lib/util/check-strong.js'() {}
});

// node_modules/mdast-util-to-markdown/lib/handle/strong.js
function strong(node, _, context, safeOptions) {
	const marker = checkStrong(context);
	const exit2 = context.enter('strong');
	const tracker = track(safeOptions);
	let value = tracker.move(marker + marker);
	value += tracker.move(
		containerPhrasing(node, context, {
			before: value,
			after: marker,
			...tracker.current()
		})
	);
	value += tracker.move(marker + marker);
	exit2();
	return value;
}
function strongPeek(_, _1, context) {
	return context.options.strong || '*';
}
var init_strong = __esm({
	'node_modules/mdast-util-to-markdown/lib/handle/strong.js'() {
		init_check_strong();
		init_container_phrasing();
		init_track();
		strong.peek = strongPeek;
	}
});

// node_modules/mdast-util-to-markdown/lib/handle/text.js
function text3(node, _, context, safeOptions) {
	return safe(context, node.value, safeOptions);
}
var init_text2 = __esm({
	'node_modules/mdast-util-to-markdown/lib/handle/text.js'() {
		init_safe();
	}
});

// node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js
function checkRuleRepetition(context) {
	const repetition = context.options.ruleRepetition || 3;
	if (repetition < 3) {
		throw new Error(
			'Cannot serialize rules with repetition `' +
				repetition +
				'` for `options.ruleRepetition`, expected `3` or more'
		);
	}
	return repetition;
}
var init_check_rule_repetition = __esm({
	'node_modules/mdast-util-to-markdown/lib/util/check-rule-repetition.js'() {}
});

// node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js
function thematicBreak2(_, _1, context) {
	const value = (checkRule(context) + (context.options.ruleSpaces ? ' ' : '')).repeat(
		checkRuleRepetition(context)
	);
	return context.options.ruleSpaces ? value.slice(0, -1) : value;
}
var init_thematic_break2 = __esm({
	'node_modules/mdast-util-to-markdown/lib/handle/thematic-break.js'() {
		init_check_rule_repetition();
		init_check_rule();
	}
});

// node_modules/mdast-util-to-markdown/lib/handle/index.js
var handle;
var init_handle = __esm({
	'node_modules/mdast-util-to-markdown/lib/handle/index.js'() {
		init_blockquote();
		init_break();
		init_code();
		init_definition2();
		init_emphasis();
		init_heading();
		init_html();
		init_image();
		init_image_reference();
		init_inline_code();
		init_link();
		init_link_reference();
		init_list2();
		init_list_item();
		init_paragraph();
		init_root();
		init_strong();
		init_text2();
		init_thematic_break2();
		handle = {
			blockquote,
			break: hardBreak,
			code,
			definition: definition2,
			emphasis,
			hardBreak,
			heading,
			html,
			image,
			imageReference,
			inlineCode,
			link,
			linkReference,
			list: list2,
			listItem,
			paragraph,
			root,
			strong,
			text: text3,
			thematicBreak: thematicBreak2
		};
	}
});

// node_modules/mdast-util-to-markdown/lib/join.js
function joinDefaults(left, right, parent, context) {
	if (
		right.type === 'code' &&
		formatCodeAsIndented(right, context) &&
		(left.type === 'list' || (left.type === right.type && formatCodeAsIndented(left, context)))
	) {
		return false;
	}
	if (
		left.type === 'list' &&
		left.type === right.type &&
		Boolean(left.ordered) === Boolean(right.ordered) &&
		!(left.ordered ? context.options.bulletOrderedOther : context.options.bulletOther)
	) {
		return false;
	}
	if ('spread' in parent && typeof parent.spread === 'boolean') {
		if (
			left.type === 'paragraph' &&
			(left.type === right.type ||
				right.type === 'definition' ||
				(right.type === 'heading' && formatHeadingAsSetext(right, context)))
		) {
			return;
		}
		return parent.spread ? 1 : 0;
	}
}
var join;
var init_join = __esm({
	'node_modules/mdast-util-to-markdown/lib/join.js'() {
		init_format_code_as_indented();
		init_format_heading_as_setext();
		join = [joinDefaults];
	}
});

// node_modules/mdast-util-to-markdown/lib/unsafe.js
var fullPhrasingSpans, unsafe;
var init_unsafe = __esm({
	'node_modules/mdast-util-to-markdown/lib/unsafe.js'() {
		fullPhrasingSpans = [
			'autolink',
			'destinationLiteral',
			'destinationRaw',
			'reference',
			'titleQuote',
			'titleApostrophe'
		];
		unsafe = [
			{ character: '	', after: '[\\r\\n]', inConstruct: 'phrasing' },
			{ character: '	', before: '[\\r\\n]', inConstruct: 'phrasing' },
			{
				character: '	',
				inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']
			},
			{
				character: '\r',
				inConstruct: [
					'codeFencedLangGraveAccent',
					'codeFencedLangTilde',
					'codeFencedMetaGraveAccent',
					'codeFencedMetaTilde',
					'destinationLiteral',
					'headingAtx'
				]
			},
			{
				character: '\n',
				inConstruct: [
					'codeFencedLangGraveAccent',
					'codeFencedLangTilde',
					'codeFencedMetaGraveAccent',
					'codeFencedMetaTilde',
					'destinationLiteral',
					'headingAtx'
				]
			},
			{ character: ' ', after: '[\\r\\n]', inConstruct: 'phrasing' },
			{ character: ' ', before: '[\\r\\n]', inConstruct: 'phrasing' },
			{
				character: ' ',
				inConstruct: ['codeFencedLangGraveAccent', 'codeFencedLangTilde']
			},
			{
				character: '!',
				after: '\\[',
				inConstruct: 'phrasing',
				notInConstruct: fullPhrasingSpans
			},
			{ character: '"', inConstruct: 'titleQuote' },
			{ atBreak: true, character: '#' },
			{ character: '#', inConstruct: 'headingAtx', after: '(?:[\r\n]|$)' },
			{ character: '&', after: '[#A-Za-z]', inConstruct: 'phrasing' },
			{ character: "'", inConstruct: 'titleApostrophe' },
			{ character: '(', inConstruct: 'destinationRaw' },
			{
				before: '\\]',
				character: '(',
				inConstruct: 'phrasing',
				notInConstruct: fullPhrasingSpans
			},
			{ atBreak: true, before: '\\d+', character: ')' },
			{ character: ')', inConstruct: 'destinationRaw' },
			{ atBreak: true, character: '*' },
			{ character: '*', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans },
			{ atBreak: true, character: '+' },
			{ atBreak: true, character: '-' },
			{ atBreak: true, before: '\\d+', character: '.', after: '(?:[ 	\r\n]|$)' },
			{ atBreak: true, character: '<', after: '[!/?A-Za-z]' },
			{
				character: '<',
				after: '[!/?A-Za-z]',
				inConstruct: 'phrasing',
				notInConstruct: fullPhrasingSpans
			},
			{ character: '<', inConstruct: 'destinationLiteral' },
			{ atBreak: true, character: '=' },
			{ atBreak: true, character: '>' },
			{ character: '>', inConstruct: 'destinationLiteral' },
			{ atBreak: true, character: '[' },
			{ character: '[', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans },
			{ character: '[', inConstruct: ['label', 'reference'] },
			{ character: '\\', after: '[\\r\\n]', inConstruct: 'phrasing' },
			{ character: ']', inConstruct: ['label', 'reference'] },
			{ atBreak: true, character: '_' },
			{ character: '_', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans },
			{ atBreak: true, character: '`' },
			{
				character: '`',
				inConstruct: ['codeFencedLangGraveAccent', 'codeFencedMetaGraveAccent']
			},
			{ character: '`', inConstruct: 'phrasing', notInConstruct: fullPhrasingSpans },
			{ atBreak: true, character: '~' }
		];
	}
});

// node_modules/mdast-util-to-markdown/lib/index.js
function toMarkdown(tree, options = {}) {
	const context = {
		enter,
		stack: [],
		unsafe: [],
		join: [],
		handlers: {},
		options: {},
		indexStack: []
	};
	configure2(context, { unsafe, join, handlers: handle });
	configure2(context, options);
	if (context.options.tightDefinitions) {
		configure2(context, { join: [joinDefinition] });
	}
	context.handle = zwitch('type', {
		invalid,
		unknown,
		handlers: context.handlers
	});
	let result = context.handle(tree, null, context, {
		before: '\n',
		after: '\n',
		now: { line: 1, column: 1 },
		lineShift: 0
	});
	if (
		result &&
		result.charCodeAt(result.length - 1) !== 10 &&
		result.charCodeAt(result.length - 1) !== 13
	) {
		result += '\n';
	}
	return result;
	function enter(name) {
		context.stack.push(name);
		return exit2;
		function exit2() {
			context.stack.pop();
		}
	}
}
function invalid(value) {
	throw new Error('Cannot handle value `' + value + '`, expected node');
}
function unknown(node) {
	throw new Error('Cannot handle unknown node `' + node.type + '`');
}
function joinDefinition(left, right) {
	if (left.type === 'definition' && left.type === right.type) {
		return 0;
	}
}
var init_lib5 = __esm({
	'node_modules/mdast-util-to-markdown/lib/index.js'() {
		init_zwitch();
		init_configure();
		init_handle();
		init_join();
		init_unsafe();
	}
});

// node_modules/mdast-util-to-markdown/index.js
var init_mdast_util_to_markdown = __esm({
	'node_modules/mdast-util-to-markdown/index.js'() {
		init_lib5();
	}
});

// node_modules/remark-stringify/lib/index.js
function remarkStringify(options) {
	const compiler2 = (tree) => {
		const settings = this.data('settings');
		return toMarkdown(
			tree,
			Object.assign({}, settings, options, {
				extensions: this.data('toMarkdownExtensions') || []
			})
		);
	};
	Object.assign(this, { Compiler: compiler2 });
}
var init_lib6 = __esm({
	'node_modules/remark-stringify/lib/index.js'() {
		init_mdast_util_to_markdown();
	}
});

// node_modules/remark-stringify/index.js
var remark_stringify_default;
var init_remark_stringify = __esm({
	'node_modules/remark-stringify/index.js'() {
		init_lib6();
		remark_stringify_default = remarkStringify;
	}
});

// node_modules/remark/index.js
var remark;
var init_remark = __esm({
	'node_modules/remark/index.js'() {
		init_unified();
		init_remark_parse();
		init_remark_stringify();
		remark = unified().use(remark_parse_default).use(remark_stringify_default).freeze();
	}
});

// node_modules/hast-util-to-html/node_modules/property-information/lib/util/schema.js
var Schema;
var init_schema = __esm({
	'node_modules/hast-util-to-html/node_modules/property-information/lib/util/schema.js'() {
		Schema = class {
			constructor(property, normal, space) {
				this.property = property;
				this.normal = normal;
				if (space) {
					this.space = space;
				}
			}
		};
		Schema.prototype.property = {};
		Schema.prototype.normal = {};
		Schema.prototype.space = null;
	}
});

// node_modules/hast-util-to-html/node_modules/property-information/lib/util/merge.js
function merge(definitions2, space) {
	const property = {};
	const normal = {};
	let index6 = -1;
	while (++index6 < definitions2.length) {
		Object.assign(property, definitions2[index6].property);
		Object.assign(normal, definitions2[index6].normal);
	}
	return new Schema(property, normal, space);
}
var init_merge = __esm({
	'node_modules/hast-util-to-html/node_modules/property-information/lib/util/merge.js'() {
		init_schema();
	}
});

// node_modules/hast-util-to-html/node_modules/property-information/lib/normalize.js
function normalize2(value) {
	return value.toLowerCase();
}
var init_normalize = __esm({
	'node_modules/hast-util-to-html/node_modules/property-information/lib/normalize.js'() {}
});

// node_modules/hast-util-to-html/node_modules/property-information/lib/util/info.js
var Info;
var init_info = __esm({
	'node_modules/hast-util-to-html/node_modules/property-information/lib/util/info.js'() {
		Info = class {
			constructor(property, attribute) {
				this.property = property;
				this.attribute = attribute;
			}
		};
		Info.prototype.space = null;
		Info.prototype.boolean = false;
		Info.prototype.booleanish = false;
		Info.prototype.overloadedBoolean = false;
		Info.prototype.number = false;
		Info.prototype.commaSeparated = false;
		Info.prototype.spaceSeparated = false;
		Info.prototype.commaOrSpaceSeparated = false;
		Info.prototype.mustUseProperty = false;
		Info.prototype.defined = false;
	}
});

// node_modules/hast-util-to-html/node_modules/property-information/lib/util/types.js
var types_exports = {};
__export(types_exports, {
	boolean: () => boolean,
	booleanish: () => booleanish,
	commaOrSpaceSeparated: () => commaOrSpaceSeparated,
	commaSeparated: () => commaSeparated,
	number: () => number,
	overloadedBoolean: () => overloadedBoolean,
	spaceSeparated: () => spaceSeparated
});
function increment() {
	return 2 ** ++powers;
}
var powers,
	boolean,
	booleanish,
	overloadedBoolean,
	number,
	spaceSeparated,
	commaSeparated,
	commaOrSpaceSeparated;
var init_types = __esm({
	'node_modules/hast-util-to-html/node_modules/property-information/lib/util/types.js'() {
		powers = 0;
		boolean = increment();
		booleanish = increment();
		overloadedBoolean = increment();
		number = increment();
		spaceSeparated = increment();
		commaSeparated = increment();
		commaOrSpaceSeparated = increment();
	}
});

// node_modules/hast-util-to-html/node_modules/property-information/lib/util/defined-info.js
function mark(values, key3, value) {
	if (value) {
		values[key3] = value;
	}
}
var checks, DefinedInfo;
var init_defined_info = __esm({
	'node_modules/hast-util-to-html/node_modules/property-information/lib/util/defined-info.js'() {
		init_info();
		init_types();
		checks = Object.keys(types_exports);
		DefinedInfo = class extends Info {
			constructor(property, attribute, mask, space) {
				let index6 = -1;
				super(property, attribute);
				mark(this, 'space', space);
				if (typeof mask === 'number') {
					while (++index6 < checks.length) {
						const check = checks[index6];
						mark(this, checks[index6], (mask & types_exports[check]) === types_exports[check]);
					}
				}
			}
		};
		DefinedInfo.prototype.defined = true;
	}
});

// node_modules/hast-util-to-html/node_modules/property-information/lib/util/create.js
function create(definition3) {
	const property = {};
	const normal = {};
	let prop;
	for (prop in definition3.properties) {
		if (own5.call(definition3.properties, prop)) {
			const value = definition3.properties[prop];
			const info = new DefinedInfo(
				prop,
				definition3.transform(definition3.attributes || {}, prop),
				value,
				definition3.space
			);
			if (definition3.mustUseProperty && definition3.mustUseProperty.includes(prop)) {
				info.mustUseProperty = true;
			}
			property[prop] = info;
			normal[normalize2(prop)] = prop;
			normal[normalize2(info.attribute)] = prop;
		}
	}
	return new Schema(property, normal, definition3.space);
}
var own5;
var init_create = __esm({
	'node_modules/hast-util-to-html/node_modules/property-information/lib/util/create.js'() {
		init_normalize();
		init_schema();
		init_defined_info();
		own5 = {}.hasOwnProperty;
	}
});

// node_modules/hast-util-to-html/node_modules/property-information/lib/xlink.js
var xlink;
var init_xlink = __esm({
	'node_modules/hast-util-to-html/node_modules/property-information/lib/xlink.js'() {
		init_create();
		xlink = create({
			space: 'xlink',
			transform(_, prop) {
				return 'xlink:' + prop.slice(5).toLowerCase();
			},
			properties: {
				xLinkActuate: null,
				xLinkArcRole: null,
				xLinkHref: null,
				xLinkRole: null,
				xLinkShow: null,
				xLinkTitle: null,
				xLinkType: null
			}
		});
	}
});

// node_modules/hast-util-to-html/node_modules/property-information/lib/xml.js
var xml;
var init_xml = __esm({
	'node_modules/hast-util-to-html/node_modules/property-information/lib/xml.js'() {
		init_create();
		xml = create({
			space: 'xml',
			transform(_, prop) {
				return 'xml:' + prop.slice(3).toLowerCase();
			},
			properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
		});
	}
});

// node_modules/hast-util-to-html/node_modules/property-information/lib/util/case-sensitive-transform.js
function caseSensitiveTransform(attributes, attribute) {
	return attribute in attributes ? attributes[attribute] : attribute;
}
var init_case_sensitive_transform = __esm({
	'node_modules/hast-util-to-html/node_modules/property-information/lib/util/case-sensitive-transform.js'() {}
});

// node_modules/hast-util-to-html/node_modules/property-information/lib/util/case-insensitive-transform.js
function caseInsensitiveTransform(attributes, property) {
	return caseSensitiveTransform(attributes, property.toLowerCase());
}
var init_case_insensitive_transform = __esm({
	'node_modules/hast-util-to-html/node_modules/property-information/lib/util/case-insensitive-transform.js'() {
		init_case_sensitive_transform();
	}
});

// node_modules/hast-util-to-html/node_modules/property-information/lib/xmlns.js
var xmlns;
var init_xmlns = __esm({
	'node_modules/hast-util-to-html/node_modules/property-information/lib/xmlns.js'() {
		init_create();
		init_case_insensitive_transform();
		xmlns = create({
			space: 'xmlns',
			attributes: { xmlnsxlink: 'xmlns:xlink' },
			transform: caseInsensitiveTransform,
			properties: { xmlns: null, xmlnsXLink: null }
		});
	}
});

// node_modules/hast-util-to-html/node_modules/property-information/lib/aria.js
var aria;
var init_aria = __esm({
	'node_modules/hast-util-to-html/node_modules/property-information/lib/aria.js'() {
		init_types();
		init_create();
		aria = create({
			transform(_, prop) {
				return prop === 'role' ? prop : 'aria-' + prop.slice(4).toLowerCase();
			},
			properties: {
				ariaActiveDescendant: null,
				ariaAtomic: booleanish,
				ariaAutoComplete: null,
				ariaBusy: booleanish,
				ariaChecked: booleanish,
				ariaColCount: number,
				ariaColIndex: number,
				ariaColSpan: number,
				ariaControls: spaceSeparated,
				ariaCurrent: null,
				ariaDescribedBy: spaceSeparated,
				ariaDetails: null,
				ariaDisabled: booleanish,
				ariaDropEffect: spaceSeparated,
				ariaErrorMessage: null,
				ariaExpanded: booleanish,
				ariaFlowTo: spaceSeparated,
				ariaGrabbed: booleanish,
				ariaHasPopup: null,
				ariaHidden: booleanish,
				ariaInvalid: null,
				ariaKeyShortcuts: null,
				ariaLabel: null,
				ariaLabelledBy: spaceSeparated,
				ariaLevel: number,
				ariaLive: null,
				ariaModal: booleanish,
				ariaMultiLine: booleanish,
				ariaMultiSelectable: booleanish,
				ariaOrientation: null,
				ariaOwns: spaceSeparated,
				ariaPlaceholder: null,
				ariaPosInSet: number,
				ariaPressed: booleanish,
				ariaReadOnly: booleanish,
				ariaRelevant: null,
				ariaRequired: booleanish,
				ariaRoleDescription: spaceSeparated,
				ariaRowCount: number,
				ariaRowIndex: number,
				ariaRowSpan: number,
				ariaSelected: booleanish,
				ariaSetSize: number,
				ariaSort: null,
				ariaValueMax: number,
				ariaValueMin: number,
				ariaValueNow: number,
				ariaValueText: null,
				role: null
			}
		});
	}
});

// node_modules/hast-util-to-html/node_modules/property-information/lib/html.js
var html2;
var init_html2 = __esm({
	'node_modules/hast-util-to-html/node_modules/property-information/lib/html.js'() {
		init_types();
		init_create();
		init_case_insensitive_transform();
		html2 = create({
			space: 'html',
			attributes: {
				acceptcharset: 'accept-charset',
				classname: 'class',
				htmlfor: 'for',
				httpequiv: 'http-equiv'
			},
			transform: caseInsensitiveTransform,
			mustUseProperty: ['checked', 'multiple', 'muted', 'selected'],
			properties: {
				abbr: null,
				accept: commaSeparated,
				acceptCharset: spaceSeparated,
				accessKey: spaceSeparated,
				action: null,
				allow: null,
				allowFullScreen: boolean,
				allowPaymentRequest: boolean,
				allowUserMedia: boolean,
				alt: null,
				as: null,
				async: boolean,
				autoCapitalize: null,
				autoComplete: spaceSeparated,
				autoFocus: boolean,
				autoPlay: boolean,
				capture: boolean,
				charSet: null,
				checked: boolean,
				cite: null,
				className: spaceSeparated,
				cols: number,
				colSpan: null,
				content: null,
				contentEditable: booleanish,
				controls: boolean,
				controlsList: spaceSeparated,
				coords: number | commaSeparated,
				crossOrigin: null,
				data: null,
				dateTime: null,
				decoding: null,
				default: boolean,
				defer: boolean,
				dir: null,
				dirName: null,
				disabled: boolean,
				download: overloadedBoolean,
				draggable: booleanish,
				encType: null,
				enterKeyHint: null,
				form: null,
				formAction: null,
				formEncType: null,
				formMethod: null,
				formNoValidate: boolean,
				formTarget: null,
				headers: spaceSeparated,
				height: number,
				hidden: boolean,
				high: number,
				href: null,
				hrefLang: null,
				htmlFor: spaceSeparated,
				httpEquiv: spaceSeparated,
				id: null,
				imageSizes: null,
				imageSrcSet: null,
				inputMode: null,
				integrity: null,
				is: null,
				isMap: boolean,
				itemId: null,
				itemProp: spaceSeparated,
				itemRef: spaceSeparated,
				itemScope: boolean,
				itemType: spaceSeparated,
				kind: null,
				label: null,
				lang: null,
				language: null,
				list: null,
				loading: null,
				loop: boolean,
				low: number,
				manifest: null,
				max: null,
				maxLength: number,
				media: null,
				method: null,
				min: null,
				minLength: number,
				multiple: boolean,
				muted: boolean,
				name: null,
				nonce: null,
				noModule: boolean,
				noValidate: boolean,
				onAbort: null,
				onAfterPrint: null,
				onAuxClick: null,
				onBeforePrint: null,
				onBeforeUnload: null,
				onBlur: null,
				onCancel: null,
				onCanPlay: null,
				onCanPlayThrough: null,
				onChange: null,
				onClick: null,
				onClose: null,
				onContextLost: null,
				onContextMenu: null,
				onContextRestored: null,
				onCopy: null,
				onCueChange: null,
				onCut: null,
				onDblClick: null,
				onDrag: null,
				onDragEnd: null,
				onDragEnter: null,
				onDragExit: null,
				onDragLeave: null,
				onDragOver: null,
				onDragStart: null,
				onDrop: null,
				onDurationChange: null,
				onEmptied: null,
				onEnded: null,
				onError: null,
				onFocus: null,
				onFormData: null,
				onHashChange: null,
				onInput: null,
				onInvalid: null,
				onKeyDown: null,
				onKeyPress: null,
				onKeyUp: null,
				onLanguageChange: null,
				onLoad: null,
				onLoadedData: null,
				onLoadedMetadata: null,
				onLoadEnd: null,
				onLoadStart: null,
				onMessage: null,
				onMessageError: null,
				onMouseDown: null,
				onMouseEnter: null,
				onMouseLeave: null,
				onMouseMove: null,
				onMouseOut: null,
				onMouseOver: null,
				onMouseUp: null,
				onOffline: null,
				onOnline: null,
				onPageHide: null,
				onPageShow: null,
				onPaste: null,
				onPause: null,
				onPlay: null,
				onPlaying: null,
				onPopState: null,
				onProgress: null,
				onRateChange: null,
				onRejectionHandled: null,
				onReset: null,
				onResize: null,
				onScroll: null,
				onSecurityPolicyViolation: null,
				onSeeked: null,
				onSeeking: null,
				onSelect: null,
				onSlotChange: null,
				onStalled: null,
				onStorage: null,
				onSubmit: null,
				onSuspend: null,
				onTimeUpdate: null,
				onToggle: null,
				onUnhandledRejection: null,
				onUnload: null,
				onVolumeChange: null,
				onWaiting: null,
				onWheel: null,
				open: boolean,
				optimum: number,
				pattern: null,
				ping: spaceSeparated,
				placeholder: null,
				playsInline: boolean,
				poster: null,
				preload: null,
				readOnly: boolean,
				referrerPolicy: null,
				rel: spaceSeparated,
				required: boolean,
				reversed: boolean,
				rows: number,
				rowSpan: number,
				sandbox: spaceSeparated,
				scope: null,
				scoped: boolean,
				seamless: boolean,
				selected: boolean,
				shape: null,
				size: number,
				sizes: null,
				slot: null,
				span: number,
				spellCheck: booleanish,
				src: null,
				srcDoc: null,
				srcLang: null,
				srcSet: null,
				start: number,
				step: null,
				style: null,
				tabIndex: number,
				target: null,
				title: null,
				translate: null,
				type: null,
				typeMustMatch: boolean,
				useMap: null,
				value: booleanish,
				width: number,
				wrap: null,
				align: null,
				aLink: null,
				archive: spaceSeparated,
				axis: null,
				background: null,
				bgColor: null,
				border: number,
				borderColor: null,
				bottomMargin: number,
				cellPadding: null,
				cellSpacing: null,
				char: null,
				charOff: null,
				classId: null,
				clear: null,
				code: null,
				codeBase: null,
				codeType: null,
				color: null,
				compact: boolean,
				declare: boolean,
				event: null,
				face: null,
				frame: null,
				frameBorder: null,
				hSpace: number,
				leftMargin: number,
				link: null,
				longDesc: null,
				lowSrc: null,
				marginHeight: number,
				marginWidth: number,
				noResize: boolean,
				noHref: boolean,
				noShade: boolean,
				noWrap: boolean,
				object: null,
				profile: null,
				prompt: null,
				rev: null,
				rightMargin: number,
				rules: null,
				scheme: null,
				scrolling: booleanish,
				standby: null,
				summary: null,
				text: null,
				topMargin: number,
				valueType: null,
				version: null,
				vAlign: null,
				vLink: null,
				vSpace: number,
				allowTransparency: null,
				autoCorrect: null,
				autoSave: null,
				disablePictureInPicture: boolean,
				disableRemotePlayback: boolean,
				prefix: null,
				property: null,
				results: number,
				security: null,
				unselectable: null
			}
		});
	}
});

// node_modules/hast-util-to-html/node_modules/property-information/lib/svg.js
var svg;
var init_svg = __esm({
	'node_modules/hast-util-to-html/node_modules/property-information/lib/svg.js'() {
		init_types();
		init_create();
		init_case_sensitive_transform();
		svg = create({
			space: 'svg',
			attributes: {
				accentHeight: 'accent-height',
				alignmentBaseline: 'alignment-baseline',
				arabicForm: 'arabic-form',
				baselineShift: 'baseline-shift',
				capHeight: 'cap-height',
				className: 'class',
				clipPath: 'clip-path',
				clipRule: 'clip-rule',
				colorInterpolation: 'color-interpolation',
				colorInterpolationFilters: 'color-interpolation-filters',
				colorProfile: 'color-profile',
				colorRendering: 'color-rendering',
				crossOrigin: 'crossorigin',
				dataType: 'datatype',
				dominantBaseline: 'dominant-baseline',
				enableBackground: 'enable-background',
				fillOpacity: 'fill-opacity',
				fillRule: 'fill-rule',
				floodColor: 'flood-color',
				floodOpacity: 'flood-opacity',
				fontFamily: 'font-family',
				fontSize: 'font-size',
				fontSizeAdjust: 'font-size-adjust',
				fontStretch: 'font-stretch',
				fontStyle: 'font-style',
				fontVariant: 'font-variant',
				fontWeight: 'font-weight',
				glyphName: 'glyph-name',
				glyphOrientationHorizontal: 'glyph-orientation-horizontal',
				glyphOrientationVertical: 'glyph-orientation-vertical',
				hrefLang: 'hreflang',
				horizAdvX: 'horiz-adv-x',
				horizOriginX: 'horiz-origin-x',
				horizOriginY: 'horiz-origin-y',
				imageRendering: 'image-rendering',
				letterSpacing: 'letter-spacing',
				lightingColor: 'lighting-color',
				markerEnd: 'marker-end',
				markerMid: 'marker-mid',
				markerStart: 'marker-start',
				navDown: 'nav-down',
				navDownLeft: 'nav-down-left',
				navDownRight: 'nav-down-right',
				navLeft: 'nav-left',
				navNext: 'nav-next',
				navPrev: 'nav-prev',
				navRight: 'nav-right',
				navUp: 'nav-up',
				navUpLeft: 'nav-up-left',
				navUpRight: 'nav-up-right',
				onAbort: 'onabort',
				onActivate: 'onactivate',
				onAfterPrint: 'onafterprint',
				onBeforePrint: 'onbeforeprint',
				onBegin: 'onbegin',
				onCancel: 'oncancel',
				onCanPlay: 'oncanplay',
				onCanPlayThrough: 'oncanplaythrough',
				onChange: 'onchange',
				onClick: 'onclick',
				onClose: 'onclose',
				onCopy: 'oncopy',
				onCueChange: 'oncuechange',
				onCut: 'oncut',
				onDblClick: 'ondblclick',
				onDrag: 'ondrag',
				onDragEnd: 'ondragend',
				onDragEnter: 'ondragenter',
				onDragExit: 'ondragexit',
				onDragLeave: 'ondragleave',
				onDragOver: 'ondragover',
				onDragStart: 'ondragstart',
				onDrop: 'ondrop',
				onDurationChange: 'ondurationchange',
				onEmptied: 'onemptied',
				onEnd: 'onend',
				onEnded: 'onended',
				onError: 'onerror',
				onFocus: 'onfocus',
				onFocusIn: 'onfocusin',
				onFocusOut: 'onfocusout',
				onHashChange: 'onhashchange',
				onInput: 'oninput',
				onInvalid: 'oninvalid',
				onKeyDown: 'onkeydown',
				onKeyPress: 'onkeypress',
				onKeyUp: 'onkeyup',
				onLoad: 'onload',
				onLoadedData: 'onloadeddata',
				onLoadedMetadata: 'onloadedmetadata',
				onLoadStart: 'onloadstart',
				onMessage: 'onmessage',
				onMouseDown: 'onmousedown',
				onMouseEnter: 'onmouseenter',
				onMouseLeave: 'onmouseleave',
				onMouseMove: 'onmousemove',
				onMouseOut: 'onmouseout',
				onMouseOver: 'onmouseover',
				onMouseUp: 'onmouseup',
				onMouseWheel: 'onmousewheel',
				onOffline: 'onoffline',
				onOnline: 'ononline',
				onPageHide: 'onpagehide',
				onPageShow: 'onpageshow',
				onPaste: 'onpaste',
				onPause: 'onpause',
				onPlay: 'onplay',
				onPlaying: 'onplaying',
				onPopState: 'onpopstate',
				onProgress: 'onprogress',
				onRateChange: 'onratechange',
				onRepeat: 'onrepeat',
				onReset: 'onreset',
				onResize: 'onresize',
				onScroll: 'onscroll',
				onSeeked: 'onseeked',
				onSeeking: 'onseeking',
				onSelect: 'onselect',
				onShow: 'onshow',
				onStalled: 'onstalled',
				onStorage: 'onstorage',
				onSubmit: 'onsubmit',
				onSuspend: 'onsuspend',
				onTimeUpdate: 'ontimeupdate',
				onToggle: 'ontoggle',
				onUnload: 'onunload',
				onVolumeChange: 'onvolumechange',
				onWaiting: 'onwaiting',
				onZoom: 'onzoom',
				overlinePosition: 'overline-position',
				overlineThickness: 'overline-thickness',
				paintOrder: 'paint-order',
				panose1: 'panose-1',
				pointerEvents: 'pointer-events',
				referrerPolicy: 'referrerpolicy',
				renderingIntent: 'rendering-intent',
				shapeRendering: 'shape-rendering',
				stopColor: 'stop-color',
				stopOpacity: 'stop-opacity',
				strikethroughPosition: 'strikethrough-position',
				strikethroughThickness: 'strikethrough-thickness',
				strokeDashArray: 'stroke-dasharray',
				strokeDashOffset: 'stroke-dashoffset',
				strokeLineCap: 'stroke-linecap',
				strokeLineJoin: 'stroke-linejoin',
				strokeMiterLimit: 'stroke-miterlimit',
				strokeOpacity: 'stroke-opacity',
				strokeWidth: 'stroke-width',
				tabIndex: 'tabindex',
				textAnchor: 'text-anchor',
				textDecoration: 'text-decoration',
				textRendering: 'text-rendering',
				typeOf: 'typeof',
				underlinePosition: 'underline-position',
				underlineThickness: 'underline-thickness',
				unicodeBidi: 'unicode-bidi',
				unicodeRange: 'unicode-range',
				unitsPerEm: 'units-per-em',
				vAlphabetic: 'v-alphabetic',
				vHanging: 'v-hanging',
				vIdeographic: 'v-ideographic',
				vMathematical: 'v-mathematical',
				vectorEffect: 'vector-effect',
				vertAdvY: 'vert-adv-y',
				vertOriginX: 'vert-origin-x',
				vertOriginY: 'vert-origin-y',
				wordSpacing: 'word-spacing',
				writingMode: 'writing-mode',
				xHeight: 'x-height',
				playbackOrder: 'playbackorder',
				timelineBegin: 'timelinebegin'
			},
			transform: caseSensitiveTransform,
			properties: {
				about: commaOrSpaceSeparated,
				accentHeight: number,
				accumulate: null,
				additive: null,
				alignmentBaseline: null,
				alphabetic: number,
				amplitude: number,
				arabicForm: null,
				ascent: number,
				attributeName: null,
				attributeType: null,
				azimuth: number,
				bandwidth: null,
				baselineShift: null,
				baseFrequency: null,
				baseProfile: null,
				bbox: null,
				begin: null,
				bias: number,
				by: null,
				calcMode: null,
				capHeight: number,
				className: spaceSeparated,
				clip: null,
				clipPath: null,
				clipPathUnits: null,
				clipRule: null,
				color: null,
				colorInterpolation: null,
				colorInterpolationFilters: null,
				colorProfile: null,
				colorRendering: null,
				content: null,
				contentScriptType: null,
				contentStyleType: null,
				crossOrigin: null,
				cursor: null,
				cx: null,
				cy: null,
				d: null,
				dataType: null,
				defaultAction: null,
				descent: number,
				diffuseConstant: number,
				direction: null,
				display: null,
				dur: null,
				divisor: number,
				dominantBaseline: null,
				download: boolean,
				dx: null,
				dy: null,
				edgeMode: null,
				editable: null,
				elevation: number,
				enableBackground: null,
				end: null,
				event: null,
				exponent: number,
				externalResourcesRequired: null,
				fill: null,
				fillOpacity: number,
				fillRule: null,
				filter: null,
				filterRes: null,
				filterUnits: null,
				floodColor: null,
				floodOpacity: null,
				focusable: null,
				focusHighlight: null,
				fontFamily: null,
				fontSize: null,
				fontSizeAdjust: null,
				fontStretch: null,
				fontStyle: null,
				fontVariant: null,
				fontWeight: null,
				format: null,
				fr: null,
				from: null,
				fx: null,
				fy: null,
				g1: commaSeparated,
				g2: commaSeparated,
				glyphName: commaSeparated,
				glyphOrientationHorizontal: null,
				glyphOrientationVertical: null,
				glyphRef: null,
				gradientTransform: null,
				gradientUnits: null,
				handler: null,
				hanging: number,
				hatchContentUnits: null,
				hatchUnits: null,
				height: null,
				href: null,
				hrefLang: null,
				horizAdvX: number,
				horizOriginX: number,
				horizOriginY: number,
				id: null,
				ideographic: number,
				imageRendering: null,
				initialVisibility: null,
				in: null,
				in2: null,
				intercept: number,
				k: number,
				k1: number,
				k2: number,
				k3: number,
				k4: number,
				kernelMatrix: commaOrSpaceSeparated,
				kernelUnitLength: null,
				keyPoints: null,
				keySplines: null,
				keyTimes: null,
				kerning: null,
				lang: null,
				lengthAdjust: null,
				letterSpacing: null,
				lightingColor: null,
				limitingConeAngle: number,
				local: null,
				markerEnd: null,
				markerMid: null,
				markerStart: null,
				markerHeight: null,
				markerUnits: null,
				markerWidth: null,
				mask: null,
				maskContentUnits: null,
				maskUnits: null,
				mathematical: null,
				max: null,
				media: null,
				mediaCharacterEncoding: null,
				mediaContentEncodings: null,
				mediaSize: number,
				mediaTime: null,
				method: null,
				min: null,
				mode: null,
				name: null,
				navDown: null,
				navDownLeft: null,
				navDownRight: null,
				navLeft: null,
				navNext: null,
				navPrev: null,
				navRight: null,
				navUp: null,
				navUpLeft: null,
				navUpRight: null,
				numOctaves: null,
				observer: null,
				offset: null,
				onAbort: null,
				onActivate: null,
				onAfterPrint: null,
				onBeforePrint: null,
				onBegin: null,
				onCancel: null,
				onCanPlay: null,
				onCanPlayThrough: null,
				onChange: null,
				onClick: null,
				onClose: null,
				onCopy: null,
				onCueChange: null,
				onCut: null,
				onDblClick: null,
				onDrag: null,
				onDragEnd: null,
				onDragEnter: null,
				onDragExit: null,
				onDragLeave: null,
				onDragOver: null,
				onDragStart: null,
				onDrop: null,
				onDurationChange: null,
				onEmptied: null,
				onEnd: null,
				onEnded: null,
				onError: null,
				onFocus: null,
				onFocusIn: null,
				onFocusOut: null,
				onHashChange: null,
				onInput: null,
				onInvalid: null,
				onKeyDown: null,
				onKeyPress: null,
				onKeyUp: null,
				onLoad: null,
				onLoadedData: null,
				onLoadedMetadata: null,
				onLoadStart: null,
				onMessage: null,
				onMouseDown: null,
				onMouseEnter: null,
				onMouseLeave: null,
				onMouseMove: null,
				onMouseOut: null,
				onMouseOver: null,
				onMouseUp: null,
				onMouseWheel: null,
				onOffline: null,
				onOnline: null,
				onPageHide: null,
				onPageShow: null,
				onPaste: null,
				onPause: null,
				onPlay: null,
				onPlaying: null,
				onPopState: null,
				onProgress: null,
				onRateChange: null,
				onRepeat: null,
				onReset: null,
				onResize: null,
				onScroll: null,
				onSeeked: null,
				onSeeking: null,
				onSelect: null,
				onShow: null,
				onStalled: null,
				onStorage: null,
				onSubmit: null,
				onSuspend: null,
				onTimeUpdate: null,
				onToggle: null,
				onUnload: null,
				onVolumeChange: null,
				onWaiting: null,
				onZoom: null,
				opacity: null,
				operator: null,
				order: null,
				orient: null,
				orientation: null,
				origin: null,
				overflow: null,
				overlay: null,
				overlinePosition: number,
				overlineThickness: number,
				paintOrder: null,
				panose1: null,
				path: null,
				pathLength: number,
				patternContentUnits: null,
				patternTransform: null,
				patternUnits: null,
				phase: null,
				ping: spaceSeparated,
				pitch: null,
				playbackOrder: null,
				pointerEvents: null,
				points: null,
				pointsAtX: number,
				pointsAtY: number,
				pointsAtZ: number,
				preserveAlpha: null,
				preserveAspectRatio: null,
				primitiveUnits: null,
				propagate: null,
				property: commaOrSpaceSeparated,
				r: null,
				radius: null,
				referrerPolicy: null,
				refX: null,
				refY: null,
				rel: commaOrSpaceSeparated,
				rev: commaOrSpaceSeparated,
				renderingIntent: null,
				repeatCount: null,
				repeatDur: null,
				requiredExtensions: commaOrSpaceSeparated,
				requiredFeatures: commaOrSpaceSeparated,
				requiredFonts: commaOrSpaceSeparated,
				requiredFormats: commaOrSpaceSeparated,
				resource: null,
				restart: null,
				result: null,
				rotate: null,
				rx: null,
				ry: null,
				scale: null,
				seed: null,
				shapeRendering: null,
				side: null,
				slope: null,
				snapshotTime: null,
				specularConstant: number,
				specularExponent: number,
				spreadMethod: null,
				spacing: null,
				startOffset: null,
				stdDeviation: null,
				stemh: null,
				stemv: null,
				stitchTiles: null,
				stopColor: null,
				stopOpacity: null,
				strikethroughPosition: number,
				strikethroughThickness: number,
				string: null,
				stroke: null,
				strokeDashArray: commaOrSpaceSeparated,
				strokeDashOffset: null,
				strokeLineCap: null,
				strokeLineJoin: null,
				strokeMiterLimit: number,
				strokeOpacity: number,
				strokeWidth: null,
				style: null,
				surfaceScale: number,
				syncBehavior: null,
				syncBehaviorDefault: null,
				syncMaster: null,
				syncTolerance: null,
				syncToleranceDefault: null,
				systemLanguage: commaOrSpaceSeparated,
				tabIndex: number,
				tableValues: null,
				target: null,
				targetX: number,
				targetY: number,
				textAnchor: null,
				textDecoration: null,
				textRendering: null,
				textLength: null,
				timelineBegin: null,
				title: null,
				transformBehavior: null,
				type: null,
				typeOf: commaOrSpaceSeparated,
				to: null,
				transform: null,
				u1: null,
				u2: null,
				underlinePosition: number,
				underlineThickness: number,
				unicode: null,
				unicodeBidi: null,
				unicodeRange: null,
				unitsPerEm: number,
				values: null,
				vAlphabetic: number,
				vMathematical: number,
				vectorEffect: null,
				vHanging: number,
				vIdeographic: number,
				version: null,
				vertAdvY: number,
				vertOriginX: number,
				vertOriginY: number,
				viewBox: null,
				viewTarget: null,
				visibility: null,
				width: null,
				widths: null,
				wordSpacing: null,
				writingMode: null,
				x: null,
				x1: null,
				x2: null,
				xChannelSelector: null,
				xHeight: number,
				y: null,
				y1: null,
				y2: null,
				yChannelSelector: null,
				z: null,
				zoomAndPan: null
			}
		});
	}
});

// node_modules/hast-util-to-html/node_modules/property-information/lib/find.js
function find(schema, value) {
	const normal = normalize2(value);
	let prop = value;
	let Type = Info;
	if (normal in schema.normal) {
		return schema.property[schema.normal[normal]];
	}
	if (normal.length > 4 && normal.slice(0, 4) === 'data' && valid.test(value)) {
		if (value.charAt(4) === '-') {
			const rest = value.slice(5).replace(dash, camelcase);
			prop = 'data' + rest.charAt(0).toUpperCase() + rest.slice(1);
		} else {
			const rest = value.slice(4);
			if (!dash.test(rest)) {
				let dashes = rest.replace(cap, kebab);
				if (dashes.charAt(0) !== '-') {
					dashes = '-' + dashes;
				}
				value = 'data' + dashes;
			}
		}
		Type = DefinedInfo;
	}
	return new Type(prop, value);
}
function kebab($0) {
	return '-' + $0.toLowerCase();
}
function camelcase($0) {
	return $0.charAt(1).toUpperCase();
}
var valid, dash, cap;
var init_find = __esm({
	'node_modules/hast-util-to-html/node_modules/property-information/lib/find.js'() {
		init_normalize();
		init_defined_info();
		init_info();
		valid = /^data[-\w.:]+$/i;
		dash = /-[a-z]/g;
		cap = /[A-Z]/g;
	}
});

// node_modules/hast-util-to-html/node_modules/property-information/index.js
var html3, svg2;
var init_property_information = __esm({
	'node_modules/hast-util-to-html/node_modules/property-information/index.js'() {
		init_merge();
		init_xlink();
		init_xml();
		init_xmlns();
		init_aria();
		init_html2();
		init_svg();
		init_find();
		html3 = merge([xml, xlink, xmlns, aria, html2], 'html');
		svg2 = merge([xml, xlink, xmlns, aria, svg], 'svg');
	}
});

// node_modules/html-void-elements/index.js
var htmlVoidElements;
var init_html_void_elements = __esm({
	'node_modules/html-void-elements/index.js'() {
		htmlVoidElements = [
			'area',
			'base',
			'basefont',
			'bgsound',
			'br',
			'col',
			'command',
			'embed',
			'frame',
			'hr',
			'image',
			'img',
			'input',
			'isindex',
			'keygen',
			'link',
			'menuitem',
			'meta',
			'nextid',
			'param',
			'source',
			'track',
			'wbr'
		];
	}
});

// node_modules/hast-util-is-element/index.js
function anyFactory2(tests) {
	const checks3 = [];
	let index6 = -1;
	while (++index6 < tests.length) {
		checks3[index6] = convertElement(tests[index6]);
	}
	return castFactory2(any);
	function any(...parameters) {
		let index7 = -1;
		while (++index7 < checks3.length) {
			if (checks3[index7].call(this, ...parameters)) {
				return true;
			}
		}
		return false;
	}
}
function tagNameFactory(check) {
	return tagName;
	function tagName(node) {
		return element(node) && node.tagName === check;
	}
}
function castFactory2(check) {
	return assertion;
	function assertion(node, ...parameters) {
		return element(node) && Boolean(check.call(this, node, ...parameters));
	}
}
function element(node) {
	return Boolean(
		node && typeof node === 'object' && node.type === 'element' && typeof node.tagName === 'string'
	);
}
var isElement, convertElement;
var init_hast_util_is_element = __esm({
	'node_modules/hast-util-is-element/index.js'() {
		isElement = function (node, test, index6, parent, context) {
			const check = convertElement(test);
			if (
				index6 !== void 0 &&
				index6 !== null &&
				(typeof index6 !== 'number' || index6 < 0 || index6 === Number.POSITIVE_INFINITY)
			) {
				throw new Error('Expected positive finite index for child node');
			}
			if (parent !== void 0 && parent !== null && (!parent.type || !parent.children)) {
				throw new Error('Expected parent node');
			}
			if (!node || !node.type || typeof node.type !== 'string') {
				return false;
			}
			if ((parent === void 0 || parent === null) !== (index6 === void 0 || index6 === null)) {
				throw new Error('Expected both parent and index');
			}
			return check.call(context, node, index6, parent);
		};
		convertElement = function (test) {
			if (test === void 0 || test === null) {
				return element;
			}
			if (typeof test === 'string') {
				return tagNameFactory(test);
			}
			if (typeof test === 'object') {
				return anyFactory2(test);
			}
			if (typeof test === 'function') {
				return castFactory2(test);
			}
			throw new Error('Expected function, string, or array as test');
		};
	}
});

// node_modules/hast-util-to-html/lib/omission/util/comment.js
var comment;
var init_comment = __esm({
	'node_modules/hast-util-to-html/lib/omission/util/comment.js'() {
		init_unist_util_is();
		comment = convert('comment');
	}
});

// node_modules/hast-util-whitespace/index.js
function whitespace(thing) {
	var value =
		thing && typeof thing === 'object' && thing.type === 'text' ? thing.value || '' : thing;
	return typeof value === 'string' && value.replace(/[ \t\n\f\r]/g, '') === '';
}
var init_hast_util_whitespace = __esm({
	'node_modules/hast-util-whitespace/index.js'() {}
});

// node_modules/hast-util-to-html/lib/omission/util/siblings.js
function siblings(increment3) {
	return sibling;
	function sibling(parent, index6, includeWhitespace) {
		const siblings2 = parent && parent.children;
		let offset = index6 + increment3;
		let next = siblings2 && siblings2[offset];
		if (!includeWhitespace) {
			while (next && whitespace(next)) {
				offset += increment3;
				next = siblings2[offset];
			}
		}
		return next;
	}
}
var siblingAfter, siblingBefore;
var init_siblings = __esm({
	'node_modules/hast-util-to-html/lib/omission/util/siblings.js'() {
		init_hast_util_whitespace();
		siblingAfter = siblings(1);
		siblingBefore = siblings(-1);
	}
});

// node_modules/hast-util-to-html/lib/omission/util/whitespace-start.js
function whitespaceStart(node) {
	return isText(node) && whitespace(node.value.charAt(0));
}
var isText;
var init_whitespace_start = __esm({
	'node_modules/hast-util-to-html/lib/omission/util/whitespace-start.js'() {
		init_unist_util_is();
		init_hast_util_whitespace();
		isText = convert('text');
	}
});

// node_modules/hast-util-to-html/lib/omission/omission.js
function omission(handlers3) {
	return omit;
	function omit(node, index6, parent) {
		return own6.call(handlers3, node.tagName) && handlers3[node.tagName](node, index6, parent);
	}
}
var own6;
var init_omission = __esm({
	'node_modules/hast-util-to-html/lib/omission/omission.js'() {
		own6 = {}.hasOwnProperty;
	}
});

// node_modules/hast-util-to-html/lib/omission/closing.js
function headOrColgroupOrCaption(_, index6, parent) {
	const next = siblingAfter(parent, index6, true);
	return !next || (!comment(next) && !whitespaceStart(next));
}
function html4(_, index6, parent) {
	const next = siblingAfter(parent, index6);
	return !next || !comment(next);
}
function body2(_, index6, parent) {
	const next = siblingAfter(parent, index6);
	return !next || !comment(next);
}
function p(_, index6, parent) {
	const next = siblingAfter(parent, index6);
	return next
		? isElement(next, [
				'address',
				'article',
				'aside',
				'blockquote',
				'details',
				'div',
				'dl',
				'fieldset',
				'figcaption',
				'figure',
				'footer',
				'form',
				'h1',
				'h2',
				'h3',
				'h4',
				'h5',
				'h6',
				'header',
				'hgroup',
				'hr',
				'main',
				'menu',
				'nav',
				'ol',
				'p',
				'pre',
				'section',
				'table',
				'ul'
		  ])
		: !parent || !isElement(parent, ['a', 'audio', 'del', 'ins', 'map', 'noscript', 'video']);
}
function li(_, index6, parent) {
	const next = siblingAfter(parent, index6);
	return !next || isElement(next, 'li');
}
function dt(_, index6, parent) {
	const next = siblingAfter(parent, index6);
	return next && isElement(next, ['dt', 'dd']);
}
function dd(_, index6, parent) {
	const next = siblingAfter(parent, index6);
	return !next || isElement(next, ['dt', 'dd']);
}
function rubyElement(_, index6, parent) {
	const next = siblingAfter(parent, index6);
	return !next || isElement(next, ['rp', 'rt']);
}
function optgroup(_, index6, parent) {
	const next = siblingAfter(parent, index6);
	return !next || isElement(next, 'optgroup');
}
function option(_, index6, parent) {
	const next = siblingAfter(parent, index6);
	return !next || isElement(next, ['option', 'optgroup']);
}
function menuitem(_, index6, parent) {
	const next = siblingAfter(parent, index6);
	return !next || isElement(next, ['menuitem', 'hr', 'menu']);
}
function thead(_, index6, parent) {
	const next = siblingAfter(parent, index6);
	return next && isElement(next, ['tbody', 'tfoot']);
}
function tbody(_, index6, parent) {
	const next = siblingAfter(parent, index6);
	return !next || isElement(next, ['tbody', 'tfoot']);
}
function tfoot(_, index6, parent) {
	return !siblingAfter(parent, index6);
}
function tr(_, index6, parent) {
	const next = siblingAfter(parent, index6);
	return !next || isElement(next, 'tr');
}
function cells(_, index6, parent) {
	const next = siblingAfter(parent, index6);
	return !next || isElement(next, ['td', 'th']);
}
var closing;
var init_closing = __esm({
	'node_modules/hast-util-to-html/lib/omission/closing.js'() {
		init_hast_util_is_element();
		init_comment();
		init_siblings();
		init_whitespace_start();
		init_omission();
		closing = omission({
			html: html4,
			head: headOrColgroupOrCaption,
			body: body2,
			p,
			li,
			dt,
			dd,
			rt: rubyElement,
			rp: rubyElement,
			optgroup,
			option,
			menuitem,
			colgroup: headOrColgroupOrCaption,
			caption: headOrColgroupOrCaption,
			thead,
			tbody,
			tfoot,
			tr,
			td: cells,
			th: cells
		});
	}
});

// node_modules/hast-util-to-html/lib/omission/opening.js
function html5(node) {
	const head2 = siblingAfter(node, -1);
	return !head2 || !comment(head2);
}
function head(node) {
	const children = node.children;
	const seen = [];
	let index6 = -1;
	let child;
	while (++index6 < children.length) {
		child = children[index6];
		if (isElement(child, ['title', 'base'])) {
			if (seen.includes(child.tagName)) return false;
			seen.push(child.tagName);
		}
	}
	return children.length > 0;
}
function body3(node) {
	const head2 = siblingAfter(node, -1, true);
	return (
		!head2 ||
		(!comment(head2) &&
			!whitespaceStart(head2) &&
			!isElement(head2, ['meta', 'link', 'script', 'style', 'template']))
	);
}
function colgroup(node, index6, parent) {
	const previous2 = siblingBefore(parent, index6);
	const head2 = siblingAfter(node, -1, true);
	if (
		isElement(previous2, 'colgroup') &&
		closing(previous2, parent.children.indexOf(previous2), parent)
	) {
		return false;
	}
	return head2 && isElement(head2, 'col');
}
function tbody2(node, index6, parent) {
	const previous2 = siblingBefore(parent, index6);
	const head2 = siblingAfter(node, -1);
	if (
		isElement(previous2, ['thead', 'tbody']) &&
		closing(previous2, parent.children.indexOf(previous2), parent)
	) {
		return false;
	}
	return head2 && isElement(head2, 'tr');
}
var opening;
var init_opening = __esm({
	'node_modules/hast-util-to-html/lib/omission/opening.js'() {
		init_hast_util_is_element();
		init_comment();
		init_siblings();
		init_whitespace_start();
		init_closing();
		init_omission();
		opening = omission({
			html: html5,
			head,
			body: body3,
			colgroup,
			tbody: tbody2
		});
	}
});

// node_modules/hast-util-to-html/lib/omission/index.js
var omission2;
var init_omission2 = __esm({
	'node_modules/hast-util-to-html/lib/omission/index.js'() {
		init_opening();
		init_closing();
		omission2 = { opening, closing };
	}
});

// node_modules/hast-util-to-html/node_modules/space-separated-tokens/index.js
function stringify(values) {
	return values.join(' ').trim();
}
var init_space_separated_tokens = __esm({
	'node_modules/hast-util-to-html/node_modules/space-separated-tokens/index.js'() {}
});

// node_modules/hast-util-to-html/node_modules/comma-separated-tokens/index.js
function stringify2(values, options) {
	var settings = options || {};
	if (values[values.length - 1] === '') {
		values = values.concat('');
	}
	return values
		.join((settings.padRight ? ' ' : '') + ',' + (settings.padLeft === false ? '' : ' '))
		.trim();
}
var init_comma_separated_tokens = __esm({
	'node_modules/hast-util-to-html/node_modules/comma-separated-tokens/index.js'() {}
});

// node_modules/stringify-entities/lib/core.js
function core(value, options) {
	value = value.replace(
		options.subset ? charactersToExpression(options.subset) : /["&'<>`]/g,
		basic
	);
	if (options.subset || options.escapeOnly) {
		return value;
	}
	return value
		.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, surrogate)
		.replace(/[\x01-\t\v\f\x0E-\x1F\x7F\x81\x8D\x8F\x90\x9D\xA0-\uFFFF]/g, basic);
	function surrogate(pair, index6, all5) {
		return options.format(
			(pair.charCodeAt(0) - 55296) * 1024 + pair.charCodeAt(1) - 56320 + 65536,
			all5.charCodeAt(index6 + 2),
			options
		);
	}
	function basic(character, index6, all5) {
		return options.format(character.charCodeAt(0), all5.charCodeAt(index6 + 1), options);
	}
}
function charactersToExpression(subset) {
	const groups = [];
	let index6 = -1;
	while (++index6 < subset.length) {
		groups.push(subset[index6].replace(/[|\\{}()[\]^$+*?.]/g, '\\$&'));
	}
	return new RegExp('(?:' + groups.join('|') + ')', 'g');
}
var init_core = __esm({
	'node_modules/stringify-entities/lib/core.js'() {}
});

// node_modules/stringify-entities/lib/util/to-hexadecimal.js
function toHexadecimal(code3, next, omit) {
	const value = '&#x' + code3.toString(16).toUpperCase();
	return omit && next && !/[\dA-Fa-f]/.test(String.fromCharCode(next)) ? value : value + ';';
}
var init_to_hexadecimal = __esm({
	'node_modules/stringify-entities/lib/util/to-hexadecimal.js'() {}
});

// node_modules/stringify-entities/lib/util/to-decimal.js
function toDecimal(code3, next, omit) {
	const value = '&#' + String(code3);
	return omit && next && !/\d/.test(String.fromCharCode(next)) ? value : value + ';';
}
var init_to_decimal = __esm({
	'node_modules/stringify-entities/lib/util/to-decimal.js'() {}
});

// node_modules/stringify-entities/node_modules/character-entities-legacy/index.js
var characterEntitiesLegacy;
var init_character_entities_legacy = __esm({
	'node_modules/stringify-entities/node_modules/character-entities-legacy/index.js'() {
		characterEntitiesLegacy = [
			'AElig',
			'AMP',
			'Aacute',
			'Acirc',
			'Agrave',
			'Aring',
			'Atilde',
			'Auml',
			'COPY',
			'Ccedil',
			'ETH',
			'Eacute',
			'Ecirc',
			'Egrave',
			'Euml',
			'GT',
			'Iacute',
			'Icirc',
			'Igrave',
			'Iuml',
			'LT',
			'Ntilde',
			'Oacute',
			'Ocirc',
			'Ograve',
			'Oslash',
			'Otilde',
			'Ouml',
			'QUOT',
			'REG',
			'THORN',
			'Uacute',
			'Ucirc',
			'Ugrave',
			'Uuml',
			'Yacute',
			'aacute',
			'acirc',
			'acute',
			'aelig',
			'agrave',
			'amp',
			'aring',
			'atilde',
			'auml',
			'brvbar',
			'ccedil',
			'cedil',
			'cent',
			'copy',
			'curren',
			'deg',
			'divide',
			'eacute',
			'ecirc',
			'egrave',
			'eth',
			'euml',
			'frac12',
			'frac14',
			'frac34',
			'gt',
			'iacute',
			'icirc',
			'iexcl',
			'igrave',
			'iquest',
			'iuml',
			'laquo',
			'lt',
			'macr',
			'micro',
			'middot',
			'nbsp',
			'not',
			'ntilde',
			'oacute',
			'ocirc',
			'ograve',
			'ordf',
			'ordm',
			'oslash',
			'otilde',
			'ouml',
			'para',
			'plusmn',
			'pound',
			'quot',
			'raquo',
			'reg',
			'sect',
			'shy',
			'sup1',
			'sup2',
			'sup3',
			'szlig',
			'thorn',
			'times',
			'uacute',
			'ucirc',
			'ugrave',
			'uml',
			'uuml',
			'yacute',
			'yen',
			'yuml'
		];
	}
});

// node_modules/character-entities-html4/index.js
var characterEntitiesHtml4;
var init_character_entities_html4 = __esm({
	'node_modules/character-entities-html4/index.js'() {
		characterEntitiesHtml4 = {
			nbsp: '\xA0',
			iexcl: '\xA1',
			cent: '\xA2',
			pound: '\xA3',
			curren: '\xA4',
			yen: '\xA5',
			brvbar: '\xA6',
			sect: '\xA7',
			uml: '\xA8',
			copy: '\xA9',
			ordf: '\xAA',
			laquo: '\xAB',
			not: '\xAC',
			shy: '\xAD',
			reg: '\xAE',
			macr: '\xAF',
			deg: '\xB0',
			plusmn: '\xB1',
			sup2: '\xB2',
			sup3: '\xB3',
			acute: '\xB4',
			micro: '\xB5',
			para: '\xB6',
			middot: '\xB7',
			cedil: '\xB8',
			sup1: '\xB9',
			ordm: '\xBA',
			raquo: '\xBB',
			frac14: '\xBC',
			frac12: '\xBD',
			frac34: '\xBE',
			iquest: '\xBF',
			Agrave: '\xC0',
			Aacute: '\xC1',
			Acirc: '\xC2',
			Atilde: '\xC3',
			Auml: '\xC4',
			Aring: '\xC5',
			AElig: '\xC6',
			Ccedil: '\xC7',
			Egrave: '\xC8',
			Eacute: '\xC9',
			Ecirc: '\xCA',
			Euml: '\xCB',
			Igrave: '\xCC',
			Iacute: '\xCD',
			Icirc: '\xCE',
			Iuml: '\xCF',
			ETH: '\xD0',
			Ntilde: '\xD1',
			Ograve: '\xD2',
			Oacute: '\xD3',
			Ocirc: '\xD4',
			Otilde: '\xD5',
			Ouml: '\xD6',
			times: '\xD7',
			Oslash: '\xD8',
			Ugrave: '\xD9',
			Uacute: '\xDA',
			Ucirc: '\xDB',
			Uuml: '\xDC',
			Yacute: '\xDD',
			THORN: '\xDE',
			szlig: '\xDF',
			agrave: '\xE0',
			aacute: '\xE1',
			acirc: '\xE2',
			atilde: '\xE3',
			auml: '\xE4',
			aring: '\xE5',
			aelig: '\xE6',
			ccedil: '\xE7',
			egrave: '\xE8',
			eacute: '\xE9',
			ecirc: '\xEA',
			euml: '\xEB',
			igrave: '\xEC',
			iacute: '\xED',
			icirc: '\xEE',
			iuml: '\xEF',
			eth: '\xF0',
			ntilde: '\xF1',
			ograve: '\xF2',
			oacute: '\xF3',
			ocirc: '\xF4',
			otilde: '\xF5',
			ouml: '\xF6',
			divide: '\xF7',
			oslash: '\xF8',
			ugrave: '\xF9',
			uacute: '\xFA',
			ucirc: '\xFB',
			uuml: '\xFC',
			yacute: '\xFD',
			thorn: '\xFE',
			yuml: '\xFF',
			fnof: '\u0192',
			Alpha: '\u0391',
			Beta: '\u0392',
			Gamma: '\u0393',
			Delta: '\u0394',
			Epsilon: '\u0395',
			Zeta: '\u0396',
			Eta: '\u0397',
			Theta: '\u0398',
			Iota: '\u0399',
			Kappa: '\u039A',
			Lambda: '\u039B',
			Mu: '\u039C',
			Nu: '\u039D',
			Xi: '\u039E',
			Omicron: '\u039F',
			Pi: '\u03A0',
			Rho: '\u03A1',
			Sigma: '\u03A3',
			Tau: '\u03A4',
			Upsilon: '\u03A5',
			Phi: '\u03A6',
			Chi: '\u03A7',
			Psi: '\u03A8',
			Omega: '\u03A9',
			alpha: '\u03B1',
			beta: '\u03B2',
			gamma: '\u03B3',
			delta: '\u03B4',
			epsilon: '\u03B5',
			zeta: '\u03B6',
			eta: '\u03B7',
			theta: '\u03B8',
			iota: '\u03B9',
			kappa: '\u03BA',
			lambda: '\u03BB',
			mu: '\u03BC',
			nu: '\u03BD',
			xi: '\u03BE',
			omicron: '\u03BF',
			pi: '\u03C0',
			rho: '\u03C1',
			sigmaf: '\u03C2',
			sigma: '\u03C3',
			tau: '\u03C4',
			upsilon: '\u03C5',
			phi: '\u03C6',
			chi: '\u03C7',
			psi: '\u03C8',
			omega: '\u03C9',
			thetasym: '\u03D1',
			upsih: '\u03D2',
			piv: '\u03D6',
			bull: '\u2022',
			hellip: '\u2026',
			prime: '\u2032',
			Prime: '\u2033',
			oline: '\u203E',
			frasl: '\u2044',
			weierp: '\u2118',
			image: '\u2111',
			real: '\u211C',
			trade: '\u2122',
			alefsym: '\u2135',
			larr: '\u2190',
			uarr: '\u2191',
			rarr: '\u2192',
			darr: '\u2193',
			harr: '\u2194',
			crarr: '\u21B5',
			lArr: '\u21D0',
			uArr: '\u21D1',
			rArr: '\u21D2',
			dArr: '\u21D3',
			hArr: '\u21D4',
			forall: '\u2200',
			part: '\u2202',
			exist: '\u2203',
			empty: '\u2205',
			nabla: '\u2207',
			isin: '\u2208',
			notin: '\u2209',
			ni: '\u220B',
			prod: '\u220F',
			sum: '\u2211',
			minus: '\u2212',
			lowast: '\u2217',
			radic: '\u221A',
			prop: '\u221D',
			infin: '\u221E',
			ang: '\u2220',
			and: '\u2227',
			or: '\u2228',
			cap: '\u2229',
			cup: '\u222A',
			int: '\u222B',
			there4: '\u2234',
			sim: '\u223C',
			cong: '\u2245',
			asymp: '\u2248',
			ne: '\u2260',
			equiv: '\u2261',
			le: '\u2264',
			ge: '\u2265',
			sub: '\u2282',
			sup: '\u2283',
			nsub: '\u2284',
			sube: '\u2286',
			supe: '\u2287',
			oplus: '\u2295',
			otimes: '\u2297',
			perp: '\u22A5',
			sdot: '\u22C5',
			lceil: '\u2308',
			rceil: '\u2309',
			lfloor: '\u230A',
			rfloor: '\u230B',
			lang: '\u2329',
			rang: '\u232A',
			loz: '\u25CA',
			spades: '\u2660',
			clubs: '\u2663',
			hearts: '\u2665',
			diams: '\u2666',
			quot: '"',
			amp: '&',
			lt: '<',
			gt: '>',
			OElig: '\u0152',
			oelig: '\u0153',
			Scaron: '\u0160',
			scaron: '\u0161',
			Yuml: '\u0178',
			circ: '\u02C6',
			tilde: '\u02DC',
			ensp: '\u2002',
			emsp: '\u2003',
			thinsp: '\u2009',
			zwnj: '\u200C',
			zwj: '\u200D',
			lrm: '\u200E',
			rlm: '\u200F',
			ndash: '\u2013',
			mdash: '\u2014',
			lsquo: '\u2018',
			rsquo: '\u2019',
			sbquo: '\u201A',
			ldquo: '\u201C',
			rdquo: '\u201D',
			bdquo: '\u201E',
			dagger: '\u2020',
			Dagger: '\u2021',
			permil: '\u2030',
			lsaquo: '\u2039',
			rsaquo: '\u203A',
			euro: '\u20AC'
		};
	}
});

// node_modules/stringify-entities/lib/constant/dangerous.js
var dangerous;
var init_dangerous = __esm({
	'node_modules/stringify-entities/lib/constant/dangerous.js'() {
		dangerous = ['cent', 'copy', 'divide', 'gt', 'lt', 'not', 'para', 'times'];
	}
});

// node_modules/stringify-entities/lib/util/to-named.js
function toNamed(code3, next, omit, attribute) {
	const character = String.fromCharCode(code3);
	if (own7.call(characters, character)) {
		const name = characters[character];
		const value = '&' + name;
		if (
			omit &&
			characterEntitiesLegacy.includes(name) &&
			!dangerous.includes(name) &&
			(!attribute || (next && next !== 61 && /[^\da-z]/i.test(String.fromCharCode(next))))
		) {
			return value;
		}
		return value + ';';
	}
	return '';
}
var own7, characters, key2;
var init_to_named = __esm({
	'node_modules/stringify-entities/lib/util/to-named.js'() {
		init_character_entities_legacy();
		init_character_entities_html4();
		init_dangerous();
		own7 = {}.hasOwnProperty;
		characters = {};
		for (key2 in characterEntitiesHtml4) {
			if (own7.call(characterEntitiesHtml4, key2)) {
				characters[characterEntitiesHtml4[key2]] = key2;
			}
		}
	}
});

// node_modules/stringify-entities/lib/util/format-smart.js
function formatSmart(code3, next, options) {
	let numeric = toHexadecimal(code3, next, options.omitOptionalSemicolons);
	let named;
	if (options.useNamedReferences || options.useShortestReferences) {
		named = toNamed(code3, next, options.omitOptionalSemicolons, options.attribute);
	}
	if ((options.useShortestReferences || !named) && options.useShortestReferences) {
		const decimal = toDecimal(code3, next, options.omitOptionalSemicolons);
		if (decimal.length < numeric.length) {
			numeric = decimal;
		}
	}
	return named && (!options.useShortestReferences || named.length < numeric.length)
		? named
		: numeric;
}
var init_format_smart = __esm({
	'node_modules/stringify-entities/lib/util/format-smart.js'() {
		init_to_hexadecimal();
		init_to_decimal();
		init_to_named();
	}
});

// node_modules/stringify-entities/lib/index.js
function stringifyEntities(value, options) {
	return core(value, Object.assign({ format: formatSmart }, options));
}
var init_lib7 = __esm({
	'node_modules/stringify-entities/lib/index.js'() {
		init_core();
		init_format_smart();
	}
});

// node_modules/stringify-entities/index.js
var init_stringify_entities = __esm({
	'node_modules/stringify-entities/index.js'() {
		init_lib7();
	}
});

// node_modules/ccount/index.js
function ccount(value, character) {
	const source = String(value);
	if (typeof character !== 'string') {
		throw new TypeError('Expected character');
	}
	let count = 0;
	let index6 = source.indexOf(character);
	while (index6 !== -1) {
		count++;
		index6 = source.indexOf(character, index6 + character.length);
	}
	return count;
}
var init_ccount = __esm({
	'node_modules/ccount/index.js'() {}
});

// node_modules/hast-util-to-html/lib/constants.js
var constants2;
var init_constants = __esm({
	'node_modules/hast-util-to-html/lib/constants.js'() {
		constants2 = {
			name: [
				['	\n\f\r &/=>'.split(''), '	\n\f\r "&\'/=>`'.split('')],
				[
					`\0	
\f\r "&'/<=>`.split(''),
					'\0	\n\f\r "&\'/<=>`'.split('')
				]
			],
			unquoted: [
				['	\n\f\r &>'.split(''), '\0	\n\f\r "&\'<=>`'.split('')],
				['\0	\n\f\r "&\'<=>`'.split(''), '\0	\n\f\r "&\'<=>`'.split('')]
			],
			single: [
				["&'".split(''), '"&\'`'.split('')],
				["\0&'".split(''), '\0"&\'`'.split('')]
			],
			double: [
				['"&'.split(''), '"&\'`'.split('')],
				['\0"&'.split(''), '\0"&\'`'.split('')]
			]
		};
	}
});

// node_modules/hast-util-to-html/lib/comment.js
function comment2(ctx, node) {
	return ctx.bogusComments
		? '<?' + stringifyEntities(node.value, Object.assign({}, ctx.entities, { subset: ['>'] })) + '>'
		: '<!--' + node.value.replace(/^>|^->|<!--|-->|--!>|<!-$/g, encode4) + '-->';
	function encode4($0) {
		return stringifyEntities($0, Object.assign({}, ctx.entities, { subset: ['<', '>'] }));
	}
}
var init_comment2 = __esm({
	'node_modules/hast-util-to-html/lib/comment.js'() {
		init_stringify_entities();
	}
});

// node_modules/hast-util-to-html/lib/doctype.js
function doctype(ctx) {
	return (
		'<!' + (ctx.upperDoctype ? 'DOCTYPE' : 'doctype') + (ctx.tightDoctype ? '' : ' ') + 'html>'
	);
}
var init_doctype = __esm({
	'node_modules/hast-util-to-html/lib/doctype.js'() {}
});

// node_modules/hast-util-to-html/lib/text.js
function text4(ctx, node, _, parent) {
	return parent &&
		parent.type === 'element' &&
		(parent.tagName === 'script' || parent.tagName === 'style')
		? node.value
		: stringifyEntities(node.value, Object.assign({}, ctx.entities, { subset: ['<', '&'] }));
}
var init_text3 = __esm({
	'node_modules/hast-util-to-html/lib/text.js'() {
		init_stringify_entities();
	}
});

// node_modules/hast-util-to-html/lib/raw.js
function raw(ctx, node, index6, parent) {
	return ctx.dangerous ? node.value : text4(ctx, node, index6, parent);
}
var init_raw = __esm({
	'node_modules/hast-util-to-html/lib/raw.js'() {
		init_text3();
	}
});

// node_modules/hast-util-to-html/lib/tree.js
function one2(ctx, node, index6, parent) {
	if (!node || !node.type) {
		throw new Error('Expected node, not `' + node + '`');
	}
	if (!own8.call(handlers, node.type)) {
		throw new Error('Cannot compile unknown node `' + node.type + '`');
	}
	return handlers[node.type](ctx, node, index6, parent);
}
function all2(ctx, parent) {
	const results = [];
	const children = (parent && parent.children) || [];
	let index6 = -1;
	while (++index6 < children.length) {
		results[index6] = one2(ctx, children[index6], index6, parent);
	}
	return results.join('');
}
function element2(ctx, node, index6, parent) {
	const schema = ctx.schema;
	const omit = schema.space === 'svg' ? void 0 : ctx.omit;
	let selfClosing =
		schema.space === 'svg' ? ctx.closeEmpty : ctx.voids.includes(node.tagName.toLowerCase());
	const parts = [];
	let last;
	if (schema.space === 'html' && node.tagName === 'svg') {
		ctx.schema = svg2;
	}
	const attrs = serializeAttributes(ctx, node.properties);
	const content3 = all2(
		ctx,
		schema.space === 'html' && node.tagName === 'template' ? node.content : node
	);
	ctx.schema = schema;
	if (content3) selfClosing = false;
	if (attrs || !omit || !omit.opening(node, index6, parent)) {
		parts.push('<', node.tagName, attrs ? ' ' + attrs : '');
		if (selfClosing && (schema.space === 'svg' || ctx.close)) {
			last = attrs.charAt(attrs.length - 1);
			if (!ctx.tightClose || last === '/' || (last && last !== '"' && last !== "'")) {
				parts.push(' ');
			}
			parts.push('/');
		}
		parts.push('>');
	}
	parts.push(content3);
	if (!selfClosing && (!omit || !omit.closing(node, index6, parent))) {
		parts.push('</' + node.tagName + '>');
	}
	return parts.join('');
}
function serializeAttributes(ctx, props) {
	const values = [];
	let index6 = -1;
	let key3;
	let value;
	let last;
	for (key3 in props) {
		if (props[key3] !== void 0 && props[key3] !== null) {
			value = serializeAttribute(ctx, key3, props[key3]);
			if (value) values.push(value);
		}
	}
	while (++index6 < values.length) {
		last = ctx.tight ? values[index6].charAt(values[index6].length - 1) : null;
		if (index6 !== values.length - 1 && last !== '"' && last !== "'") {
			values[index6] += ' ';
		}
	}
	return values.join('');
}
function serializeAttribute(ctx, key3, value) {
	const info = find(ctx.schema, key3);
	let quote = ctx.quote;
	let result;
	if (info.overloadedBoolean && (value === info.attribute || value === '')) {
		value = true;
	} else if (info.boolean || (info.overloadedBoolean && typeof value !== 'string')) {
		value = Boolean(value);
	}
	if (
		value === void 0 ||
		value === null ||
		value === false ||
		(typeof value === 'number' && Number.isNaN(value))
	) {
		return '';
	}
	const name = stringifyEntities(
		info.attribute,
		Object.assign({}, ctx.entities, {
			subset: constants2.name[ctx.schema.space === 'html' ? ctx.valid : 1][ctx.safe]
		})
	);
	if (value === true) return name;
	value =
		typeof value === 'object' && 'length' in value
			? (info.commaSeparated ? stringify2 : stringify)(value, {
					padLeft: !ctx.tightLists
			  })
			: String(value);
	if (ctx.collapseEmpty && !value) return name;
	if (ctx.unquoted) {
		result = stringifyEntities(
			value,
			Object.assign({}, ctx.entities, {
				subset: constants2.unquoted[ctx.valid][ctx.safe],
				attribute: true
			})
		);
	}
	if (result !== value) {
		if (ctx.smart && ccount(value, quote) > ccount(value, ctx.alternative)) {
			quote = ctx.alternative;
		}
		result =
			quote +
			stringifyEntities(
				value,
				Object.assign({}, ctx.entities, {
					subset: (quote === "'" ? constants2.single : constants2.double)[
						ctx.schema.space === 'html' ? ctx.valid : 1
					][ctx.safe],
					attribute: true
				})
			) +
			quote;
	}
	return name + (result ? '=' + result : result);
}
var handlers, own8;
var init_tree = __esm({
	'node_modules/hast-util-to-html/lib/tree.js'() {
		init_property_information();
		init_space_separated_tokens();
		init_comma_separated_tokens();
		init_stringify_entities();
		init_ccount();
		init_constants();
		init_comment2();
		init_doctype();
		init_raw();
		init_text3();
		handlers = {
			comment: comment2,
			doctype,
			element: element2,
			raw,
			root: all2,
			text: text4
		};
		own8 = {}.hasOwnProperty;
	}
});

// node_modules/hast-util-to-html/lib/index.js
function toHtml(node, options = {}) {
	const quote = options.quote || '"';
	const alternative = quote === '"' ? "'" : '"';
	if (quote !== '"' && quote !== "'") {
		throw new Error('Invalid quote `' + quote + '`, expected `\'` or `"`');
	}
	const context = {
		valid: options.allowParseErrors ? 0 : 1,
		safe: options.allowDangerousCharacters ? 0 : 1,
		schema: options.space === 'svg' ? svg2 : html3,
		omit: options.omitOptionalTags ? omission2 : void 0,
		quote,
		alternative,
		smart: options.quoteSmart,
		unquoted: options.preferUnquoted,
		tight: options.tightAttributes,
		upperDoctype: options.upperDoctype,
		tightDoctype: options.tightDoctype,
		bogusComments: options.bogusComments,
		tightLists: options.tightCommaSeparatedLists,
		tightClose: options.tightSelfClosing,
		collapseEmpty: options.collapseEmptyAttributes,
		dangerous: options.allowDangerousHtml,
		voids: options.voids || htmlVoidElements.concat(),
		entities: options.entities || {},
		close: options.closeSelfClosing,
		closeEmpty: options.closeEmptyElements
	};
	return one2(context, Array.isArray(node) ? { type: 'root', children: node } : node, null, null);
}
var init_lib8 = __esm({
	'node_modules/hast-util-to-html/lib/index.js'() {
		init_property_information();
		init_html_void_elements();
		init_omission2();
		init_tree();
	}
});

// node_modules/hast-util-to-html/index.js
var init_hast_util_to_html = __esm({
	'node_modules/hast-util-to-html/index.js'() {
		init_lib8();
	}
});

// node_modules/hast-util-sanitize/lib/schema.js
var defaultSchema;
var init_schema2 = __esm({
	'node_modules/hast-util-sanitize/lib/schema.js'() {
		defaultSchema = {
			strip: ['script'],
			clobberPrefix: 'user-content-',
			clobber: ['name', 'id'],
			ancestors: {
				tbody: ['table'],
				tfoot: ['table'],
				thead: ['table'],
				td: ['table'],
				th: ['table'],
				tr: ['table']
			},
			protocols: {
				href: ['http', 'https', 'mailto', 'xmpp', 'irc', 'ircs'],
				cite: ['http', 'https'],
				src: ['http', 'https'],
				longDesc: ['http', 'https']
			},
			tagNames: [
				'h1',
				'h2',
				'h3',
				'h4',
				'h5',
				'h6',
				'br',
				'b',
				'i',
				'strong',
				'em',
				'a',
				'pre',
				'code',
				'img',
				'tt',
				'div',
				'ins',
				'del',
				'sup',
				'sub',
				'p',
				'ol',
				'ul',
				'table',
				'thead',
				'tbody',
				'tfoot',
				'blockquote',
				'dl',
				'dt',
				'dd',
				'kbd',
				'q',
				'samp',
				'var',
				'hr',
				'ruby',
				'rt',
				'rp',
				'li',
				'tr',
				'td',
				'th',
				's',
				'strike',
				'summary',
				'details',
				'caption',
				'figure',
				'figcaption',
				'abbr',
				'bdo',
				'cite',
				'dfn',
				'mark',
				'small',
				'span',
				'time',
				'wbr',
				'input'
			],
			attributes: {
				a: ['href'],
				img: ['src', 'longDesc'],
				input: [
					['type', 'checkbox'],
					['disabled', true]
				],
				li: [['className', 'task-list-item']],
				div: ['itemScope', 'itemType'],
				blockquote: ['cite'],
				del: ['cite'],
				ins: ['cite'],
				q: ['cite'],
				'*': [
					'abbr',
					'accept',
					'acceptCharset',
					'accessKey',
					'action',
					'align',
					'alt',
					'ariaDescribedBy',
					'ariaHidden',
					'ariaLabel',
					'ariaLabelledBy',
					'axis',
					'border',
					'cellPadding',
					'cellSpacing',
					'char',
					'charOff',
					'charSet',
					'checked',
					'clear',
					'cols',
					'colSpan',
					'color',
					'compact',
					'coords',
					'dateTime',
					'dir',
					'disabled',
					'encType',
					'htmlFor',
					'frame',
					'headers',
					'height',
					'hrefLang',
					'hSpace',
					'isMap',
					'id',
					'label',
					'lang',
					'maxLength',
					'media',
					'method',
					'multiple',
					'name',
					'noHref',
					'noShade',
					'noWrap',
					'open',
					'prompt',
					'readOnly',
					'rel',
					'rev',
					'rows',
					'rowSpan',
					'rules',
					'scope',
					'selected',
					'shape',
					'size',
					'span',
					'start',
					'summary',
					'tabIndex',
					'target',
					'title',
					'type',
					'useMap',
					'vAlign',
					'value',
					'vSpace',
					'width',
					'itemProp'
				]
			},
			required: {
				input: {
					type: 'checkbox',
					disabled: true
				}
			}
		};
	}
});

// node_modules/hast-util-sanitize/lib/index.js
function sanitize(node, schema) {
	var ctx = { type: 'root', children: [] };
	var replace;
	if (node && typeof node === 'object' && node.type) {
		replace = one3(Object.assign({}, defaultSchema, schema || {}), node, []);
		if (replace) {
			if (Array.isArray(replace)) {
				if (replace.length === 1) {
					ctx = replace[0];
				} else {
					ctx.children = replace;
				}
			} else {
				ctx = replace;
			}
		}
	}
	return ctx;
}
function one3(schema, node, stack) {
	var type = node && node.type;
	var replacement = { type: node.type };
	var replace;
	var definition3;
	var allowed;
	var result;
	var key3;
	if (own9.call(nodeSchema, type)) {
		definition3 = nodeSchema[type];
		if (typeof definition3 === 'function') {
			definition3 = definition3(schema, node);
		}
		if (definition3) {
			replace = true;
			allowed = Object.assign({}, definition3, nodeSchema['*']);
			for (key3 in allowed) {
				if (own9.call(allowed, key3)) {
					result = allowed[key3](schema, node[key3], node, stack);
					if (result === false) {
						replace = null;
						replacement[key3] = node[key3];
					} else if (result !== void 0 && result !== null) {
						replacement[key3] = result;
					}
				}
			}
		}
	}
	if (replace) {
		return replacement;
	}
	return replacement.type === 'element' && !schema.strip.includes(replacement.tagName)
		? replacement.children
		: null;
}
function all3(schema, children, node, stack) {
	var results = [];
	var index6 = -1;
	var value;
	if (Array.isArray(children)) {
		if (node.type === 'element') {
			stack.push(node.tagName);
		}
		while (++index6 < children.length) {
			value = one3(schema, children[index6], stack);
			if (value) {
				if ('length' in value) {
					push2.apply(results, value);
				} else {
					results.push(value);
				}
			}
		}
		if (node.type === 'element') {
			stack.pop();
		}
	}
	return results;
}
function handleDoctype(schema) {
	return schema.allowDoctypes ? { name: handleDoctypeName } : null;
}
function handleComment(schema) {
	return schema.allowComments ? { value: handleCommentValue } : null;
}
function handleProperties(schema, properties2, node, stack) {
	var name = handleTagName(schema, node.tagName, node, stack);
	var reqs = schema.required || {};
	var props = properties2 || {};
	var allowed = Object.assign(
		{},
		toPropertyValueMap(schema.attributes['*']),
		toPropertyValueMap(name && own9.call(schema.attributes, name) ? schema.attributes[name] : [])
	);
	var result = {};
	var definition3;
	var value;
	var key3;
	for (key3 in props) {
		if (own9.call(props, key3)) {
			if (own9.call(allowed, key3)) {
				definition3 = allowed[key3];
			} else if (data(key3) && own9.call(allowed, 'data*')) {
				definition3 = allowed['data*'];
			} else {
				continue;
			}
			value = props[key3];
			value = Array.isArray(value)
				? handlePropertyValues(schema, value, key3, definition3)
				: handlePropertyValue(schema, value, key3, definition3);
			if (value !== void 0 && value !== null) {
				result[key3] = value;
			}
		}
	}
	if (name && own9.call(reqs, name)) {
		for (key3 in reqs[name]) {
			if (!own9.call(result, key3)) {
				result[key3] = reqs[name][key3];
			}
		}
	}
	return result;
}
function handleDoctypeName() {
	return 'html';
}
function handleTagName(schema, tagName, _, stack) {
	var name = typeof tagName === 'string' ? tagName : '';
	var index6 = -1;
	if (!name || name === '*' || !schema.tagNames.includes(name)) {
		return false;
	}
	if (own9.call(schema.ancestors, name)) {
		while (++index6 < schema.ancestors[name].length) {
			if (stack.includes(schema.ancestors[name][index6])) {
				return name;
			}
		}
		return false;
	}
	return name;
}
function handleCommentValue(_, value) {
	var result = typeof value === 'string' ? value : '';
	var index6 = result.indexOf('-->');
	return index6 < 0 ? result : result.slice(0, index6);
}
function handleValue(_, value) {
	return typeof value === 'string' ? value : '';
}
function allow(_, value) {
	return value;
}
function handlePropertyValues(schema, values, prop, definition3) {
	var index6 = -1;
	var result = [];
	var value;
	while (++index6 < values.length) {
		value = handlePropertyValue(schema, values[index6], prop, definition3);
		if (value !== void 0 && value !== null) {
			result.push(value);
		}
	}
	return result;
}
function handlePropertyValue(schema, value, prop, definition3) {
	if (
		(typeof value === 'boolean' || typeof value === 'number' || typeof value === 'string') &&
		safeProtocol(schema, value, prop) &&
		(definition3.length === 0 || definition3.includes(value))
	) {
		return schema.clobber.includes(prop) ? schema.clobberPrefix + value : value;
	}
}
function safeProtocol(schema, value, prop) {
	var url = String(value);
	var colon = url.indexOf(':');
	var questionMark = url.indexOf('?');
	var numberSign = url.indexOf('#');
	var slash = url.indexOf('/');
	var protocols = own9.call(schema.protocols, prop) ? schema.protocols[prop].concat() : [];
	var index6 = -1;
	if (
		protocols.length === 0 ||
		colon < 0 ||
		(slash > -1 && colon > slash) ||
		(questionMark > -1 && colon > questionMark) ||
		(numberSign > -1 && colon > numberSign)
	) {
		return true;
	}
	while (++index6 < protocols.length) {
		if (
			colon === protocols[index6].length &&
			url.slice(0, protocols[index6].length) === protocols[index6]
		) {
			return true;
		}
	}
	return false;
}
function toPropertyValueMap(values) {
	var result = {};
	var index6 = -1;
	var value;
	while (++index6 < values.length) {
		value = values[index6];
		if (Array.isArray(value)) {
			result[value[0]] = value.slice(1);
		} else {
			result[value] = [];
		}
	}
	return result;
}
function data(prop) {
	return prop.length > 4 && prop.slice(0, 4).toLowerCase() === 'data';
}
var own9, push2, nodeSchema;
var init_lib9 = __esm({
	'node_modules/hast-util-sanitize/lib/index.js'() {
		init_schema2();
		own9 = {}.hasOwnProperty;
		push2 = [].push;
		nodeSchema = {
			root: { children: all3 },
			doctype: handleDoctype,
			comment: handleComment,
			element: {
				tagName: handleTagName,
				properties: handleProperties,
				children: all3
			},
			text: { value: handleValue },
			'*': { data: allow, position: allow }
		};
	}
});

// node_modules/hast-util-sanitize/index.js
var init_hast_util_sanitize = __esm({
	'node_modules/hast-util-sanitize/index.js'() {
		init_lib9();
	}
});

// node_modules/unist-builder/index.js
var u;
var init_unist_builder = __esm({
	'node_modules/unist-builder/index.js'() {
		u = function (type, props, value) {
			var node = { type: String(type) };
			if (
				(value === void 0 || value === null) &&
				(typeof props === 'string' || Array.isArray(props))
			) {
				value = props;
			} else {
				Object.assign(node, props);
			}
			if (Array.isArray(value)) {
				node.children = value;
			} else if (value !== void 0 && value !== null) {
				node.value = String(value);
			}
			return node;
		};
	}
});

// node_modules/mdast-util-to-hast/lib/traverse.js
function unknown2(h3, node) {
	const data2 = node.data || {};
	if (
		'value' in node &&
		!(
			own10.call(data2, 'hName') ||
			own10.call(data2, 'hProperties') ||
			own10.call(data2, 'hChildren')
		)
	) {
		return h3.augment(node, u('text', node.value));
	}
	return h3(node, 'div', all4(h3, node));
}
function one4(h3, node, parent) {
	const type = node && node.type;
	let fn;
	if (!type) {
		throw new Error('Expected node, got `' + node + '`');
	}
	if (own10.call(h3.handlers, type)) {
		fn = h3.handlers[type];
	} else if (h3.passThrough && h3.passThrough.includes(type)) {
		fn = returnNode;
	} else {
		fn = h3.unknownHandler;
	}
	return (typeof fn === 'function' ? fn : unknown2)(h3, node, parent);
}
function returnNode(h3, node) {
	return 'children' in node ? { ...node, children: all4(h3, node) } : node;
}
function all4(h3, parent) {
	const values = [];
	if ('children' in parent) {
		const nodes2 = parent.children;
		let index6 = -1;
		while (++index6 < nodes2.length) {
			const result = one4(h3, nodes2[index6], parent);
			if (result) {
				if (index6 && nodes2[index6 - 1].type === 'break') {
					if (!Array.isArray(result) && result.type === 'text') {
						result.value = result.value.replace(/^\s+/, '');
					}
					if (!Array.isArray(result) && result.type === 'element') {
						const head2 = result.children[0];
						if (head2 && head2.type === 'text') {
							head2.value = head2.value.replace(/^\s+/, '');
						}
					}
				}
				if (Array.isArray(result)) {
					values.push(...result);
				} else {
					values.push(result);
				}
			}
		}
	}
	return values;
}
var own10;
var init_traverse = __esm({
	'node_modules/mdast-util-to-hast/lib/traverse.js'() {
		init_unist_builder();
		own10 = {}.hasOwnProperty;
	}
});

// node_modules/mdast-util-to-hast/node_modules/unist-util-visit-parents/color.js
function color2(d) {
	return '\x1B[33m' + d + '\x1B[39m';
}
var init_color2 = __esm({
	'node_modules/mdast-util-to-hast/node_modules/unist-util-visit-parents/color.js'() {}
});

// node_modules/mdast-util-to-hast/node_modules/unist-util-visit-parents/index.js
function toResult2(value) {
	if (Array.isArray(value)) {
		return value;
	}
	if (typeof value === 'number') {
		return [CONTINUE2, value];
	}
	return [value];
}
var CONTINUE2, SKIP2, EXIT2, visitParents2;
var init_unist_util_visit_parents2 = __esm({
	'node_modules/mdast-util-to-hast/node_modules/unist-util-visit-parents/index.js'() {
		init_unist_util_is();
		init_color2();
		CONTINUE2 = true;
		SKIP2 = 'skip';
		EXIT2 = false;
		visitParents2 = function (tree, test, visitor, reverse) {
			if (typeof test === 'function' && typeof visitor !== 'function') {
				reverse = visitor;
				visitor = test;
				test = null;
			}
			const is = convert(test);
			const step = reverse ? -1 : 1;
			factory2(tree, null, [])();
			function factory2(node, index6, parents) {
				const value = typeof node === 'object' && node !== null ? node : {};
				let name;
				if (typeof value.type === 'string') {
					name =
						typeof value.tagName === 'string'
							? value.tagName
							: typeof value.name === 'string'
							? value.name
							: void 0;
					Object.defineProperty(visit4, 'name', {
						value: 'node (' + color2(value.type + (name ? '<' + name + '>' : '')) + ')'
					});
				}
				return visit4;
				function visit4() {
					let result = [];
					let subresult;
					let offset;
					let grandparents;
					if (!test || is(node, index6, parents[parents.length - 1] || null)) {
						result = toResult2(visitor(node, parents));
						if (result[0] === EXIT2) {
							return result;
						}
					}
					if (node.children && result[0] !== SKIP2) {
						offset = (reverse ? node.children.length : -1) + step;
						grandparents = parents.concat(node);
						while (offset > -1 && offset < node.children.length) {
							subresult = factory2(node.children[offset], offset, grandparents)();
							if (subresult[0] === EXIT2) {
								return subresult;
							}
							offset = typeof subresult[1] === 'number' ? subresult[1] : offset + step;
						}
					}
					return result;
				}
			}
		};
	}
});

// node_modules/mdast-util-to-hast/node_modules/unist-util-visit/index.js
var visit2;
var init_unist_util_visit2 = __esm({
	'node_modules/mdast-util-to-hast/node_modules/unist-util-visit/index.js'() {
		init_unist_util_visit_parents2();
		visit2 = function (tree, test, visitor, reverse) {
			if (typeof test === 'function' && typeof visitor !== 'function') {
				reverse = visitor;
				visitor = test;
				test = null;
			}
			visitParents2(tree, test, overload, reverse);
			function overload(node, parents) {
				const parent = parents[parents.length - 1];
				return visitor(node, parent ? parent.children.indexOf(node) : null, parent);
			}
		};
	}
});

// node_modules/unist-util-position/index.js
function point2(type) {
	return point4;
	function point4(node) {
		const point5 = (node && node.position && node.position[type]) || {};
		return {
			line: point5.line || null,
			column: point5.column || null,
			offset: point5.offset > -1 ? point5.offset : null
		};
	}
}
var pointStart, pointEnd;
var init_unist_util_position = __esm({
	'node_modules/unist-util-position/index.js'() {
		pointStart = point2('start');
		pointEnd = point2('end');
	}
});

// node_modules/unist-util-generated/index.js
function generated(node) {
	return (
		!node ||
		!node.position ||
		!node.position.start ||
		!node.position.start.line ||
		!node.position.start.column ||
		!node.position.end ||
		!node.position.end.line ||
		!node.position.end.column
	);
}
var init_unist_util_generated = __esm({
	'node_modules/unist-util-generated/index.js'() {}
});

// node_modules/mdast-util-definitions/node_modules/unist-util-visit-parents/color.js
function color3(d) {
	return '\x1B[33m' + d + '\x1B[39m';
}
var init_color3 = __esm({
	'node_modules/mdast-util-definitions/node_modules/unist-util-visit-parents/color.js'() {}
});

// node_modules/mdast-util-definitions/node_modules/unist-util-visit-parents/index.js
function toResult3(value) {
	if (Array.isArray(value)) {
		return value;
	}
	if (typeof value === 'number') {
		return [CONTINUE3, value];
	}
	return [value];
}
var CONTINUE3, SKIP3, EXIT3, visitParents3;
var init_unist_util_visit_parents3 = __esm({
	'node_modules/mdast-util-definitions/node_modules/unist-util-visit-parents/index.js'() {
		init_unist_util_is();
		init_color3();
		CONTINUE3 = true;
		SKIP3 = 'skip';
		EXIT3 = false;
		visitParents3 = function (tree, test, visitor, reverse) {
			if (typeof test === 'function' && typeof visitor !== 'function') {
				reverse = visitor;
				visitor = test;
				test = null;
			}
			const is = convert(test);
			const step = reverse ? -1 : 1;
			factory2(tree, null, [])();
			function factory2(node, index6, parents) {
				const value = typeof node === 'object' && node !== null ? node : {};
				let name;
				if (typeof value.type === 'string') {
					name =
						typeof value.tagName === 'string'
							? value.tagName
							: typeof value.name === 'string'
							? value.name
							: void 0;
					Object.defineProperty(visit4, 'name', {
						value: 'node (' + color3(value.type + (name ? '<' + name + '>' : '')) + ')'
					});
				}
				return visit4;
				function visit4() {
					let result = [];
					let subresult;
					let offset;
					let grandparents;
					if (!test || is(node, index6, parents[parents.length - 1] || null)) {
						result = toResult3(visitor(node, parents));
						if (result[0] === EXIT3) {
							return result;
						}
					}
					if (node.children && result[0] !== SKIP3) {
						offset = (reverse ? node.children.length : -1) + step;
						grandparents = parents.concat(node);
						while (offset > -1 && offset < node.children.length) {
							subresult = factory2(node.children[offset], offset, grandparents)();
							if (subresult[0] === EXIT3) {
								return subresult;
							}
							offset = typeof subresult[1] === 'number' ? subresult[1] : offset + step;
						}
					}
					return result;
				}
			}
		};
	}
});

// node_modules/mdast-util-definitions/node_modules/unist-util-visit/index.js
var visit3;
var init_unist_util_visit3 = __esm({
	'node_modules/mdast-util-definitions/node_modules/unist-util-visit/index.js'() {
		init_unist_util_visit_parents3();
		visit3 = function (tree, test, visitor, reverse) {
			if (typeof test === 'function' && typeof visitor !== 'function') {
				reverse = visitor;
				visitor = test;
				test = null;
			}
			visitParents3(tree, test, overload, reverse);
			function overload(node, parents) {
				const parent = parents[parents.length - 1];
				return visitor(node, parent ? parent.children.indexOf(node) : null, parent);
			}
		};
	}
});

// node_modules/mdast-util-definitions/index.js
function definitions(node) {
	const cache = /* @__PURE__ */ Object.create(null);
	if (!node || !node.type) {
		throw new Error('mdast-util-definitions expected node');
	}
	visit3(node, 'definition', (definition4) => {
		const id = clean(definition4.identifier);
		if (id && !own11.call(cache, id)) {
			cache[id] = definition4;
		}
	});
	return definition3;
	function definition3(identifier) {
		const id = clean(identifier);
		return id && own11.call(cache, id) ? cache[id] : null;
	}
}
function clean(value) {
	return String(value || '').toUpperCase();
}
var own11;
var init_mdast_util_definitions = __esm({
	'node_modules/mdast-util-definitions/index.js'() {
		init_unist_util_visit3();
		own11 = {}.hasOwnProperty;
	}
});

// node_modules/micromark-util-encode/index.js
function encode3(value) {
	return value.replace(/["&<>]/g, replace);
	function replace(value2) {
		return '&' + characterReferences[value2] + ';';
	}
}
var characterReferences;
var init_micromark_util_encode = __esm({
	'node_modules/micromark-util-encode/index.js'() {
		characterReferences = { '"': 'quot', '&': 'amp', '<': 'lt', '>': 'gt' };
	}
});

// node_modules/micromark-util-sanitize-uri/index.js
function sanitizeUri(url, protocol) {
	const value = encode3(normalizeUri(url || ''));
	if (!protocol) {
		return value;
	}
	const colon = value.indexOf(':');
	const questionMark = value.indexOf('?');
	const numberSign = value.indexOf('#');
	const slash = value.indexOf('/');
	if (
		colon < 0 ||
		(slash > -1 && colon > slash) ||
		(questionMark > -1 && colon > questionMark) ||
		(numberSign > -1 && colon > numberSign) ||
		protocol.test(value.slice(0, colon))
	) {
		return value;
	}
	return '';
}
function normalizeUri(value) {
	const result = [];
	let index6 = -1;
	let start = 0;
	let skip = 0;
	while (++index6 < value.length) {
		const code3 = value.charCodeAt(index6);
		let replace = '';
		if (
			code3 === 37 &&
			asciiAlphanumeric(value.charCodeAt(index6 + 1)) &&
			asciiAlphanumeric(value.charCodeAt(index6 + 2))
		) {
			skip = 2;
		} else if (code3 < 128) {
			if (!/[!#$&-;=?-Z_a-z~]/.test(String.fromCharCode(code3))) {
				replace = String.fromCharCode(code3);
			}
		} else if (code3 > 55295 && code3 < 57344) {
			const next = value.charCodeAt(index6 + 1);
			if (code3 < 56320 && next > 56319 && next < 57344) {
				replace = String.fromCharCode(code3, next);
				skip = 1;
			} else {
				replace = '\uFFFD';
			}
		} else {
			replace = String.fromCharCode(code3);
		}
		if (replace) {
			result.push(value.slice(start, index6), encodeURIComponent(replace));
			start = index6 + skip + 1;
			replace = '';
		}
		if (skip) {
			index6 += skip;
			skip = 0;
		}
	}
	return result.join('') + value.slice(start);
}
var init_micromark_util_sanitize_uri = __esm({
	'node_modules/micromark-util-sanitize-uri/index.js'() {
		init_micromark_util_character();
		init_micromark_util_encode();
	}
});

// node_modules/mdast-util-to-hast/lib/wrap.js
function wrap2(nodes2, loose) {
	const result = [];
	let index6 = -1;
	if (loose) {
		result.push(u('text', '\n'));
	}
	while (++index6 < nodes2.length) {
		if (index6) result.push(u('text', '\n'));
		result.push(nodes2[index6]);
	}
	if (loose && nodes2.length > 0) {
		result.push(u('text', '\n'));
	}
	return result;
}
var init_wrap = __esm({
	'node_modules/mdast-util-to-hast/lib/wrap.js'() {
		init_unist_builder();
	}
});

// node_modules/mdast-util-to-hast/lib/footer.js
function footer(h3) {
	let index6 = -1;
	const listItems = [];
	while (++index6 < h3.footnoteOrder.length) {
		const def = h3.footnoteById[h3.footnoteOrder[index6].toUpperCase()];
		if (!def) {
			continue;
		}
		const content3 = all4(h3, def);
		const id = String(def.identifier);
		const safeId = sanitizeUri(id.toLowerCase());
		let referenceIndex = 0;
		const backReferences = [];
		while (++referenceIndex <= h3.footnoteCounts[id]) {
			const backReference = {
				type: 'element',
				tagName: 'a',
				properties: {
					href:
						'#' +
						h3.clobberPrefix +
						'fnref-' +
						safeId +
						(referenceIndex > 1 ? '-' + referenceIndex : ''),
					dataFootnoteBackref: true,
					className: ['data-footnote-backref'],
					ariaLabel: h3.footnoteBackLabel
				},
				children: [{ type: 'text', value: '\u21A9' }]
			};
			if (referenceIndex > 1) {
				backReference.children.push({
					type: 'element',
					tagName: 'sup',
					children: [{ type: 'text', value: String(referenceIndex) }]
				});
			}
			if (backReferences.length > 0) {
				backReferences.push({ type: 'text', value: ' ' });
			}
			backReferences.push(backReference);
		}
		const tail = content3[content3.length - 1];
		if (tail && tail.type === 'element' && tail.tagName === 'p') {
			const tailTail = tail.children[tail.children.length - 1];
			if (tailTail && tailTail.type === 'text') {
				tailTail.value += ' ';
			} else {
				tail.children.push({ type: 'text', value: ' ' });
			}
			tail.children.push(...backReferences);
		} else {
			content3.push(...backReferences);
		}
		const listItem3 = {
			type: 'element',
			tagName: 'li',
			properties: { id: h3.clobberPrefix + 'fn-' + safeId },
			children: wrap2(content3, true)
		};
		if (def.position) {
			listItem3.position = def.position;
		}
		listItems.push(listItem3);
	}
	if (listItems.length === 0) {
		return null;
	}
	return {
		type: 'element',
		tagName: 'section',
		properties: { dataFootnotes: true, className: ['footnotes'] },
		children: [
			{
				type: 'element',
				tagName: 'h2',
				properties: { id: 'footnote-label', className: ['sr-only'] },
				children: [u('text', h3.footnoteLabel)]
			},
			{ type: 'text', value: '\n' },
			{
				type: 'element',
				tagName: 'ol',
				properties: {},
				children: wrap2(listItems, true)
			},
			{ type: 'text', value: '\n' }
		]
	};
}
var init_footer = __esm({
	'node_modules/mdast-util-to-hast/lib/footer.js'() {
		init_micromark_util_sanitize_uri();
		init_unist_builder();
		init_traverse();
		init_wrap();
	}
});

// node_modules/mdast-util-to-hast/lib/handlers/blockquote.js
function blockquote2(h3, node) {
	return h3(node, 'blockquote', wrap2(all4(h3, node), true));
}
var init_blockquote2 = __esm({
	'node_modules/mdast-util-to-hast/lib/handlers/blockquote.js'() {
		init_wrap();
		init_traverse();
	}
});

// node_modules/mdast-util-to-hast/lib/handlers/break.js
function hardBreak2(h3, node) {
	return [h3(node, 'br'), u('text', '\n')];
}
var init_break2 = __esm({
	'node_modules/mdast-util-to-hast/lib/handlers/break.js'() {
		init_unist_builder();
	}
});

// node_modules/mdast-util-to-hast/lib/handlers/code.js
function code2(h3, node) {
	const value = node.value ? node.value + '\n' : '';
	const lang = node.lang && node.lang.match(/^[^ \t]+(?=[ \t]|$)/);
	const props = {};
	if (lang) {
		props.className = ['language-' + lang];
	}
	const code3 = h3(node, 'code', props, [u('text', value)]);
	if (node.meta) {
		code3.data = { meta: node.meta };
	}
	return h3(node.position, 'pre', [code3]);
}
var init_code2 = __esm({
	'node_modules/mdast-util-to-hast/lib/handlers/code.js'() {
		init_unist_builder();
	}
});

// node_modules/mdast-util-to-hast/lib/handlers/delete.js
function strikethrough(h3, node) {
	return h3(node, 'del', all4(h3, node));
}
var init_delete = __esm({
	'node_modules/mdast-util-to-hast/lib/handlers/delete.js'() {
		init_traverse();
	}
});

// node_modules/mdast-util-to-hast/lib/handlers/emphasis.js
function emphasis2(h3, node) {
	return h3(node, 'em', all4(h3, node));
}
var init_emphasis2 = __esm({
	'node_modules/mdast-util-to-hast/lib/handlers/emphasis.js'() {
		init_traverse();
	}
});

// node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js
function footnoteReference(h3, node) {
	const id = String(node.identifier);
	const safeId = sanitizeUri(id.toLowerCase());
	const index6 = h3.footnoteOrder.indexOf(id);
	let counter;
	if (index6 === -1) {
		h3.footnoteOrder.push(id);
		h3.footnoteCounts[id] = 1;
		counter = h3.footnoteOrder.length;
	} else {
		h3.footnoteCounts[id]++;
		counter = index6 + 1;
	}
	const reuseCounter = h3.footnoteCounts[id];
	return h3(node, 'sup', [
		h3(
			node.position,
			'a',
			{
				href: '#' + h3.clobberPrefix + 'fn-' + safeId,
				id: h3.clobberPrefix + 'fnref-' + safeId + (reuseCounter > 1 ? '-' + reuseCounter : ''),
				dataFootnoteRef: true,
				ariaDescribedBy: 'footnote-label'
			},
			[u('text', String(counter))]
		)
	]);
}
var init_footnote_reference = __esm({
	'node_modules/mdast-util-to-hast/lib/handlers/footnote-reference.js'() {
		init_micromark_util_sanitize_uri();
		init_unist_builder();
	}
});

// node_modules/mdast-util-to-hast/lib/handlers/footnote.js
function footnote(h3, node) {
	const footnoteById = h3.footnoteById;
	let no = 1;
	while (no in footnoteById) no++;
	const identifier = String(no);
	footnoteById[identifier] = {
		type: 'footnoteDefinition',
		identifier,
		children: [{ type: 'paragraph', children: node.children }],
		position: node.position
	};
	return footnoteReference(h3, {
		type: 'footnoteReference',
		identifier,
		position: node.position
	});
}
var init_footnote = __esm({
	'node_modules/mdast-util-to-hast/lib/handlers/footnote.js'() {
		init_footnote_reference();
	}
});

// node_modules/mdast-util-to-hast/lib/handlers/heading.js
function heading2(h3, node) {
	return h3(node, 'h' + node.depth, all4(h3, node));
}
var init_heading2 = __esm({
	'node_modules/mdast-util-to-hast/lib/handlers/heading.js'() {
		init_traverse();
	}
});

// node_modules/mdast-util-to-hast/lib/handlers/html.js
function html6(h3, node) {
	return h3.dangerous ? h3.augment(node, u('raw', node.value)) : null;
}
var init_html3 = __esm({
	'node_modules/mdast-util-to-hast/lib/handlers/html.js'() {
		init_unist_builder();
	}
});

// node_modules/mdurl/encode.js
var require_encode = __commonJS({
	'node_modules/mdurl/encode.js'(exports, module2) {
		'use strict';
		var encodeCache = {};
		function getEncodeCache(exclude) {
			var i2,
				ch,
				cache = encodeCache[exclude];
			if (cache) {
				return cache;
			}
			cache = encodeCache[exclude] = [];
			for (i2 = 0; i2 < 128; i2++) {
				ch = String.fromCharCode(i2);
				if (/^[0-9a-z]$/i.test(ch)) {
					cache.push(ch);
				} else {
					cache.push('%' + ('0' + i2.toString(16).toUpperCase()).slice(-2));
				}
			}
			for (i2 = 0; i2 < exclude.length; i2++) {
				cache[exclude.charCodeAt(i2)] = exclude[i2];
			}
			return cache;
		}
		function encode4(string3, exclude, keepEscaped) {
			var i2,
				l,
				code3,
				nextCode,
				cache,
				result = '';
			if (typeof exclude !== 'string') {
				keepEscaped = exclude;
				exclude = encode4.defaultChars;
			}
			if (typeof keepEscaped === 'undefined') {
				keepEscaped = true;
			}
			cache = getEncodeCache(exclude);
			for (i2 = 0, l = string3.length; i2 < l; i2++) {
				code3 = string3.charCodeAt(i2);
				if (keepEscaped && code3 === 37 && i2 + 2 < l) {
					if (/^[0-9a-f]{2}$/i.test(string3.slice(i2 + 1, i2 + 3))) {
						result += string3.slice(i2, i2 + 3);
						i2 += 2;
						continue;
					}
				}
				if (code3 < 128) {
					result += cache[code3];
					continue;
				}
				if (code3 >= 55296 && code3 <= 57343) {
					if (code3 >= 55296 && code3 <= 56319 && i2 + 1 < l) {
						nextCode = string3.charCodeAt(i2 + 1);
						if (nextCode >= 56320 && nextCode <= 57343) {
							result += encodeURIComponent(string3[i2] + string3[i2 + 1]);
							i2++;
							continue;
						}
					}
					result += '%EF%BF%BD';
					continue;
				}
				result += encodeURIComponent(string3[i2]);
			}
			return result;
		}
		encode4.defaultChars = ";/?:@&=+$,-_.!~*'()#";
		encode4.componentChars = "-_.!~*'()";
		module2.exports = encode4;
	}
});

// node_modules/mdast-util-to-hast/lib/revert.js
function revert(h3, node) {
	const subtype = node.referenceType;
	let suffix = ']';
	if (subtype === 'collapsed') {
		suffix += '[]';
	} else if (subtype === 'full') {
		suffix += '[' + (node.label || node.identifier) + ']';
	}
	if (node.type === 'imageReference') {
		return u('text', '![' + node.alt + suffix);
	}
	const contents = all4(h3, node);
	const head2 = contents[0];
	if (head2 && head2.type === 'text') {
		head2.value = '[' + head2.value;
	} else {
		contents.unshift(u('text', '['));
	}
	const tail = contents[contents.length - 1];
	if (tail && tail.type === 'text') {
		tail.value += suffix;
	} else {
		contents.push(u('text', suffix));
	}
	return contents;
}
var init_revert = __esm({
	'node_modules/mdast-util-to-hast/lib/revert.js'() {
		init_unist_builder();
		init_traverse();
	}
});

// node_modules/mdast-util-to-hast/lib/handlers/image-reference.js
function imageReference2(h3, node) {
	const def = h3.definition(node.identifier);
	if (!def) {
		return revert(h3, node);
	}
	const props = { src: (0, import_encode.default)(def.url || ''), alt: node.alt };
	if (def.title !== null && def.title !== void 0) {
		props.title = def.title;
	}
	return h3(node, 'img', props);
}
var import_encode;
var init_image_reference2 = __esm({
	'node_modules/mdast-util-to-hast/lib/handlers/image-reference.js'() {
		import_encode = __toESM(require_encode(), 1);
		init_revert();
	}
});

// node_modules/mdast-util-to-hast/lib/handlers/image.js
function image2(h3, node) {
	const props = { src: (0, import_encode2.default)(node.url), alt: node.alt };
	if (node.title !== null && node.title !== void 0) {
		props.title = node.title;
	}
	return h3(node, 'img', props);
}
var import_encode2;
var init_image2 = __esm({
	'node_modules/mdast-util-to-hast/lib/handlers/image.js'() {
		import_encode2 = __toESM(require_encode(), 1);
	}
});

// node_modules/mdast-util-to-hast/lib/handlers/inline-code.js
function inlineCode2(h3, node) {
	return h3(node, 'code', [u('text', node.value.replace(/\r?\n|\r/g, ' '))]);
}
var init_inline_code2 = __esm({
	'node_modules/mdast-util-to-hast/lib/handlers/inline-code.js'() {
		init_unist_builder();
	}
});

// node_modules/mdast-util-to-hast/lib/handlers/link-reference.js
function linkReference2(h3, node) {
	const def = h3.definition(node.identifier);
	if (!def) {
		return revert(h3, node);
	}
	const props = { href: (0, import_encode3.default)(def.url || '') };
	if (def.title !== null && def.title !== void 0) {
		props.title = def.title;
	}
	return h3(node, 'a', props, all4(h3, node));
}
var import_encode3;
var init_link_reference2 = __esm({
	'node_modules/mdast-util-to-hast/lib/handlers/link-reference.js'() {
		import_encode3 = __toESM(require_encode(), 1);
		init_revert();
		init_traverse();
	}
});

// node_modules/mdast-util-to-hast/lib/handlers/link.js
function link2(h3, node) {
	const props = { href: (0, import_encode4.default)(node.url) };
	if (node.title !== null && node.title !== void 0) {
		props.title = node.title;
	}
	return h3(node, 'a', props, all4(h3, node));
}
var import_encode4;
var init_link2 = __esm({
	'node_modules/mdast-util-to-hast/lib/handlers/link.js'() {
		import_encode4 = __toESM(require_encode(), 1);
		init_traverse();
	}
});

// node_modules/mdast-util-to-hast/lib/handlers/list-item.js
function listItem2(h3, node, parent) {
	const result = all4(h3, node);
	const loose = parent ? listLoose(parent) : listItemLoose(node);
	const props = {};
	const wrapped = [];
	if (typeof node.checked === 'boolean') {
		let paragraph3;
		if (result[0] && result[0].type === 'element' && result[0].tagName === 'p') {
			paragraph3 = result[0];
		} else {
			paragraph3 = h3(null, 'p', []);
			result.unshift(paragraph3);
		}
		if (paragraph3.children.length > 0) {
			paragraph3.children.unshift(u('text', ' '));
		}
		paragraph3.children.unshift(
			h3(null, 'input', {
				type: 'checkbox',
				checked: node.checked,
				disabled: true
			})
		);
		props.className = ['task-list-item'];
	}
	let index6 = -1;
	while (++index6 < result.length) {
		const child = result[index6];
		if (loose || index6 !== 0 || child.type !== 'element' || child.tagName !== 'p') {
			wrapped.push(u('text', '\n'));
		}
		if (child.type === 'element' && child.tagName === 'p' && !loose) {
			wrapped.push(...child.children);
		} else {
			wrapped.push(child);
		}
	}
	const tail = result[result.length - 1];
	if (tail && (loose || !('tagName' in tail) || tail.tagName !== 'p')) {
		wrapped.push(u('text', '\n'));
	}
	return h3(node, 'li', props, wrapped);
}
function listLoose(node) {
	let loose = node.spread;
	const children = node.children;
	let index6 = -1;
	while (!loose && ++index6 < children.length) {
		loose = listItemLoose(children[index6]);
	}
	return Boolean(loose);
}
function listItemLoose(node) {
	const spread = node.spread;
	return spread === void 0 || spread === null ? node.children.length > 1 : spread;
}
var init_list_item2 = __esm({
	'node_modules/mdast-util-to-hast/lib/handlers/list-item.js'() {
		init_unist_builder();
		init_traverse();
	}
});

// node_modules/mdast-util-to-hast/lib/handlers/list.js
function list3(h3, node) {
	const props = {};
	const name = node.ordered ? 'ol' : 'ul';
	const items = all4(h3, node);
	let index6 = -1;
	if (typeof node.start === 'number' && node.start !== 1) {
		props.start = node.start;
	}
	while (++index6 < items.length) {
		const item = items[index6];
		if (
			item.type === 'element' &&
			item.tagName === 'li' &&
			item.properties &&
			Array.isArray(item.properties.className) &&
			item.properties.className.includes('task-list-item')
		) {
			props.className = ['contains-task-list'];
			break;
		}
	}
	return h3(node, name, props, wrap2(items, true));
}
var init_list3 = __esm({
	'node_modules/mdast-util-to-hast/lib/handlers/list.js'() {
		init_wrap();
		init_traverse();
	}
});

// node_modules/mdast-util-to-hast/lib/handlers/paragraph.js
function paragraph2(h3, node) {
	return h3(node, 'p', all4(h3, node));
}
var init_paragraph2 = __esm({
	'node_modules/mdast-util-to-hast/lib/handlers/paragraph.js'() {
		init_traverse();
	}
});

// node_modules/mdast-util-to-hast/lib/handlers/root.js
function root2(h3, node) {
	return h3.augment(node, u('root', wrap2(all4(h3, node))));
}
var init_root2 = __esm({
	'node_modules/mdast-util-to-hast/lib/handlers/root.js'() {
		init_unist_builder();
		init_traverse();
		init_wrap();
	}
});

// node_modules/mdast-util-to-hast/lib/handlers/strong.js
function strong2(h3, node) {
	return h3(node, 'strong', all4(h3, node));
}
var init_strong2 = __esm({
	'node_modules/mdast-util-to-hast/lib/handlers/strong.js'() {
		init_traverse();
	}
});

// node_modules/mdast-util-to-hast/lib/handlers/table.js
function table(h3, node) {
	const rows = node.children;
	let index6 = -1;
	const align = node.align || [];
	const result = [];
	while (++index6 < rows.length) {
		const row = rows[index6].children;
		const name = index6 === 0 ? 'th' : 'td';
		const out = [];
		let cellIndex = -1;
		const length = node.align ? align.length : row.length;
		while (++cellIndex < length) {
			const cell = row[cellIndex];
			out.push(h3(cell, name, { align: align[cellIndex] }, cell ? all4(h3, cell) : []));
		}
		result[index6] = h3(rows[index6], 'tr', wrap2(out, true));
	}
	return h3(
		node,
		'table',
		wrap2(
			[h3(result[0].position, 'thead', wrap2([result[0]], true))].concat(
				result[1]
					? h3(
							{
								start: pointStart(result[1]),
								end: pointEnd(result[result.length - 1])
							},
							'tbody',
							wrap2(result.slice(1), true)
					  )
					: []
			),
			true
		)
	);
}
var init_table = __esm({
	'node_modules/mdast-util-to-hast/lib/handlers/table.js'() {
		init_unist_util_position();
		init_wrap();
		init_traverse();
	}
});

// node_modules/mdast-util-to-hast/lib/handlers/text.js
function text5(h3, node) {
	return h3.augment(node, u('text', String(node.value).replace(/[ \t]*(\r?\n|\r)[ \t]*/g, '$1')));
}
var init_text4 = __esm({
	'node_modules/mdast-util-to-hast/lib/handlers/text.js'() {
		init_unist_builder();
	}
});

// node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js
function thematicBreak3(h3, node) {
	return h3(node, 'hr');
}
var init_thematic_break3 = __esm({
	'node_modules/mdast-util-to-hast/lib/handlers/thematic-break.js'() {}
});

// node_modules/mdast-util-to-hast/lib/handlers/index.js
function ignore() {
	return null;
}
var handlers2;
var init_handlers = __esm({
	'node_modules/mdast-util-to-hast/lib/handlers/index.js'() {
		init_blockquote2();
		init_break2();
		init_code2();
		init_delete();
		init_emphasis2();
		init_footnote_reference();
		init_footnote();
		init_heading2();
		init_html3();
		init_image_reference2();
		init_image2();
		init_inline_code2();
		init_link_reference2();
		init_link2();
		init_list_item2();
		init_list3();
		init_paragraph2();
		init_root2();
		init_strong2();
		init_table();
		init_text4();
		init_thematic_break3();
		handlers2 = {
			blockquote: blockquote2,
			break: hardBreak2,
			code: code2,
			delete: strikethrough,
			emphasis: emphasis2,
			footnoteReference,
			footnote,
			heading: heading2,
			html: html6,
			imageReference: imageReference2,
			image: image2,
			inlineCode: inlineCode2,
			linkReference: linkReference2,
			link: link2,
			listItem: listItem2,
			list: list3,
			paragraph: paragraph2,
			root: root2,
			strong: strong2,
			table,
			text: text5,
			thematicBreak: thematicBreak3,
			toml: ignore,
			yaml: ignore,
			definition: ignore,
			footnoteDefinition: ignore
		};
	}
});

// node_modules/mdast-util-to-hast/lib/index.js
function factory(tree, options) {
	const settings = options || {};
	const dangerous2 = settings.allowDangerousHtml || false;
	const footnoteById = {};
	h3.dangerous = dangerous2;
	h3.clobberPrefix =
		settings.clobberPrefix === void 0 || settings.clobberPrefix === null
			? 'user-content-'
			: settings.clobberPrefix;
	h3.footnoteLabel = settings.footnoteLabel || 'Footnotes';
	h3.footnoteBackLabel = settings.footnoteBackLabel || 'Back to content';
	h3.definition = definitions(tree);
	h3.footnoteById = footnoteById;
	h3.footnoteOrder = [];
	h3.footnoteCounts = {};
	h3.augment = augment;
	h3.handlers = { ...handlers2, ...settings.handlers };
	h3.unknownHandler = settings.unknownHandler;
	h3.passThrough = settings.passThrough;
	visit2(tree, 'footnoteDefinition', (definition3) => {
		const id = String(definition3.identifier).toUpperCase();
		if (!own12.call(footnoteById, id)) {
			footnoteById[id] = definition3;
		}
	});
	return h3;
	function augment(left, right) {
		if (left && 'data' in left && left.data) {
			const data2 = left.data;
			if (data2.hName) {
				if (right.type !== 'element') {
					right = {
						type: 'element',
						tagName: '',
						properties: {},
						children: []
					};
				}
				right.tagName = data2.hName;
			}
			if (right.type === 'element' && data2.hProperties) {
				right.properties = { ...right.properties, ...data2.hProperties };
			}
			if ('children' in right && right.children && data2.hChildren) {
				right.children = data2.hChildren;
			}
		}
		if (left) {
			const ctx = 'type' in left ? left : { position: left };
			if (!generated(ctx)) {
				right.position = { start: pointStart(ctx), end: pointEnd(ctx) };
			}
		}
		return right;
	}
	function h3(node, tagName, props, children) {
		if (Array.isArray(props)) {
			children = props;
			props = {};
		}
		return augment(node, {
			type: 'element',
			tagName,
			properties: props || {},
			children: children || []
		});
	}
}
function toHast(tree, options) {
	const h3 = factory(tree, options);
	const node = one4(h3, tree, null);
	const foot = footer(h3);
	if (foot) {
		node.children.push(u('text', '\n'), foot);
	}
	return Array.isArray(node) ? { type: 'root', children: node } : node;
}
var own12;
var init_lib10 = __esm({
	'node_modules/mdast-util-to-hast/lib/index.js'() {
		init_unist_builder();
		init_unist_util_visit2();
		init_unist_util_position();
		init_unist_util_generated();
		init_mdast_util_definitions();
		init_traverse();
		init_footer();
		init_handlers();
		own12 = {}.hasOwnProperty;
	}
});

// node_modules/mdast-util-to-hast/index.js
var init_mdast_util_to_hast = __esm({
	'node_modules/mdast-util-to-hast/index.js'() {
		init_lib10();
	}
});

// node_modules/remark-html/index.js
function remarkHtml(settings = {}) {
	const options = { ...settings };
	let clean2;
	if (typeof options.sanitize === 'boolean') {
		clean2 = options.sanitize;
		options.sanitize = void 0;
	}
	if (typeof clean2 !== 'boolean') {
		clean2 = true;
	}
	Object.assign(this, { Compiler: compiler2 });
	function compiler2(node, file2) {
		const hast = toHast(node, {
			allowDangerousHtml: !clean2,
			handlers: options.handlers
		});
		const cleanHast = clean2 ? sanitize(hast, options.sanitize) : hast;
		const result = toHtml(cleanHast, Object.assign({}, options, { allowDangerousHtml: !clean2 }));
		if (file2.extname) {
			file2.extname = '.html';
		}
		return node &&
			node.type &&
			node.type === 'root' &&
			result &&
			/[^\r\n]/.test(result.charAt(result.length - 1))
			? result + '\n'
			: result;
	}
}
var init_remark_html = __esm({
	'node_modules/remark-html/index.js'() {
		init_hast_util_to_html();
		init_hast_util_sanitize();
		init_mdast_util_to_hast();
	}
});

// node_modules/parse5/lib/common/unicode.js
var require_unicode = __commonJS({
	'node_modules/parse5/lib/common/unicode.js'(exports) {
		'use strict';
		var UNDEFINED_CODE_POINTS = [
			65534, 65535, 131070, 131071, 196606, 196607, 262142, 262143, 327678, 327679, 393214, 393215,
			458750, 458751, 524286, 524287, 589822, 589823, 655358, 655359, 720894, 720895, 786430,
			786431, 851966, 851967, 917502, 917503, 983038, 983039, 1048574, 1048575, 1114110, 1114111
		];
		exports.REPLACEMENT_CHARACTER = '\uFFFD';
		exports.CODE_POINTS = {
			EOF: -1,
			NULL: 0,
			TABULATION: 9,
			CARRIAGE_RETURN: 13,
			LINE_FEED: 10,
			FORM_FEED: 12,
			SPACE: 32,
			EXCLAMATION_MARK: 33,
			QUOTATION_MARK: 34,
			NUMBER_SIGN: 35,
			AMPERSAND: 38,
			APOSTROPHE: 39,
			HYPHEN_MINUS: 45,
			SOLIDUS: 47,
			DIGIT_0: 48,
			DIGIT_9: 57,
			SEMICOLON: 59,
			LESS_THAN_SIGN: 60,
			EQUALS_SIGN: 61,
			GREATER_THAN_SIGN: 62,
			QUESTION_MARK: 63,
			LATIN_CAPITAL_A: 65,
			LATIN_CAPITAL_F: 70,
			LATIN_CAPITAL_X: 88,
			LATIN_CAPITAL_Z: 90,
			RIGHT_SQUARE_BRACKET: 93,
			GRAVE_ACCENT: 96,
			LATIN_SMALL_A: 97,
			LATIN_SMALL_F: 102,
			LATIN_SMALL_X: 120,
			LATIN_SMALL_Z: 122,
			REPLACEMENT_CHARACTER: 65533
		};
		exports.CODE_POINT_SEQUENCES = {
			DASH_DASH_STRING: [45, 45],
			DOCTYPE_STRING: [68, 79, 67, 84, 89, 80, 69],
			CDATA_START_STRING: [91, 67, 68, 65, 84, 65, 91],
			SCRIPT_STRING: [115, 99, 114, 105, 112, 116],
			PUBLIC_STRING: [80, 85, 66, 76, 73, 67],
			SYSTEM_STRING: [83, 89, 83, 84, 69, 77]
		};
		exports.isSurrogate = function (cp) {
			return cp >= 55296 && cp <= 57343;
		};
		exports.isSurrogatePair = function (cp) {
			return cp >= 56320 && cp <= 57343;
		};
		exports.getSurrogatePairCodePoint = function (cp1, cp2) {
			return (cp1 - 55296) * 1024 + 9216 + cp2;
		};
		exports.isControlCodePoint = function (cp) {
			return (
				(cp !== 32 && cp !== 10 && cp !== 13 && cp !== 9 && cp !== 12 && cp >= 1 && cp <= 31) ||
				(cp >= 127 && cp <= 159)
			);
		};
		exports.isUndefinedCodePoint = function (cp) {
			return (cp >= 64976 && cp <= 65007) || UNDEFINED_CODE_POINTS.indexOf(cp) > -1;
		};
	}
});

// node_modules/parse5/lib/common/error-codes.js
var require_error_codes = __commonJS({
	'node_modules/parse5/lib/common/error-codes.js'(exports, module2) {
		'use strict';
		module2.exports = {
			controlCharacterInInputStream: 'control-character-in-input-stream',
			noncharacterInInputStream: 'noncharacter-in-input-stream',
			surrogateInInputStream: 'surrogate-in-input-stream',
			nonVoidHtmlElementStartTagWithTrailingSolidus:
				'non-void-html-element-start-tag-with-trailing-solidus',
			endTagWithAttributes: 'end-tag-with-attributes',
			endTagWithTrailingSolidus: 'end-tag-with-trailing-solidus',
			unexpectedSolidusInTag: 'unexpected-solidus-in-tag',
			unexpectedNullCharacter: 'unexpected-null-character',
			unexpectedQuestionMarkInsteadOfTagName: 'unexpected-question-mark-instead-of-tag-name',
			invalidFirstCharacterOfTagName: 'invalid-first-character-of-tag-name',
			unexpectedEqualsSignBeforeAttributeName: 'unexpected-equals-sign-before-attribute-name',
			missingEndTagName: 'missing-end-tag-name',
			unexpectedCharacterInAttributeName: 'unexpected-character-in-attribute-name',
			unknownNamedCharacterReference: 'unknown-named-character-reference',
			missingSemicolonAfterCharacterReference: 'missing-semicolon-after-character-reference',
			unexpectedCharacterAfterDoctypeSystemIdentifier:
				'unexpected-character-after-doctype-system-identifier',
			unexpectedCharacterInUnquotedAttributeValue:
				'unexpected-character-in-unquoted-attribute-value',
			eofBeforeTagName: 'eof-before-tag-name',
			eofInTag: 'eof-in-tag',
			missingAttributeValue: 'missing-attribute-value',
			missingWhitespaceBetweenAttributes: 'missing-whitespace-between-attributes',
			missingWhitespaceAfterDoctypePublicKeyword: 'missing-whitespace-after-doctype-public-keyword',
			missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers:
				'missing-whitespace-between-doctype-public-and-system-identifiers',
			missingWhitespaceAfterDoctypeSystemKeyword: 'missing-whitespace-after-doctype-system-keyword',
			missingQuoteBeforeDoctypePublicIdentifier: 'missing-quote-before-doctype-public-identifier',
			missingQuoteBeforeDoctypeSystemIdentifier: 'missing-quote-before-doctype-system-identifier',
			missingDoctypePublicIdentifier: 'missing-doctype-public-identifier',
			missingDoctypeSystemIdentifier: 'missing-doctype-system-identifier',
			abruptDoctypePublicIdentifier: 'abrupt-doctype-public-identifier',
			abruptDoctypeSystemIdentifier: 'abrupt-doctype-system-identifier',
			cdataInHtmlContent: 'cdata-in-html-content',
			incorrectlyOpenedComment: 'incorrectly-opened-comment',
			eofInScriptHtmlCommentLikeText: 'eof-in-script-html-comment-like-text',
			eofInDoctype: 'eof-in-doctype',
			nestedComment: 'nested-comment',
			abruptClosingOfEmptyComment: 'abrupt-closing-of-empty-comment',
			eofInComment: 'eof-in-comment',
			incorrectlyClosedComment: 'incorrectly-closed-comment',
			eofInCdata: 'eof-in-cdata',
			absenceOfDigitsInNumericCharacterReference:
				'absence-of-digits-in-numeric-character-reference',
			nullCharacterReference: 'null-character-reference',
			surrogateCharacterReference: 'surrogate-character-reference',
			characterReferenceOutsideUnicodeRange: 'character-reference-outside-unicode-range',
			controlCharacterReference: 'control-character-reference',
			noncharacterCharacterReference: 'noncharacter-character-reference',
			missingWhitespaceBeforeDoctypeName: 'missing-whitespace-before-doctype-name',
			missingDoctypeName: 'missing-doctype-name',
			invalidCharacterSequenceAfterDoctypeName: 'invalid-character-sequence-after-doctype-name',
			duplicateAttribute: 'duplicate-attribute',
			nonConformingDoctype: 'non-conforming-doctype',
			missingDoctype: 'missing-doctype',
			misplacedDoctype: 'misplaced-doctype',
			endTagWithoutMatchingOpenElement: 'end-tag-without-matching-open-element',
			closingOfElementWithOpenChildElements: 'closing-of-element-with-open-child-elements',
			disallowedContentInNoscriptInHead: 'disallowed-content-in-noscript-in-head',
			openElementsLeftAfterEof: 'open-elements-left-after-eof',
			abandonedHeadElementChild: 'abandoned-head-element-child',
			misplacedStartTagForHeadElement: 'misplaced-start-tag-for-head-element',
			nestedNoscriptInHead: 'nested-noscript-in-head',
			eofInElementThatCanContainOnlyText: 'eof-in-element-that-can-contain-only-text'
		};
	}
});

// node_modules/parse5/lib/tokenizer/preprocessor.js
var require_preprocessor = __commonJS({
	'node_modules/parse5/lib/tokenizer/preprocessor.js'(exports, module2) {
		'use strict';
		var unicode = require_unicode();
		var ERR = require_error_codes();
		var $ = unicode.CODE_POINTS;
		var DEFAULT_BUFFER_WATERLINE = 1 << 16;
		var Preprocessor = class {
			constructor() {
				this.html = null;
				this.pos = -1;
				this.lastGapPos = -1;
				this.lastCharPos = -1;
				this.gapStack = [];
				this.skipNextNewLine = false;
				this.lastChunkWritten = false;
				this.endOfChunkHit = false;
				this.bufferWaterline = DEFAULT_BUFFER_WATERLINE;
			}
			_err() {}
			_addGap() {
				this.gapStack.push(this.lastGapPos);
				this.lastGapPos = this.pos;
			}
			_processSurrogate(cp) {
				if (this.pos !== this.lastCharPos) {
					const nextCp = this.html.charCodeAt(this.pos + 1);
					if (unicode.isSurrogatePair(nextCp)) {
						this.pos++;
						this._addGap();
						return unicode.getSurrogatePairCodePoint(cp, nextCp);
					}
				} else if (!this.lastChunkWritten) {
					this.endOfChunkHit = true;
					return $.EOF;
				}
				this._err(ERR.surrogateInInputStream);
				return cp;
			}
			dropParsedChunk() {
				if (this.pos > this.bufferWaterline) {
					this.lastCharPos -= this.pos;
					this.html = this.html.substring(this.pos);
					this.pos = 0;
					this.lastGapPos = -1;
					this.gapStack = [];
				}
			}
			write(chunk, isLastChunk) {
				if (this.html) {
					this.html += chunk;
				} else {
					this.html = chunk;
				}
				this.lastCharPos = this.html.length - 1;
				this.endOfChunkHit = false;
				this.lastChunkWritten = isLastChunk;
			}
			insertHtmlAtCurrentPos(chunk) {
				this.html =
					this.html.substring(0, this.pos + 1) +
					chunk +
					this.html.substring(this.pos + 1, this.html.length);
				this.lastCharPos = this.html.length - 1;
				this.endOfChunkHit = false;
			}
			advance() {
				this.pos++;
				if (this.pos > this.lastCharPos) {
					this.endOfChunkHit = !this.lastChunkWritten;
					return $.EOF;
				}
				let cp = this.html.charCodeAt(this.pos);
				if (this.skipNextNewLine && cp === $.LINE_FEED) {
					this.skipNextNewLine = false;
					this._addGap();
					return this.advance();
				}
				if (cp === $.CARRIAGE_RETURN) {
					this.skipNextNewLine = true;
					return $.LINE_FEED;
				}
				this.skipNextNewLine = false;
				if (unicode.isSurrogate(cp)) {
					cp = this._processSurrogate(cp);
				}
				const isCommonValidRange =
					(cp > 31 && cp < 127) ||
					cp === $.LINE_FEED ||
					cp === $.CARRIAGE_RETURN ||
					(cp > 159 && cp < 64976);
				if (!isCommonValidRange) {
					this._checkForProblematicCharacters(cp);
				}
				return cp;
			}
			_checkForProblematicCharacters(cp) {
				if (unicode.isControlCodePoint(cp)) {
					this._err(ERR.controlCharacterInInputStream);
				} else if (unicode.isUndefinedCodePoint(cp)) {
					this._err(ERR.noncharacterInInputStream);
				}
			}
			retreat() {
				if (this.pos === this.lastGapPos) {
					this.lastGapPos = this.gapStack.pop();
					this.pos--;
				}
				this.pos--;
			}
		};
		module2.exports = Preprocessor;
	}
});

// node_modules/parse5/lib/tokenizer/named-entity-data.js
var require_named_entity_data = __commonJS({
	'node_modules/parse5/lib/tokenizer/named-entity-data.js'(exports, module2) {
		'use strict';
		module2.exports = new Uint16Array([
			4, 52, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86,
			87, 88, 89, 90, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,
			113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 106, 303, 412, 810, 1432, 1701, 1796, 1987,
			2114, 2360, 2420, 2484, 3170, 3251, 4140, 4393, 4575, 4610, 5106, 5512, 5728, 6117, 6274,
			6315, 6345, 6427, 6516, 7002, 7910, 8733, 9323, 9870, 10170, 10631, 10893, 11318, 11386,
			11467, 12773, 13092, 14474, 14922, 15448, 15542, 16419, 17666, 18166, 18611, 19004, 19095,
			19298, 19397, 4, 16, 69, 77, 97, 98, 99, 102, 103, 108, 109, 110, 111, 112, 114, 115, 116,
			117, 140, 150, 158, 169, 176, 194, 199, 210, 216, 222, 226, 242, 256, 266, 283, 294, 108, 105,
			103, 5, 198, 1, 59, 148, 1, 198, 80, 5, 38, 1, 59, 156, 1, 38, 99, 117, 116, 101, 5, 193, 1,
			59, 167, 1, 193, 114, 101, 118, 101, 59, 1, 258, 4, 2, 105, 121, 182, 191, 114, 99, 5, 194, 1,
			59, 189, 1, 194, 59, 1, 1040, 114, 59, 3, 55349, 56580, 114, 97, 118, 101, 5, 192, 1, 59, 208,
			1, 192, 112, 104, 97, 59, 1, 913, 97, 99, 114, 59, 1, 256, 100, 59, 1, 10835, 4, 2, 103, 112,
			232, 237, 111, 110, 59, 1, 260, 102, 59, 3, 55349, 56632, 112, 108, 121, 70, 117, 110, 99,
			116, 105, 111, 110, 59, 1, 8289, 105, 110, 103, 5, 197, 1, 59, 264, 1, 197, 4, 2, 99, 115,
			272, 277, 114, 59, 3, 55349, 56476, 105, 103, 110, 59, 1, 8788, 105, 108, 100, 101, 5, 195, 1,
			59, 292, 1, 195, 109, 108, 5, 196, 1, 59, 301, 1, 196, 4, 8, 97, 99, 101, 102, 111, 114, 115,
			117, 321, 350, 354, 383, 388, 394, 400, 405, 4, 2, 99, 114, 327, 336, 107, 115, 108, 97, 115,
			104, 59, 1, 8726, 4, 2, 118, 119, 342, 345, 59, 1, 10983, 101, 100, 59, 1, 8966, 121, 59, 1,
			1041, 4, 3, 99, 114, 116, 362, 369, 379, 97, 117, 115, 101, 59, 1, 8757, 110, 111, 117, 108,
			108, 105, 115, 59, 1, 8492, 97, 59, 1, 914, 114, 59, 3, 55349, 56581, 112, 102, 59, 3, 55349,
			56633, 101, 118, 101, 59, 1, 728, 99, 114, 59, 1, 8492, 109, 112, 101, 113, 59, 1, 8782, 4,
			14, 72, 79, 97, 99, 100, 101, 102, 104, 105, 108, 111, 114, 115, 117, 442, 447, 456, 504, 542,
			547, 569, 573, 577, 616, 678, 784, 790, 796, 99, 121, 59, 1, 1063, 80, 89, 5, 169, 1, 59, 454,
			1, 169, 4, 3, 99, 112, 121, 464, 470, 497, 117, 116, 101, 59, 1, 262, 4, 2, 59, 105, 476, 478,
			1, 8914, 116, 97, 108, 68, 105, 102, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68, 59, 1,
			8517, 108, 101, 121, 115, 59, 1, 8493, 4, 4, 97, 101, 105, 111, 514, 520, 530, 535, 114, 111,
			110, 59, 1, 268, 100, 105, 108, 5, 199, 1, 59, 528, 1, 199, 114, 99, 59, 1, 264, 110, 105,
			110, 116, 59, 1, 8752, 111, 116, 59, 1, 266, 4, 2, 100, 110, 553, 560, 105, 108, 108, 97, 59,
			1, 184, 116, 101, 114, 68, 111, 116, 59, 1, 183, 114, 59, 1, 8493, 105, 59, 1, 935, 114, 99,
			108, 101, 4, 4, 68, 77, 80, 84, 591, 596, 603, 609, 111, 116, 59, 1, 8857, 105, 110, 117, 115,
			59, 1, 8854, 108, 117, 115, 59, 1, 8853, 105, 109, 101, 115, 59, 1, 8855, 111, 4, 2, 99, 115,
			623, 646, 107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103,
			114, 97, 108, 59, 1, 8754, 101, 67, 117, 114, 108, 121, 4, 2, 68, 81, 658, 671, 111, 117, 98,
			108, 101, 81, 117, 111, 116, 101, 59, 1, 8221, 117, 111, 116, 101, 59, 1, 8217, 4, 4, 108,
			110, 112, 117, 688, 701, 736, 753, 111, 110, 4, 2, 59, 101, 696, 698, 1, 8759, 59, 1, 10868,
			4, 3, 103, 105, 116, 709, 717, 722, 114, 117, 101, 110, 116, 59, 1, 8801, 110, 116, 59, 1,
			8751, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8750, 4, 2, 102, 114, 742,
			745, 59, 1, 8450, 111, 100, 117, 99, 116, 59, 1, 8720, 110, 116, 101, 114, 67, 108, 111, 99,
			107, 119, 105, 115, 101, 67, 111, 110, 116, 111, 117, 114, 73, 110, 116, 101, 103, 114, 97,
			108, 59, 1, 8755, 111, 115, 115, 59, 1, 10799, 99, 114, 59, 3, 55349, 56478, 112, 4, 2, 59,
			67, 803, 805, 1, 8915, 97, 112, 59, 1, 8781, 4, 11, 68, 74, 83, 90, 97, 99, 101, 102, 105,
			111, 115, 834, 850, 855, 860, 865, 888, 903, 916, 921, 1011, 1415, 4, 2, 59, 111, 840, 842, 1,
			8517, 116, 114, 97, 104, 100, 59, 1, 10513, 99, 121, 59, 1, 1026, 99, 121, 59, 1, 1029, 99,
			121, 59, 1, 1039, 4, 3, 103, 114, 115, 873, 879, 883, 103, 101, 114, 59, 1, 8225, 114, 59, 1,
			8609, 104, 118, 59, 1, 10980, 4, 2, 97, 121, 894, 900, 114, 111, 110, 59, 1, 270, 59, 1, 1044,
			108, 4, 2, 59, 116, 910, 912, 1, 8711, 97, 59, 1, 916, 114, 59, 3, 55349, 56583, 4, 2, 97,
			102, 927, 998, 4, 2, 99, 109, 933, 992, 114, 105, 116, 105, 99, 97, 108, 4, 4, 65, 68, 71, 84,
			950, 957, 978, 985, 99, 117, 116, 101, 59, 1, 180, 111, 4, 2, 116, 117, 964, 967, 59, 1, 729,
			98, 108, 101, 65, 99, 117, 116, 101, 59, 1, 733, 114, 97, 118, 101, 59, 1, 96, 105, 108, 100,
			101, 59, 1, 732, 111, 110, 100, 59, 1, 8900, 102, 101, 114, 101, 110, 116, 105, 97, 108, 68,
			59, 1, 8518, 4, 4, 112, 116, 117, 119, 1021, 1026, 1048, 1249, 102, 59, 3, 55349, 56635, 4, 3,
			59, 68, 69, 1034, 1036, 1041, 1, 168, 111, 116, 59, 1, 8412, 113, 117, 97, 108, 59, 1, 8784,
			98, 108, 101, 4, 6, 67, 68, 76, 82, 85, 86, 1065, 1082, 1101, 1189, 1211, 1236, 111, 110, 116,
			111, 117, 114, 73, 110, 116, 101, 103, 114, 97, 108, 59, 1, 8751, 111, 4, 2, 116, 119, 1089,
			1092, 59, 1, 168, 110, 65, 114, 114, 111, 119, 59, 1, 8659, 4, 2, 101, 111, 1107, 1141, 102,
			116, 4, 3, 65, 82, 84, 1117, 1124, 1136, 114, 114, 111, 119, 59, 1, 8656, 105, 103, 104, 116,
			65, 114, 114, 111, 119, 59, 1, 8660, 101, 101, 59, 1, 10980, 110, 103, 4, 2, 76, 82, 1149,
			1177, 101, 102, 116, 4, 2, 65, 82, 1158, 1165, 114, 114, 111, 119, 59, 1, 10232, 105, 103,
			104, 116, 65, 114, 114, 111, 119, 59, 1, 10234, 105, 103, 104, 116, 65, 114, 114, 111, 119,
			59, 1, 10233, 105, 103, 104, 116, 4, 2, 65, 84, 1199, 1206, 114, 114, 111, 119, 59, 1, 8658,
			101, 101, 59, 1, 8872, 112, 4, 2, 65, 68, 1218, 1225, 114, 114, 111, 119, 59, 1, 8657, 111,
			119, 110, 65, 114, 114, 111, 119, 59, 1, 8661, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114,
			59, 1, 8741, 110, 4, 6, 65, 66, 76, 82, 84, 97, 1264, 1292, 1299, 1352, 1391, 1408, 114, 114,
			111, 119, 4, 3, 59, 66, 85, 1276, 1278, 1283, 1, 8595, 97, 114, 59, 1, 10515, 112, 65, 114,
			114, 111, 119, 59, 1, 8693, 114, 101, 118, 101, 59, 1, 785, 101, 102, 116, 4, 3, 82, 84, 86,
			1310, 1323, 1334, 105, 103, 104, 116, 86, 101, 99, 116, 111, 114, 59, 1, 10576, 101, 101, 86,
			101, 99, 116, 111, 114, 59, 1, 10590, 101, 99, 116, 111, 114, 4, 2, 59, 66, 1345, 1347, 1,
			8637, 97, 114, 59, 1, 10582, 105, 103, 104, 116, 4, 2, 84, 86, 1362, 1373, 101, 101, 86, 101,
			99, 116, 111, 114, 59, 1, 10591, 101, 99, 116, 111, 114, 4, 2, 59, 66, 1384, 1386, 1, 8641,
			97, 114, 59, 1, 10583, 101, 101, 4, 2, 59, 65, 1399, 1401, 1, 8868, 114, 114, 111, 119, 59, 1,
			8615, 114, 114, 111, 119, 59, 1, 8659, 4, 2, 99, 116, 1421, 1426, 114, 59, 3, 55349, 56479,
			114, 111, 107, 59, 1, 272, 4, 16, 78, 84, 97, 99, 100, 102, 103, 108, 109, 111, 112, 113, 115,
			116, 117, 120, 1466, 1470, 1478, 1489, 1515, 1520, 1525, 1536, 1544, 1593, 1609, 1617, 1650,
			1664, 1668, 1677, 71, 59, 1, 330, 72, 5, 208, 1, 59, 1476, 1, 208, 99, 117, 116, 101, 5, 201,
			1, 59, 1487, 1, 201, 4, 3, 97, 105, 121, 1497, 1503, 1512, 114, 111, 110, 59, 1, 282, 114, 99,
			5, 202, 1, 59, 1510, 1, 202, 59, 1, 1069, 111, 116, 59, 1, 278, 114, 59, 3, 55349, 56584, 114,
			97, 118, 101, 5, 200, 1, 59, 1534, 1, 200, 101, 109, 101, 110, 116, 59, 1, 8712, 4, 2, 97,
			112, 1550, 1555, 99, 114, 59, 1, 274, 116, 121, 4, 2, 83, 86, 1563, 1576, 109, 97, 108, 108,
			83, 113, 117, 97, 114, 101, 59, 1, 9723, 101, 114, 121, 83, 109, 97, 108, 108, 83, 113, 117,
			97, 114, 101, 59, 1, 9643, 4, 2, 103, 112, 1599, 1604, 111, 110, 59, 1, 280, 102, 59, 3,
			55349, 56636, 115, 105, 108, 111, 110, 59, 1, 917, 117, 4, 2, 97, 105, 1624, 1640, 108, 4, 2,
			59, 84, 1631, 1633, 1, 10869, 105, 108, 100, 101, 59, 1, 8770, 108, 105, 98, 114, 105, 117,
			109, 59, 1, 8652, 4, 2, 99, 105, 1656, 1660, 114, 59, 1, 8496, 109, 59, 1, 10867, 97, 59, 1,
			919, 109, 108, 5, 203, 1, 59, 1675, 1, 203, 4, 2, 105, 112, 1683, 1689, 115, 116, 115, 59, 1,
			8707, 111, 110, 101, 110, 116, 105, 97, 108, 69, 59, 1, 8519, 4, 5, 99, 102, 105, 111, 115,
			1713, 1717, 1722, 1762, 1791, 121, 59, 1, 1060, 114, 59, 3, 55349, 56585, 108, 108, 101, 100,
			4, 2, 83, 86, 1732, 1745, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9724, 101,
			114, 121, 83, 109, 97, 108, 108, 83, 113, 117, 97, 114, 101, 59, 1, 9642, 4, 3, 112, 114, 117,
			1770, 1775, 1781, 102, 59, 3, 55349, 56637, 65, 108, 108, 59, 1, 8704, 114, 105, 101, 114,
			116, 114, 102, 59, 1, 8497, 99, 114, 59, 1, 8497, 4, 12, 74, 84, 97, 98, 99, 100, 102, 103,
			111, 114, 115, 116, 1822, 1827, 1834, 1848, 1855, 1877, 1882, 1887, 1890, 1896, 1978, 1984,
			99, 121, 59, 1, 1027, 5, 62, 1, 59, 1832, 1, 62, 109, 109, 97, 4, 2, 59, 100, 1843, 1845, 1,
			915, 59, 1, 988, 114, 101, 118, 101, 59, 1, 286, 4, 3, 101, 105, 121, 1863, 1869, 1874, 100,
			105, 108, 59, 1, 290, 114, 99, 59, 1, 284, 59, 1, 1043, 111, 116, 59, 1, 288, 114, 59, 3,
			55349, 56586, 59, 1, 8921, 112, 102, 59, 3, 55349, 56638, 101, 97, 116, 101, 114, 4, 6, 69,
			70, 71, 76, 83, 84, 1915, 1933, 1944, 1953, 1959, 1971, 113, 117, 97, 108, 4, 2, 59, 76, 1925,
			1927, 1, 8805, 101, 115, 115, 59, 1, 8923, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8807,
			114, 101, 97, 116, 101, 114, 59, 1, 10914, 101, 115, 115, 59, 1, 8823, 108, 97, 110, 116, 69,
			113, 117, 97, 108, 59, 1, 10878, 105, 108, 100, 101, 59, 1, 8819, 99, 114, 59, 3, 55349,
			56482, 59, 1, 8811, 4, 8, 65, 97, 99, 102, 105, 111, 115, 117, 2005, 2012, 2026, 2032, 2036,
			2049, 2073, 2089, 82, 68, 99, 121, 59, 1, 1066, 4, 2, 99, 116, 2018, 2023, 101, 107, 59, 1,
			711, 59, 1, 94, 105, 114, 99, 59, 1, 292, 114, 59, 1, 8460, 108, 98, 101, 114, 116, 83, 112,
			97, 99, 101, 59, 1, 8459, 4, 2, 112, 114, 2055, 2059, 102, 59, 1, 8461, 105, 122, 111, 110,
			116, 97, 108, 76, 105, 110, 101, 59, 1, 9472, 4, 2, 99, 116, 2079, 2083, 114, 59, 1, 8459,
			114, 111, 107, 59, 1, 294, 109, 112, 4, 2, 68, 69, 2097, 2107, 111, 119, 110, 72, 117, 109,
			112, 59, 1, 8782, 113, 117, 97, 108, 59, 1, 8783, 4, 14, 69, 74, 79, 97, 99, 100, 102, 103,
			109, 110, 111, 115, 116, 117, 2144, 2149, 2155, 2160, 2171, 2189, 2194, 2198, 2209, 2245,
			2307, 2329, 2334, 2341, 99, 121, 59, 1, 1045, 108, 105, 103, 59, 1, 306, 99, 121, 59, 1, 1025,
			99, 117, 116, 101, 5, 205, 1, 59, 2169, 1, 205, 4, 2, 105, 121, 2177, 2186, 114, 99, 5, 206,
			1, 59, 2184, 1, 206, 59, 1, 1048, 111, 116, 59, 1, 304, 114, 59, 1, 8465, 114, 97, 118, 101,
			5, 204, 1, 59, 2207, 1, 204, 4, 3, 59, 97, 112, 2217, 2219, 2238, 1, 8465, 4, 2, 99, 103,
			2225, 2229, 114, 59, 1, 298, 105, 110, 97, 114, 121, 73, 59, 1, 8520, 108, 105, 101, 115, 59,
			1, 8658, 4, 2, 116, 118, 2251, 2281, 4, 2, 59, 101, 2257, 2259, 1, 8748, 4, 2, 103, 114, 2265,
			2271, 114, 97, 108, 59, 1, 8747, 115, 101, 99, 116, 105, 111, 110, 59, 1, 8898, 105, 115, 105,
			98, 108, 101, 4, 2, 67, 84, 2293, 2300, 111, 109, 109, 97, 59, 1, 8291, 105, 109, 101, 115,
			59, 1, 8290, 4, 3, 103, 112, 116, 2315, 2320, 2325, 111, 110, 59, 1, 302, 102, 59, 3, 55349,
			56640, 97, 59, 1, 921, 99, 114, 59, 1, 8464, 105, 108, 100, 101, 59, 1, 296, 4, 2, 107, 109,
			2347, 2352, 99, 121, 59, 1, 1030, 108, 5, 207, 1, 59, 2358, 1, 207, 4, 5, 99, 102, 111, 115,
			117, 2372, 2386, 2391, 2397, 2414, 4, 2, 105, 121, 2378, 2383, 114, 99, 59, 1, 308, 59, 1,
			1049, 114, 59, 3, 55349, 56589, 112, 102, 59, 3, 55349, 56641, 4, 2, 99, 101, 2403, 2408, 114,
			59, 3, 55349, 56485, 114, 99, 121, 59, 1, 1032, 107, 99, 121, 59, 1, 1028, 4, 7, 72, 74, 97,
			99, 102, 111, 115, 2436, 2441, 2446, 2452, 2467, 2472, 2478, 99, 121, 59, 1, 1061, 99, 121,
			59, 1, 1036, 112, 112, 97, 59, 1, 922, 4, 2, 101, 121, 2458, 2464, 100, 105, 108, 59, 1, 310,
			59, 1, 1050, 114, 59, 3, 55349, 56590, 112, 102, 59, 3, 55349, 56642, 99, 114, 59, 3, 55349,
			56486, 4, 11, 74, 84, 97, 99, 101, 102, 108, 109, 111, 115, 116, 2508, 2513, 2520, 2562, 2585,
			2981, 2986, 3004, 3011, 3146, 3167, 99, 121, 59, 1, 1033, 5, 60, 1, 59, 2518, 1, 60, 4, 5, 99,
			109, 110, 112, 114, 2532, 2538, 2544, 2548, 2558, 117, 116, 101, 59, 1, 313, 98, 100, 97, 59,
			1, 923, 103, 59, 1, 10218, 108, 97, 99, 101, 116, 114, 102, 59, 1, 8466, 114, 59, 1, 8606, 4,
			3, 97, 101, 121, 2570, 2576, 2582, 114, 111, 110, 59, 1, 317, 100, 105, 108, 59, 1, 315, 59,
			1, 1051, 4, 2, 102, 115, 2591, 2907, 116, 4, 10, 65, 67, 68, 70, 82, 84, 85, 86, 97, 114,
			2614, 2663, 2672, 2728, 2735, 2760, 2820, 2870, 2888, 2895, 4, 2, 110, 114, 2620, 2633, 103,
			108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10216, 114, 111, 119, 4, 3, 59, 66, 82, 2644,
			2646, 2651, 1, 8592, 97, 114, 59, 1, 8676, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1,
			8646, 101, 105, 108, 105, 110, 103, 59, 1, 8968, 111, 4, 2, 117, 119, 2679, 2692, 98, 108,
			101, 66, 114, 97, 99, 107, 101, 116, 59, 1, 10214, 110, 4, 2, 84, 86, 2699, 2710, 101, 101,
			86, 101, 99, 116, 111, 114, 59, 1, 10593, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2721, 2723, 1,
			8643, 97, 114, 59, 1, 10585, 108, 111, 111, 114, 59, 1, 8970, 105, 103, 104, 116, 4, 2, 65,
			86, 2745, 2752, 114, 114, 111, 119, 59, 1, 8596, 101, 99, 116, 111, 114, 59, 1, 10574, 4, 2,
			101, 114, 2766, 2792, 101, 4, 3, 59, 65, 86, 2775, 2777, 2784, 1, 8867, 114, 114, 111, 119,
			59, 1, 8612, 101, 99, 116, 111, 114, 59, 1, 10586, 105, 97, 110, 103, 108, 101, 4, 3, 59, 66,
			69, 2806, 2808, 2813, 1, 8882, 97, 114, 59, 1, 10703, 113, 117, 97, 108, 59, 1, 8884, 112, 4,
			3, 68, 84, 86, 2829, 2841, 2852, 111, 119, 110, 86, 101, 99, 116, 111, 114, 59, 1, 10577, 101,
			101, 86, 101, 99, 116, 111, 114, 59, 1, 10592, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2863,
			2865, 1, 8639, 97, 114, 59, 1, 10584, 101, 99, 116, 111, 114, 4, 2, 59, 66, 2881, 2883, 1,
			8636, 97, 114, 59, 1, 10578, 114, 114, 111, 119, 59, 1, 8656, 105, 103, 104, 116, 97, 114,
			114, 111, 119, 59, 1, 8660, 115, 4, 6, 69, 70, 71, 76, 83, 84, 2922, 2936, 2947, 2956, 2962,
			2974, 113, 117, 97, 108, 71, 114, 101, 97, 116, 101, 114, 59, 1, 8922, 117, 108, 108, 69, 113,
			117, 97, 108, 59, 1, 8806, 114, 101, 97, 116, 101, 114, 59, 1, 8822, 101, 115, 115, 59, 1,
			10913, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 10877, 105, 108, 100, 101, 59, 1,
			8818, 114, 59, 3, 55349, 56591, 4, 2, 59, 101, 2992, 2994, 1, 8920, 102, 116, 97, 114, 114,
			111, 119, 59, 1, 8666, 105, 100, 111, 116, 59, 1, 319, 4, 3, 110, 112, 119, 3019, 3110, 3115,
			103, 4, 4, 76, 82, 108, 114, 3030, 3058, 3070, 3098, 101, 102, 116, 4, 2, 65, 82, 3039, 3046,
			114, 114, 111, 119, 59, 1, 10229, 105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10231,
			105, 103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 10230, 101, 102, 116, 4, 2, 97, 114, 3079,
			3086, 114, 114, 111, 119, 59, 1, 10232, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1,
			10234, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 10233, 102, 59, 3, 55349, 56643,
			101, 114, 4, 2, 76, 82, 3123, 3134, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8601, 105,
			103, 104, 116, 65, 114, 114, 111, 119, 59, 1, 8600, 4, 3, 99, 104, 116, 3154, 3158, 3161, 114,
			59, 1, 8466, 59, 1, 8624, 114, 111, 107, 59, 1, 321, 59, 1, 8810, 4, 8, 97, 99, 101, 102, 105,
			111, 115, 117, 3188, 3192, 3196, 3222, 3227, 3237, 3243, 3248, 112, 59, 1, 10501, 121, 59, 1,
			1052, 4, 2, 100, 108, 3202, 3213, 105, 117, 109, 83, 112, 97, 99, 101, 59, 1, 8287, 108, 105,
			110, 116, 114, 102, 59, 1, 8499, 114, 59, 3, 55349, 56592, 110, 117, 115, 80, 108, 117, 115,
			59, 1, 8723, 112, 102, 59, 3, 55349, 56644, 99, 114, 59, 1, 8499, 59, 1, 924, 4, 9, 74, 97,
			99, 101, 102, 111, 115, 116, 117, 3271, 3276, 3283, 3306, 3422, 3427, 4120, 4126, 4137, 99,
			121, 59, 1, 1034, 99, 117, 116, 101, 59, 1, 323, 4, 3, 97, 101, 121, 3291, 3297, 3303, 114,
			111, 110, 59, 1, 327, 100, 105, 108, 59, 1, 325, 59, 1, 1053, 4, 3, 103, 115, 119, 3314, 3380,
			3415, 97, 116, 105, 118, 101, 4, 3, 77, 84, 86, 3327, 3340, 3365, 101, 100, 105, 117, 109, 83,
			112, 97, 99, 101, 59, 1, 8203, 104, 105, 4, 2, 99, 110, 3348, 3357, 107, 83, 112, 97, 99, 101,
			59, 1, 8203, 83, 112, 97, 99, 101, 59, 1, 8203, 101, 114, 121, 84, 104, 105, 110, 83, 112, 97,
			99, 101, 59, 1, 8203, 116, 101, 100, 4, 2, 71, 76, 3389, 3405, 114, 101, 97, 116, 101, 114,
			71, 114, 101, 97, 116, 101, 114, 59, 1, 8811, 101, 115, 115, 76, 101, 115, 115, 59, 1, 8810,
			76, 105, 110, 101, 59, 1, 10, 114, 59, 3, 55349, 56593, 4, 4, 66, 110, 112, 116, 3437, 3444,
			3460, 3464, 114, 101, 97, 107, 59, 1, 8288, 66, 114, 101, 97, 107, 105, 110, 103, 83, 112, 97,
			99, 101, 59, 1, 160, 102, 59, 1, 8469, 4, 13, 59, 67, 68, 69, 71, 72, 76, 78, 80, 82, 83, 84,
			86, 3492, 3494, 3517, 3536, 3578, 3657, 3685, 3784, 3823, 3860, 3915, 4066, 4107, 1, 10988, 4,
			2, 111, 117, 3500, 3510, 110, 103, 114, 117, 101, 110, 116, 59, 1, 8802, 112, 67, 97, 112, 59,
			1, 8813, 111, 117, 98, 108, 101, 86, 101, 114, 116, 105, 99, 97, 108, 66, 97, 114, 59, 1,
			8742, 4, 3, 108, 113, 120, 3544, 3552, 3571, 101, 109, 101, 110, 116, 59, 1, 8713, 117, 97,
			108, 4, 2, 59, 84, 3561, 3563, 1, 8800, 105, 108, 100, 101, 59, 3, 8770, 824, 105, 115, 116,
			115, 59, 1, 8708, 114, 101, 97, 116, 101, 114, 4, 7, 59, 69, 70, 71, 76, 83, 84, 3600, 3602,
			3609, 3621, 3631, 3637, 3650, 1, 8815, 113, 117, 97, 108, 59, 1, 8817, 117, 108, 108, 69, 113,
			117, 97, 108, 59, 3, 8807, 824, 114, 101, 97, 116, 101, 114, 59, 3, 8811, 824, 101, 115, 115,
			59, 1, 8825, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 3, 10878, 824, 105, 108, 100, 101,
			59, 1, 8821, 117, 109, 112, 4, 2, 68, 69, 3666, 3677, 111, 119, 110, 72, 117, 109, 112, 59, 3,
			8782, 824, 113, 117, 97, 108, 59, 3, 8783, 824, 101, 4, 2, 102, 115, 3692, 3724, 116, 84, 114,
			105, 97, 110, 103, 108, 101, 4, 3, 59, 66, 69, 3709, 3711, 3717, 1, 8938, 97, 114, 59, 3,
			10703, 824, 113, 117, 97, 108, 59, 1, 8940, 115, 4, 6, 59, 69, 71, 76, 83, 84, 3739, 3741,
			3748, 3757, 3764, 3777, 1, 8814, 113, 117, 97, 108, 59, 1, 8816, 114, 101, 97, 116, 101, 114,
			59, 1, 8824, 101, 115, 115, 59, 3, 8810, 824, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 3,
			10877, 824, 105, 108, 100, 101, 59, 1, 8820, 101, 115, 116, 101, 100, 4, 2, 71, 76, 3795,
			3812, 114, 101, 97, 116, 101, 114, 71, 114, 101, 97, 116, 101, 114, 59, 3, 10914, 824, 101,
			115, 115, 76, 101, 115, 115, 59, 3, 10913, 824, 114, 101, 99, 101, 100, 101, 115, 4, 3, 59,
			69, 83, 3838, 3840, 3848, 1, 8832, 113, 117, 97, 108, 59, 3, 10927, 824, 108, 97, 110, 116,
			69, 113, 117, 97, 108, 59, 1, 8928, 4, 2, 101, 105, 3866, 3881, 118, 101, 114, 115, 101, 69,
			108, 101, 109, 101, 110, 116, 59, 1, 8716, 103, 104, 116, 84, 114, 105, 97, 110, 103, 108,
			101, 4, 3, 59, 66, 69, 3900, 3902, 3908, 1, 8939, 97, 114, 59, 3, 10704, 824, 113, 117, 97,
			108, 59, 1, 8941, 4, 2, 113, 117, 3921, 3973, 117, 97, 114, 101, 83, 117, 4, 2, 98, 112, 3933,
			3952, 115, 101, 116, 4, 2, 59, 69, 3942, 3945, 3, 8847, 824, 113, 117, 97, 108, 59, 1, 8930,
			101, 114, 115, 101, 116, 4, 2, 59, 69, 3963, 3966, 3, 8848, 824, 113, 117, 97, 108, 59, 1,
			8931, 4, 3, 98, 99, 112, 3981, 4e3, 4045, 115, 101, 116, 4, 2, 59, 69, 3990, 3993, 3, 8834,
			8402, 113, 117, 97, 108, 59, 1, 8840, 99, 101, 101, 100, 115, 4, 4, 59, 69, 83, 84, 4015,
			4017, 4025, 4037, 1, 8833, 113, 117, 97, 108, 59, 3, 10928, 824, 108, 97, 110, 116, 69, 113,
			117, 97, 108, 59, 1, 8929, 105, 108, 100, 101, 59, 3, 8831, 824, 101, 114, 115, 101, 116, 4,
			2, 59, 69, 4056, 4059, 3, 8835, 8402, 113, 117, 97, 108, 59, 1, 8841, 105, 108, 100, 101, 4,
			4, 59, 69, 70, 84, 4080, 4082, 4089, 4100, 1, 8769, 113, 117, 97, 108, 59, 1, 8772, 117, 108,
			108, 69, 113, 117, 97, 108, 59, 1, 8775, 105, 108, 100, 101, 59, 1, 8777, 101, 114, 116, 105,
			99, 97, 108, 66, 97, 114, 59, 1, 8740, 99, 114, 59, 3, 55349, 56489, 105, 108, 100, 101, 5,
			209, 1, 59, 4135, 1, 209, 59, 1, 925, 4, 14, 69, 97, 99, 100, 102, 103, 109, 111, 112, 114,
			115, 116, 117, 118, 4170, 4176, 4187, 4205, 4212, 4217, 4228, 4253, 4259, 4292, 4295, 4316,
			4337, 4346, 108, 105, 103, 59, 1, 338, 99, 117, 116, 101, 5, 211, 1, 59, 4185, 1, 211, 4, 2,
			105, 121, 4193, 4202, 114, 99, 5, 212, 1, 59, 4200, 1, 212, 59, 1, 1054, 98, 108, 97, 99, 59,
			1, 336, 114, 59, 3, 55349, 56594, 114, 97, 118, 101, 5, 210, 1, 59, 4226, 1, 210, 4, 3, 97,
			101, 105, 4236, 4241, 4246, 99, 114, 59, 1, 332, 103, 97, 59, 1, 937, 99, 114, 111, 110, 59,
			1, 927, 112, 102, 59, 3, 55349, 56646, 101, 110, 67, 117, 114, 108, 121, 4, 2, 68, 81, 4272,
			4285, 111, 117, 98, 108, 101, 81, 117, 111, 116, 101, 59, 1, 8220, 117, 111, 116, 101, 59, 1,
			8216, 59, 1, 10836, 4, 2, 99, 108, 4301, 4306, 114, 59, 3, 55349, 56490, 97, 115, 104, 5, 216,
			1, 59, 4314, 1, 216, 105, 4, 2, 108, 109, 4323, 4332, 100, 101, 5, 213, 1, 59, 4330, 1, 213,
			101, 115, 59, 1, 10807, 109, 108, 5, 214, 1, 59, 4344, 1, 214, 101, 114, 4, 2, 66, 80, 4354,
			4380, 4, 2, 97, 114, 4360, 4364, 114, 59, 1, 8254, 97, 99, 4, 2, 101, 107, 4372, 4375, 59, 1,
			9182, 101, 116, 59, 1, 9140, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 1, 9180, 4,
			9, 97, 99, 102, 104, 105, 108, 111, 114, 115, 4413, 4422, 4426, 4431, 4435, 4438, 4448, 4471,
			4561, 114, 116, 105, 97, 108, 68, 59, 1, 8706, 121, 59, 1, 1055, 114, 59, 3, 55349, 56595,
			105, 59, 1, 934, 59, 1, 928, 117, 115, 77, 105, 110, 117, 115, 59, 1, 177, 4, 2, 105, 112,
			4454, 4467, 110, 99, 97, 114, 101, 112, 108, 97, 110, 101, 59, 1, 8460, 102, 59, 1, 8473, 4,
			4, 59, 101, 105, 111, 4481, 4483, 4526, 4531, 1, 10939, 99, 101, 100, 101, 115, 4, 4, 59, 69,
			83, 84, 4498, 4500, 4507, 4519, 1, 8826, 113, 117, 97, 108, 59, 1, 10927, 108, 97, 110, 116,
			69, 113, 117, 97, 108, 59, 1, 8828, 105, 108, 100, 101, 59, 1, 8830, 109, 101, 59, 1, 8243, 4,
			2, 100, 112, 4537, 4543, 117, 99, 116, 59, 1, 8719, 111, 114, 116, 105, 111, 110, 4, 2, 59,
			97, 4555, 4557, 1, 8759, 108, 59, 1, 8733, 4, 2, 99, 105, 4567, 4572, 114, 59, 3, 55349,
			56491, 59, 1, 936, 4, 4, 85, 102, 111, 115, 4585, 4594, 4599, 4604, 79, 84, 5, 34, 1, 59,
			4592, 1, 34, 114, 59, 3, 55349, 56596, 112, 102, 59, 1, 8474, 99, 114, 59, 3, 55349, 56492, 4,
			12, 66, 69, 97, 99, 101, 102, 104, 105, 111, 114, 115, 117, 4636, 4642, 4650, 4681, 4704,
			4763, 4767, 4771, 5047, 5069, 5081, 5094, 97, 114, 114, 59, 1, 10512, 71, 5, 174, 1, 59, 4648,
			1, 174, 4, 3, 99, 110, 114, 4658, 4664, 4668, 117, 116, 101, 59, 1, 340, 103, 59, 1, 10219,
			114, 4, 2, 59, 116, 4675, 4677, 1, 8608, 108, 59, 1, 10518, 4, 3, 97, 101, 121, 4689, 4695,
			4701, 114, 111, 110, 59, 1, 344, 100, 105, 108, 59, 1, 342, 59, 1, 1056, 4, 2, 59, 118, 4710,
			4712, 1, 8476, 101, 114, 115, 101, 4, 2, 69, 85, 4722, 4748, 4, 2, 108, 113, 4728, 4736, 101,
			109, 101, 110, 116, 59, 1, 8715, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 8651, 112,
			69, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1, 10607, 114, 59, 1, 8476, 111, 59,
			1, 929, 103, 104, 116, 4, 8, 65, 67, 68, 70, 84, 85, 86, 97, 4792, 4840, 4849, 4905, 4912,
			4972, 5022, 5040, 4, 2, 110, 114, 4798, 4811, 103, 108, 101, 66, 114, 97, 99, 107, 101, 116,
			59, 1, 10217, 114, 111, 119, 4, 3, 59, 66, 76, 4822, 4824, 4829, 1, 8594, 97, 114, 59, 1,
			8677, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8644, 101, 105, 108, 105, 110, 103, 59, 1,
			8969, 111, 4, 2, 117, 119, 4856, 4869, 98, 108, 101, 66, 114, 97, 99, 107, 101, 116, 59, 1,
			10215, 110, 4, 2, 84, 86, 4876, 4887, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10589, 101,
			99, 116, 111, 114, 4, 2, 59, 66, 4898, 4900, 1, 8642, 97, 114, 59, 1, 10581, 108, 111, 111,
			114, 59, 1, 8971, 4, 2, 101, 114, 4918, 4944, 101, 4, 3, 59, 65, 86, 4927, 4929, 4936, 1,
			8866, 114, 114, 111, 119, 59, 1, 8614, 101, 99, 116, 111, 114, 59, 1, 10587, 105, 97, 110,
			103, 108, 101, 4, 3, 59, 66, 69, 4958, 4960, 4965, 1, 8883, 97, 114, 59, 1, 10704, 113, 117,
			97, 108, 59, 1, 8885, 112, 4, 3, 68, 84, 86, 4981, 4993, 5004, 111, 119, 110, 86, 101, 99,
			116, 111, 114, 59, 1, 10575, 101, 101, 86, 101, 99, 116, 111, 114, 59, 1, 10588, 101, 99, 116,
			111, 114, 4, 2, 59, 66, 5015, 5017, 1, 8638, 97, 114, 59, 1, 10580, 101, 99, 116, 111, 114, 4,
			2, 59, 66, 5033, 5035, 1, 8640, 97, 114, 59, 1, 10579, 114, 114, 111, 119, 59, 1, 8658, 4, 2,
			112, 117, 5053, 5057, 102, 59, 1, 8477, 110, 100, 73, 109, 112, 108, 105, 101, 115, 59, 1,
			10608, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8667, 4, 2, 99, 104, 5087, 5091,
			114, 59, 1, 8475, 59, 1, 8625, 108, 101, 68, 101, 108, 97, 121, 101, 100, 59, 1, 10740, 4, 13,
			72, 79, 97, 99, 102, 104, 105, 109, 111, 113, 115, 116, 117, 5134, 5150, 5157, 5164, 5198,
			5203, 5259, 5265, 5277, 5283, 5374, 5380, 5385, 4, 2, 67, 99, 5140, 5146, 72, 99, 121, 59, 1,
			1065, 121, 59, 1, 1064, 70, 84, 99, 121, 59, 1, 1068, 99, 117, 116, 101, 59, 1, 346, 4, 5, 59,
			97, 101, 105, 121, 5176, 5178, 5184, 5190, 5195, 1, 10940, 114, 111, 110, 59, 1, 352, 100,
			105, 108, 59, 1, 350, 114, 99, 59, 1, 348, 59, 1, 1057, 114, 59, 3, 55349, 56598, 111, 114,
			116, 4, 4, 68, 76, 82, 85, 5216, 5227, 5238, 5250, 111, 119, 110, 65, 114, 114, 111, 119, 59,
			1, 8595, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8592, 105, 103, 104, 116, 65, 114, 114,
			111, 119, 59, 1, 8594, 112, 65, 114, 114, 111, 119, 59, 1, 8593, 103, 109, 97, 59, 1, 931, 97,
			108, 108, 67, 105, 114, 99, 108, 101, 59, 1, 8728, 112, 102, 59, 3, 55349, 56650, 4, 2, 114,
			117, 5289, 5293, 116, 59, 1, 8730, 97, 114, 101, 4, 4, 59, 73, 83, 85, 5306, 5308, 5322, 5367,
			1, 9633, 110, 116, 101, 114, 115, 101, 99, 116, 105, 111, 110, 59, 1, 8851, 117, 4, 2, 98,
			112, 5329, 5347, 115, 101, 116, 4, 2, 59, 69, 5338, 5340, 1, 8847, 113, 117, 97, 108, 59, 1,
			8849, 101, 114, 115, 101, 116, 4, 2, 59, 69, 5358, 5360, 1, 8848, 113, 117, 97, 108, 59, 1,
			8850, 110, 105, 111, 110, 59, 1, 8852, 99, 114, 59, 3, 55349, 56494, 97, 114, 59, 1, 8902, 4,
			4, 98, 99, 109, 112, 5395, 5420, 5475, 5478, 4, 2, 59, 115, 5401, 5403, 1, 8912, 101, 116, 4,
			2, 59, 69, 5411, 5413, 1, 8912, 113, 117, 97, 108, 59, 1, 8838, 4, 2, 99, 104, 5426, 5468,
			101, 101, 100, 115, 4, 4, 59, 69, 83, 84, 5440, 5442, 5449, 5461, 1, 8827, 113, 117, 97, 108,
			59, 1, 10928, 108, 97, 110, 116, 69, 113, 117, 97, 108, 59, 1, 8829, 105, 108, 100, 101, 59,
			1, 8831, 84, 104, 97, 116, 59, 1, 8715, 59, 1, 8721, 4, 3, 59, 101, 115, 5486, 5488, 5507, 1,
			8913, 114, 115, 101, 116, 4, 2, 59, 69, 5498, 5500, 1, 8835, 113, 117, 97, 108, 59, 1, 8839,
			101, 116, 59, 1, 8913, 4, 11, 72, 82, 83, 97, 99, 102, 104, 105, 111, 114, 115, 5536, 5546,
			5552, 5567, 5579, 5602, 5607, 5655, 5695, 5701, 5711, 79, 82, 78, 5, 222, 1, 59, 5544, 1, 222,
			65, 68, 69, 59, 1, 8482, 4, 2, 72, 99, 5558, 5563, 99, 121, 59, 1, 1035, 121, 59, 1, 1062, 4,
			2, 98, 117, 5573, 5576, 59, 1, 9, 59, 1, 932, 4, 3, 97, 101, 121, 5587, 5593, 5599, 114, 111,
			110, 59, 1, 356, 100, 105, 108, 59, 1, 354, 59, 1, 1058, 114, 59, 3, 55349, 56599, 4, 2, 101,
			105, 5613, 5631, 4, 2, 114, 116, 5619, 5627, 101, 102, 111, 114, 101, 59, 1, 8756, 97, 59, 1,
			920, 4, 2, 99, 110, 5637, 5647, 107, 83, 112, 97, 99, 101, 59, 3, 8287, 8202, 83, 112, 97, 99,
			101, 59, 1, 8201, 108, 100, 101, 4, 4, 59, 69, 70, 84, 5668, 5670, 5677, 5688, 1, 8764, 113,
			117, 97, 108, 59, 1, 8771, 117, 108, 108, 69, 113, 117, 97, 108, 59, 1, 8773, 105, 108, 100,
			101, 59, 1, 8776, 112, 102, 59, 3, 55349, 56651, 105, 112, 108, 101, 68, 111, 116, 59, 1,
			8411, 4, 2, 99, 116, 5717, 5722, 114, 59, 3, 55349, 56495, 114, 111, 107, 59, 1, 358, 4, 14,
			97, 98, 99, 100, 102, 103, 109, 110, 111, 112, 114, 115, 116, 117, 5758, 5789, 5805, 5823,
			5830, 5835, 5846, 5852, 5921, 5937, 6089, 6095, 6101, 6108, 4, 2, 99, 114, 5764, 5774, 117,
			116, 101, 5, 218, 1, 59, 5772, 1, 218, 114, 4, 2, 59, 111, 5781, 5783, 1, 8607, 99, 105, 114,
			59, 1, 10569, 114, 4, 2, 99, 101, 5796, 5800, 121, 59, 1, 1038, 118, 101, 59, 1, 364, 4, 2,
			105, 121, 5811, 5820, 114, 99, 5, 219, 1, 59, 5818, 1, 219, 59, 1, 1059, 98, 108, 97, 99, 59,
			1, 368, 114, 59, 3, 55349, 56600, 114, 97, 118, 101, 5, 217, 1, 59, 5844, 1, 217, 97, 99, 114,
			59, 1, 362, 4, 2, 100, 105, 5858, 5905, 101, 114, 4, 2, 66, 80, 5866, 5892, 4, 2, 97, 114,
			5872, 5876, 114, 59, 1, 95, 97, 99, 4, 2, 101, 107, 5884, 5887, 59, 1, 9183, 101, 116, 59, 1,
			9141, 97, 114, 101, 110, 116, 104, 101, 115, 105, 115, 59, 1, 9181, 111, 110, 4, 2, 59, 80,
			5913, 5915, 1, 8899, 108, 117, 115, 59, 1, 8846, 4, 2, 103, 112, 5927, 5932, 111, 110, 59, 1,
			370, 102, 59, 3, 55349, 56652, 4, 8, 65, 68, 69, 84, 97, 100, 112, 115, 5955, 5985, 5996,
			6009, 6026, 6033, 6044, 6075, 114, 114, 111, 119, 4, 3, 59, 66, 68, 5967, 5969, 5974, 1, 8593,
			97, 114, 59, 1, 10514, 111, 119, 110, 65, 114, 114, 111, 119, 59, 1, 8645, 111, 119, 110, 65,
			114, 114, 111, 119, 59, 1, 8597, 113, 117, 105, 108, 105, 98, 114, 105, 117, 109, 59, 1,
			10606, 101, 101, 4, 2, 59, 65, 6017, 6019, 1, 8869, 114, 114, 111, 119, 59, 1, 8613, 114, 114,
			111, 119, 59, 1, 8657, 111, 119, 110, 97, 114, 114, 111, 119, 59, 1, 8661, 101, 114, 4, 2, 76,
			82, 6052, 6063, 101, 102, 116, 65, 114, 114, 111, 119, 59, 1, 8598, 105, 103, 104, 116, 65,
			114, 114, 111, 119, 59, 1, 8599, 105, 4, 2, 59, 108, 6082, 6084, 1, 978, 111, 110, 59, 1, 933,
			105, 110, 103, 59, 1, 366, 99, 114, 59, 3, 55349, 56496, 105, 108, 100, 101, 59, 1, 360, 109,
			108, 5, 220, 1, 59, 6115, 1, 220, 4, 9, 68, 98, 99, 100, 101, 102, 111, 115, 118, 6137, 6143,
			6148, 6152, 6166, 6250, 6255, 6261, 6267, 97, 115, 104, 59, 1, 8875, 97, 114, 59, 1, 10987,
			121, 59, 1, 1042, 97, 115, 104, 4, 2, 59, 108, 6161, 6163, 1, 8873, 59, 1, 10982, 4, 2, 101,
			114, 6172, 6175, 59, 1, 8897, 4, 3, 98, 116, 121, 6183, 6188, 6238, 97, 114, 59, 1, 8214, 4,
			2, 59, 105, 6194, 6196, 1, 8214, 99, 97, 108, 4, 4, 66, 76, 83, 84, 6209, 6214, 6220, 6231,
			97, 114, 59, 1, 8739, 105, 110, 101, 59, 1, 124, 101, 112, 97, 114, 97, 116, 111, 114, 59, 1,
			10072, 105, 108, 100, 101, 59, 1, 8768, 84, 104, 105, 110, 83, 112, 97, 99, 101, 59, 1, 8202,
			114, 59, 3, 55349, 56601, 112, 102, 59, 3, 55349, 56653, 99, 114, 59, 3, 55349, 56497, 100,
			97, 115, 104, 59, 1, 8874, 4, 5, 99, 101, 102, 111, 115, 6286, 6292, 6298, 6303, 6309, 105,
			114, 99, 59, 1, 372, 100, 103, 101, 59, 1, 8896, 114, 59, 3, 55349, 56602, 112, 102, 59, 3,
			55349, 56654, 99, 114, 59, 3, 55349, 56498, 4, 4, 102, 105, 111, 115, 6325, 6330, 6333, 6339,
			114, 59, 3, 55349, 56603, 59, 1, 926, 112, 102, 59, 3, 55349, 56655, 99, 114, 59, 3, 55349,
			56499, 4, 9, 65, 73, 85, 97, 99, 102, 111, 115, 117, 6365, 6370, 6375, 6380, 6391, 6405, 6410,
			6416, 6422, 99, 121, 59, 1, 1071, 99, 121, 59, 1, 1031, 99, 121, 59, 1, 1070, 99, 117, 116,
			101, 5, 221, 1, 59, 6389, 1, 221, 4, 2, 105, 121, 6397, 6402, 114, 99, 59, 1, 374, 59, 1,
			1067, 114, 59, 3, 55349, 56604, 112, 102, 59, 3, 55349, 56656, 99, 114, 59, 3, 55349, 56500,
			109, 108, 59, 1, 376, 4, 8, 72, 97, 99, 100, 101, 102, 111, 115, 6445, 6450, 6457, 6472, 6477,
			6501, 6505, 6510, 99, 121, 59, 1, 1046, 99, 117, 116, 101, 59, 1, 377, 4, 2, 97, 121, 6463,
			6469, 114, 111, 110, 59, 1, 381, 59, 1, 1047, 111, 116, 59, 1, 379, 4, 2, 114, 116, 6483,
			6497, 111, 87, 105, 100, 116, 104, 83, 112, 97, 99, 101, 59, 1, 8203, 97, 59, 1, 918, 114, 59,
			1, 8488, 112, 102, 59, 1, 8484, 99, 114, 59, 3, 55349, 56501, 4, 16, 97, 98, 99, 101, 102,
			103, 108, 109, 110, 111, 112, 114, 115, 116, 117, 119, 6550, 6561, 6568, 6612, 6622, 6634,
			6645, 6672, 6699, 6854, 6870, 6923, 6933, 6963, 6974, 6983, 99, 117, 116, 101, 5, 225, 1, 59,
			6559, 1, 225, 114, 101, 118, 101, 59, 1, 259, 4, 6, 59, 69, 100, 105, 117, 121, 6582, 6584,
			6588, 6591, 6600, 6609, 1, 8766, 59, 3, 8766, 819, 59, 1, 8767, 114, 99, 5, 226, 1, 59, 6598,
			1, 226, 116, 101, 5, 180, 1, 59, 6607, 1, 180, 59, 1, 1072, 108, 105, 103, 5, 230, 1, 59,
			6620, 1, 230, 4, 2, 59, 114, 6628, 6630, 1, 8289, 59, 3, 55349, 56606, 114, 97, 118, 101, 5,
			224, 1, 59, 6643, 1, 224, 4, 2, 101, 112, 6651, 6667, 4, 2, 102, 112, 6657, 6663, 115, 121,
			109, 59, 1, 8501, 104, 59, 1, 8501, 104, 97, 59, 1, 945, 4, 2, 97, 112, 6678, 6692, 4, 2, 99,
			108, 6684, 6688, 114, 59, 1, 257, 103, 59, 1, 10815, 5, 38, 1, 59, 6697, 1, 38, 4, 2, 100,
			103, 6705, 6737, 4, 5, 59, 97, 100, 115, 118, 6717, 6719, 6724, 6727, 6734, 1, 8743, 110, 100,
			59, 1, 10837, 59, 1, 10844, 108, 111, 112, 101, 59, 1, 10840, 59, 1, 10842, 4, 7, 59, 101,
			108, 109, 114, 115, 122, 6753, 6755, 6758, 6762, 6814, 6835, 6848, 1, 8736, 59, 1, 10660, 101,
			59, 1, 8736, 115, 100, 4, 2, 59, 97, 6770, 6772, 1, 8737, 4, 8, 97, 98, 99, 100, 101, 102,
			103, 104, 6790, 6793, 6796, 6799, 6802, 6805, 6808, 6811, 59, 1, 10664, 59, 1, 10665, 59, 1,
			10666, 59, 1, 10667, 59, 1, 10668, 59, 1, 10669, 59, 1, 10670, 59, 1, 10671, 116, 4, 2, 59,
			118, 6821, 6823, 1, 8735, 98, 4, 2, 59, 100, 6830, 6832, 1, 8894, 59, 1, 10653, 4, 2, 112,
			116, 6841, 6845, 104, 59, 1, 8738, 59, 1, 197, 97, 114, 114, 59, 1, 9084, 4, 2, 103, 112,
			6860, 6865, 111, 110, 59, 1, 261, 102, 59, 3, 55349, 56658, 4, 7, 59, 69, 97, 101, 105, 111,
			112, 6886, 6888, 6891, 6897, 6900, 6904, 6908, 1, 8776, 59, 1, 10864, 99, 105, 114, 59, 1,
			10863, 59, 1, 8778, 100, 59, 1, 8779, 115, 59, 1, 39, 114, 111, 120, 4, 2, 59, 101, 6917,
			6919, 1, 8776, 113, 59, 1, 8778, 105, 110, 103, 5, 229, 1, 59, 6931, 1, 229, 4, 3, 99, 116,
			121, 6941, 6946, 6949, 114, 59, 3, 55349, 56502, 59, 1, 42, 109, 112, 4, 2, 59, 101, 6957,
			6959, 1, 8776, 113, 59, 1, 8781, 105, 108, 100, 101, 5, 227, 1, 59, 6972, 1, 227, 109, 108, 5,
			228, 1, 59, 6981, 1, 228, 4, 2, 99, 105, 6989, 6997, 111, 110, 105, 110, 116, 59, 1, 8755,
			110, 116, 59, 1, 10769, 4, 16, 78, 97, 98, 99, 100, 101, 102, 105, 107, 108, 110, 111, 112,
			114, 115, 117, 7036, 7041, 7119, 7135, 7149, 7155, 7219, 7224, 7347, 7354, 7463, 7489, 7786,
			7793, 7814, 7866, 111, 116, 59, 1, 10989, 4, 2, 99, 114, 7047, 7094, 107, 4, 4, 99, 101, 112,
			115, 7058, 7064, 7073, 7080, 111, 110, 103, 59, 1, 8780, 112, 115, 105, 108, 111, 110, 59, 1,
			1014, 114, 105, 109, 101, 59, 1, 8245, 105, 109, 4, 2, 59, 101, 7088, 7090, 1, 8765, 113, 59,
			1, 8909, 4, 2, 118, 119, 7100, 7105, 101, 101, 59, 1, 8893, 101, 100, 4, 2, 59, 103, 7113,
			7115, 1, 8965, 101, 59, 1, 8965, 114, 107, 4, 2, 59, 116, 7127, 7129, 1, 9141, 98, 114, 107,
			59, 1, 9142, 4, 2, 111, 121, 7141, 7146, 110, 103, 59, 1, 8780, 59, 1, 1073, 113, 117, 111,
			59, 1, 8222, 4, 5, 99, 109, 112, 114, 116, 7167, 7181, 7188, 7193, 7199, 97, 117, 115, 4, 2,
			59, 101, 7176, 7178, 1, 8757, 59, 1, 8757, 112, 116, 121, 118, 59, 1, 10672, 115, 105, 59, 1,
			1014, 110, 111, 117, 59, 1, 8492, 4, 3, 97, 104, 119, 7207, 7210, 7213, 59, 1, 946, 59, 1,
			8502, 101, 101, 110, 59, 1, 8812, 114, 59, 3, 55349, 56607, 103, 4, 7, 99, 111, 115, 116, 117,
			118, 119, 7241, 7262, 7288, 7305, 7328, 7335, 7340, 4, 3, 97, 105, 117, 7249, 7253, 7258, 112,
			59, 1, 8898, 114, 99, 59, 1, 9711, 112, 59, 1, 8899, 4, 3, 100, 112, 116, 7270, 7275, 7281,
			111, 116, 59, 1, 10752, 108, 117, 115, 59, 1, 10753, 105, 109, 101, 115, 59, 1, 10754, 4, 2,
			113, 116, 7294, 7300, 99, 117, 112, 59, 1, 10758, 97, 114, 59, 1, 9733, 114, 105, 97, 110,
			103, 108, 101, 4, 2, 100, 117, 7318, 7324, 111, 119, 110, 59, 1, 9661, 112, 59, 1, 9651, 112,
			108, 117, 115, 59, 1, 10756, 101, 101, 59, 1, 8897, 101, 100, 103, 101, 59, 1, 8896, 97, 114,
			111, 119, 59, 1, 10509, 4, 3, 97, 107, 111, 7362, 7436, 7458, 4, 2, 99, 110, 7368, 7432, 107,
			4, 3, 108, 115, 116, 7377, 7386, 7394, 111, 122, 101, 110, 103, 101, 59, 1, 10731, 113, 117,
			97, 114, 101, 59, 1, 9642, 114, 105, 97, 110, 103, 108, 101, 4, 4, 59, 100, 108, 114, 7411,
			7413, 7419, 7425, 1, 9652, 111, 119, 110, 59, 1, 9662, 101, 102, 116, 59, 1, 9666, 105, 103,
			104, 116, 59, 1, 9656, 107, 59, 1, 9251, 4, 2, 49, 51, 7442, 7454, 4, 2, 50, 52, 7448, 7451,
			59, 1, 9618, 59, 1, 9617, 52, 59, 1, 9619, 99, 107, 59, 1, 9608, 4, 2, 101, 111, 7469, 7485,
			4, 2, 59, 113, 7475, 7478, 3, 61, 8421, 117, 105, 118, 59, 3, 8801, 8421, 116, 59, 1, 8976, 4,
			4, 112, 116, 119, 120, 7499, 7504, 7517, 7523, 102, 59, 3, 55349, 56659, 4, 2, 59, 116, 7510,
			7512, 1, 8869, 111, 109, 59, 1, 8869, 116, 105, 101, 59, 1, 8904, 4, 12, 68, 72, 85, 86, 98,
			100, 104, 109, 112, 116, 117, 118, 7549, 7571, 7597, 7619, 7655, 7660, 7682, 7708, 7715, 7721,
			7728, 7750, 4, 4, 76, 82, 108, 114, 7559, 7562, 7565, 7568, 59, 1, 9559, 59, 1, 9556, 59, 1,
			9558, 59, 1, 9555, 4, 5, 59, 68, 85, 100, 117, 7583, 7585, 7588, 7591, 7594, 1, 9552, 59, 1,
			9574, 59, 1, 9577, 59, 1, 9572, 59, 1, 9575, 4, 4, 76, 82, 108, 114, 7607, 7610, 7613, 7616,
			59, 1, 9565, 59, 1, 9562, 59, 1, 9564, 59, 1, 9561, 4, 7, 59, 72, 76, 82, 104, 108, 114, 7635,
			7637, 7640, 7643, 7646, 7649, 7652, 1, 9553, 59, 1, 9580, 59, 1, 9571, 59, 1, 9568, 59, 1,
			9579, 59, 1, 9570, 59, 1, 9567, 111, 120, 59, 1, 10697, 4, 4, 76, 82, 108, 114, 7670, 7673,
			7676, 7679, 59, 1, 9557, 59, 1, 9554, 59, 1, 9488, 59, 1, 9484, 4, 5, 59, 68, 85, 100, 117,
			7694, 7696, 7699, 7702, 7705, 1, 9472, 59, 1, 9573, 59, 1, 9576, 59, 1, 9516, 59, 1, 9524,
			105, 110, 117, 115, 59, 1, 8863, 108, 117, 115, 59, 1, 8862, 105, 109, 101, 115, 59, 1, 8864,
			4, 4, 76, 82, 108, 114, 7738, 7741, 7744, 7747, 59, 1, 9563, 59, 1, 9560, 59, 1, 9496, 59, 1,
			9492, 4, 7, 59, 72, 76, 82, 104, 108, 114, 7766, 7768, 7771, 7774, 7777, 7780, 7783, 1, 9474,
			59, 1, 9578, 59, 1, 9569, 59, 1, 9566, 59, 1, 9532, 59, 1, 9508, 59, 1, 9500, 114, 105, 109,
			101, 59, 1, 8245, 4, 2, 101, 118, 7799, 7804, 118, 101, 59, 1, 728, 98, 97, 114, 5, 166, 1,
			59, 7812, 1, 166, 4, 4, 99, 101, 105, 111, 7824, 7829, 7834, 7846, 114, 59, 3, 55349, 56503,
			109, 105, 59, 1, 8271, 109, 4, 2, 59, 101, 7841, 7843, 1, 8765, 59, 1, 8909, 108, 4, 3, 59,
			98, 104, 7855, 7857, 7860, 1, 92, 59, 1, 10693, 115, 117, 98, 59, 1, 10184, 4, 2, 108, 109,
			7872, 7885, 108, 4, 2, 59, 101, 7879, 7881, 1, 8226, 116, 59, 1, 8226, 112, 4, 3, 59, 69, 101,
			7894, 7896, 7899, 1, 8782, 59, 1, 10926, 4, 2, 59, 113, 7905, 7907, 1, 8783, 59, 1, 8783, 4,
			15, 97, 99, 100, 101, 102, 104, 105, 108, 111, 114, 115, 116, 117, 119, 121, 7942, 8021, 8075,
			8080, 8121, 8126, 8157, 8279, 8295, 8430, 8446, 8485, 8491, 8707, 8726, 4, 3, 99, 112, 114,
			7950, 7956, 8007, 117, 116, 101, 59, 1, 263, 4, 6, 59, 97, 98, 99, 100, 115, 7970, 7972, 7977,
			7984, 7998, 8003, 1, 8745, 110, 100, 59, 1, 10820, 114, 99, 117, 112, 59, 1, 10825, 4, 2, 97,
			117, 7990, 7994, 112, 59, 1, 10827, 112, 59, 1, 10823, 111, 116, 59, 1, 10816, 59, 3, 8745,
			65024, 4, 2, 101, 111, 8013, 8017, 116, 59, 1, 8257, 110, 59, 1, 711, 4, 4, 97, 101, 105, 117,
			8031, 8046, 8056, 8061, 4, 2, 112, 114, 8037, 8041, 115, 59, 1, 10829, 111, 110, 59, 1, 269,
			100, 105, 108, 5, 231, 1, 59, 8054, 1, 231, 114, 99, 59, 1, 265, 112, 115, 4, 2, 59, 115,
			8069, 8071, 1, 10828, 109, 59, 1, 10832, 111, 116, 59, 1, 267, 4, 3, 100, 109, 110, 8088,
			8097, 8104, 105, 108, 5, 184, 1, 59, 8095, 1, 184, 112, 116, 121, 118, 59, 1, 10674, 116, 5,
			162, 2, 59, 101, 8112, 8114, 1, 162, 114, 100, 111, 116, 59, 1, 183, 114, 59, 3, 55349, 56608,
			4, 3, 99, 101, 105, 8134, 8138, 8154, 121, 59, 1, 1095, 99, 107, 4, 2, 59, 109, 8146, 8148, 1,
			10003, 97, 114, 107, 59, 1, 10003, 59, 1, 967, 114, 4, 7, 59, 69, 99, 101, 102, 109, 115,
			8174, 8176, 8179, 8258, 8261, 8268, 8273, 1, 9675, 59, 1, 10691, 4, 3, 59, 101, 108, 8187,
			8189, 8193, 1, 710, 113, 59, 1, 8791, 101, 4, 2, 97, 100, 8200, 8223, 114, 114, 111, 119, 4,
			2, 108, 114, 8210, 8216, 101, 102, 116, 59, 1, 8634, 105, 103, 104, 116, 59, 1, 8635, 4, 5,
			82, 83, 97, 99, 100, 8235, 8238, 8241, 8246, 8252, 59, 1, 174, 59, 1, 9416, 115, 116, 59, 1,
			8859, 105, 114, 99, 59, 1, 8858, 97, 115, 104, 59, 1, 8861, 59, 1, 8791, 110, 105, 110, 116,
			59, 1, 10768, 105, 100, 59, 1, 10991, 99, 105, 114, 59, 1, 10690, 117, 98, 115, 4, 2, 59, 117,
			8288, 8290, 1, 9827, 105, 116, 59, 1, 9827, 4, 4, 108, 109, 110, 112, 8305, 8326, 8376, 8400,
			111, 110, 4, 2, 59, 101, 8313, 8315, 1, 58, 4, 2, 59, 113, 8321, 8323, 1, 8788, 59, 1, 8788,
			4, 2, 109, 112, 8332, 8344, 97, 4, 2, 59, 116, 8339, 8341, 1, 44, 59, 1, 64, 4, 3, 59, 102,
			108, 8352, 8354, 8358, 1, 8705, 110, 59, 1, 8728, 101, 4, 2, 109, 120, 8365, 8371, 101, 110,
			116, 59, 1, 8705, 101, 115, 59, 1, 8450, 4, 2, 103, 105, 8382, 8395, 4, 2, 59, 100, 8388,
			8390, 1, 8773, 111, 116, 59, 1, 10861, 110, 116, 59, 1, 8750, 4, 3, 102, 114, 121, 8408, 8412,
			8417, 59, 3, 55349, 56660, 111, 100, 59, 1, 8720, 5, 169, 2, 59, 115, 8424, 8426, 1, 169, 114,
			59, 1, 8471, 4, 2, 97, 111, 8436, 8441, 114, 114, 59, 1, 8629, 115, 115, 59, 1, 10007, 4, 2,
			99, 117, 8452, 8457, 114, 59, 3, 55349, 56504, 4, 2, 98, 112, 8463, 8474, 4, 2, 59, 101, 8469,
			8471, 1, 10959, 59, 1, 10961, 4, 2, 59, 101, 8480, 8482, 1, 10960, 59, 1, 10962, 100, 111,
			116, 59, 1, 8943, 4, 7, 100, 101, 108, 112, 114, 118, 119, 8507, 8522, 8536, 8550, 8600, 8697,
			8702, 97, 114, 114, 4, 2, 108, 114, 8516, 8519, 59, 1, 10552, 59, 1, 10549, 4, 2, 112, 115,
			8528, 8532, 114, 59, 1, 8926, 99, 59, 1, 8927, 97, 114, 114, 4, 2, 59, 112, 8545, 8547, 1,
			8630, 59, 1, 10557, 4, 6, 59, 98, 99, 100, 111, 115, 8564, 8566, 8573, 8587, 8592, 8596, 1,
			8746, 114, 99, 97, 112, 59, 1, 10824, 4, 2, 97, 117, 8579, 8583, 112, 59, 1, 10822, 112, 59,
			1, 10826, 111, 116, 59, 1, 8845, 114, 59, 1, 10821, 59, 3, 8746, 65024, 4, 4, 97, 108, 114,
			118, 8610, 8623, 8663, 8672, 114, 114, 4, 2, 59, 109, 8618, 8620, 1, 8631, 59, 1, 10556, 121,
			4, 3, 101, 118, 119, 8632, 8651, 8656, 113, 4, 2, 112, 115, 8639, 8645, 114, 101, 99, 59, 1,
			8926, 117, 99, 99, 59, 1, 8927, 101, 101, 59, 1, 8910, 101, 100, 103, 101, 59, 1, 8911, 101,
			110, 5, 164, 1, 59, 8670, 1, 164, 101, 97, 114, 114, 111, 119, 4, 2, 108, 114, 8684, 8690,
			101, 102, 116, 59, 1, 8630, 105, 103, 104, 116, 59, 1, 8631, 101, 101, 59, 1, 8910, 101, 100,
			59, 1, 8911, 4, 2, 99, 105, 8713, 8721, 111, 110, 105, 110, 116, 59, 1, 8754, 110, 116, 59, 1,
			8753, 108, 99, 116, 121, 59, 1, 9005, 4, 19, 65, 72, 97, 98, 99, 100, 101, 102, 104, 105, 106,
			108, 111, 114, 115, 116, 117, 119, 122, 8773, 8778, 8783, 8821, 8839, 8854, 8887, 8914, 8930,
			8944, 9036, 9041, 9058, 9197, 9227, 9258, 9281, 9297, 9305, 114, 114, 59, 1, 8659, 97, 114,
			59, 1, 10597, 4, 4, 103, 108, 114, 115, 8793, 8799, 8805, 8809, 103, 101, 114, 59, 1, 8224,
			101, 116, 104, 59, 1, 8504, 114, 59, 1, 8595, 104, 4, 2, 59, 118, 8816, 8818, 1, 8208, 59, 1,
			8867, 4, 2, 107, 108, 8827, 8834, 97, 114, 111, 119, 59, 1, 10511, 97, 99, 59, 1, 733, 4, 2,
			97, 121, 8845, 8851, 114, 111, 110, 59, 1, 271, 59, 1, 1076, 4, 3, 59, 97, 111, 8862, 8864,
			8880, 1, 8518, 4, 2, 103, 114, 8870, 8876, 103, 101, 114, 59, 1, 8225, 114, 59, 1, 8650, 116,
			115, 101, 113, 59, 1, 10871, 4, 3, 103, 108, 109, 8895, 8902, 8907, 5, 176, 1, 59, 8900, 1,
			176, 116, 97, 59, 1, 948, 112, 116, 121, 118, 59, 1, 10673, 4, 2, 105, 114, 8920, 8926, 115,
			104, 116, 59, 1, 10623, 59, 3, 55349, 56609, 97, 114, 4, 2, 108, 114, 8938, 8941, 59, 1, 8643,
			59, 1, 8642, 4, 5, 97, 101, 103, 115, 118, 8956, 8986, 8989, 8996, 9001, 109, 4, 3, 59, 111,
			115, 8965, 8967, 8983, 1, 8900, 110, 100, 4, 2, 59, 115, 8975, 8977, 1, 8900, 117, 105, 116,
			59, 1, 9830, 59, 1, 9830, 59, 1, 168, 97, 109, 109, 97, 59, 1, 989, 105, 110, 59, 1, 8946, 4,
			3, 59, 105, 111, 9009, 9011, 9031, 1, 247, 100, 101, 5, 247, 2, 59, 111, 9020, 9022, 1, 247,
			110, 116, 105, 109, 101, 115, 59, 1, 8903, 110, 120, 59, 1, 8903, 99, 121, 59, 1, 1106, 99, 4,
			2, 111, 114, 9048, 9053, 114, 110, 59, 1, 8990, 111, 112, 59, 1, 8973, 4, 5, 108, 112, 116,
			117, 119, 9070, 9076, 9081, 9130, 9144, 108, 97, 114, 59, 1, 36, 102, 59, 3, 55349, 56661, 4,
			5, 59, 101, 109, 112, 115, 9093, 9095, 9109, 9116, 9122, 1, 729, 113, 4, 2, 59, 100, 9102,
			9104, 1, 8784, 111, 116, 59, 1, 8785, 105, 110, 117, 115, 59, 1, 8760, 108, 117, 115, 59, 1,
			8724, 113, 117, 97, 114, 101, 59, 1, 8865, 98, 108, 101, 98, 97, 114, 119, 101, 100, 103, 101,
			59, 1, 8966, 110, 4, 3, 97, 100, 104, 9153, 9160, 9172, 114, 114, 111, 119, 59, 1, 8595, 111,
			119, 110, 97, 114, 114, 111, 119, 115, 59, 1, 8650, 97, 114, 112, 111, 111, 110, 4, 2, 108,
			114, 9184, 9190, 101, 102, 116, 59, 1, 8643, 105, 103, 104, 116, 59, 1, 8642, 4, 2, 98, 99,
			9203, 9211, 107, 97, 114, 111, 119, 59, 1, 10512, 4, 2, 111, 114, 9217, 9222, 114, 110, 59, 1,
			8991, 111, 112, 59, 1, 8972, 4, 3, 99, 111, 116, 9235, 9248, 9252, 4, 2, 114, 121, 9241, 9245,
			59, 3, 55349, 56505, 59, 1, 1109, 108, 59, 1, 10742, 114, 111, 107, 59, 1, 273, 4, 2, 100,
			114, 9264, 9269, 111, 116, 59, 1, 8945, 105, 4, 2, 59, 102, 9276, 9278, 1, 9663, 59, 1, 9662,
			4, 2, 97, 104, 9287, 9292, 114, 114, 59, 1, 8693, 97, 114, 59, 1, 10607, 97, 110, 103, 108,
			101, 59, 1, 10662, 4, 2, 99, 105, 9311, 9315, 121, 59, 1, 1119, 103, 114, 97, 114, 114, 59, 1,
			10239, 4, 18, 68, 97, 99, 100, 101, 102, 103, 108, 109, 110, 111, 112, 113, 114, 115, 116,
			117, 120, 9361, 9376, 9398, 9439, 9444, 9447, 9462, 9495, 9531, 9585, 9598, 9614, 9659, 9755,
			9771, 9792, 9808, 9826, 4, 2, 68, 111, 9367, 9372, 111, 116, 59, 1, 10871, 116, 59, 1, 8785,
			4, 2, 99, 115, 9382, 9392, 117, 116, 101, 5, 233, 1, 59, 9390, 1, 233, 116, 101, 114, 59, 1,
			10862, 4, 4, 97, 105, 111, 121, 9408, 9414, 9430, 9436, 114, 111, 110, 59, 1, 283, 114, 4, 2,
			59, 99, 9421, 9423, 1, 8790, 5, 234, 1, 59, 9428, 1, 234, 108, 111, 110, 59, 1, 8789, 59, 1,
			1101, 111, 116, 59, 1, 279, 59, 1, 8519, 4, 2, 68, 114, 9453, 9458, 111, 116, 59, 1, 8786, 59,
			3, 55349, 56610, 4, 3, 59, 114, 115, 9470, 9472, 9482, 1, 10906, 97, 118, 101, 5, 232, 1, 59,
			9480, 1, 232, 4, 2, 59, 100, 9488, 9490, 1, 10902, 111, 116, 59, 1, 10904, 4, 4, 59, 105, 108,
			115, 9505, 9507, 9515, 9518, 1, 10905, 110, 116, 101, 114, 115, 59, 1, 9191, 59, 1, 8467, 4,
			2, 59, 100, 9524, 9526, 1, 10901, 111, 116, 59, 1, 10903, 4, 3, 97, 112, 115, 9539, 9544,
			9564, 99, 114, 59, 1, 275, 116, 121, 4, 3, 59, 115, 118, 9554, 9556, 9561, 1, 8709, 101, 116,
			59, 1, 8709, 59, 1, 8709, 112, 4, 2, 49, 59, 9571, 9583, 4, 2, 51, 52, 9577, 9580, 59, 1,
			8196, 59, 1, 8197, 1, 8195, 4, 2, 103, 115, 9591, 9594, 59, 1, 331, 112, 59, 1, 8194, 4, 2,
			103, 112, 9604, 9609, 111, 110, 59, 1, 281, 102, 59, 3, 55349, 56662, 4, 3, 97, 108, 115,
			9622, 9635, 9640, 114, 4, 2, 59, 115, 9629, 9631, 1, 8917, 108, 59, 1, 10723, 117, 115, 59, 1,
			10865, 105, 4, 3, 59, 108, 118, 9649, 9651, 9656, 1, 949, 111, 110, 59, 1, 949, 59, 1, 1013,
			4, 4, 99, 115, 117, 118, 9669, 9686, 9716, 9747, 4, 2, 105, 111, 9675, 9680, 114, 99, 59, 1,
			8790, 108, 111, 110, 59, 1, 8789, 4, 2, 105, 108, 9692, 9696, 109, 59, 1, 8770, 97, 110, 116,
			4, 2, 103, 108, 9705, 9710, 116, 114, 59, 1, 10902, 101, 115, 115, 59, 1, 10901, 4, 3, 97,
			101, 105, 9724, 9729, 9734, 108, 115, 59, 1, 61, 115, 116, 59, 1, 8799, 118, 4, 2, 59, 68,
			9741, 9743, 1, 8801, 68, 59, 1, 10872, 112, 97, 114, 115, 108, 59, 1, 10725, 4, 2, 68, 97,
			9761, 9766, 111, 116, 59, 1, 8787, 114, 114, 59, 1, 10609, 4, 3, 99, 100, 105, 9779, 9783,
			9788, 114, 59, 1, 8495, 111, 116, 59, 1, 8784, 109, 59, 1, 8770, 4, 2, 97, 104, 9798, 9801,
			59, 1, 951, 5, 240, 1, 59, 9806, 1, 240, 4, 2, 109, 114, 9814, 9822, 108, 5, 235, 1, 59, 9820,
			1, 235, 111, 59, 1, 8364, 4, 3, 99, 105, 112, 9834, 9838, 9843, 108, 59, 1, 33, 115, 116, 59,
			1, 8707, 4, 2, 101, 111, 9849, 9859, 99, 116, 97, 116, 105, 111, 110, 59, 1, 8496, 110, 101,
			110, 116, 105, 97, 108, 101, 59, 1, 8519, 4, 12, 97, 99, 101, 102, 105, 106, 108, 110, 111,
			112, 114, 115, 9896, 9910, 9914, 9921, 9954, 9960, 9967, 9989, 9994, 10027, 10036, 10164, 108,
			108, 105, 110, 103, 100, 111, 116, 115, 101, 113, 59, 1, 8786, 121, 59, 1, 1092, 109, 97, 108,
			101, 59, 1, 9792, 4, 3, 105, 108, 114, 9929, 9935, 9950, 108, 105, 103, 59, 1, 64259, 4, 2,
			105, 108, 9941, 9945, 103, 59, 1, 64256, 105, 103, 59, 1, 64260, 59, 3, 55349, 56611, 108,
			105, 103, 59, 1, 64257, 108, 105, 103, 59, 3, 102, 106, 4, 3, 97, 108, 116, 9975, 9979, 9984,
			116, 59, 1, 9837, 105, 103, 59, 1, 64258, 110, 115, 59, 1, 9649, 111, 102, 59, 1, 402, 4, 2,
			112, 114, 1e4, 10005, 102, 59, 3, 55349, 56663, 4, 2, 97, 107, 10011, 10016, 108, 108, 59, 1,
			8704, 4, 2, 59, 118, 10022, 10024, 1, 8916, 59, 1, 10969, 97, 114, 116, 105, 110, 116, 59, 1,
			10765, 4, 2, 97, 111, 10042, 10159, 4, 2, 99, 115, 10048, 10155, 4, 6, 49, 50, 51, 52, 53, 55,
			10062, 10102, 10114, 10135, 10139, 10151, 4, 6, 50, 51, 52, 53, 54, 56, 10076, 10083, 10086,
			10093, 10096, 10099, 5, 189, 1, 59, 10081, 1, 189, 59, 1, 8531, 5, 188, 1, 59, 10091, 1, 188,
			59, 1, 8533, 59, 1, 8537, 59, 1, 8539, 4, 2, 51, 53, 10108, 10111, 59, 1, 8532, 59, 1, 8534,
			4, 3, 52, 53, 56, 10122, 10129, 10132, 5, 190, 1, 59, 10127, 1, 190, 59, 1, 8535, 59, 1, 8540,
			53, 59, 1, 8536, 4, 2, 54, 56, 10145, 10148, 59, 1, 8538, 59, 1, 8541, 56, 59, 1, 8542, 108,
			59, 1, 8260, 119, 110, 59, 1, 8994, 99, 114, 59, 3, 55349, 56507, 4, 17, 69, 97, 98, 99, 100,
			101, 102, 103, 105, 106, 108, 110, 111, 114, 115, 116, 118, 10206, 10217, 10247, 10254, 10268,
			10273, 10358, 10363, 10374, 10380, 10385, 10406, 10458, 10464, 10470, 10497, 10610, 4, 2, 59,
			108, 10212, 10214, 1, 8807, 59, 1, 10892, 4, 3, 99, 109, 112, 10225, 10231, 10244, 117, 116,
			101, 59, 1, 501, 109, 97, 4, 2, 59, 100, 10239, 10241, 1, 947, 59, 1, 989, 59, 1, 10886, 114,
			101, 118, 101, 59, 1, 287, 4, 2, 105, 121, 10260, 10265, 114, 99, 59, 1, 285, 59, 1, 1075,
			111, 116, 59, 1, 289, 4, 4, 59, 108, 113, 115, 10283, 10285, 10288, 10308, 1, 8805, 59, 1,
			8923, 4, 3, 59, 113, 115, 10296, 10298, 10301, 1, 8805, 59, 1, 8807, 108, 97, 110, 116, 59, 1,
			10878, 4, 4, 59, 99, 100, 108, 10318, 10320, 10324, 10345, 1, 10878, 99, 59, 1, 10921, 111,
			116, 4, 2, 59, 111, 10332, 10334, 1, 10880, 4, 2, 59, 108, 10340, 10342, 1, 10882, 59, 1,
			10884, 4, 2, 59, 101, 10351, 10354, 3, 8923, 65024, 115, 59, 1, 10900, 114, 59, 3, 55349,
			56612, 4, 2, 59, 103, 10369, 10371, 1, 8811, 59, 1, 8921, 109, 101, 108, 59, 1, 8503, 99, 121,
			59, 1, 1107, 4, 4, 59, 69, 97, 106, 10395, 10397, 10400, 10403, 1, 8823, 59, 1, 10898, 59, 1,
			10917, 59, 1, 10916, 4, 4, 69, 97, 101, 115, 10416, 10419, 10434, 10453, 59, 1, 8809, 112, 4,
			2, 59, 112, 10426, 10428, 1, 10890, 114, 111, 120, 59, 1, 10890, 4, 2, 59, 113, 10440, 10442,
			1, 10888, 4, 2, 59, 113, 10448, 10450, 1, 10888, 59, 1, 8809, 105, 109, 59, 1, 8935, 112, 102,
			59, 3, 55349, 56664, 97, 118, 101, 59, 1, 96, 4, 2, 99, 105, 10476, 10480, 114, 59, 1, 8458,
			109, 4, 3, 59, 101, 108, 10489, 10491, 10494, 1, 8819, 59, 1, 10894, 59, 1, 10896, 5, 62, 6,
			59, 99, 100, 108, 113, 114, 10512, 10514, 10527, 10532, 10538, 10545, 1, 62, 4, 2, 99, 105,
			10520, 10523, 59, 1, 10919, 114, 59, 1, 10874, 111, 116, 59, 1, 8919, 80, 97, 114, 59, 1,
			10645, 117, 101, 115, 116, 59, 1, 10876, 4, 5, 97, 100, 101, 108, 115, 10557, 10574, 10579,
			10599, 10605, 4, 2, 112, 114, 10563, 10570, 112, 114, 111, 120, 59, 1, 10886, 114, 59, 1,
			10616, 111, 116, 59, 1, 8919, 113, 4, 2, 108, 113, 10586, 10592, 101, 115, 115, 59, 1, 8923,
			108, 101, 115, 115, 59, 1, 10892, 101, 115, 115, 59, 1, 8823, 105, 109, 59, 1, 8819, 4, 2,
			101, 110, 10616, 10626, 114, 116, 110, 101, 113, 113, 59, 3, 8809, 65024, 69, 59, 3, 8809,
			65024, 4, 10, 65, 97, 98, 99, 101, 102, 107, 111, 115, 121, 10653, 10658, 10713, 10718, 10724,
			10760, 10765, 10786, 10850, 10875, 114, 114, 59, 1, 8660, 4, 4, 105, 108, 109, 114, 10668,
			10674, 10678, 10684, 114, 115, 112, 59, 1, 8202, 102, 59, 1, 189, 105, 108, 116, 59, 1, 8459,
			4, 2, 100, 114, 10690, 10695, 99, 121, 59, 1, 1098, 4, 3, 59, 99, 119, 10703, 10705, 10710, 1,
			8596, 105, 114, 59, 1, 10568, 59, 1, 8621, 97, 114, 59, 1, 8463, 105, 114, 99, 59, 1, 293, 4,
			3, 97, 108, 114, 10732, 10748, 10754, 114, 116, 115, 4, 2, 59, 117, 10741, 10743, 1, 9829,
			105, 116, 59, 1, 9829, 108, 105, 112, 59, 1, 8230, 99, 111, 110, 59, 1, 8889, 114, 59, 3,
			55349, 56613, 115, 4, 2, 101, 119, 10772, 10779, 97, 114, 111, 119, 59, 1, 10533, 97, 114,
			111, 119, 59, 1, 10534, 4, 5, 97, 109, 111, 112, 114, 10798, 10803, 10809, 10839, 10844, 114,
			114, 59, 1, 8703, 116, 104, 116, 59, 1, 8763, 107, 4, 2, 108, 114, 10816, 10827, 101, 102,
			116, 97, 114, 114, 111, 119, 59, 1, 8617, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1,
			8618, 102, 59, 3, 55349, 56665, 98, 97, 114, 59, 1, 8213, 4, 3, 99, 108, 116, 10858, 10863,
			10869, 114, 59, 3, 55349, 56509, 97, 115, 104, 59, 1, 8463, 114, 111, 107, 59, 1, 295, 4, 2,
			98, 112, 10881, 10887, 117, 108, 108, 59, 1, 8259, 104, 101, 110, 59, 1, 8208, 4, 15, 97, 99,
			101, 102, 103, 105, 106, 109, 110, 111, 112, 113, 115, 116, 117, 10925, 10936, 10958, 10977,
			10990, 11001, 11039, 11045, 11101, 11192, 11220, 11226, 11237, 11285, 11299, 99, 117, 116,
			101, 5, 237, 1, 59, 10934, 1, 237, 4, 3, 59, 105, 121, 10944, 10946, 10955, 1, 8291, 114, 99,
			5, 238, 1, 59, 10953, 1, 238, 59, 1, 1080, 4, 2, 99, 120, 10964, 10968, 121, 59, 1, 1077, 99,
			108, 5, 161, 1, 59, 10975, 1, 161, 4, 2, 102, 114, 10983, 10986, 59, 1, 8660, 59, 3, 55349,
			56614, 114, 97, 118, 101, 5, 236, 1, 59, 10999, 1, 236, 4, 4, 59, 105, 110, 111, 11011, 11013,
			11028, 11034, 1, 8520, 4, 2, 105, 110, 11019, 11024, 110, 116, 59, 1, 10764, 116, 59, 1, 8749,
			102, 105, 110, 59, 1, 10716, 116, 97, 59, 1, 8489, 108, 105, 103, 59, 1, 307, 4, 3, 97, 111,
			112, 11053, 11092, 11096, 4, 3, 99, 103, 116, 11061, 11065, 11088, 114, 59, 1, 299, 4, 3, 101,
			108, 112, 11073, 11076, 11082, 59, 1, 8465, 105, 110, 101, 59, 1, 8464, 97, 114, 116, 59, 1,
			8465, 104, 59, 1, 305, 102, 59, 1, 8887, 101, 100, 59, 1, 437, 4, 5, 59, 99, 102, 111, 116,
			11113, 11115, 11121, 11136, 11142, 1, 8712, 97, 114, 101, 59, 1, 8453, 105, 110, 4, 2, 59,
			116, 11129, 11131, 1, 8734, 105, 101, 59, 1, 10717, 100, 111, 116, 59, 1, 305, 4, 5, 59, 99,
			101, 108, 112, 11154, 11156, 11161, 11179, 11186, 1, 8747, 97, 108, 59, 1, 8890, 4, 2, 103,
			114, 11167, 11173, 101, 114, 115, 59, 1, 8484, 99, 97, 108, 59, 1, 8890, 97, 114, 104, 107,
			59, 1, 10775, 114, 111, 100, 59, 1, 10812, 4, 4, 99, 103, 112, 116, 11202, 11206, 11211,
			11216, 121, 59, 1, 1105, 111, 110, 59, 1, 303, 102, 59, 3, 55349, 56666, 97, 59, 1, 953, 114,
			111, 100, 59, 1, 10812, 117, 101, 115, 116, 5, 191, 1, 59, 11235, 1, 191, 4, 2, 99, 105,
			11243, 11248, 114, 59, 3, 55349, 56510, 110, 4, 5, 59, 69, 100, 115, 118, 11261, 11263, 11266,
			11271, 11282, 1, 8712, 59, 1, 8953, 111, 116, 59, 1, 8949, 4, 2, 59, 118, 11277, 11279, 1,
			8948, 59, 1, 8947, 59, 1, 8712, 4, 2, 59, 105, 11291, 11293, 1, 8290, 108, 100, 101, 59, 1,
			297, 4, 2, 107, 109, 11305, 11310, 99, 121, 59, 1, 1110, 108, 5, 239, 1, 59, 11316, 1, 239, 4,
			6, 99, 102, 109, 111, 115, 117, 11332, 11346, 11351, 11357, 11363, 11380, 4, 2, 105, 121,
			11338, 11343, 114, 99, 59, 1, 309, 59, 1, 1081, 114, 59, 3, 55349, 56615, 97, 116, 104, 59, 1,
			567, 112, 102, 59, 3, 55349, 56667, 4, 2, 99, 101, 11369, 11374, 114, 59, 3, 55349, 56511,
			114, 99, 121, 59, 1, 1112, 107, 99, 121, 59, 1, 1108, 4, 8, 97, 99, 102, 103, 104, 106, 111,
			115, 11404, 11418, 11433, 11438, 11445, 11450, 11455, 11461, 112, 112, 97, 4, 2, 59, 118,
			11413, 11415, 1, 954, 59, 1, 1008, 4, 2, 101, 121, 11424, 11430, 100, 105, 108, 59, 1, 311,
			59, 1, 1082, 114, 59, 3, 55349, 56616, 114, 101, 101, 110, 59, 1, 312, 99, 121, 59, 1, 1093,
			99, 121, 59, 1, 1116, 112, 102, 59, 3, 55349, 56668, 99, 114, 59, 3, 55349, 56512, 4, 23, 65,
			66, 69, 72, 97, 98, 99, 100, 101, 102, 103, 104, 106, 108, 109, 110, 111, 112, 114, 115, 116,
			117, 118, 11515, 11538, 11544, 11555, 11560, 11721, 11780, 11818, 11868, 12136, 12160, 12171,
			12203, 12208, 12246, 12275, 12327, 12509, 12523, 12569, 12641, 12732, 12752, 4, 3, 97, 114,
			116, 11523, 11528, 11532, 114, 114, 59, 1, 8666, 114, 59, 1, 8656, 97, 105, 108, 59, 1, 10523,
			97, 114, 114, 59, 1, 10510, 4, 2, 59, 103, 11550, 11552, 1, 8806, 59, 1, 10891, 97, 114, 59,
			1, 10594, 4, 9, 99, 101, 103, 109, 110, 112, 113, 114, 116, 11580, 11586, 11594, 11600, 11606,
			11624, 11627, 11636, 11694, 117, 116, 101, 59, 1, 314, 109, 112, 116, 121, 118, 59, 1, 10676,
			114, 97, 110, 59, 1, 8466, 98, 100, 97, 59, 1, 955, 103, 4, 3, 59, 100, 108, 11615, 11617,
			11620, 1, 10216, 59, 1, 10641, 101, 59, 1, 10216, 59, 1, 10885, 117, 111, 5, 171, 1, 59,
			11634, 1, 171, 114, 4, 8, 59, 98, 102, 104, 108, 112, 115, 116, 11655, 11657, 11669, 11673,
			11677, 11681, 11685, 11690, 1, 8592, 4, 2, 59, 102, 11663, 11665, 1, 8676, 115, 59, 1, 10527,
			115, 59, 1, 10525, 107, 59, 1, 8617, 112, 59, 1, 8619, 108, 59, 1, 10553, 105, 109, 59, 1,
			10611, 108, 59, 1, 8610, 4, 3, 59, 97, 101, 11702, 11704, 11709, 1, 10923, 105, 108, 59, 1,
			10521, 4, 2, 59, 115, 11715, 11717, 1, 10925, 59, 3, 10925, 65024, 4, 3, 97, 98, 114, 11729,
			11734, 11739, 114, 114, 59, 1, 10508, 114, 107, 59, 1, 10098, 4, 2, 97, 107, 11745, 11758, 99,
			4, 2, 101, 107, 11752, 11755, 59, 1, 123, 59, 1, 91, 4, 2, 101, 115, 11764, 11767, 59, 1,
			10635, 108, 4, 2, 100, 117, 11774, 11777, 59, 1, 10639, 59, 1, 10637, 4, 4, 97, 101, 117, 121,
			11790, 11796, 11811, 11815, 114, 111, 110, 59, 1, 318, 4, 2, 100, 105, 11802, 11807, 105, 108,
			59, 1, 316, 108, 59, 1, 8968, 98, 59, 1, 123, 59, 1, 1083, 4, 4, 99, 113, 114, 115, 11828,
			11832, 11845, 11864, 97, 59, 1, 10550, 117, 111, 4, 2, 59, 114, 11840, 11842, 1, 8220, 59, 1,
			8222, 4, 2, 100, 117, 11851, 11857, 104, 97, 114, 59, 1, 10599, 115, 104, 97, 114, 59, 1,
			10571, 104, 59, 1, 8626, 4, 5, 59, 102, 103, 113, 115, 11880, 11882, 12008, 12011, 12031, 1,
			8804, 116, 4, 5, 97, 104, 108, 114, 116, 11895, 11913, 11935, 11947, 11996, 114, 114, 111,
			119, 4, 2, 59, 116, 11905, 11907, 1, 8592, 97, 105, 108, 59, 1, 8610, 97, 114, 112, 111, 111,
			110, 4, 2, 100, 117, 11925, 11931, 111, 119, 110, 59, 1, 8637, 112, 59, 1, 8636, 101, 102,
			116, 97, 114, 114, 111, 119, 115, 59, 1, 8647, 105, 103, 104, 116, 4, 3, 97, 104, 115, 11959,
			11974, 11984, 114, 114, 111, 119, 4, 2, 59, 115, 11969, 11971, 1, 8596, 59, 1, 8646, 97, 114,
			112, 111, 111, 110, 115, 59, 1, 8651, 113, 117, 105, 103, 97, 114, 114, 111, 119, 59, 1, 8621,
			104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 1, 8907, 59, 1, 8922, 4, 3, 59, 113, 115,
			12019, 12021, 12024, 1, 8804, 59, 1, 8806, 108, 97, 110, 116, 59, 1, 10877, 4, 5, 59, 99, 100,
			103, 115, 12043, 12045, 12049, 12070, 12083, 1, 10877, 99, 59, 1, 10920, 111, 116, 4, 2, 59,
			111, 12057, 12059, 1, 10879, 4, 2, 59, 114, 12065, 12067, 1, 10881, 59, 1, 10883, 4, 2, 59,
			101, 12076, 12079, 3, 8922, 65024, 115, 59, 1, 10899, 4, 5, 97, 100, 101, 103, 115, 12095,
			12103, 12108, 12126, 12131, 112, 112, 114, 111, 120, 59, 1, 10885, 111, 116, 59, 1, 8918, 113,
			4, 2, 103, 113, 12115, 12120, 116, 114, 59, 1, 8922, 103, 116, 114, 59, 1, 10891, 116, 114,
			59, 1, 8822, 105, 109, 59, 1, 8818, 4, 3, 105, 108, 114, 12144, 12150, 12156, 115, 104, 116,
			59, 1, 10620, 111, 111, 114, 59, 1, 8970, 59, 3, 55349, 56617, 4, 2, 59, 69, 12166, 12168, 1,
			8822, 59, 1, 10897, 4, 2, 97, 98, 12177, 12198, 114, 4, 2, 100, 117, 12184, 12187, 59, 1,
			8637, 4, 2, 59, 108, 12193, 12195, 1, 8636, 59, 1, 10602, 108, 107, 59, 1, 9604, 99, 121, 59,
			1, 1113, 4, 5, 59, 97, 99, 104, 116, 12220, 12222, 12227, 12235, 12241, 1, 8810, 114, 114, 59,
			1, 8647, 111, 114, 110, 101, 114, 59, 1, 8990, 97, 114, 100, 59, 1, 10603, 114, 105, 59, 1,
			9722, 4, 2, 105, 111, 12252, 12258, 100, 111, 116, 59, 1, 320, 117, 115, 116, 4, 2, 59, 97,
			12267, 12269, 1, 9136, 99, 104, 101, 59, 1, 9136, 4, 4, 69, 97, 101, 115, 12285, 12288, 12303,
			12322, 59, 1, 8808, 112, 4, 2, 59, 112, 12295, 12297, 1, 10889, 114, 111, 120, 59, 1, 10889,
			4, 2, 59, 113, 12309, 12311, 1, 10887, 4, 2, 59, 113, 12317, 12319, 1, 10887, 59, 1, 8808,
			105, 109, 59, 1, 8934, 4, 8, 97, 98, 110, 111, 112, 116, 119, 122, 12345, 12359, 12364, 12421,
			12446, 12467, 12474, 12490, 4, 2, 110, 114, 12351, 12355, 103, 59, 1, 10220, 114, 59, 1, 8701,
			114, 107, 59, 1, 10214, 103, 4, 3, 108, 109, 114, 12373, 12401, 12409, 101, 102, 116, 4, 2,
			97, 114, 12382, 12389, 114, 114, 111, 119, 59, 1, 10229, 105, 103, 104, 116, 97, 114, 114,
			111, 119, 59, 1, 10231, 97, 112, 115, 116, 111, 59, 1, 10236, 105, 103, 104, 116, 97, 114,
			114, 111, 119, 59, 1, 10230, 112, 97, 114, 114, 111, 119, 4, 2, 108, 114, 12433, 12439, 101,
			102, 116, 59, 1, 8619, 105, 103, 104, 116, 59, 1, 8620, 4, 3, 97, 102, 108, 12454, 12458,
			12462, 114, 59, 1, 10629, 59, 3, 55349, 56669, 117, 115, 59, 1, 10797, 105, 109, 101, 115, 59,
			1, 10804, 4, 2, 97, 98, 12480, 12485, 115, 116, 59, 1, 8727, 97, 114, 59, 1, 95, 4, 3, 59,
			101, 102, 12498, 12500, 12506, 1, 9674, 110, 103, 101, 59, 1, 9674, 59, 1, 10731, 97, 114, 4,
			2, 59, 108, 12517, 12519, 1, 40, 116, 59, 1, 10643, 4, 5, 97, 99, 104, 109, 116, 12535, 12540,
			12548, 12561, 12564, 114, 114, 59, 1, 8646, 111, 114, 110, 101, 114, 59, 1, 8991, 97, 114, 4,
			2, 59, 100, 12556, 12558, 1, 8651, 59, 1, 10605, 59, 1, 8206, 114, 105, 59, 1, 8895, 4, 6, 97,
			99, 104, 105, 113, 116, 12583, 12589, 12594, 12597, 12614, 12635, 113, 117, 111, 59, 1, 8249,
			114, 59, 3, 55349, 56513, 59, 1, 8624, 109, 4, 3, 59, 101, 103, 12606, 12608, 12611, 1, 8818,
			59, 1, 10893, 59, 1, 10895, 4, 2, 98, 117, 12620, 12623, 59, 1, 91, 111, 4, 2, 59, 114, 12630,
			12632, 1, 8216, 59, 1, 8218, 114, 111, 107, 59, 1, 322, 5, 60, 8, 59, 99, 100, 104, 105, 108,
			113, 114, 12660, 12662, 12675, 12680, 12686, 12692, 12698, 12705, 1, 60, 4, 2, 99, 105, 12668,
			12671, 59, 1, 10918, 114, 59, 1, 10873, 111, 116, 59, 1, 8918, 114, 101, 101, 59, 1, 8907,
			109, 101, 115, 59, 1, 8905, 97, 114, 114, 59, 1, 10614, 117, 101, 115, 116, 59, 1, 10875, 4,
			2, 80, 105, 12711, 12716, 97, 114, 59, 1, 10646, 4, 3, 59, 101, 102, 12724, 12726, 12729, 1,
			9667, 59, 1, 8884, 59, 1, 9666, 114, 4, 2, 100, 117, 12739, 12746, 115, 104, 97, 114, 59, 1,
			10570, 104, 97, 114, 59, 1, 10598, 4, 2, 101, 110, 12758, 12768, 114, 116, 110, 101, 113, 113,
			59, 3, 8808, 65024, 69, 59, 3, 8808, 65024, 4, 14, 68, 97, 99, 100, 101, 102, 104, 105, 108,
			110, 111, 112, 115, 117, 12803, 12809, 12893, 12908, 12914, 12928, 12933, 12937, 13011, 13025,
			13032, 13049, 13052, 13069, 68, 111, 116, 59, 1, 8762, 4, 4, 99, 108, 112, 114, 12819, 12827,
			12849, 12887, 114, 5, 175, 1, 59, 12825, 1, 175, 4, 2, 101, 116, 12833, 12836, 59, 1, 9794, 4,
			2, 59, 101, 12842, 12844, 1, 10016, 115, 101, 59, 1, 10016, 4, 2, 59, 115, 12855, 12857, 1,
			8614, 116, 111, 4, 4, 59, 100, 108, 117, 12869, 12871, 12877, 12883, 1, 8614, 111, 119, 110,
			59, 1, 8615, 101, 102, 116, 59, 1, 8612, 112, 59, 1, 8613, 107, 101, 114, 59, 1, 9646, 4, 2,
			111, 121, 12899, 12905, 109, 109, 97, 59, 1, 10793, 59, 1, 1084, 97, 115, 104, 59, 1, 8212,
			97, 115, 117, 114, 101, 100, 97, 110, 103, 108, 101, 59, 1, 8737, 114, 59, 3, 55349, 56618,
			111, 59, 1, 8487, 4, 3, 99, 100, 110, 12945, 12954, 12985, 114, 111, 5, 181, 1, 59, 12952, 1,
			181, 4, 4, 59, 97, 99, 100, 12964, 12966, 12971, 12976, 1, 8739, 115, 116, 59, 1, 42, 105,
			114, 59, 1, 10992, 111, 116, 5, 183, 1, 59, 12983, 1, 183, 117, 115, 4, 3, 59, 98, 100, 12995,
			12997, 13e3, 1, 8722, 59, 1, 8863, 4, 2, 59, 117, 13006, 13008, 1, 8760, 59, 1, 10794, 4, 2,
			99, 100, 13017, 13021, 112, 59, 1, 10971, 114, 59, 1, 8230, 112, 108, 117, 115, 59, 1, 8723,
			4, 2, 100, 112, 13038, 13044, 101, 108, 115, 59, 1, 8871, 102, 59, 3, 55349, 56670, 59, 1,
			8723, 4, 2, 99, 116, 13058, 13063, 114, 59, 3, 55349, 56514, 112, 111, 115, 59, 1, 8766, 4, 3,
			59, 108, 109, 13077, 13079, 13087, 1, 956, 116, 105, 109, 97, 112, 59, 1, 8888, 97, 112, 59,
			1, 8888, 4, 24, 71, 76, 82, 86, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 108, 109, 111,
			112, 114, 115, 116, 117, 118, 119, 13142, 13165, 13217, 13229, 13247, 13330, 13359, 13414,
			13420, 13508, 13513, 13579, 13602, 13626, 13631, 13762, 13767, 13855, 13936, 13995, 14214,
			14285, 14312, 14432, 4, 2, 103, 116, 13148, 13152, 59, 3, 8921, 824, 4, 2, 59, 118, 13158,
			13161, 3, 8811, 8402, 59, 3, 8811, 824, 4, 3, 101, 108, 116, 13173, 13200, 13204, 102, 116, 4,
			2, 97, 114, 13181, 13188, 114, 114, 111, 119, 59, 1, 8653, 105, 103, 104, 116, 97, 114, 114,
			111, 119, 59, 1, 8654, 59, 3, 8920, 824, 4, 2, 59, 118, 13210, 13213, 3, 8810, 8402, 59, 3,
			8810, 824, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8655, 4, 2, 68, 100, 13235,
			13241, 97, 115, 104, 59, 1, 8879, 97, 115, 104, 59, 1, 8878, 4, 5, 98, 99, 110, 112, 116,
			13259, 13264, 13270, 13275, 13308, 108, 97, 59, 1, 8711, 117, 116, 101, 59, 1, 324, 103, 59,
			3, 8736, 8402, 4, 5, 59, 69, 105, 111, 112, 13287, 13289, 13293, 13298, 13302, 1, 8777, 59, 3,
			10864, 824, 100, 59, 3, 8779, 824, 115, 59, 1, 329, 114, 111, 120, 59, 1, 8777, 117, 114, 4,
			2, 59, 97, 13316, 13318, 1, 9838, 108, 4, 2, 59, 115, 13325, 13327, 1, 9838, 59, 1, 8469, 4,
			2, 115, 117, 13336, 13344, 112, 5, 160, 1, 59, 13342, 1, 160, 109, 112, 4, 2, 59, 101, 13352,
			13355, 3, 8782, 824, 59, 3, 8783, 824, 4, 5, 97, 101, 111, 117, 121, 13371, 13385, 13391,
			13407, 13411, 4, 2, 112, 114, 13377, 13380, 59, 1, 10819, 111, 110, 59, 1, 328, 100, 105, 108,
			59, 1, 326, 110, 103, 4, 2, 59, 100, 13399, 13401, 1, 8775, 111, 116, 59, 3, 10861, 824, 112,
			59, 1, 10818, 59, 1, 1085, 97, 115, 104, 59, 1, 8211, 4, 7, 59, 65, 97, 100, 113, 115, 120,
			13436, 13438, 13443, 13466, 13472, 13478, 13494, 1, 8800, 114, 114, 59, 1, 8663, 114, 4, 2,
			104, 114, 13450, 13454, 107, 59, 1, 10532, 4, 2, 59, 111, 13460, 13462, 1, 8599, 119, 59, 1,
			8599, 111, 116, 59, 3, 8784, 824, 117, 105, 118, 59, 1, 8802, 4, 2, 101, 105, 13484, 13489,
			97, 114, 59, 1, 10536, 109, 59, 3, 8770, 824, 105, 115, 116, 4, 2, 59, 115, 13503, 13505, 1,
			8708, 59, 1, 8708, 114, 59, 3, 55349, 56619, 4, 4, 69, 101, 115, 116, 13523, 13527, 13563,
			13568, 59, 3, 8807, 824, 4, 3, 59, 113, 115, 13535, 13537, 13559, 1, 8817, 4, 3, 59, 113, 115,
			13545, 13547, 13551, 1, 8817, 59, 3, 8807, 824, 108, 97, 110, 116, 59, 3, 10878, 824, 59, 3,
			10878, 824, 105, 109, 59, 1, 8821, 4, 2, 59, 114, 13574, 13576, 1, 8815, 59, 1, 8815, 4, 3,
			65, 97, 112, 13587, 13592, 13597, 114, 114, 59, 1, 8654, 114, 114, 59, 1, 8622, 97, 114, 59,
			1, 10994, 4, 3, 59, 115, 118, 13610, 13612, 13623, 1, 8715, 4, 2, 59, 100, 13618, 13620, 1,
			8956, 59, 1, 8954, 59, 1, 8715, 99, 121, 59, 1, 1114, 4, 7, 65, 69, 97, 100, 101, 115, 116,
			13647, 13652, 13656, 13661, 13665, 13737, 13742, 114, 114, 59, 1, 8653, 59, 3, 8806, 824, 114,
			114, 59, 1, 8602, 114, 59, 1, 8229, 4, 4, 59, 102, 113, 115, 13675, 13677, 13703, 13725, 1,
			8816, 116, 4, 2, 97, 114, 13684, 13691, 114, 114, 111, 119, 59, 1, 8602, 105, 103, 104, 116,
			97, 114, 114, 111, 119, 59, 1, 8622, 4, 3, 59, 113, 115, 13711, 13713, 13717, 1, 8816, 59, 3,
			8806, 824, 108, 97, 110, 116, 59, 3, 10877, 824, 4, 2, 59, 115, 13731, 13734, 3, 10877, 824,
			59, 1, 8814, 105, 109, 59, 1, 8820, 4, 2, 59, 114, 13748, 13750, 1, 8814, 105, 4, 2, 59, 101,
			13757, 13759, 1, 8938, 59, 1, 8940, 105, 100, 59, 1, 8740, 4, 2, 112, 116, 13773, 13778, 102,
			59, 3, 55349, 56671, 5, 172, 3, 59, 105, 110, 13787, 13789, 13829, 1, 172, 110, 4, 4, 59, 69,
			100, 118, 13800, 13802, 13806, 13812, 1, 8713, 59, 3, 8953, 824, 111, 116, 59, 3, 8949, 824,
			4, 3, 97, 98, 99, 13820, 13823, 13826, 59, 1, 8713, 59, 1, 8951, 59, 1, 8950, 105, 4, 2, 59,
			118, 13836, 13838, 1, 8716, 4, 3, 97, 98, 99, 13846, 13849, 13852, 59, 1, 8716, 59, 1, 8958,
			59, 1, 8957, 4, 3, 97, 111, 114, 13863, 13892, 13899, 114, 4, 4, 59, 97, 115, 116, 13874,
			13876, 13883, 13888, 1, 8742, 108, 108, 101, 108, 59, 1, 8742, 108, 59, 3, 11005, 8421, 59, 3,
			8706, 824, 108, 105, 110, 116, 59, 1, 10772, 4, 3, 59, 99, 101, 13907, 13909, 13914, 1, 8832,
			117, 101, 59, 1, 8928, 4, 2, 59, 99, 13920, 13923, 3, 10927, 824, 4, 2, 59, 101, 13929, 13931,
			1, 8832, 113, 59, 3, 10927, 824, 4, 4, 65, 97, 105, 116, 13946, 13951, 13971, 13982, 114, 114,
			59, 1, 8655, 114, 114, 4, 3, 59, 99, 119, 13961, 13963, 13967, 1, 8603, 59, 3, 10547, 824, 59,
			3, 8605, 824, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8603, 114, 105, 4, 2, 59, 101,
			13990, 13992, 1, 8939, 59, 1, 8941, 4, 7, 99, 104, 105, 109, 112, 113, 117, 14011, 14036,
			14060, 14080, 14085, 14090, 14106, 4, 4, 59, 99, 101, 114, 14021, 14023, 14028, 14032, 1,
			8833, 117, 101, 59, 1, 8929, 59, 3, 10928, 824, 59, 3, 55349, 56515, 111, 114, 116, 4, 2, 109,
			112, 14045, 14050, 105, 100, 59, 1, 8740, 97, 114, 97, 108, 108, 101, 108, 59, 1, 8742, 109,
			4, 2, 59, 101, 14067, 14069, 1, 8769, 4, 2, 59, 113, 14075, 14077, 1, 8772, 59, 1, 8772, 105,
			100, 59, 1, 8740, 97, 114, 59, 1, 8742, 115, 117, 4, 2, 98, 112, 14098, 14102, 101, 59, 1,
			8930, 101, 59, 1, 8931, 4, 3, 98, 99, 112, 14114, 14157, 14171, 4, 4, 59, 69, 101, 115, 14124,
			14126, 14130, 14133, 1, 8836, 59, 3, 10949, 824, 59, 1, 8840, 101, 116, 4, 2, 59, 101, 14141,
			14144, 3, 8834, 8402, 113, 4, 2, 59, 113, 14151, 14153, 1, 8840, 59, 3, 10949, 824, 99, 4, 2,
			59, 101, 14164, 14166, 1, 8833, 113, 59, 3, 10928, 824, 4, 4, 59, 69, 101, 115, 14181, 14183,
			14187, 14190, 1, 8837, 59, 3, 10950, 824, 59, 1, 8841, 101, 116, 4, 2, 59, 101, 14198, 14201,
			3, 8835, 8402, 113, 4, 2, 59, 113, 14208, 14210, 1, 8841, 59, 3, 10950, 824, 4, 4, 103, 105,
			108, 114, 14224, 14228, 14238, 14242, 108, 59, 1, 8825, 108, 100, 101, 5, 241, 1, 59, 14236,
			1, 241, 103, 59, 1, 8824, 105, 97, 110, 103, 108, 101, 4, 2, 108, 114, 14254, 14269, 101, 102,
			116, 4, 2, 59, 101, 14263, 14265, 1, 8938, 113, 59, 1, 8940, 105, 103, 104, 116, 4, 2, 59,
			101, 14279, 14281, 1, 8939, 113, 59, 1, 8941, 4, 2, 59, 109, 14291, 14293, 1, 957, 4, 3, 59,
			101, 115, 14301, 14303, 14308, 1, 35, 114, 111, 59, 1, 8470, 112, 59, 1, 8199, 4, 9, 68, 72,
			97, 100, 103, 105, 108, 114, 115, 14332, 14338, 14344, 14349, 14355, 14369, 14376, 14408,
			14426, 97, 115, 104, 59, 1, 8877, 97, 114, 114, 59, 1, 10500, 112, 59, 3, 8781, 8402, 97, 115,
			104, 59, 1, 8876, 4, 2, 101, 116, 14361, 14365, 59, 3, 8805, 8402, 59, 3, 62, 8402, 110, 102,
			105, 110, 59, 1, 10718, 4, 3, 65, 101, 116, 14384, 14389, 14393, 114, 114, 59, 1, 10498, 59,
			3, 8804, 8402, 4, 2, 59, 114, 14399, 14402, 3, 60, 8402, 105, 101, 59, 3, 8884, 8402, 4, 2,
			65, 116, 14414, 14419, 114, 114, 59, 1, 10499, 114, 105, 101, 59, 3, 8885, 8402, 105, 109, 59,
			3, 8764, 8402, 4, 3, 65, 97, 110, 14440, 14445, 14468, 114, 114, 59, 1, 8662, 114, 4, 2, 104,
			114, 14452, 14456, 107, 59, 1, 10531, 4, 2, 59, 111, 14462, 14464, 1, 8598, 119, 59, 1, 8598,
			101, 97, 114, 59, 1, 10535, 4, 18, 83, 97, 99, 100, 101, 102, 103, 104, 105, 108, 109, 111,
			112, 114, 115, 116, 117, 118, 14512, 14515, 14535, 14560, 14597, 14603, 14618, 14643, 14657,
			14662, 14701, 14741, 14747, 14769, 14851, 14877, 14907, 14916, 59, 1, 9416, 4, 2, 99, 115,
			14521, 14531, 117, 116, 101, 5, 243, 1, 59, 14529, 1, 243, 116, 59, 1, 8859, 4, 2, 105, 121,
			14541, 14557, 114, 4, 2, 59, 99, 14548, 14550, 1, 8858, 5, 244, 1, 59, 14555, 1, 244, 59, 1,
			1086, 4, 5, 97, 98, 105, 111, 115, 14572, 14577, 14583, 14587, 14591, 115, 104, 59, 1, 8861,
			108, 97, 99, 59, 1, 337, 118, 59, 1, 10808, 116, 59, 1, 8857, 111, 108, 100, 59, 1, 10684,
			108, 105, 103, 59, 1, 339, 4, 2, 99, 114, 14609, 14614, 105, 114, 59, 1, 10687, 59, 3, 55349,
			56620, 4, 3, 111, 114, 116, 14626, 14630, 14640, 110, 59, 1, 731, 97, 118, 101, 5, 242, 1, 59,
			14638, 1, 242, 59, 1, 10689, 4, 2, 98, 109, 14649, 14654, 97, 114, 59, 1, 10677, 59, 1, 937,
			110, 116, 59, 1, 8750, 4, 4, 97, 99, 105, 116, 14672, 14677, 14693, 14698, 114, 114, 59, 1,
			8634, 4, 2, 105, 114, 14683, 14687, 114, 59, 1, 10686, 111, 115, 115, 59, 1, 10683, 110, 101,
			59, 1, 8254, 59, 1, 10688, 4, 3, 97, 101, 105, 14709, 14714, 14719, 99, 114, 59, 1, 333, 103,
			97, 59, 1, 969, 4, 3, 99, 100, 110, 14727, 14733, 14736, 114, 111, 110, 59, 1, 959, 59, 1,
			10678, 117, 115, 59, 1, 8854, 112, 102, 59, 3, 55349, 56672, 4, 3, 97, 101, 108, 14755, 14759,
			14764, 114, 59, 1, 10679, 114, 112, 59, 1, 10681, 117, 115, 59, 1, 8853, 4, 7, 59, 97, 100,
			105, 111, 115, 118, 14785, 14787, 14792, 14831, 14837, 14841, 14848, 1, 8744, 114, 114, 59, 1,
			8635, 4, 4, 59, 101, 102, 109, 14802, 14804, 14817, 14824, 1, 10845, 114, 4, 2, 59, 111,
			14811, 14813, 1, 8500, 102, 59, 1, 8500, 5, 170, 1, 59, 14822, 1, 170, 5, 186, 1, 59, 14829,
			1, 186, 103, 111, 102, 59, 1, 8886, 114, 59, 1, 10838, 108, 111, 112, 101, 59, 1, 10839, 59,
			1, 10843, 4, 3, 99, 108, 111, 14859, 14863, 14873, 114, 59, 1, 8500, 97, 115, 104, 5, 248, 1,
			59, 14871, 1, 248, 108, 59, 1, 8856, 105, 4, 2, 108, 109, 14884, 14893, 100, 101, 5, 245, 1,
			59, 14891, 1, 245, 101, 115, 4, 2, 59, 97, 14901, 14903, 1, 8855, 115, 59, 1, 10806, 109, 108,
			5, 246, 1, 59, 14914, 1, 246, 98, 97, 114, 59, 1, 9021, 4, 12, 97, 99, 101, 102, 104, 105,
			108, 109, 111, 114, 115, 117, 14948, 14992, 14996, 15033, 15038, 15068, 15090, 15189, 15192,
			15222, 15427, 15441, 114, 4, 4, 59, 97, 115, 116, 14959, 14961, 14976, 14989, 1, 8741, 5, 182,
			2, 59, 108, 14968, 14970, 1, 182, 108, 101, 108, 59, 1, 8741, 4, 2, 105, 108, 14982, 14986,
			109, 59, 1, 10995, 59, 1, 11005, 59, 1, 8706, 121, 59, 1, 1087, 114, 4, 5, 99, 105, 109, 112,
			116, 15009, 15014, 15019, 15024, 15027, 110, 116, 59, 1, 37, 111, 100, 59, 1, 46, 105, 108,
			59, 1, 8240, 59, 1, 8869, 101, 110, 107, 59, 1, 8241, 114, 59, 3, 55349, 56621, 4, 3, 105,
			109, 111, 15046, 15057, 15063, 4, 2, 59, 118, 15052, 15054, 1, 966, 59, 1, 981, 109, 97, 116,
			59, 1, 8499, 110, 101, 59, 1, 9742, 4, 3, 59, 116, 118, 15076, 15078, 15087, 1, 960, 99, 104,
			102, 111, 114, 107, 59, 1, 8916, 59, 1, 982, 4, 2, 97, 117, 15096, 15119, 110, 4, 2, 99, 107,
			15103, 15115, 107, 4, 2, 59, 104, 15110, 15112, 1, 8463, 59, 1, 8462, 118, 59, 1, 8463, 115,
			4, 9, 59, 97, 98, 99, 100, 101, 109, 115, 116, 15140, 15142, 15148, 15151, 15156, 15168,
			15171, 15179, 15184, 1, 43, 99, 105, 114, 59, 1, 10787, 59, 1, 8862, 105, 114, 59, 1, 10786,
			4, 2, 111, 117, 15162, 15165, 59, 1, 8724, 59, 1, 10789, 59, 1, 10866, 110, 5, 177, 1, 59,
			15177, 1, 177, 105, 109, 59, 1, 10790, 119, 111, 59, 1, 10791, 59, 1, 177, 4, 3, 105, 112,
			117, 15200, 15208, 15213, 110, 116, 105, 110, 116, 59, 1, 10773, 102, 59, 3, 55349, 56673,
			110, 100, 5, 163, 1, 59, 15220, 1, 163, 4, 10, 59, 69, 97, 99, 101, 105, 110, 111, 115, 117,
			15244, 15246, 15249, 15253, 15258, 15334, 15347, 15367, 15416, 15421, 1, 8826, 59, 1, 10931,
			112, 59, 1, 10935, 117, 101, 59, 1, 8828, 4, 2, 59, 99, 15264, 15266, 1, 10927, 4, 6, 59, 97,
			99, 101, 110, 115, 15280, 15282, 15290, 15299, 15303, 15329, 1, 8826, 112, 112, 114, 111, 120,
			59, 1, 10935, 117, 114, 108, 121, 101, 113, 59, 1, 8828, 113, 59, 1, 10927, 4, 3, 97, 101,
			115, 15311, 15319, 15324, 112, 112, 114, 111, 120, 59, 1, 10937, 113, 113, 59, 1, 10933, 105,
			109, 59, 1, 8936, 105, 109, 59, 1, 8830, 109, 101, 4, 2, 59, 115, 15342, 15344, 1, 8242, 59,
			1, 8473, 4, 3, 69, 97, 115, 15355, 15358, 15362, 59, 1, 10933, 112, 59, 1, 10937, 105, 109,
			59, 1, 8936, 4, 3, 100, 102, 112, 15375, 15378, 15404, 59, 1, 8719, 4, 3, 97, 108, 115, 15386,
			15392, 15398, 108, 97, 114, 59, 1, 9006, 105, 110, 101, 59, 1, 8978, 117, 114, 102, 59, 1,
			8979, 4, 2, 59, 116, 15410, 15412, 1, 8733, 111, 59, 1, 8733, 105, 109, 59, 1, 8830, 114, 101,
			108, 59, 1, 8880, 4, 2, 99, 105, 15433, 15438, 114, 59, 3, 55349, 56517, 59, 1, 968, 110, 99,
			115, 112, 59, 1, 8200, 4, 6, 102, 105, 111, 112, 115, 117, 15462, 15467, 15472, 15478, 15485,
			15491, 114, 59, 3, 55349, 56622, 110, 116, 59, 1, 10764, 112, 102, 59, 3, 55349, 56674, 114,
			105, 109, 101, 59, 1, 8279, 99, 114, 59, 3, 55349, 56518, 4, 3, 97, 101, 111, 15499, 15520,
			15534, 116, 4, 2, 101, 105, 15506, 15515, 114, 110, 105, 111, 110, 115, 59, 1, 8461, 110, 116,
			59, 1, 10774, 115, 116, 4, 2, 59, 101, 15528, 15530, 1, 63, 113, 59, 1, 8799, 116, 5, 34, 1,
			59, 15540, 1, 34, 4, 21, 65, 66, 72, 97, 98, 99, 100, 101, 102, 104, 105, 108, 109, 110, 111,
			112, 114, 115, 116, 117, 120, 15586, 15609, 15615, 15620, 15796, 15855, 15893, 15931, 15977,
			16001, 16039, 16183, 16204, 16222, 16228, 16285, 16312, 16318, 16363, 16408, 16416, 4, 3, 97,
			114, 116, 15594, 15599, 15603, 114, 114, 59, 1, 8667, 114, 59, 1, 8658, 97, 105, 108, 59, 1,
			10524, 97, 114, 114, 59, 1, 10511, 97, 114, 59, 1, 10596, 4, 7, 99, 100, 101, 110, 113, 114,
			116, 15636, 15651, 15656, 15664, 15687, 15696, 15770, 4, 2, 101, 117, 15642, 15646, 59, 3,
			8765, 817, 116, 101, 59, 1, 341, 105, 99, 59, 1, 8730, 109, 112, 116, 121, 118, 59, 1, 10675,
			103, 4, 4, 59, 100, 101, 108, 15675, 15677, 15680, 15683, 1, 10217, 59, 1, 10642, 59, 1,
			10661, 101, 59, 1, 10217, 117, 111, 5, 187, 1, 59, 15694, 1, 187, 114, 4, 11, 59, 97, 98, 99,
			102, 104, 108, 112, 115, 116, 119, 15721, 15723, 15727, 15739, 15742, 15746, 15750, 15754,
			15758, 15763, 15767, 1, 8594, 112, 59, 1, 10613, 4, 2, 59, 102, 15733, 15735, 1, 8677, 115,
			59, 1, 10528, 59, 1, 10547, 115, 59, 1, 10526, 107, 59, 1, 8618, 112, 59, 1, 8620, 108, 59, 1,
			10565, 105, 109, 59, 1, 10612, 108, 59, 1, 8611, 59, 1, 8605, 4, 2, 97, 105, 15776, 15781,
			105, 108, 59, 1, 10522, 111, 4, 2, 59, 110, 15788, 15790, 1, 8758, 97, 108, 115, 59, 1, 8474,
			4, 3, 97, 98, 114, 15804, 15809, 15814, 114, 114, 59, 1, 10509, 114, 107, 59, 1, 10099, 4, 2,
			97, 107, 15820, 15833, 99, 4, 2, 101, 107, 15827, 15830, 59, 1, 125, 59, 1, 93, 4, 2, 101,
			115, 15839, 15842, 59, 1, 10636, 108, 4, 2, 100, 117, 15849, 15852, 59, 1, 10638, 59, 1,
			10640, 4, 4, 97, 101, 117, 121, 15865, 15871, 15886, 15890, 114, 111, 110, 59, 1, 345, 4, 2,
			100, 105, 15877, 15882, 105, 108, 59, 1, 343, 108, 59, 1, 8969, 98, 59, 1, 125, 59, 1, 1088,
			4, 4, 99, 108, 113, 115, 15903, 15907, 15914, 15927, 97, 59, 1, 10551, 100, 104, 97, 114, 59,
			1, 10601, 117, 111, 4, 2, 59, 114, 15922, 15924, 1, 8221, 59, 1, 8221, 104, 59, 1, 8627, 4, 3,
			97, 99, 103, 15939, 15966, 15970, 108, 4, 4, 59, 105, 112, 115, 15950, 15952, 15957, 15963, 1,
			8476, 110, 101, 59, 1, 8475, 97, 114, 116, 59, 1, 8476, 59, 1, 8477, 116, 59, 1, 9645, 5, 174,
			1, 59, 15975, 1, 174, 4, 3, 105, 108, 114, 15985, 15991, 15997, 115, 104, 116, 59, 1, 10621,
			111, 111, 114, 59, 1, 8971, 59, 3, 55349, 56623, 4, 2, 97, 111, 16007, 16028, 114, 4, 2, 100,
			117, 16014, 16017, 59, 1, 8641, 4, 2, 59, 108, 16023, 16025, 1, 8640, 59, 1, 10604, 4, 2, 59,
			118, 16034, 16036, 1, 961, 59, 1, 1009, 4, 3, 103, 110, 115, 16047, 16167, 16171, 104, 116, 4,
			6, 97, 104, 108, 114, 115, 116, 16063, 16081, 16103, 16130, 16143, 16155, 114, 114, 111, 119,
			4, 2, 59, 116, 16073, 16075, 1, 8594, 97, 105, 108, 59, 1, 8611, 97, 114, 112, 111, 111, 110,
			4, 2, 100, 117, 16093, 16099, 111, 119, 110, 59, 1, 8641, 112, 59, 1, 8640, 101, 102, 116, 4,
			2, 97, 104, 16112, 16120, 114, 114, 111, 119, 115, 59, 1, 8644, 97, 114, 112, 111, 111, 110,
			115, 59, 1, 8652, 105, 103, 104, 116, 97, 114, 114, 111, 119, 115, 59, 1, 8649, 113, 117, 105,
			103, 97, 114, 114, 111, 119, 59, 1, 8605, 104, 114, 101, 101, 116, 105, 109, 101, 115, 59, 1,
			8908, 103, 59, 1, 730, 105, 110, 103, 100, 111, 116, 115, 101, 113, 59, 1, 8787, 4, 3, 97,
			104, 109, 16191, 16196, 16201, 114, 114, 59, 1, 8644, 97, 114, 59, 1, 8652, 59, 1, 8207, 111,
			117, 115, 116, 4, 2, 59, 97, 16214, 16216, 1, 9137, 99, 104, 101, 59, 1, 9137, 109, 105, 100,
			59, 1, 10990, 4, 4, 97, 98, 112, 116, 16238, 16252, 16257, 16278, 4, 2, 110, 114, 16244,
			16248, 103, 59, 1, 10221, 114, 59, 1, 8702, 114, 107, 59, 1, 10215, 4, 3, 97, 102, 108, 16265,
			16269, 16273, 114, 59, 1, 10630, 59, 3, 55349, 56675, 117, 115, 59, 1, 10798, 105, 109, 101,
			115, 59, 1, 10805, 4, 2, 97, 112, 16291, 16304, 114, 4, 2, 59, 103, 16298, 16300, 1, 41, 116,
			59, 1, 10644, 111, 108, 105, 110, 116, 59, 1, 10770, 97, 114, 114, 59, 1, 8649, 4, 4, 97, 99,
			104, 113, 16328, 16334, 16339, 16342, 113, 117, 111, 59, 1, 8250, 114, 59, 3, 55349, 56519,
			59, 1, 8625, 4, 2, 98, 117, 16348, 16351, 59, 1, 93, 111, 4, 2, 59, 114, 16358, 16360, 1,
			8217, 59, 1, 8217, 4, 3, 104, 105, 114, 16371, 16377, 16383, 114, 101, 101, 59, 1, 8908, 109,
			101, 115, 59, 1, 8906, 105, 4, 4, 59, 101, 102, 108, 16394, 16396, 16399, 16402, 1, 9657, 59,
			1, 8885, 59, 1, 9656, 116, 114, 105, 59, 1, 10702, 108, 117, 104, 97, 114, 59, 1, 10600, 59,
			1, 8478, 4, 19, 97, 98, 99, 100, 101, 102, 104, 105, 108, 109, 111, 112, 113, 114, 115, 116,
			117, 119, 122, 16459, 16466, 16472, 16572, 16590, 16672, 16687, 16746, 16844, 16850, 16924,
			16963, 16988, 17115, 17121, 17154, 17206, 17614, 17656, 99, 117, 116, 101, 59, 1, 347, 113,
			117, 111, 59, 1, 8218, 4, 10, 59, 69, 97, 99, 101, 105, 110, 112, 115, 121, 16494, 16496,
			16499, 16513, 16518, 16531, 16536, 16556, 16564, 16569, 1, 8827, 59, 1, 10932, 4, 2, 112, 114,
			16505, 16508, 59, 1, 10936, 111, 110, 59, 1, 353, 117, 101, 59, 1, 8829, 4, 2, 59, 100, 16524,
			16526, 1, 10928, 105, 108, 59, 1, 351, 114, 99, 59, 1, 349, 4, 3, 69, 97, 115, 16544, 16547,
			16551, 59, 1, 10934, 112, 59, 1, 10938, 105, 109, 59, 1, 8937, 111, 108, 105, 110, 116, 59, 1,
			10771, 105, 109, 59, 1, 8831, 59, 1, 1089, 111, 116, 4, 3, 59, 98, 101, 16582, 16584, 16587,
			1, 8901, 59, 1, 8865, 59, 1, 10854, 4, 7, 65, 97, 99, 109, 115, 116, 120, 16606, 16611, 16634,
			16642, 16646, 16652, 16668, 114, 114, 59, 1, 8664, 114, 4, 2, 104, 114, 16618, 16622, 107, 59,
			1, 10533, 4, 2, 59, 111, 16628, 16630, 1, 8600, 119, 59, 1, 8600, 116, 5, 167, 1, 59, 16640,
			1, 167, 105, 59, 1, 59, 119, 97, 114, 59, 1, 10537, 109, 4, 2, 105, 110, 16659, 16665, 110,
			117, 115, 59, 1, 8726, 59, 1, 8726, 116, 59, 1, 10038, 114, 4, 2, 59, 111, 16679, 16682, 3,
			55349, 56624, 119, 110, 59, 1, 8994, 4, 4, 97, 99, 111, 121, 16697, 16702, 16716, 16739, 114,
			112, 59, 1, 9839, 4, 2, 104, 121, 16708, 16713, 99, 121, 59, 1, 1097, 59, 1, 1096, 114, 116,
			4, 2, 109, 112, 16724, 16729, 105, 100, 59, 1, 8739, 97, 114, 97, 108, 108, 101, 108, 59, 1,
			8741, 5, 173, 1, 59, 16744, 1, 173, 4, 2, 103, 109, 16752, 16770, 109, 97, 4, 3, 59, 102, 118,
			16762, 16764, 16767, 1, 963, 59, 1, 962, 59, 1, 962, 4, 8, 59, 100, 101, 103, 108, 110, 112,
			114, 16788, 16790, 16795, 16806, 16817, 16828, 16832, 16838, 1, 8764, 111, 116, 59, 1, 10858,
			4, 2, 59, 113, 16801, 16803, 1, 8771, 59, 1, 8771, 4, 2, 59, 69, 16812, 16814, 1, 10910, 59,
			1, 10912, 4, 2, 59, 69, 16823, 16825, 1, 10909, 59, 1, 10911, 101, 59, 1, 8774, 108, 117, 115,
			59, 1, 10788, 97, 114, 114, 59, 1, 10610, 97, 114, 114, 59, 1, 8592, 4, 4, 97, 101, 105, 116,
			16860, 16883, 16891, 16904, 4, 2, 108, 115, 16866, 16878, 108, 115, 101, 116, 109, 105, 110,
			117, 115, 59, 1, 8726, 104, 112, 59, 1, 10803, 112, 97, 114, 115, 108, 59, 1, 10724, 4, 2,
			100, 108, 16897, 16900, 59, 1, 8739, 101, 59, 1, 8995, 4, 2, 59, 101, 16910, 16912, 1, 10922,
			4, 2, 59, 115, 16918, 16920, 1, 10924, 59, 3, 10924, 65024, 4, 3, 102, 108, 112, 16932, 16938,
			16958, 116, 99, 121, 59, 1, 1100, 4, 2, 59, 98, 16944, 16946, 1, 47, 4, 2, 59, 97, 16952,
			16954, 1, 10692, 114, 59, 1, 9023, 102, 59, 3, 55349, 56676, 97, 4, 2, 100, 114, 16970, 16985,
			101, 115, 4, 2, 59, 117, 16978, 16980, 1, 9824, 105, 116, 59, 1, 9824, 59, 1, 8741, 4, 3, 99,
			115, 117, 16996, 17028, 17089, 4, 2, 97, 117, 17002, 17015, 112, 4, 2, 59, 115, 17009, 17011,
			1, 8851, 59, 3, 8851, 65024, 112, 4, 2, 59, 115, 17022, 17024, 1, 8852, 59, 3, 8852, 65024,
			117, 4, 2, 98, 112, 17035, 17062, 4, 3, 59, 101, 115, 17043, 17045, 17048, 1, 8847, 59, 1,
			8849, 101, 116, 4, 2, 59, 101, 17056, 17058, 1, 8847, 113, 59, 1, 8849, 4, 3, 59, 101, 115,
			17070, 17072, 17075, 1, 8848, 59, 1, 8850, 101, 116, 4, 2, 59, 101, 17083, 17085, 1, 8848,
			113, 59, 1, 8850, 4, 3, 59, 97, 102, 17097, 17099, 17112, 1, 9633, 114, 4, 2, 101, 102, 17106,
			17109, 59, 1, 9633, 59, 1, 9642, 59, 1, 9642, 97, 114, 114, 59, 1, 8594, 4, 4, 99, 101, 109,
			116, 17131, 17136, 17142, 17148, 114, 59, 3, 55349, 56520, 116, 109, 110, 59, 1, 8726, 105,
			108, 101, 59, 1, 8995, 97, 114, 102, 59, 1, 8902, 4, 2, 97, 114, 17160, 17172, 114, 4, 2, 59,
			102, 17167, 17169, 1, 9734, 59, 1, 9733, 4, 2, 97, 110, 17178, 17202, 105, 103, 104, 116, 4,
			2, 101, 112, 17188, 17197, 112, 115, 105, 108, 111, 110, 59, 1, 1013, 104, 105, 59, 1, 981,
			115, 59, 1, 175, 4, 5, 98, 99, 109, 110, 112, 17218, 17351, 17420, 17423, 17427, 4, 9, 59, 69,
			100, 101, 109, 110, 112, 114, 115, 17238, 17240, 17243, 17248, 17261, 17267, 17279, 17285,
			17291, 1, 8834, 59, 1, 10949, 111, 116, 59, 1, 10941, 4, 2, 59, 100, 17254, 17256, 1, 8838,
			111, 116, 59, 1, 10947, 117, 108, 116, 59, 1, 10945, 4, 2, 69, 101, 17273, 17276, 59, 1,
			10955, 59, 1, 8842, 108, 117, 115, 59, 1, 10943, 97, 114, 114, 59, 1, 10617, 4, 3, 101, 105,
			117, 17299, 17335, 17339, 116, 4, 3, 59, 101, 110, 17308, 17310, 17322, 1, 8834, 113, 4, 2,
			59, 113, 17317, 17319, 1, 8838, 59, 1, 10949, 101, 113, 4, 2, 59, 113, 17330, 17332, 1, 8842,
			59, 1, 10955, 109, 59, 1, 10951, 4, 2, 98, 112, 17345, 17348, 59, 1, 10965, 59, 1, 10963, 99,
			4, 6, 59, 97, 99, 101, 110, 115, 17366, 17368, 17376, 17385, 17389, 17415, 1, 8827, 112, 112,
			114, 111, 120, 59, 1, 10936, 117, 114, 108, 121, 101, 113, 59, 1, 8829, 113, 59, 1, 10928, 4,
			3, 97, 101, 115, 17397, 17405, 17410, 112, 112, 114, 111, 120, 59, 1, 10938, 113, 113, 59, 1,
			10934, 105, 109, 59, 1, 8937, 105, 109, 59, 1, 8831, 59, 1, 8721, 103, 59, 1, 9834, 4, 13, 49,
			50, 51, 59, 69, 100, 101, 104, 108, 109, 110, 112, 115, 17455, 17462, 17469, 17476, 17478,
			17481, 17496, 17509, 17524, 17530, 17536, 17548, 17554, 5, 185, 1, 59, 17460, 1, 185, 5, 178,
			1, 59, 17467, 1, 178, 5, 179, 1, 59, 17474, 1, 179, 1, 8835, 59, 1, 10950, 4, 2, 111, 115,
			17487, 17491, 116, 59, 1, 10942, 117, 98, 59, 1, 10968, 4, 2, 59, 100, 17502, 17504, 1, 8839,
			111, 116, 59, 1, 10948, 115, 4, 2, 111, 117, 17516, 17520, 108, 59, 1, 10185, 98, 59, 1,
			10967, 97, 114, 114, 59, 1, 10619, 117, 108, 116, 59, 1, 10946, 4, 2, 69, 101, 17542, 17545,
			59, 1, 10956, 59, 1, 8843, 108, 117, 115, 59, 1, 10944, 4, 3, 101, 105, 117, 17562, 17598,
			17602, 116, 4, 3, 59, 101, 110, 17571, 17573, 17585, 1, 8835, 113, 4, 2, 59, 113, 17580,
			17582, 1, 8839, 59, 1, 10950, 101, 113, 4, 2, 59, 113, 17593, 17595, 1, 8843, 59, 1, 10956,
			109, 59, 1, 10952, 4, 2, 98, 112, 17608, 17611, 59, 1, 10964, 59, 1, 10966, 4, 3, 65, 97, 110,
			17622, 17627, 17650, 114, 114, 59, 1, 8665, 114, 4, 2, 104, 114, 17634, 17638, 107, 59, 1,
			10534, 4, 2, 59, 111, 17644, 17646, 1, 8601, 119, 59, 1, 8601, 119, 97, 114, 59, 1, 10538,
			108, 105, 103, 5, 223, 1, 59, 17664, 1, 223, 4, 13, 97, 98, 99, 100, 101, 102, 104, 105, 111,
			112, 114, 115, 119, 17694, 17709, 17714, 17737, 17742, 17749, 17754, 17860, 17905, 17957,
			17964, 18090, 18122, 4, 2, 114, 117, 17700, 17706, 103, 101, 116, 59, 1, 8982, 59, 1, 964,
			114, 107, 59, 1, 9140, 4, 3, 97, 101, 121, 17722, 17728, 17734, 114, 111, 110, 59, 1, 357,
			100, 105, 108, 59, 1, 355, 59, 1, 1090, 111, 116, 59, 1, 8411, 108, 114, 101, 99, 59, 1, 8981,
			114, 59, 3, 55349, 56625, 4, 4, 101, 105, 107, 111, 17764, 17805, 17836, 17851, 4, 2, 114,
			116, 17770, 17786, 101, 4, 2, 52, 102, 17777, 17780, 59, 1, 8756, 111, 114, 101, 59, 1, 8756,
			97, 4, 3, 59, 115, 118, 17795, 17797, 17802, 1, 952, 121, 109, 59, 1, 977, 59, 1, 977, 4, 2,
			99, 110, 17811, 17831, 107, 4, 2, 97, 115, 17818, 17826, 112, 112, 114, 111, 120, 59, 1, 8776,
			105, 109, 59, 1, 8764, 115, 112, 59, 1, 8201, 4, 2, 97, 115, 17842, 17846, 112, 59, 1, 8776,
			105, 109, 59, 1, 8764, 114, 110, 5, 254, 1, 59, 17858, 1, 254, 4, 3, 108, 109, 110, 17868,
			17873, 17901, 100, 101, 59, 1, 732, 101, 115, 5, 215, 3, 59, 98, 100, 17884, 17886, 17898, 1,
			215, 4, 2, 59, 97, 17892, 17894, 1, 8864, 114, 59, 1, 10801, 59, 1, 10800, 116, 59, 1, 8749,
			4, 3, 101, 112, 115, 17913, 17917, 17953, 97, 59, 1, 10536, 4, 4, 59, 98, 99, 102, 17927,
			17929, 17934, 17939, 1, 8868, 111, 116, 59, 1, 9014, 105, 114, 59, 1, 10993, 4, 2, 59, 111,
			17945, 17948, 3, 55349, 56677, 114, 107, 59, 1, 10970, 97, 59, 1, 10537, 114, 105, 109, 101,
			59, 1, 8244, 4, 3, 97, 105, 112, 17972, 17977, 18082, 100, 101, 59, 1, 8482, 4, 7, 97, 100,
			101, 109, 112, 115, 116, 17993, 18051, 18056, 18059, 18066, 18072, 18076, 110, 103, 108, 101,
			4, 5, 59, 100, 108, 113, 114, 18009, 18011, 18017, 18032, 18035, 1, 9653, 111, 119, 110, 59,
			1, 9663, 101, 102, 116, 4, 2, 59, 101, 18026, 18028, 1, 9667, 113, 59, 1, 8884, 59, 1, 8796,
			105, 103, 104, 116, 4, 2, 59, 101, 18045, 18047, 1, 9657, 113, 59, 1, 8885, 111, 116, 59, 1,
			9708, 59, 1, 8796, 105, 110, 117, 115, 59, 1, 10810, 108, 117, 115, 59, 1, 10809, 98, 59, 1,
			10701, 105, 109, 101, 59, 1, 10811, 101, 122, 105, 117, 109, 59, 1, 9186, 4, 3, 99, 104, 116,
			18098, 18111, 18116, 4, 2, 114, 121, 18104, 18108, 59, 3, 55349, 56521, 59, 1, 1094, 99, 121,
			59, 1, 1115, 114, 111, 107, 59, 1, 359, 4, 2, 105, 111, 18128, 18133, 120, 116, 59, 1, 8812,
			104, 101, 97, 100, 4, 2, 108, 114, 18143, 18154, 101, 102, 116, 97, 114, 114, 111, 119, 59, 1,
			8606, 105, 103, 104, 116, 97, 114, 114, 111, 119, 59, 1, 8608, 4, 18, 65, 72, 97, 98, 99, 100,
			102, 103, 104, 108, 109, 111, 112, 114, 115, 116, 117, 119, 18204, 18209, 18214, 18234, 18250,
			18268, 18292, 18308, 18319, 18343, 18379, 18397, 18413, 18504, 18547, 18553, 18584, 18603,
			114, 114, 59, 1, 8657, 97, 114, 59, 1, 10595, 4, 2, 99, 114, 18220, 18230, 117, 116, 101, 5,
			250, 1, 59, 18228, 1, 250, 114, 59, 1, 8593, 114, 4, 2, 99, 101, 18241, 18245, 121, 59, 1,
			1118, 118, 101, 59, 1, 365, 4, 2, 105, 121, 18256, 18265, 114, 99, 5, 251, 1, 59, 18263, 1,
			251, 59, 1, 1091, 4, 3, 97, 98, 104, 18276, 18281, 18287, 114, 114, 59, 1, 8645, 108, 97, 99,
			59, 1, 369, 97, 114, 59, 1, 10606, 4, 2, 105, 114, 18298, 18304, 115, 104, 116, 59, 1, 10622,
			59, 3, 55349, 56626, 114, 97, 118, 101, 5, 249, 1, 59, 18317, 1, 249, 4, 2, 97, 98, 18325,
			18338, 114, 4, 2, 108, 114, 18332, 18335, 59, 1, 8639, 59, 1, 8638, 108, 107, 59, 1, 9600, 4,
			2, 99, 116, 18349, 18374, 4, 2, 111, 114, 18355, 18369, 114, 110, 4, 2, 59, 101, 18363, 18365,
			1, 8988, 114, 59, 1, 8988, 111, 112, 59, 1, 8975, 114, 105, 59, 1, 9720, 4, 2, 97, 108, 18385,
			18390, 99, 114, 59, 1, 363, 5, 168, 1, 59, 18395, 1, 168, 4, 2, 103, 112, 18403, 18408, 111,
			110, 59, 1, 371, 102, 59, 3, 55349, 56678, 4, 6, 97, 100, 104, 108, 115, 117, 18427, 18434,
			18445, 18470, 18475, 18494, 114, 114, 111, 119, 59, 1, 8593, 111, 119, 110, 97, 114, 114, 111,
			119, 59, 1, 8597, 97, 114, 112, 111, 111, 110, 4, 2, 108, 114, 18457, 18463, 101, 102, 116,
			59, 1, 8639, 105, 103, 104, 116, 59, 1, 8638, 117, 115, 59, 1, 8846, 105, 4, 3, 59, 104, 108,
			18484, 18486, 18489, 1, 965, 59, 1, 978, 111, 110, 59, 1, 965, 112, 97, 114, 114, 111, 119,
			115, 59, 1, 8648, 4, 3, 99, 105, 116, 18512, 18537, 18542, 4, 2, 111, 114, 18518, 18532, 114,
			110, 4, 2, 59, 101, 18526, 18528, 1, 8989, 114, 59, 1, 8989, 111, 112, 59, 1, 8974, 110, 103,
			59, 1, 367, 114, 105, 59, 1, 9721, 99, 114, 59, 3, 55349, 56522, 4, 3, 100, 105, 114, 18561,
			18566, 18572, 111, 116, 59, 1, 8944, 108, 100, 101, 59, 1, 361, 105, 4, 2, 59, 102, 18579,
			18581, 1, 9653, 59, 1, 9652, 4, 2, 97, 109, 18590, 18595, 114, 114, 59, 1, 8648, 108, 5, 252,
			1, 59, 18601, 1, 252, 97, 110, 103, 108, 101, 59, 1, 10663, 4, 15, 65, 66, 68, 97, 99, 100,
			101, 102, 108, 110, 111, 112, 114, 115, 122, 18643, 18648, 18661, 18667, 18847, 18851, 18857,
			18904, 18909, 18915, 18931, 18937, 18943, 18949, 18996, 114, 114, 59, 1, 8661, 97, 114, 4, 2,
			59, 118, 18656, 18658, 1, 10984, 59, 1, 10985, 97, 115, 104, 59, 1, 8872, 4, 2, 110, 114,
			18673, 18679, 103, 114, 116, 59, 1, 10652, 4, 7, 101, 107, 110, 112, 114, 115, 116, 18695,
			18704, 18711, 18720, 18742, 18754, 18810, 112, 115, 105, 108, 111, 110, 59, 1, 1013, 97, 112,
			112, 97, 59, 1, 1008, 111, 116, 104, 105, 110, 103, 59, 1, 8709, 4, 3, 104, 105, 114, 18728,
			18732, 18735, 105, 59, 1, 981, 59, 1, 982, 111, 112, 116, 111, 59, 1, 8733, 4, 2, 59, 104,
			18748, 18750, 1, 8597, 111, 59, 1, 1009, 4, 2, 105, 117, 18760, 18766, 103, 109, 97, 59, 1,
			962, 4, 2, 98, 112, 18772, 18791, 115, 101, 116, 110, 101, 113, 4, 2, 59, 113, 18784, 18787,
			3, 8842, 65024, 59, 3, 10955, 65024, 115, 101, 116, 110, 101, 113, 4, 2, 59, 113, 18803,
			18806, 3, 8843, 65024, 59, 3, 10956, 65024, 4, 2, 104, 114, 18816, 18822, 101, 116, 97, 59, 1,
			977, 105, 97, 110, 103, 108, 101, 4, 2, 108, 114, 18834, 18840, 101, 102, 116, 59, 1, 8882,
			105, 103, 104, 116, 59, 1, 8883, 121, 59, 1, 1074, 97, 115, 104, 59, 1, 8866, 4, 3, 101, 108,
			114, 18865, 18884, 18890, 4, 3, 59, 98, 101, 18873, 18875, 18880, 1, 8744, 97, 114, 59, 1,
			8891, 113, 59, 1, 8794, 108, 105, 112, 59, 1, 8942, 4, 2, 98, 116, 18896, 18901, 97, 114, 59,
			1, 124, 59, 1, 124, 114, 59, 3, 55349, 56627, 116, 114, 105, 59, 1, 8882, 115, 117, 4, 2, 98,
			112, 18923, 18927, 59, 3, 8834, 8402, 59, 3, 8835, 8402, 112, 102, 59, 3, 55349, 56679, 114,
			111, 112, 59, 1, 8733, 116, 114, 105, 59, 1, 8883, 4, 2, 99, 117, 18955, 18960, 114, 59, 3,
			55349, 56523, 4, 2, 98, 112, 18966, 18981, 110, 4, 2, 69, 101, 18973, 18977, 59, 3, 10955,
			65024, 59, 3, 8842, 65024, 110, 4, 2, 69, 101, 18988, 18992, 59, 3, 10956, 65024, 59, 3, 8843,
			65024, 105, 103, 122, 97, 103, 59, 1, 10650, 4, 7, 99, 101, 102, 111, 112, 114, 115, 19020,
			19026, 19061, 19066, 19072, 19075, 19089, 105, 114, 99, 59, 1, 373, 4, 2, 100, 105, 19032,
			19055, 4, 2, 98, 103, 19038, 19043, 97, 114, 59, 1, 10847, 101, 4, 2, 59, 113, 19050, 19052,
			1, 8743, 59, 1, 8793, 101, 114, 112, 59, 1, 8472, 114, 59, 3, 55349, 56628, 112, 102, 59, 3,
			55349, 56680, 59, 1, 8472, 4, 2, 59, 101, 19081, 19083, 1, 8768, 97, 116, 104, 59, 1, 8768,
			99, 114, 59, 3, 55349, 56524, 4, 14, 99, 100, 102, 104, 105, 108, 109, 110, 111, 114, 115,
			117, 118, 119, 19125, 19146, 19152, 19157, 19173, 19176, 19192, 19197, 19202, 19236, 19252,
			19269, 19286, 19291, 4, 3, 97, 105, 117, 19133, 19137, 19142, 112, 59, 1, 8898, 114, 99, 59,
			1, 9711, 112, 59, 1, 8899, 116, 114, 105, 59, 1, 9661, 114, 59, 3, 55349, 56629, 4, 2, 65, 97,
			19163, 19168, 114, 114, 59, 1, 10234, 114, 114, 59, 1, 10231, 59, 1, 958, 4, 2, 65, 97, 19182,
			19187, 114, 114, 59, 1, 10232, 114, 114, 59, 1, 10229, 97, 112, 59, 1, 10236, 105, 115, 59, 1,
			8955, 4, 3, 100, 112, 116, 19210, 19215, 19230, 111, 116, 59, 1, 10752, 4, 2, 102, 108, 19221,
			19225, 59, 3, 55349, 56681, 117, 115, 59, 1, 10753, 105, 109, 101, 59, 1, 10754, 4, 2, 65, 97,
			19242, 19247, 114, 114, 59, 1, 10233, 114, 114, 59, 1, 10230, 4, 2, 99, 113, 19258, 19263,
			114, 59, 3, 55349, 56525, 99, 117, 112, 59, 1, 10758, 4, 2, 112, 116, 19275, 19281, 108, 117,
			115, 59, 1, 10756, 114, 105, 59, 1, 9651, 101, 101, 59, 1, 8897, 101, 100, 103, 101, 59, 1,
			8896, 4, 8, 97, 99, 101, 102, 105, 111, 115, 117, 19316, 19335, 19349, 19357, 19362, 19367,
			19373, 19379, 99, 4, 2, 117, 121, 19323, 19332, 116, 101, 5, 253, 1, 59, 19330, 1, 253, 59, 1,
			1103, 4, 2, 105, 121, 19341, 19346, 114, 99, 59, 1, 375, 59, 1, 1099, 110, 5, 165, 1, 59,
			19355, 1, 165, 114, 59, 3, 55349, 56630, 99, 121, 59, 1, 1111, 112, 102, 59, 3, 55349, 56682,
			99, 114, 59, 3, 55349, 56526, 4, 2, 99, 109, 19385, 19389, 121, 59, 1, 1102, 108, 5, 255, 1,
			59, 19395, 1, 255, 4, 10, 97, 99, 100, 101, 102, 104, 105, 111, 115, 119, 19419, 19426, 19441,
			19446, 19462, 19467, 19472, 19480, 19486, 19492, 99, 117, 116, 101, 59, 1, 378, 4, 2, 97, 121,
			19432, 19438, 114, 111, 110, 59, 1, 382, 59, 1, 1079, 111, 116, 59, 1, 380, 4, 2, 101, 116,
			19452, 19458, 116, 114, 102, 59, 1, 8488, 97, 59, 1, 950, 114, 59, 3, 55349, 56631, 99, 121,
			59, 1, 1078, 103, 114, 97, 114, 114, 59, 1, 8669, 112, 102, 59, 3, 55349, 56683, 99, 114, 59,
			3, 55349, 56527, 4, 2, 106, 110, 19498, 19501, 59, 1, 8205, 106, 59, 1, 8204
		]);
	}
});

// node_modules/parse5/lib/tokenizer/index.js
var require_tokenizer = __commonJS({
	'node_modules/parse5/lib/tokenizer/index.js'(exports, module2) {
		'use strict';
		var Preprocessor = require_preprocessor();
		var unicode = require_unicode();
		var neTree = require_named_entity_data();
		var ERR = require_error_codes();
		var $ = unicode.CODE_POINTS;
		var $$ = unicode.CODE_POINT_SEQUENCES;
		var C1_CONTROLS_REFERENCE_REPLACEMENTS = {
			128: 8364,
			130: 8218,
			131: 402,
			132: 8222,
			133: 8230,
			134: 8224,
			135: 8225,
			136: 710,
			137: 8240,
			138: 352,
			139: 8249,
			140: 338,
			142: 381,
			145: 8216,
			146: 8217,
			147: 8220,
			148: 8221,
			149: 8226,
			150: 8211,
			151: 8212,
			152: 732,
			153: 8482,
			154: 353,
			155: 8250,
			156: 339,
			158: 382,
			159: 376
		};
		var HAS_DATA_FLAG = 1 << 0;
		var DATA_DUPLET_FLAG = 1 << 1;
		var HAS_BRANCHES_FLAG = 1 << 2;
		var MAX_BRANCH_MARKER_VALUE = HAS_DATA_FLAG | DATA_DUPLET_FLAG | HAS_BRANCHES_FLAG;
		var DATA_STATE = 'DATA_STATE';
		var RCDATA_STATE = 'RCDATA_STATE';
		var RAWTEXT_STATE = 'RAWTEXT_STATE';
		var SCRIPT_DATA_STATE = 'SCRIPT_DATA_STATE';
		var PLAINTEXT_STATE = 'PLAINTEXT_STATE';
		var TAG_OPEN_STATE = 'TAG_OPEN_STATE';
		var END_TAG_OPEN_STATE = 'END_TAG_OPEN_STATE';
		var TAG_NAME_STATE = 'TAG_NAME_STATE';
		var RCDATA_LESS_THAN_SIGN_STATE = 'RCDATA_LESS_THAN_SIGN_STATE';
		var RCDATA_END_TAG_OPEN_STATE = 'RCDATA_END_TAG_OPEN_STATE';
		var RCDATA_END_TAG_NAME_STATE = 'RCDATA_END_TAG_NAME_STATE';
		var RAWTEXT_LESS_THAN_SIGN_STATE = 'RAWTEXT_LESS_THAN_SIGN_STATE';
		var RAWTEXT_END_TAG_OPEN_STATE = 'RAWTEXT_END_TAG_OPEN_STATE';
		var RAWTEXT_END_TAG_NAME_STATE = 'RAWTEXT_END_TAG_NAME_STATE';
		var SCRIPT_DATA_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_LESS_THAN_SIGN_STATE';
		var SCRIPT_DATA_END_TAG_OPEN_STATE = 'SCRIPT_DATA_END_TAG_OPEN_STATE';
		var SCRIPT_DATA_END_TAG_NAME_STATE = 'SCRIPT_DATA_END_TAG_NAME_STATE';
		var SCRIPT_DATA_ESCAPE_START_STATE = 'SCRIPT_DATA_ESCAPE_START_STATE';
		var SCRIPT_DATA_ESCAPE_START_DASH_STATE = 'SCRIPT_DATA_ESCAPE_START_DASH_STATE';
		var SCRIPT_DATA_ESCAPED_STATE = 'SCRIPT_DATA_ESCAPED_STATE';
		var SCRIPT_DATA_ESCAPED_DASH_STATE = 'SCRIPT_DATA_ESCAPED_DASH_STATE';
		var SCRIPT_DATA_ESCAPED_DASH_DASH_STATE = 'SCRIPT_DATA_ESCAPED_DASH_DASH_STATE';
		var SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE = 'SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE';
		var SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE = 'SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE';
		var SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE = 'SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE';
		var SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE';
		var SCRIPT_DATA_DOUBLE_ESCAPED_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_STATE';
		var SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE';
		var SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE';
		var SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE =
			'SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE';
		var SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE = 'SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE';
		var BEFORE_ATTRIBUTE_NAME_STATE = 'BEFORE_ATTRIBUTE_NAME_STATE';
		var ATTRIBUTE_NAME_STATE = 'ATTRIBUTE_NAME_STATE';
		var AFTER_ATTRIBUTE_NAME_STATE = 'AFTER_ATTRIBUTE_NAME_STATE';
		var BEFORE_ATTRIBUTE_VALUE_STATE = 'BEFORE_ATTRIBUTE_VALUE_STATE';
		var ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE = 'ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE';
		var ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE = 'ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE';
		var ATTRIBUTE_VALUE_UNQUOTED_STATE = 'ATTRIBUTE_VALUE_UNQUOTED_STATE';
		var AFTER_ATTRIBUTE_VALUE_QUOTED_STATE = 'AFTER_ATTRIBUTE_VALUE_QUOTED_STATE';
		var SELF_CLOSING_START_TAG_STATE = 'SELF_CLOSING_START_TAG_STATE';
		var BOGUS_COMMENT_STATE = 'BOGUS_COMMENT_STATE';
		var MARKUP_DECLARATION_OPEN_STATE = 'MARKUP_DECLARATION_OPEN_STATE';
		var COMMENT_START_STATE = 'COMMENT_START_STATE';
		var COMMENT_START_DASH_STATE = 'COMMENT_START_DASH_STATE';
		var COMMENT_STATE = 'COMMENT_STATE';
		var COMMENT_LESS_THAN_SIGN_STATE = 'COMMENT_LESS_THAN_SIGN_STATE';
		var COMMENT_LESS_THAN_SIGN_BANG_STATE = 'COMMENT_LESS_THAN_SIGN_BANG_STATE';
		var COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE = 'COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE';
		var COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE = 'COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE';
		var COMMENT_END_DASH_STATE = 'COMMENT_END_DASH_STATE';
		var COMMENT_END_STATE = 'COMMENT_END_STATE';
		var COMMENT_END_BANG_STATE = 'COMMENT_END_BANG_STATE';
		var DOCTYPE_STATE = 'DOCTYPE_STATE';
		var BEFORE_DOCTYPE_NAME_STATE = 'BEFORE_DOCTYPE_NAME_STATE';
		var DOCTYPE_NAME_STATE = 'DOCTYPE_NAME_STATE';
		var AFTER_DOCTYPE_NAME_STATE = 'AFTER_DOCTYPE_NAME_STATE';
		var AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE = 'AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE';
		var BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE = 'BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE';
		var DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE =
			'DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE';
		var DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE =
			'DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE';
		var AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE = 'AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE';
		var BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE =
			'BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE';
		var AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE = 'AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE';
		var BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE = 'BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE';
		var DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE =
			'DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE';
		var DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE =
			'DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE';
		var AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE = 'AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE';
		var BOGUS_DOCTYPE_STATE = 'BOGUS_DOCTYPE_STATE';
		var CDATA_SECTION_STATE = 'CDATA_SECTION_STATE';
		var CDATA_SECTION_BRACKET_STATE = 'CDATA_SECTION_BRACKET_STATE';
		var CDATA_SECTION_END_STATE = 'CDATA_SECTION_END_STATE';
		var CHARACTER_REFERENCE_STATE = 'CHARACTER_REFERENCE_STATE';
		var NAMED_CHARACTER_REFERENCE_STATE = 'NAMED_CHARACTER_REFERENCE_STATE';
		var AMBIGUOUS_AMPERSAND_STATE = 'AMBIGUOS_AMPERSAND_STATE';
		var NUMERIC_CHARACTER_REFERENCE_STATE = 'NUMERIC_CHARACTER_REFERENCE_STATE';
		var HEXADEMICAL_CHARACTER_REFERENCE_START_STATE = 'HEXADEMICAL_CHARACTER_REFERENCE_START_STATE';
		var DECIMAL_CHARACTER_REFERENCE_START_STATE = 'DECIMAL_CHARACTER_REFERENCE_START_STATE';
		var HEXADEMICAL_CHARACTER_REFERENCE_STATE = 'HEXADEMICAL_CHARACTER_REFERENCE_STATE';
		var DECIMAL_CHARACTER_REFERENCE_STATE = 'DECIMAL_CHARACTER_REFERENCE_STATE';
		var NUMERIC_CHARACTER_REFERENCE_END_STATE = 'NUMERIC_CHARACTER_REFERENCE_END_STATE';
		function isWhitespace(cp) {
			return cp === $.SPACE || cp === $.LINE_FEED || cp === $.TABULATION || cp === $.FORM_FEED;
		}
		function isAsciiDigit(cp) {
			return cp >= $.DIGIT_0 && cp <= $.DIGIT_9;
		}
		function isAsciiUpper(cp) {
			return cp >= $.LATIN_CAPITAL_A && cp <= $.LATIN_CAPITAL_Z;
		}
		function isAsciiLower(cp) {
			return cp >= $.LATIN_SMALL_A && cp <= $.LATIN_SMALL_Z;
		}
		function isAsciiLetter(cp) {
			return isAsciiLower(cp) || isAsciiUpper(cp);
		}
		function isAsciiAlphaNumeric(cp) {
			return isAsciiLetter(cp) || isAsciiDigit(cp);
		}
		function isAsciiUpperHexDigit(cp) {
			return cp >= $.LATIN_CAPITAL_A && cp <= $.LATIN_CAPITAL_F;
		}
		function isAsciiLowerHexDigit(cp) {
			return cp >= $.LATIN_SMALL_A && cp <= $.LATIN_SMALL_F;
		}
		function isAsciiHexDigit(cp) {
			return isAsciiDigit(cp) || isAsciiUpperHexDigit(cp) || isAsciiLowerHexDigit(cp);
		}
		function toAsciiLowerCodePoint(cp) {
			return cp + 32;
		}
		function toChar(cp) {
			if (cp <= 65535) {
				return String.fromCharCode(cp);
			}
			cp -= 65536;
			return (
				String.fromCharCode(((cp >>> 10) & 1023) | 55296) + String.fromCharCode(56320 | (cp & 1023))
			);
		}
		function toAsciiLowerChar(cp) {
			return String.fromCharCode(toAsciiLowerCodePoint(cp));
		}
		function findNamedEntityTreeBranch(nodeIx, cp) {
			const branchCount = neTree[++nodeIx];
			let lo = ++nodeIx;
			let hi = lo + branchCount - 1;
			while (lo <= hi) {
				const mid = (lo + hi) >>> 1;
				const midCp = neTree[mid];
				if (midCp < cp) {
					lo = mid + 1;
				} else if (midCp > cp) {
					hi = mid - 1;
				} else {
					return neTree[mid + branchCount];
				}
			}
			return -1;
		}
		var Tokenizer = class {
			constructor() {
				this.preprocessor = new Preprocessor();
				this.tokenQueue = [];
				this.allowCDATA = false;
				this.state = DATA_STATE;
				this.returnState = '';
				this.charRefCode = -1;
				this.tempBuff = [];
				this.lastStartTagName = '';
				this.consumedAfterSnapshot = -1;
				this.active = false;
				this.currentCharacterToken = null;
				this.currentToken = null;
				this.currentAttr = null;
			}
			_err() {}
			_errOnNextCodePoint(err) {
				this._consume();
				this._err(err);
				this._unconsume();
			}
			getNextToken() {
				while (!this.tokenQueue.length && this.active) {
					this.consumedAfterSnapshot = 0;
					const cp = this._consume();
					if (!this._ensureHibernation()) {
						this[this.state](cp);
					}
				}
				return this.tokenQueue.shift();
			}
			write(chunk, isLastChunk) {
				this.active = true;
				this.preprocessor.write(chunk, isLastChunk);
			}
			insertHtmlAtCurrentPos(chunk) {
				this.active = true;
				this.preprocessor.insertHtmlAtCurrentPos(chunk);
			}
			_ensureHibernation() {
				if (this.preprocessor.endOfChunkHit) {
					for (; this.consumedAfterSnapshot > 0; this.consumedAfterSnapshot--) {
						this.preprocessor.retreat();
					}
					this.active = false;
					this.tokenQueue.push({ type: Tokenizer.HIBERNATION_TOKEN });
					return true;
				}
				return false;
			}
			_consume() {
				this.consumedAfterSnapshot++;
				return this.preprocessor.advance();
			}
			_unconsume() {
				this.consumedAfterSnapshot--;
				this.preprocessor.retreat();
			}
			_reconsumeInState(state) {
				this.state = state;
				this._unconsume();
			}
			_consumeSequenceIfMatch(pattern, startCp, caseSensitive) {
				let consumedCount = 0;
				let isMatch = true;
				const patternLength = pattern.length;
				let patternPos = 0;
				let cp = startCp;
				let patternCp = void 0;
				for (; patternPos < patternLength; patternPos++) {
					if (patternPos > 0) {
						cp = this._consume();
						consumedCount++;
					}
					if (cp === $.EOF) {
						isMatch = false;
						break;
					}
					patternCp = pattern[patternPos];
					if (cp !== patternCp && (caseSensitive || cp !== toAsciiLowerCodePoint(patternCp))) {
						isMatch = false;
						break;
					}
				}
				if (!isMatch) {
					while (consumedCount--) {
						this._unconsume();
					}
				}
				return isMatch;
			}
			_isTempBufferEqualToScriptString() {
				if (this.tempBuff.length !== $$.SCRIPT_STRING.length) {
					return false;
				}
				for (let i2 = 0; i2 < this.tempBuff.length; i2++) {
					if (this.tempBuff[i2] !== $$.SCRIPT_STRING[i2]) {
						return false;
					}
				}
				return true;
			}
			_createStartTagToken() {
				this.currentToken = {
					type: Tokenizer.START_TAG_TOKEN,
					tagName: '',
					selfClosing: false,
					ackSelfClosing: false,
					attrs: []
				};
			}
			_createEndTagToken() {
				this.currentToken = {
					type: Tokenizer.END_TAG_TOKEN,
					tagName: '',
					selfClosing: false,
					attrs: []
				};
			}
			_createCommentToken() {
				this.currentToken = {
					type: Tokenizer.COMMENT_TOKEN,
					data: ''
				};
			}
			_createDoctypeToken(initialName) {
				this.currentToken = {
					type: Tokenizer.DOCTYPE_TOKEN,
					name: initialName,
					forceQuirks: false,
					publicId: null,
					systemId: null
				};
			}
			_createCharacterToken(type, ch) {
				this.currentCharacterToken = {
					type,
					chars: ch
				};
			}
			_createEOFToken() {
				this.currentToken = { type: Tokenizer.EOF_TOKEN };
			}
			_createAttr(attrNameFirstCh) {
				this.currentAttr = {
					name: attrNameFirstCh,
					value: ''
				};
			}
			_leaveAttrName(toState) {
				if (Tokenizer.getTokenAttr(this.currentToken, this.currentAttr.name) === null) {
					this.currentToken.attrs.push(this.currentAttr);
				} else {
					this._err(ERR.duplicateAttribute);
				}
				this.state = toState;
			}
			_leaveAttrValue(toState) {
				this.state = toState;
			}
			_emitCurrentToken() {
				this._emitCurrentCharacterToken();
				const ct = this.currentToken;
				this.currentToken = null;
				if (ct.type === Tokenizer.START_TAG_TOKEN) {
					this.lastStartTagName = ct.tagName;
				} else if (ct.type === Tokenizer.END_TAG_TOKEN) {
					if (ct.attrs.length > 0) {
						this._err(ERR.endTagWithAttributes);
					}
					if (ct.selfClosing) {
						this._err(ERR.endTagWithTrailingSolidus);
					}
				}
				this.tokenQueue.push(ct);
			}
			_emitCurrentCharacterToken() {
				if (this.currentCharacterToken) {
					this.tokenQueue.push(this.currentCharacterToken);
					this.currentCharacterToken = null;
				}
			}
			_emitEOFToken() {
				this._createEOFToken();
				this._emitCurrentToken();
			}
			_appendCharToCurrentCharacterToken(type, ch) {
				if (this.currentCharacterToken && this.currentCharacterToken.type !== type) {
					this._emitCurrentCharacterToken();
				}
				if (this.currentCharacterToken) {
					this.currentCharacterToken.chars += ch;
				} else {
					this._createCharacterToken(type, ch);
				}
			}
			_emitCodePoint(cp) {
				let type = Tokenizer.CHARACTER_TOKEN;
				if (isWhitespace(cp)) {
					type = Tokenizer.WHITESPACE_CHARACTER_TOKEN;
				} else if (cp === $.NULL) {
					type = Tokenizer.NULL_CHARACTER_TOKEN;
				}
				this._appendCharToCurrentCharacterToken(type, toChar(cp));
			}
			_emitSeveralCodePoints(codePoints) {
				for (let i2 = 0; i2 < codePoints.length; i2++) {
					this._emitCodePoint(codePoints[i2]);
				}
			}
			_emitChars(ch) {
				this._appendCharToCurrentCharacterToken(Tokenizer.CHARACTER_TOKEN, ch);
			}
			_matchNamedCharacterReference(startCp) {
				let result = null;
				let excess = 1;
				let i2 = findNamedEntityTreeBranch(0, startCp);
				this.tempBuff.push(startCp);
				while (i2 > -1) {
					const current = neTree[i2];
					const inNode = current < MAX_BRANCH_MARKER_VALUE;
					const nodeWithData = inNode && current & HAS_DATA_FLAG;
					if (nodeWithData) {
						result = current & DATA_DUPLET_FLAG ? [neTree[++i2], neTree[++i2]] : [neTree[++i2]];
						excess = 0;
					}
					const cp = this._consume();
					this.tempBuff.push(cp);
					excess++;
					if (cp === $.EOF) {
						break;
					}
					if (inNode) {
						i2 = current & HAS_BRANCHES_FLAG ? findNamedEntityTreeBranch(i2, cp) : -1;
					} else {
						i2 = cp === current ? ++i2 : -1;
					}
				}
				while (excess--) {
					this.tempBuff.pop();
					this._unconsume();
				}
				return result;
			}
			_isCharacterReferenceInAttribute() {
				return (
					this.returnState === ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE ||
					this.returnState === ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE ||
					this.returnState === ATTRIBUTE_VALUE_UNQUOTED_STATE
				);
			}
			_isCharacterReferenceAttributeQuirk(withSemicolon) {
				if (!withSemicolon && this._isCharacterReferenceInAttribute()) {
					const nextCp = this._consume();
					this._unconsume();
					return nextCp === $.EQUALS_SIGN || isAsciiAlphaNumeric(nextCp);
				}
				return false;
			}
			_flushCodePointsConsumedAsCharacterReference() {
				if (this._isCharacterReferenceInAttribute()) {
					for (let i2 = 0; i2 < this.tempBuff.length; i2++) {
						this.currentAttr.value += toChar(this.tempBuff[i2]);
					}
				} else {
					this._emitSeveralCodePoints(this.tempBuff);
				}
				this.tempBuff = [];
			}
			[DATA_STATE](cp) {
				this.preprocessor.dropParsedChunk();
				if (cp === $.LESS_THAN_SIGN) {
					this.state = TAG_OPEN_STATE;
				} else if (cp === $.AMPERSAND) {
					this.returnState = DATA_STATE;
					this.state = CHARACTER_REFERENCE_STATE;
				} else if (cp === $.NULL) {
					this._err(ERR.unexpectedNullCharacter);
					this._emitCodePoint(cp);
				} else if (cp === $.EOF) {
					this._emitEOFToken();
				} else {
					this._emitCodePoint(cp);
				}
			}
			[RCDATA_STATE](cp) {
				this.preprocessor.dropParsedChunk();
				if (cp === $.AMPERSAND) {
					this.returnState = RCDATA_STATE;
					this.state = CHARACTER_REFERENCE_STATE;
				} else if (cp === $.LESS_THAN_SIGN) {
					this.state = RCDATA_LESS_THAN_SIGN_STATE;
				} else if (cp === $.NULL) {
					this._err(ERR.unexpectedNullCharacter);
					this._emitChars(unicode.REPLACEMENT_CHARACTER);
				} else if (cp === $.EOF) {
					this._emitEOFToken();
				} else {
					this._emitCodePoint(cp);
				}
			}
			[RAWTEXT_STATE](cp) {
				this.preprocessor.dropParsedChunk();
				if (cp === $.LESS_THAN_SIGN) {
					this.state = RAWTEXT_LESS_THAN_SIGN_STATE;
				} else if (cp === $.NULL) {
					this._err(ERR.unexpectedNullCharacter);
					this._emitChars(unicode.REPLACEMENT_CHARACTER);
				} else if (cp === $.EOF) {
					this._emitEOFToken();
				} else {
					this._emitCodePoint(cp);
				}
			}
			[SCRIPT_DATA_STATE](cp) {
				this.preprocessor.dropParsedChunk();
				if (cp === $.LESS_THAN_SIGN) {
					this.state = SCRIPT_DATA_LESS_THAN_SIGN_STATE;
				} else if (cp === $.NULL) {
					this._err(ERR.unexpectedNullCharacter);
					this._emitChars(unicode.REPLACEMENT_CHARACTER);
				} else if (cp === $.EOF) {
					this._emitEOFToken();
				} else {
					this._emitCodePoint(cp);
				}
			}
			[PLAINTEXT_STATE](cp) {
				this.preprocessor.dropParsedChunk();
				if (cp === $.NULL) {
					this._err(ERR.unexpectedNullCharacter);
					this._emitChars(unicode.REPLACEMENT_CHARACTER);
				} else if (cp === $.EOF) {
					this._emitEOFToken();
				} else {
					this._emitCodePoint(cp);
				}
			}
			[TAG_OPEN_STATE](cp) {
				if (cp === $.EXCLAMATION_MARK) {
					this.state = MARKUP_DECLARATION_OPEN_STATE;
				} else if (cp === $.SOLIDUS) {
					this.state = END_TAG_OPEN_STATE;
				} else if (isAsciiLetter(cp)) {
					this._createStartTagToken();
					this._reconsumeInState(TAG_NAME_STATE);
				} else if (cp === $.QUESTION_MARK) {
					this._err(ERR.unexpectedQuestionMarkInsteadOfTagName);
					this._createCommentToken();
					this._reconsumeInState(BOGUS_COMMENT_STATE);
				} else if (cp === $.EOF) {
					this._err(ERR.eofBeforeTagName);
					this._emitChars('<');
					this._emitEOFToken();
				} else {
					this._err(ERR.invalidFirstCharacterOfTagName);
					this._emitChars('<');
					this._reconsumeInState(DATA_STATE);
				}
			}
			[END_TAG_OPEN_STATE](cp) {
				if (isAsciiLetter(cp)) {
					this._createEndTagToken();
					this._reconsumeInState(TAG_NAME_STATE);
				} else if (cp === $.GREATER_THAN_SIGN) {
					this._err(ERR.missingEndTagName);
					this.state = DATA_STATE;
				} else if (cp === $.EOF) {
					this._err(ERR.eofBeforeTagName);
					this._emitChars('</');
					this._emitEOFToken();
				} else {
					this._err(ERR.invalidFirstCharacterOfTagName);
					this._createCommentToken();
					this._reconsumeInState(BOGUS_COMMENT_STATE);
				}
			}
			[TAG_NAME_STATE](cp) {
				if (isWhitespace(cp)) {
					this.state = BEFORE_ATTRIBUTE_NAME_STATE;
				} else if (cp === $.SOLIDUS) {
					this.state = SELF_CLOSING_START_TAG_STATE;
				} else if (cp === $.GREATER_THAN_SIGN) {
					this.state = DATA_STATE;
					this._emitCurrentToken();
				} else if (isAsciiUpper(cp)) {
					this.currentToken.tagName += toAsciiLowerChar(cp);
				} else if (cp === $.NULL) {
					this._err(ERR.unexpectedNullCharacter);
					this.currentToken.tagName += unicode.REPLACEMENT_CHARACTER;
				} else if (cp === $.EOF) {
					this._err(ERR.eofInTag);
					this._emitEOFToken();
				} else {
					this.currentToken.tagName += toChar(cp);
				}
			}
			[RCDATA_LESS_THAN_SIGN_STATE](cp) {
				if (cp === $.SOLIDUS) {
					this.tempBuff = [];
					this.state = RCDATA_END_TAG_OPEN_STATE;
				} else {
					this._emitChars('<');
					this._reconsumeInState(RCDATA_STATE);
				}
			}
			[RCDATA_END_TAG_OPEN_STATE](cp) {
				if (isAsciiLetter(cp)) {
					this._createEndTagToken();
					this._reconsumeInState(RCDATA_END_TAG_NAME_STATE);
				} else {
					this._emitChars('</');
					this._reconsumeInState(RCDATA_STATE);
				}
			}
			[RCDATA_END_TAG_NAME_STATE](cp) {
				if (isAsciiUpper(cp)) {
					this.currentToken.tagName += toAsciiLowerChar(cp);
					this.tempBuff.push(cp);
				} else if (isAsciiLower(cp)) {
					this.currentToken.tagName += toChar(cp);
					this.tempBuff.push(cp);
				} else {
					if (this.lastStartTagName === this.currentToken.tagName) {
						if (isWhitespace(cp)) {
							this.state = BEFORE_ATTRIBUTE_NAME_STATE;
							return;
						}
						if (cp === $.SOLIDUS) {
							this.state = SELF_CLOSING_START_TAG_STATE;
							return;
						}
						if (cp === $.GREATER_THAN_SIGN) {
							this.state = DATA_STATE;
							this._emitCurrentToken();
							return;
						}
					}
					this._emitChars('</');
					this._emitSeveralCodePoints(this.tempBuff);
					this._reconsumeInState(RCDATA_STATE);
				}
			}
			[RAWTEXT_LESS_THAN_SIGN_STATE](cp) {
				if (cp === $.SOLIDUS) {
					this.tempBuff = [];
					this.state = RAWTEXT_END_TAG_OPEN_STATE;
				} else {
					this._emitChars('<');
					this._reconsumeInState(RAWTEXT_STATE);
				}
			}
			[RAWTEXT_END_TAG_OPEN_STATE](cp) {
				if (isAsciiLetter(cp)) {
					this._createEndTagToken();
					this._reconsumeInState(RAWTEXT_END_TAG_NAME_STATE);
				} else {
					this._emitChars('</');
					this._reconsumeInState(RAWTEXT_STATE);
				}
			}
			[RAWTEXT_END_TAG_NAME_STATE](cp) {
				if (isAsciiUpper(cp)) {
					this.currentToken.tagName += toAsciiLowerChar(cp);
					this.tempBuff.push(cp);
				} else if (isAsciiLower(cp)) {
					this.currentToken.tagName += toChar(cp);
					this.tempBuff.push(cp);
				} else {
					if (this.lastStartTagName === this.currentToken.tagName) {
						if (isWhitespace(cp)) {
							this.state = BEFORE_ATTRIBUTE_NAME_STATE;
							return;
						}
						if (cp === $.SOLIDUS) {
							this.state = SELF_CLOSING_START_TAG_STATE;
							return;
						}
						if (cp === $.GREATER_THAN_SIGN) {
							this._emitCurrentToken();
							this.state = DATA_STATE;
							return;
						}
					}
					this._emitChars('</');
					this._emitSeveralCodePoints(this.tempBuff);
					this._reconsumeInState(RAWTEXT_STATE);
				}
			}
			[SCRIPT_DATA_LESS_THAN_SIGN_STATE](cp) {
				if (cp === $.SOLIDUS) {
					this.tempBuff = [];
					this.state = SCRIPT_DATA_END_TAG_OPEN_STATE;
				} else if (cp === $.EXCLAMATION_MARK) {
					this.state = SCRIPT_DATA_ESCAPE_START_STATE;
					this._emitChars('<!');
				} else {
					this._emitChars('<');
					this._reconsumeInState(SCRIPT_DATA_STATE);
				}
			}
			[SCRIPT_DATA_END_TAG_OPEN_STATE](cp) {
				if (isAsciiLetter(cp)) {
					this._createEndTagToken();
					this._reconsumeInState(SCRIPT_DATA_END_TAG_NAME_STATE);
				} else {
					this._emitChars('</');
					this._reconsumeInState(SCRIPT_DATA_STATE);
				}
			}
			[SCRIPT_DATA_END_TAG_NAME_STATE](cp) {
				if (isAsciiUpper(cp)) {
					this.currentToken.tagName += toAsciiLowerChar(cp);
					this.tempBuff.push(cp);
				} else if (isAsciiLower(cp)) {
					this.currentToken.tagName += toChar(cp);
					this.tempBuff.push(cp);
				} else {
					if (this.lastStartTagName === this.currentToken.tagName) {
						if (isWhitespace(cp)) {
							this.state = BEFORE_ATTRIBUTE_NAME_STATE;
							return;
						} else if (cp === $.SOLIDUS) {
							this.state = SELF_CLOSING_START_TAG_STATE;
							return;
						} else if (cp === $.GREATER_THAN_SIGN) {
							this._emitCurrentToken();
							this.state = DATA_STATE;
							return;
						}
					}
					this._emitChars('</');
					this._emitSeveralCodePoints(this.tempBuff);
					this._reconsumeInState(SCRIPT_DATA_STATE);
				}
			}
			[SCRIPT_DATA_ESCAPE_START_STATE](cp) {
				if (cp === $.HYPHEN_MINUS) {
					this.state = SCRIPT_DATA_ESCAPE_START_DASH_STATE;
					this._emitChars('-');
				} else {
					this._reconsumeInState(SCRIPT_DATA_STATE);
				}
			}
			[SCRIPT_DATA_ESCAPE_START_DASH_STATE](cp) {
				if (cp === $.HYPHEN_MINUS) {
					this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
					this._emitChars('-');
				} else {
					this._reconsumeInState(SCRIPT_DATA_STATE);
				}
			}
			[SCRIPT_DATA_ESCAPED_STATE](cp) {
				if (cp === $.HYPHEN_MINUS) {
					this.state = SCRIPT_DATA_ESCAPED_DASH_STATE;
					this._emitChars('-');
				} else if (cp === $.LESS_THAN_SIGN) {
					this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
				} else if (cp === $.NULL) {
					this._err(ERR.unexpectedNullCharacter);
					this._emitChars(unicode.REPLACEMENT_CHARACTER);
				} else if (cp === $.EOF) {
					this._err(ERR.eofInScriptHtmlCommentLikeText);
					this._emitEOFToken();
				} else {
					this._emitCodePoint(cp);
				}
			}
			[SCRIPT_DATA_ESCAPED_DASH_STATE](cp) {
				if (cp === $.HYPHEN_MINUS) {
					this.state = SCRIPT_DATA_ESCAPED_DASH_DASH_STATE;
					this._emitChars('-');
				} else if (cp === $.LESS_THAN_SIGN) {
					this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
				} else if (cp === $.NULL) {
					this._err(ERR.unexpectedNullCharacter);
					this.state = SCRIPT_DATA_ESCAPED_STATE;
					this._emitChars(unicode.REPLACEMENT_CHARACTER);
				} else if (cp === $.EOF) {
					this._err(ERR.eofInScriptHtmlCommentLikeText);
					this._emitEOFToken();
				} else {
					this.state = SCRIPT_DATA_ESCAPED_STATE;
					this._emitCodePoint(cp);
				}
			}
			[SCRIPT_DATA_ESCAPED_DASH_DASH_STATE](cp) {
				if (cp === $.HYPHEN_MINUS) {
					this._emitChars('-');
				} else if (cp === $.LESS_THAN_SIGN) {
					this.state = SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE;
				} else if (cp === $.GREATER_THAN_SIGN) {
					this.state = SCRIPT_DATA_STATE;
					this._emitChars('>');
				} else if (cp === $.NULL) {
					this._err(ERR.unexpectedNullCharacter);
					this.state = SCRIPT_DATA_ESCAPED_STATE;
					this._emitChars(unicode.REPLACEMENT_CHARACTER);
				} else if (cp === $.EOF) {
					this._err(ERR.eofInScriptHtmlCommentLikeText);
					this._emitEOFToken();
				} else {
					this.state = SCRIPT_DATA_ESCAPED_STATE;
					this._emitCodePoint(cp);
				}
			}
			[SCRIPT_DATA_ESCAPED_LESS_THAN_SIGN_STATE](cp) {
				if (cp === $.SOLIDUS) {
					this.tempBuff = [];
					this.state = SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE;
				} else if (isAsciiLetter(cp)) {
					this.tempBuff = [];
					this._emitChars('<');
					this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE);
				} else {
					this._emitChars('<');
					this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
				}
			}
			[SCRIPT_DATA_ESCAPED_END_TAG_OPEN_STATE](cp) {
				if (isAsciiLetter(cp)) {
					this._createEndTagToken();
					this._reconsumeInState(SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE);
				} else {
					this._emitChars('</');
					this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
				}
			}
			[SCRIPT_DATA_ESCAPED_END_TAG_NAME_STATE](cp) {
				if (isAsciiUpper(cp)) {
					this.currentToken.tagName += toAsciiLowerChar(cp);
					this.tempBuff.push(cp);
				} else if (isAsciiLower(cp)) {
					this.currentToken.tagName += toChar(cp);
					this.tempBuff.push(cp);
				} else {
					if (this.lastStartTagName === this.currentToken.tagName) {
						if (isWhitespace(cp)) {
							this.state = BEFORE_ATTRIBUTE_NAME_STATE;
							return;
						}
						if (cp === $.SOLIDUS) {
							this.state = SELF_CLOSING_START_TAG_STATE;
							return;
						}
						if (cp === $.GREATER_THAN_SIGN) {
							this._emitCurrentToken();
							this.state = DATA_STATE;
							return;
						}
					}
					this._emitChars('</');
					this._emitSeveralCodePoints(this.tempBuff);
					this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
				}
			}
			[SCRIPT_DATA_DOUBLE_ESCAPE_START_STATE](cp) {
				if (isWhitespace(cp) || cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN) {
					this.state = this._isTempBufferEqualToScriptString()
						? SCRIPT_DATA_DOUBLE_ESCAPED_STATE
						: SCRIPT_DATA_ESCAPED_STATE;
					this._emitCodePoint(cp);
				} else if (isAsciiUpper(cp)) {
					this.tempBuff.push(toAsciiLowerCodePoint(cp));
					this._emitCodePoint(cp);
				} else if (isAsciiLower(cp)) {
					this.tempBuff.push(cp);
					this._emitCodePoint(cp);
				} else {
					this._reconsumeInState(SCRIPT_DATA_ESCAPED_STATE);
				}
			}
			[SCRIPT_DATA_DOUBLE_ESCAPED_STATE](cp) {
				if (cp === $.HYPHEN_MINUS) {
					this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE;
					this._emitChars('-');
				} else if (cp === $.LESS_THAN_SIGN) {
					this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
					this._emitChars('<');
				} else if (cp === $.NULL) {
					this._err(ERR.unexpectedNullCharacter);
					this._emitChars(unicode.REPLACEMENT_CHARACTER);
				} else if (cp === $.EOF) {
					this._err(ERR.eofInScriptHtmlCommentLikeText);
					this._emitEOFToken();
				} else {
					this._emitCodePoint(cp);
				}
			}
			[SCRIPT_DATA_DOUBLE_ESCAPED_DASH_STATE](cp) {
				if (cp === $.HYPHEN_MINUS) {
					this.state = SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE;
					this._emitChars('-');
				} else if (cp === $.LESS_THAN_SIGN) {
					this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
					this._emitChars('<');
				} else if (cp === $.NULL) {
					this._err(ERR.unexpectedNullCharacter);
					this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
					this._emitChars(unicode.REPLACEMENT_CHARACTER);
				} else if (cp === $.EOF) {
					this._err(ERR.eofInScriptHtmlCommentLikeText);
					this._emitEOFToken();
				} else {
					this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
					this._emitCodePoint(cp);
				}
			}
			[SCRIPT_DATA_DOUBLE_ESCAPED_DASH_DASH_STATE](cp) {
				if (cp === $.HYPHEN_MINUS) {
					this._emitChars('-');
				} else if (cp === $.LESS_THAN_SIGN) {
					this.state = SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE;
					this._emitChars('<');
				} else if (cp === $.GREATER_THAN_SIGN) {
					this.state = SCRIPT_DATA_STATE;
					this._emitChars('>');
				} else if (cp === $.NULL) {
					this._err(ERR.unexpectedNullCharacter);
					this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
					this._emitChars(unicode.REPLACEMENT_CHARACTER);
				} else if (cp === $.EOF) {
					this._err(ERR.eofInScriptHtmlCommentLikeText);
					this._emitEOFToken();
				} else {
					this.state = SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
					this._emitCodePoint(cp);
				}
			}
			[SCRIPT_DATA_DOUBLE_ESCAPED_LESS_THAN_SIGN_STATE](cp) {
				if (cp === $.SOLIDUS) {
					this.tempBuff = [];
					this.state = SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE;
					this._emitChars('/');
				} else {
					this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
				}
			}
			[SCRIPT_DATA_DOUBLE_ESCAPE_END_STATE](cp) {
				if (isWhitespace(cp) || cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN) {
					this.state = this._isTempBufferEqualToScriptString()
						? SCRIPT_DATA_ESCAPED_STATE
						: SCRIPT_DATA_DOUBLE_ESCAPED_STATE;
					this._emitCodePoint(cp);
				} else if (isAsciiUpper(cp)) {
					this.tempBuff.push(toAsciiLowerCodePoint(cp));
					this._emitCodePoint(cp);
				} else if (isAsciiLower(cp)) {
					this.tempBuff.push(cp);
					this._emitCodePoint(cp);
				} else {
					this._reconsumeInState(SCRIPT_DATA_DOUBLE_ESCAPED_STATE);
				}
			}
			[BEFORE_ATTRIBUTE_NAME_STATE](cp) {
				if (isWhitespace(cp)) {
					return;
				}
				if (cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN || cp === $.EOF) {
					this._reconsumeInState(AFTER_ATTRIBUTE_NAME_STATE);
				} else if (cp === $.EQUALS_SIGN) {
					this._err(ERR.unexpectedEqualsSignBeforeAttributeName);
					this._createAttr('=');
					this.state = ATTRIBUTE_NAME_STATE;
				} else {
					this._createAttr('');
					this._reconsumeInState(ATTRIBUTE_NAME_STATE);
				}
			}
			[ATTRIBUTE_NAME_STATE](cp) {
				if (isWhitespace(cp) || cp === $.SOLIDUS || cp === $.GREATER_THAN_SIGN || cp === $.EOF) {
					this._leaveAttrName(AFTER_ATTRIBUTE_NAME_STATE);
					this._unconsume();
				} else if (cp === $.EQUALS_SIGN) {
					this._leaveAttrName(BEFORE_ATTRIBUTE_VALUE_STATE);
				} else if (isAsciiUpper(cp)) {
					this.currentAttr.name += toAsciiLowerChar(cp);
				} else if (cp === $.QUOTATION_MARK || cp === $.APOSTROPHE || cp === $.LESS_THAN_SIGN) {
					this._err(ERR.unexpectedCharacterInAttributeName);
					this.currentAttr.name += toChar(cp);
				} else if (cp === $.NULL) {
					this._err(ERR.unexpectedNullCharacter);
					this.currentAttr.name += unicode.REPLACEMENT_CHARACTER;
				} else {
					this.currentAttr.name += toChar(cp);
				}
			}
			[AFTER_ATTRIBUTE_NAME_STATE](cp) {
				if (isWhitespace(cp)) {
					return;
				}
				if (cp === $.SOLIDUS) {
					this.state = SELF_CLOSING_START_TAG_STATE;
				} else if (cp === $.EQUALS_SIGN) {
					this.state = BEFORE_ATTRIBUTE_VALUE_STATE;
				} else if (cp === $.GREATER_THAN_SIGN) {
					this.state = DATA_STATE;
					this._emitCurrentToken();
				} else if (cp === $.EOF) {
					this._err(ERR.eofInTag);
					this._emitEOFToken();
				} else {
					this._createAttr('');
					this._reconsumeInState(ATTRIBUTE_NAME_STATE);
				}
			}
			[BEFORE_ATTRIBUTE_VALUE_STATE](cp) {
				if (isWhitespace(cp)) {
					return;
				}
				if (cp === $.QUOTATION_MARK) {
					this.state = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
				} else if (cp === $.APOSTROPHE) {
					this.state = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
				} else if (cp === $.GREATER_THAN_SIGN) {
					this._err(ERR.missingAttributeValue);
					this.state = DATA_STATE;
					this._emitCurrentToken();
				} else {
					this._reconsumeInState(ATTRIBUTE_VALUE_UNQUOTED_STATE);
				}
			}
			[ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE](cp) {
				if (cp === $.QUOTATION_MARK) {
					this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;
				} else if (cp === $.AMPERSAND) {
					this.returnState = ATTRIBUTE_VALUE_DOUBLE_QUOTED_STATE;
					this.state = CHARACTER_REFERENCE_STATE;
				} else if (cp === $.NULL) {
					this._err(ERR.unexpectedNullCharacter);
					this.currentAttr.value += unicode.REPLACEMENT_CHARACTER;
				} else if (cp === $.EOF) {
					this._err(ERR.eofInTag);
					this._emitEOFToken();
				} else {
					this.currentAttr.value += toChar(cp);
				}
			}
			[ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE](cp) {
				if (cp === $.APOSTROPHE) {
					this.state = AFTER_ATTRIBUTE_VALUE_QUOTED_STATE;
				} else if (cp === $.AMPERSAND) {
					this.returnState = ATTRIBUTE_VALUE_SINGLE_QUOTED_STATE;
					this.state = CHARACTER_REFERENCE_STATE;
				} else if (cp === $.NULL) {
					this._err(ERR.unexpectedNullCharacter);
					this.currentAttr.value += unicode.REPLACEMENT_CHARACTER;
				} else if (cp === $.EOF) {
					this._err(ERR.eofInTag);
					this._emitEOFToken();
				} else {
					this.currentAttr.value += toChar(cp);
				}
			}
			[ATTRIBUTE_VALUE_UNQUOTED_STATE](cp) {
				if (isWhitespace(cp)) {
					this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);
				} else if (cp === $.AMPERSAND) {
					this.returnState = ATTRIBUTE_VALUE_UNQUOTED_STATE;
					this.state = CHARACTER_REFERENCE_STATE;
				} else if (cp === $.GREATER_THAN_SIGN) {
					this._leaveAttrValue(DATA_STATE);
					this._emitCurrentToken();
				} else if (cp === $.NULL) {
					this._err(ERR.unexpectedNullCharacter);
					this.currentAttr.value += unicode.REPLACEMENT_CHARACTER;
				} else if (
					cp === $.QUOTATION_MARK ||
					cp === $.APOSTROPHE ||
					cp === $.LESS_THAN_SIGN ||
					cp === $.EQUALS_SIGN ||
					cp === $.GRAVE_ACCENT
				) {
					this._err(ERR.unexpectedCharacterInUnquotedAttributeValue);
					this.currentAttr.value += toChar(cp);
				} else if (cp === $.EOF) {
					this._err(ERR.eofInTag);
					this._emitEOFToken();
				} else {
					this.currentAttr.value += toChar(cp);
				}
			}
			[AFTER_ATTRIBUTE_VALUE_QUOTED_STATE](cp) {
				if (isWhitespace(cp)) {
					this._leaveAttrValue(BEFORE_ATTRIBUTE_NAME_STATE);
				} else if (cp === $.SOLIDUS) {
					this._leaveAttrValue(SELF_CLOSING_START_TAG_STATE);
				} else if (cp === $.GREATER_THAN_SIGN) {
					this._leaveAttrValue(DATA_STATE);
					this._emitCurrentToken();
				} else if (cp === $.EOF) {
					this._err(ERR.eofInTag);
					this._emitEOFToken();
				} else {
					this._err(ERR.missingWhitespaceBetweenAttributes);
					this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
				}
			}
			[SELF_CLOSING_START_TAG_STATE](cp) {
				if (cp === $.GREATER_THAN_SIGN) {
					this.currentToken.selfClosing = true;
					this.state = DATA_STATE;
					this._emitCurrentToken();
				} else if (cp === $.EOF) {
					this._err(ERR.eofInTag);
					this._emitEOFToken();
				} else {
					this._err(ERR.unexpectedSolidusInTag);
					this._reconsumeInState(BEFORE_ATTRIBUTE_NAME_STATE);
				}
			}
			[BOGUS_COMMENT_STATE](cp) {
				if (cp === $.GREATER_THAN_SIGN) {
					this.state = DATA_STATE;
					this._emitCurrentToken();
				} else if (cp === $.EOF) {
					this._emitCurrentToken();
					this._emitEOFToken();
				} else if (cp === $.NULL) {
					this._err(ERR.unexpectedNullCharacter);
					this.currentToken.data += unicode.REPLACEMENT_CHARACTER;
				} else {
					this.currentToken.data += toChar(cp);
				}
			}
			[MARKUP_DECLARATION_OPEN_STATE](cp) {
				if (this._consumeSequenceIfMatch($$.DASH_DASH_STRING, cp, true)) {
					this._createCommentToken();
					this.state = COMMENT_START_STATE;
				} else if (this._consumeSequenceIfMatch($$.DOCTYPE_STRING, cp, false)) {
					this.state = DOCTYPE_STATE;
				} else if (this._consumeSequenceIfMatch($$.CDATA_START_STRING, cp, true)) {
					if (this.allowCDATA) {
						this.state = CDATA_SECTION_STATE;
					} else {
						this._err(ERR.cdataInHtmlContent);
						this._createCommentToken();
						this.currentToken.data = '[CDATA[';
						this.state = BOGUS_COMMENT_STATE;
					}
				} else if (!this._ensureHibernation()) {
					this._err(ERR.incorrectlyOpenedComment);
					this._createCommentToken();
					this._reconsumeInState(BOGUS_COMMENT_STATE);
				}
			}
			[COMMENT_START_STATE](cp) {
				if (cp === $.HYPHEN_MINUS) {
					this.state = COMMENT_START_DASH_STATE;
				} else if (cp === $.GREATER_THAN_SIGN) {
					this._err(ERR.abruptClosingOfEmptyComment);
					this.state = DATA_STATE;
					this._emitCurrentToken();
				} else {
					this._reconsumeInState(COMMENT_STATE);
				}
			}
			[COMMENT_START_DASH_STATE](cp) {
				if (cp === $.HYPHEN_MINUS) {
					this.state = COMMENT_END_STATE;
				} else if (cp === $.GREATER_THAN_SIGN) {
					this._err(ERR.abruptClosingOfEmptyComment);
					this.state = DATA_STATE;
					this._emitCurrentToken();
				} else if (cp === $.EOF) {
					this._err(ERR.eofInComment);
					this._emitCurrentToken();
					this._emitEOFToken();
				} else {
					this.currentToken.data += '-';
					this._reconsumeInState(COMMENT_STATE);
				}
			}
			[COMMENT_STATE](cp) {
				if (cp === $.HYPHEN_MINUS) {
					this.state = COMMENT_END_DASH_STATE;
				} else if (cp === $.LESS_THAN_SIGN) {
					this.currentToken.data += '<';
					this.state = COMMENT_LESS_THAN_SIGN_STATE;
				} else if (cp === $.NULL) {
					this._err(ERR.unexpectedNullCharacter);
					this.currentToken.data += unicode.REPLACEMENT_CHARACTER;
				} else if (cp === $.EOF) {
					this._err(ERR.eofInComment);
					this._emitCurrentToken();
					this._emitEOFToken();
				} else {
					this.currentToken.data += toChar(cp);
				}
			}
			[COMMENT_LESS_THAN_SIGN_STATE](cp) {
				if (cp === $.EXCLAMATION_MARK) {
					this.currentToken.data += '!';
					this.state = COMMENT_LESS_THAN_SIGN_BANG_STATE;
				} else if (cp === $.LESS_THAN_SIGN) {
					this.currentToken.data += '!';
				} else {
					this._reconsumeInState(COMMENT_STATE);
				}
			}
			[COMMENT_LESS_THAN_SIGN_BANG_STATE](cp) {
				if (cp === $.HYPHEN_MINUS) {
					this.state = COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE;
				} else {
					this._reconsumeInState(COMMENT_STATE);
				}
			}
			[COMMENT_LESS_THAN_SIGN_BANG_DASH_STATE](cp) {
				if (cp === $.HYPHEN_MINUS) {
					this.state = COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE;
				} else {
					this._reconsumeInState(COMMENT_END_DASH_STATE);
				}
			}
			[COMMENT_LESS_THAN_SIGN_BANG_DASH_DASH_STATE](cp) {
				if (cp !== $.GREATER_THAN_SIGN && cp !== $.EOF) {
					this._err(ERR.nestedComment);
				}
				this._reconsumeInState(COMMENT_END_STATE);
			}
			[COMMENT_END_DASH_STATE](cp) {
				if (cp === $.HYPHEN_MINUS) {
					this.state = COMMENT_END_STATE;
				} else if (cp === $.EOF) {
					this._err(ERR.eofInComment);
					this._emitCurrentToken();
					this._emitEOFToken();
				} else {
					this.currentToken.data += '-';
					this._reconsumeInState(COMMENT_STATE);
				}
			}
			[COMMENT_END_STATE](cp) {
				if (cp === $.GREATER_THAN_SIGN) {
					this.state = DATA_STATE;
					this._emitCurrentToken();
				} else if (cp === $.EXCLAMATION_MARK) {
					this.state = COMMENT_END_BANG_STATE;
				} else if (cp === $.HYPHEN_MINUS) {
					this.currentToken.data += '-';
				} else if (cp === $.EOF) {
					this._err(ERR.eofInComment);
					this._emitCurrentToken();
					this._emitEOFToken();
				} else {
					this.currentToken.data += '--';
					this._reconsumeInState(COMMENT_STATE);
				}
			}
			[COMMENT_END_BANG_STATE](cp) {
				if (cp === $.HYPHEN_MINUS) {
					this.currentToken.data += '--!';
					this.state = COMMENT_END_DASH_STATE;
				} else if (cp === $.GREATER_THAN_SIGN) {
					this._err(ERR.incorrectlyClosedComment);
					this.state = DATA_STATE;
					this._emitCurrentToken();
				} else if (cp === $.EOF) {
					this._err(ERR.eofInComment);
					this._emitCurrentToken();
					this._emitEOFToken();
				} else {
					this.currentToken.data += '--!';
					this._reconsumeInState(COMMENT_STATE);
				}
			}
			[DOCTYPE_STATE](cp) {
				if (isWhitespace(cp)) {
					this.state = BEFORE_DOCTYPE_NAME_STATE;
				} else if (cp === $.GREATER_THAN_SIGN) {
					this._reconsumeInState(BEFORE_DOCTYPE_NAME_STATE);
				} else if (cp === $.EOF) {
					this._err(ERR.eofInDoctype);
					this._createDoctypeToken(null);
					this.currentToken.forceQuirks = true;
					this._emitCurrentToken();
					this._emitEOFToken();
				} else {
					this._err(ERR.missingWhitespaceBeforeDoctypeName);
					this._reconsumeInState(BEFORE_DOCTYPE_NAME_STATE);
				}
			}
			[BEFORE_DOCTYPE_NAME_STATE](cp) {
				if (isWhitespace(cp)) {
					return;
				}
				if (isAsciiUpper(cp)) {
					this._createDoctypeToken(toAsciiLowerChar(cp));
					this.state = DOCTYPE_NAME_STATE;
				} else if (cp === $.NULL) {
					this._err(ERR.unexpectedNullCharacter);
					this._createDoctypeToken(unicode.REPLACEMENT_CHARACTER);
					this.state = DOCTYPE_NAME_STATE;
				} else if (cp === $.GREATER_THAN_SIGN) {
					this._err(ERR.missingDoctypeName);
					this._createDoctypeToken(null);
					this.currentToken.forceQuirks = true;
					this._emitCurrentToken();
					this.state = DATA_STATE;
				} else if (cp === $.EOF) {
					this._err(ERR.eofInDoctype);
					this._createDoctypeToken(null);
					this.currentToken.forceQuirks = true;
					this._emitCurrentToken();
					this._emitEOFToken();
				} else {
					this._createDoctypeToken(toChar(cp));
					this.state = DOCTYPE_NAME_STATE;
				}
			}
			[DOCTYPE_NAME_STATE](cp) {
				if (isWhitespace(cp)) {
					this.state = AFTER_DOCTYPE_NAME_STATE;
				} else if (cp === $.GREATER_THAN_SIGN) {
					this.state = DATA_STATE;
					this._emitCurrentToken();
				} else if (isAsciiUpper(cp)) {
					this.currentToken.name += toAsciiLowerChar(cp);
				} else if (cp === $.NULL) {
					this._err(ERR.unexpectedNullCharacter);
					this.currentToken.name += unicode.REPLACEMENT_CHARACTER;
				} else if (cp === $.EOF) {
					this._err(ERR.eofInDoctype);
					this.currentToken.forceQuirks = true;
					this._emitCurrentToken();
					this._emitEOFToken();
				} else {
					this.currentToken.name += toChar(cp);
				}
			}
			[AFTER_DOCTYPE_NAME_STATE](cp) {
				if (isWhitespace(cp)) {
					return;
				}
				if (cp === $.GREATER_THAN_SIGN) {
					this.state = DATA_STATE;
					this._emitCurrentToken();
				} else if (cp === $.EOF) {
					this._err(ERR.eofInDoctype);
					this.currentToken.forceQuirks = true;
					this._emitCurrentToken();
					this._emitEOFToken();
				} else if (this._consumeSequenceIfMatch($$.PUBLIC_STRING, cp, false)) {
					this.state = AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE;
				} else if (this._consumeSequenceIfMatch($$.SYSTEM_STRING, cp, false)) {
					this.state = AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE;
				} else if (!this._ensureHibernation()) {
					this._err(ERR.invalidCharacterSequenceAfterDoctypeName);
					this.currentToken.forceQuirks = true;
					this._reconsumeInState(BOGUS_DOCTYPE_STATE);
				}
			}
			[AFTER_DOCTYPE_PUBLIC_KEYWORD_STATE](cp) {
				if (isWhitespace(cp)) {
					this.state = BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
				} else if (cp === $.QUOTATION_MARK) {
					this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
					this.currentToken.publicId = '';
					this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;
				} else if (cp === $.APOSTROPHE) {
					this._err(ERR.missingWhitespaceAfterDoctypePublicKeyword);
					this.currentToken.publicId = '';
					this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;
				} else if (cp === $.GREATER_THAN_SIGN) {
					this._err(ERR.missingDoctypePublicIdentifier);
					this.currentToken.forceQuirks = true;
					this.state = DATA_STATE;
					this._emitCurrentToken();
				} else if (cp === $.EOF) {
					this._err(ERR.eofInDoctype);
					this.currentToken.forceQuirks = true;
					this._emitCurrentToken();
					this._emitEOFToken();
				} else {
					this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
					this.currentToken.forceQuirks = true;
					this._reconsumeInState(BOGUS_DOCTYPE_STATE);
				}
			}
			[BEFORE_DOCTYPE_PUBLIC_IDENTIFIER_STATE](cp) {
				if (isWhitespace(cp)) {
					return;
				}
				if (cp === $.QUOTATION_MARK) {
					this.currentToken.publicId = '';
					this.state = DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE;
				} else if (cp === $.APOSTROPHE) {
					this.currentToken.publicId = '';
					this.state = DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE;
				} else if (cp === $.GREATER_THAN_SIGN) {
					this._err(ERR.missingDoctypePublicIdentifier);
					this.currentToken.forceQuirks = true;
					this.state = DATA_STATE;
					this._emitCurrentToken();
				} else if (cp === $.EOF) {
					this._err(ERR.eofInDoctype);
					this.currentToken.forceQuirks = true;
					this._emitCurrentToken();
					this._emitEOFToken();
				} else {
					this._err(ERR.missingQuoteBeforeDoctypePublicIdentifier);
					this.currentToken.forceQuirks = true;
					this._reconsumeInState(BOGUS_DOCTYPE_STATE);
				}
			}
			[DOCTYPE_PUBLIC_IDENTIFIER_DOUBLE_QUOTED_STATE](cp) {
				if (cp === $.QUOTATION_MARK) {
					this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
				} else if (cp === $.NULL) {
					this._err(ERR.unexpectedNullCharacter);
					this.currentToken.publicId += unicode.REPLACEMENT_CHARACTER;
				} else if (cp === $.GREATER_THAN_SIGN) {
					this._err(ERR.abruptDoctypePublicIdentifier);
					this.currentToken.forceQuirks = true;
					this._emitCurrentToken();
					this.state = DATA_STATE;
				} else if (cp === $.EOF) {
					this._err(ERR.eofInDoctype);
					this.currentToken.forceQuirks = true;
					this._emitCurrentToken();
					this._emitEOFToken();
				} else {
					this.currentToken.publicId += toChar(cp);
				}
			}
			[DOCTYPE_PUBLIC_IDENTIFIER_SINGLE_QUOTED_STATE](cp) {
				if (cp === $.APOSTROPHE) {
					this.state = AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE;
				} else if (cp === $.NULL) {
					this._err(ERR.unexpectedNullCharacter);
					this.currentToken.publicId += unicode.REPLACEMENT_CHARACTER;
				} else if (cp === $.GREATER_THAN_SIGN) {
					this._err(ERR.abruptDoctypePublicIdentifier);
					this.currentToken.forceQuirks = true;
					this._emitCurrentToken();
					this.state = DATA_STATE;
				} else if (cp === $.EOF) {
					this._err(ERR.eofInDoctype);
					this.currentToken.forceQuirks = true;
					this._emitCurrentToken();
					this._emitEOFToken();
				} else {
					this.currentToken.publicId += toChar(cp);
				}
			}
			[AFTER_DOCTYPE_PUBLIC_IDENTIFIER_STATE](cp) {
				if (isWhitespace(cp)) {
					this.state = BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE;
				} else if (cp === $.GREATER_THAN_SIGN) {
					this.state = DATA_STATE;
					this._emitCurrentToken();
				} else if (cp === $.QUOTATION_MARK) {
					this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
					this.currentToken.systemId = '';
					this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
				} else if (cp === $.APOSTROPHE) {
					this._err(ERR.missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers);
					this.currentToken.systemId = '';
					this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
				} else if (cp === $.EOF) {
					this._err(ERR.eofInDoctype);
					this.currentToken.forceQuirks = true;
					this._emitCurrentToken();
					this._emitEOFToken();
				} else {
					this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
					this.currentToken.forceQuirks = true;
					this._reconsumeInState(BOGUS_DOCTYPE_STATE);
				}
			}
			[BETWEEN_DOCTYPE_PUBLIC_AND_SYSTEM_IDENTIFIERS_STATE](cp) {
				if (isWhitespace(cp)) {
					return;
				}
				if (cp === $.GREATER_THAN_SIGN) {
					this._emitCurrentToken();
					this.state = DATA_STATE;
				} else if (cp === $.QUOTATION_MARK) {
					this.currentToken.systemId = '';
					this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
				} else if (cp === $.APOSTROPHE) {
					this.currentToken.systemId = '';
					this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
				} else if (cp === $.EOF) {
					this._err(ERR.eofInDoctype);
					this.currentToken.forceQuirks = true;
					this._emitCurrentToken();
					this._emitEOFToken();
				} else {
					this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
					this.currentToken.forceQuirks = true;
					this._reconsumeInState(BOGUS_DOCTYPE_STATE);
				}
			}
			[AFTER_DOCTYPE_SYSTEM_KEYWORD_STATE](cp) {
				if (isWhitespace(cp)) {
					this.state = BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
				} else if (cp === $.QUOTATION_MARK) {
					this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
					this.currentToken.systemId = '';
					this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
				} else if (cp === $.APOSTROPHE) {
					this._err(ERR.missingWhitespaceAfterDoctypeSystemKeyword);
					this.currentToken.systemId = '';
					this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
				} else if (cp === $.GREATER_THAN_SIGN) {
					this._err(ERR.missingDoctypeSystemIdentifier);
					this.currentToken.forceQuirks = true;
					this.state = DATA_STATE;
					this._emitCurrentToken();
				} else if (cp === $.EOF) {
					this._err(ERR.eofInDoctype);
					this.currentToken.forceQuirks = true;
					this._emitCurrentToken();
					this._emitEOFToken();
				} else {
					this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
					this.currentToken.forceQuirks = true;
					this._reconsumeInState(BOGUS_DOCTYPE_STATE);
				}
			}
			[BEFORE_DOCTYPE_SYSTEM_IDENTIFIER_STATE](cp) {
				if (isWhitespace(cp)) {
					return;
				}
				if (cp === $.QUOTATION_MARK) {
					this.currentToken.systemId = '';
					this.state = DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE;
				} else if (cp === $.APOSTROPHE) {
					this.currentToken.systemId = '';
					this.state = DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE;
				} else if (cp === $.GREATER_THAN_SIGN) {
					this._err(ERR.missingDoctypeSystemIdentifier);
					this.currentToken.forceQuirks = true;
					this.state = DATA_STATE;
					this._emitCurrentToken();
				} else if (cp === $.EOF) {
					this._err(ERR.eofInDoctype);
					this.currentToken.forceQuirks = true;
					this._emitCurrentToken();
					this._emitEOFToken();
				} else {
					this._err(ERR.missingQuoteBeforeDoctypeSystemIdentifier);
					this.currentToken.forceQuirks = true;
					this._reconsumeInState(BOGUS_DOCTYPE_STATE);
				}
			}
			[DOCTYPE_SYSTEM_IDENTIFIER_DOUBLE_QUOTED_STATE](cp) {
				if (cp === $.QUOTATION_MARK) {
					this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
				} else if (cp === $.NULL) {
					this._err(ERR.unexpectedNullCharacter);
					this.currentToken.systemId += unicode.REPLACEMENT_CHARACTER;
				} else if (cp === $.GREATER_THAN_SIGN) {
					this._err(ERR.abruptDoctypeSystemIdentifier);
					this.currentToken.forceQuirks = true;
					this._emitCurrentToken();
					this.state = DATA_STATE;
				} else if (cp === $.EOF) {
					this._err(ERR.eofInDoctype);
					this.currentToken.forceQuirks = true;
					this._emitCurrentToken();
					this._emitEOFToken();
				} else {
					this.currentToken.systemId += toChar(cp);
				}
			}
			[DOCTYPE_SYSTEM_IDENTIFIER_SINGLE_QUOTED_STATE](cp) {
				if (cp === $.APOSTROPHE) {
					this.state = AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE;
				} else if (cp === $.NULL) {
					this._err(ERR.unexpectedNullCharacter);
					this.currentToken.systemId += unicode.REPLACEMENT_CHARACTER;
				} else if (cp === $.GREATER_THAN_SIGN) {
					this._err(ERR.abruptDoctypeSystemIdentifier);
					this.currentToken.forceQuirks = true;
					this._emitCurrentToken();
					this.state = DATA_STATE;
				} else if (cp === $.EOF) {
					this._err(ERR.eofInDoctype);
					this.currentToken.forceQuirks = true;
					this._emitCurrentToken();
					this._emitEOFToken();
				} else {
					this.currentToken.systemId += toChar(cp);
				}
			}
			[AFTER_DOCTYPE_SYSTEM_IDENTIFIER_STATE](cp) {
				if (isWhitespace(cp)) {
					return;
				}
				if (cp === $.GREATER_THAN_SIGN) {
					this._emitCurrentToken();
					this.state = DATA_STATE;
				} else if (cp === $.EOF) {
					this._err(ERR.eofInDoctype);
					this.currentToken.forceQuirks = true;
					this._emitCurrentToken();
					this._emitEOFToken();
				} else {
					this._err(ERR.unexpectedCharacterAfterDoctypeSystemIdentifier);
					this._reconsumeInState(BOGUS_DOCTYPE_STATE);
				}
			}
			[BOGUS_DOCTYPE_STATE](cp) {
				if (cp === $.GREATER_THAN_SIGN) {
					this._emitCurrentToken();
					this.state = DATA_STATE;
				} else if (cp === $.NULL) {
					this._err(ERR.unexpectedNullCharacter);
				} else if (cp === $.EOF) {
					this._emitCurrentToken();
					this._emitEOFToken();
				}
			}
			[CDATA_SECTION_STATE](cp) {
				if (cp === $.RIGHT_SQUARE_BRACKET) {
					this.state = CDATA_SECTION_BRACKET_STATE;
				} else if (cp === $.EOF) {
					this._err(ERR.eofInCdata);
					this._emitEOFToken();
				} else {
					this._emitCodePoint(cp);
				}
			}
			[CDATA_SECTION_BRACKET_STATE](cp) {
				if (cp === $.RIGHT_SQUARE_BRACKET) {
					this.state = CDATA_SECTION_END_STATE;
				} else {
					this._emitChars(']');
					this._reconsumeInState(CDATA_SECTION_STATE);
				}
			}
			[CDATA_SECTION_END_STATE](cp) {
				if (cp === $.GREATER_THAN_SIGN) {
					this.state = DATA_STATE;
				} else if (cp === $.RIGHT_SQUARE_BRACKET) {
					this._emitChars(']');
				} else {
					this._emitChars(']]');
					this._reconsumeInState(CDATA_SECTION_STATE);
				}
			}
			[CHARACTER_REFERENCE_STATE](cp) {
				this.tempBuff = [$.AMPERSAND];
				if (cp === $.NUMBER_SIGN) {
					this.tempBuff.push(cp);
					this.state = NUMERIC_CHARACTER_REFERENCE_STATE;
				} else if (isAsciiAlphaNumeric(cp)) {
					this._reconsumeInState(NAMED_CHARACTER_REFERENCE_STATE);
				} else {
					this._flushCodePointsConsumedAsCharacterReference();
					this._reconsumeInState(this.returnState);
				}
			}
			[NAMED_CHARACTER_REFERENCE_STATE](cp) {
				const matchResult = this._matchNamedCharacterReference(cp);
				if (this._ensureHibernation()) {
					this.tempBuff = [$.AMPERSAND];
				} else if (matchResult) {
					const withSemicolon = this.tempBuff[this.tempBuff.length - 1] === $.SEMICOLON;
					if (!this._isCharacterReferenceAttributeQuirk(withSemicolon)) {
						if (!withSemicolon) {
							this._errOnNextCodePoint(ERR.missingSemicolonAfterCharacterReference);
						}
						this.tempBuff = matchResult;
					}
					this._flushCodePointsConsumedAsCharacterReference();
					this.state = this.returnState;
				} else {
					this._flushCodePointsConsumedAsCharacterReference();
					this.state = AMBIGUOUS_AMPERSAND_STATE;
				}
			}
			[AMBIGUOUS_AMPERSAND_STATE](cp) {
				if (isAsciiAlphaNumeric(cp)) {
					if (this._isCharacterReferenceInAttribute()) {
						this.currentAttr.value += toChar(cp);
					} else {
						this._emitCodePoint(cp);
					}
				} else {
					if (cp === $.SEMICOLON) {
						this._err(ERR.unknownNamedCharacterReference);
					}
					this._reconsumeInState(this.returnState);
				}
			}
			[NUMERIC_CHARACTER_REFERENCE_STATE](cp) {
				this.charRefCode = 0;
				if (cp === $.LATIN_SMALL_X || cp === $.LATIN_CAPITAL_X) {
					this.tempBuff.push(cp);
					this.state = HEXADEMICAL_CHARACTER_REFERENCE_START_STATE;
				} else {
					this._reconsumeInState(DECIMAL_CHARACTER_REFERENCE_START_STATE);
				}
			}
			[HEXADEMICAL_CHARACTER_REFERENCE_START_STATE](cp) {
				if (isAsciiHexDigit(cp)) {
					this._reconsumeInState(HEXADEMICAL_CHARACTER_REFERENCE_STATE);
				} else {
					this._err(ERR.absenceOfDigitsInNumericCharacterReference);
					this._flushCodePointsConsumedAsCharacterReference();
					this._reconsumeInState(this.returnState);
				}
			}
			[DECIMAL_CHARACTER_REFERENCE_START_STATE](cp) {
				if (isAsciiDigit(cp)) {
					this._reconsumeInState(DECIMAL_CHARACTER_REFERENCE_STATE);
				} else {
					this._err(ERR.absenceOfDigitsInNumericCharacterReference);
					this._flushCodePointsConsumedAsCharacterReference();
					this._reconsumeInState(this.returnState);
				}
			}
			[HEXADEMICAL_CHARACTER_REFERENCE_STATE](cp) {
				if (isAsciiUpperHexDigit(cp)) {
					this.charRefCode = this.charRefCode * 16 + cp - 55;
				} else if (isAsciiLowerHexDigit(cp)) {
					this.charRefCode = this.charRefCode * 16 + cp - 87;
				} else if (isAsciiDigit(cp)) {
					this.charRefCode = this.charRefCode * 16 + cp - 48;
				} else if (cp === $.SEMICOLON) {
					this.state = NUMERIC_CHARACTER_REFERENCE_END_STATE;
				} else {
					this._err(ERR.missingSemicolonAfterCharacterReference);
					this._reconsumeInState(NUMERIC_CHARACTER_REFERENCE_END_STATE);
				}
			}
			[DECIMAL_CHARACTER_REFERENCE_STATE](cp) {
				if (isAsciiDigit(cp)) {
					this.charRefCode = this.charRefCode * 10 + cp - 48;
				} else if (cp === $.SEMICOLON) {
					this.state = NUMERIC_CHARACTER_REFERENCE_END_STATE;
				} else {
					this._err(ERR.missingSemicolonAfterCharacterReference);
					this._reconsumeInState(NUMERIC_CHARACTER_REFERENCE_END_STATE);
				}
			}
			[NUMERIC_CHARACTER_REFERENCE_END_STATE]() {
				if (this.charRefCode === $.NULL) {
					this._err(ERR.nullCharacterReference);
					this.charRefCode = $.REPLACEMENT_CHARACTER;
				} else if (this.charRefCode > 1114111) {
					this._err(ERR.characterReferenceOutsideUnicodeRange);
					this.charRefCode = $.REPLACEMENT_CHARACTER;
				} else if (unicode.isSurrogate(this.charRefCode)) {
					this._err(ERR.surrogateCharacterReference);
					this.charRefCode = $.REPLACEMENT_CHARACTER;
				} else if (unicode.isUndefinedCodePoint(this.charRefCode)) {
					this._err(ERR.noncharacterCharacterReference);
				} else if (
					unicode.isControlCodePoint(this.charRefCode) ||
					this.charRefCode === $.CARRIAGE_RETURN
				) {
					this._err(ERR.controlCharacterReference);
					const replacement = C1_CONTROLS_REFERENCE_REPLACEMENTS[this.charRefCode];
					if (replacement) {
						this.charRefCode = replacement;
					}
				}
				this.tempBuff = [this.charRefCode];
				this._flushCodePointsConsumedAsCharacterReference();
				this._reconsumeInState(this.returnState);
			}
		};
		Tokenizer.CHARACTER_TOKEN = 'CHARACTER_TOKEN';
		Tokenizer.NULL_CHARACTER_TOKEN = 'NULL_CHARACTER_TOKEN';
		Tokenizer.WHITESPACE_CHARACTER_TOKEN = 'WHITESPACE_CHARACTER_TOKEN';
		Tokenizer.START_TAG_TOKEN = 'START_TAG_TOKEN';
		Tokenizer.END_TAG_TOKEN = 'END_TAG_TOKEN';
		Tokenizer.COMMENT_TOKEN = 'COMMENT_TOKEN';
		Tokenizer.DOCTYPE_TOKEN = 'DOCTYPE_TOKEN';
		Tokenizer.EOF_TOKEN = 'EOF_TOKEN';
		Tokenizer.HIBERNATION_TOKEN = 'HIBERNATION_TOKEN';
		Tokenizer.MODE = {
			DATA: DATA_STATE,
			RCDATA: RCDATA_STATE,
			RAWTEXT: RAWTEXT_STATE,
			SCRIPT_DATA: SCRIPT_DATA_STATE,
			PLAINTEXT: PLAINTEXT_STATE
		};
		Tokenizer.getTokenAttr = function (token, attrName) {
			for (let i2 = token.attrs.length - 1; i2 >= 0; i2--) {
				if (token.attrs[i2].name === attrName) {
					return token.attrs[i2].value;
				}
			}
			return null;
		};
		module2.exports = Tokenizer;
	}
});

// node_modules/parse5/lib/common/html.js
var require_html = __commonJS({
	'node_modules/parse5/lib/common/html.js'(exports) {
		'use strict';
		var NS = (exports.NAMESPACES = {
			HTML: 'http://www.w3.org/1999/xhtml',
			MATHML: 'http://www.w3.org/1998/Math/MathML',
			SVG: 'http://www.w3.org/2000/svg',
			XLINK: 'http://www.w3.org/1999/xlink',
			XML: 'http://www.w3.org/XML/1998/namespace',
			XMLNS: 'http://www.w3.org/2000/xmlns/'
		});
		exports.ATTRS = {
			TYPE: 'type',
			ACTION: 'action',
			ENCODING: 'encoding',
			PROMPT: 'prompt',
			NAME: 'name',
			COLOR: 'color',
			FACE: 'face',
			SIZE: 'size'
		};
		exports.DOCUMENT_MODE = {
			NO_QUIRKS: 'no-quirks',
			QUIRKS: 'quirks',
			LIMITED_QUIRKS: 'limited-quirks'
		};
		var $ = (exports.TAG_NAMES = {
			A: 'a',
			ADDRESS: 'address',
			ANNOTATION_XML: 'annotation-xml',
			APPLET: 'applet',
			AREA: 'area',
			ARTICLE: 'article',
			ASIDE: 'aside',
			B: 'b',
			BASE: 'base',
			BASEFONT: 'basefont',
			BGSOUND: 'bgsound',
			BIG: 'big',
			BLOCKQUOTE: 'blockquote',
			BODY: 'body',
			BR: 'br',
			BUTTON: 'button',
			CAPTION: 'caption',
			CENTER: 'center',
			CODE: 'code',
			COL: 'col',
			COLGROUP: 'colgroup',
			DD: 'dd',
			DESC: 'desc',
			DETAILS: 'details',
			DIALOG: 'dialog',
			DIR: 'dir',
			DIV: 'div',
			DL: 'dl',
			DT: 'dt',
			EM: 'em',
			EMBED: 'embed',
			FIELDSET: 'fieldset',
			FIGCAPTION: 'figcaption',
			FIGURE: 'figure',
			FONT: 'font',
			FOOTER: 'footer',
			FOREIGN_OBJECT: 'foreignObject',
			FORM: 'form',
			FRAME: 'frame',
			FRAMESET: 'frameset',
			H1: 'h1',
			H2: 'h2',
			H3: 'h3',
			H4: 'h4',
			H5: 'h5',
			H6: 'h6',
			HEAD: 'head',
			HEADER: 'header',
			HGROUP: 'hgroup',
			HR: 'hr',
			HTML: 'html',
			I: 'i',
			IMG: 'img',
			IMAGE: 'image',
			INPUT: 'input',
			IFRAME: 'iframe',
			KEYGEN: 'keygen',
			LABEL: 'label',
			LI: 'li',
			LINK: 'link',
			LISTING: 'listing',
			MAIN: 'main',
			MALIGNMARK: 'malignmark',
			MARQUEE: 'marquee',
			MATH: 'math',
			MENU: 'menu',
			META: 'meta',
			MGLYPH: 'mglyph',
			MI: 'mi',
			MO: 'mo',
			MN: 'mn',
			MS: 'ms',
			MTEXT: 'mtext',
			NAV: 'nav',
			NOBR: 'nobr',
			NOFRAMES: 'noframes',
			NOEMBED: 'noembed',
			NOSCRIPT: 'noscript',
			OBJECT: 'object',
			OL: 'ol',
			OPTGROUP: 'optgroup',
			OPTION: 'option',
			P: 'p',
			PARAM: 'param',
			PLAINTEXT: 'plaintext',
			PRE: 'pre',
			RB: 'rb',
			RP: 'rp',
			RT: 'rt',
			RTC: 'rtc',
			RUBY: 'ruby',
			S: 's',
			SCRIPT: 'script',
			SECTION: 'section',
			SELECT: 'select',
			SOURCE: 'source',
			SMALL: 'small',
			SPAN: 'span',
			STRIKE: 'strike',
			STRONG: 'strong',
			STYLE: 'style',
			SUB: 'sub',
			SUMMARY: 'summary',
			SUP: 'sup',
			TABLE: 'table',
			TBODY: 'tbody',
			TEMPLATE: 'template',
			TEXTAREA: 'textarea',
			TFOOT: 'tfoot',
			TD: 'td',
			TH: 'th',
			THEAD: 'thead',
			TITLE: 'title',
			TR: 'tr',
			TRACK: 'track',
			TT: 'tt',
			U: 'u',
			UL: 'ul',
			SVG: 'svg',
			VAR: 'var',
			WBR: 'wbr',
			XMP: 'xmp'
		});
		exports.SPECIAL_ELEMENTS = {
			[NS.HTML]: {
				[$.ADDRESS]: true,
				[$.APPLET]: true,
				[$.AREA]: true,
				[$.ARTICLE]: true,
				[$.ASIDE]: true,
				[$.BASE]: true,
				[$.BASEFONT]: true,
				[$.BGSOUND]: true,
				[$.BLOCKQUOTE]: true,
				[$.BODY]: true,
				[$.BR]: true,
				[$.BUTTON]: true,
				[$.CAPTION]: true,
				[$.CENTER]: true,
				[$.COL]: true,
				[$.COLGROUP]: true,
				[$.DD]: true,
				[$.DETAILS]: true,
				[$.DIR]: true,
				[$.DIV]: true,
				[$.DL]: true,
				[$.DT]: true,
				[$.EMBED]: true,
				[$.FIELDSET]: true,
				[$.FIGCAPTION]: true,
				[$.FIGURE]: true,
				[$.FOOTER]: true,
				[$.FORM]: true,
				[$.FRAME]: true,
				[$.FRAMESET]: true,
				[$.H1]: true,
				[$.H2]: true,
				[$.H3]: true,
				[$.H4]: true,
				[$.H5]: true,
				[$.H6]: true,
				[$.HEAD]: true,
				[$.HEADER]: true,
				[$.HGROUP]: true,
				[$.HR]: true,
				[$.HTML]: true,
				[$.IFRAME]: true,
				[$.IMG]: true,
				[$.INPUT]: true,
				[$.LI]: true,
				[$.LINK]: true,
				[$.LISTING]: true,
				[$.MAIN]: true,
				[$.MARQUEE]: true,
				[$.MENU]: true,
				[$.META]: true,
				[$.NAV]: true,
				[$.NOEMBED]: true,
				[$.NOFRAMES]: true,
				[$.NOSCRIPT]: true,
				[$.OBJECT]: true,
				[$.OL]: true,
				[$.P]: true,
				[$.PARAM]: true,
				[$.PLAINTEXT]: true,
				[$.PRE]: true,
				[$.SCRIPT]: true,
				[$.SECTION]: true,
				[$.SELECT]: true,
				[$.SOURCE]: true,
				[$.STYLE]: true,
				[$.SUMMARY]: true,
				[$.TABLE]: true,
				[$.TBODY]: true,
				[$.TD]: true,
				[$.TEMPLATE]: true,
				[$.TEXTAREA]: true,
				[$.TFOOT]: true,
				[$.TH]: true,
				[$.THEAD]: true,
				[$.TITLE]: true,
				[$.TR]: true,
				[$.TRACK]: true,
				[$.UL]: true,
				[$.WBR]: true,
				[$.XMP]: true
			},
			[NS.MATHML]: {
				[$.MI]: true,
				[$.MO]: true,
				[$.MN]: true,
				[$.MS]: true,
				[$.MTEXT]: true,
				[$.ANNOTATION_XML]: true
			},
			[NS.SVG]: {
				[$.TITLE]: true,
				[$.FOREIGN_OBJECT]: true,
				[$.DESC]: true
			}
		};
	}
});

// node_modules/parse5/lib/parser/open-element-stack.js
var require_open_element_stack = __commonJS({
	'node_modules/parse5/lib/parser/open-element-stack.js'(exports, module2) {
		'use strict';
		var HTML = require_html();
		var $ = HTML.TAG_NAMES;
		var NS = HTML.NAMESPACES;
		function isImpliedEndTagRequired(tn) {
			switch (tn.length) {
				case 1:
					return tn === $.P;
				case 2:
					return (
						tn === $.RB || tn === $.RP || tn === $.RT || tn === $.DD || tn === $.DT || tn === $.LI
					);
				case 3:
					return tn === $.RTC;
				case 6:
					return tn === $.OPTION;
				case 8:
					return tn === $.OPTGROUP;
			}
			return false;
		}
		function isImpliedEndTagRequiredThoroughly(tn) {
			switch (tn.length) {
				case 1:
					return tn === $.P;
				case 2:
					return (
						tn === $.RB ||
						tn === $.RP ||
						tn === $.RT ||
						tn === $.DD ||
						tn === $.DT ||
						tn === $.LI ||
						tn === $.TD ||
						tn === $.TH ||
						tn === $.TR
					);
				case 3:
					return tn === $.RTC;
				case 5:
					return tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD;
				case 6:
					return tn === $.OPTION;
				case 7:
					return tn === $.CAPTION;
				case 8:
					return tn === $.OPTGROUP || tn === $.COLGROUP;
			}
			return false;
		}
		function isScopingElement(tn, ns) {
			switch (tn.length) {
				case 2:
					if (tn === $.TD || tn === $.TH) {
						return ns === NS.HTML;
					} else if (tn === $.MI || tn === $.MO || tn === $.MN || tn === $.MS) {
						return ns === NS.MATHML;
					}
					break;
				case 4:
					if (tn === $.HTML) {
						return ns === NS.HTML;
					} else if (tn === $.DESC) {
						return ns === NS.SVG;
					}
					break;
				case 5:
					if (tn === $.TABLE) {
						return ns === NS.HTML;
					} else if (tn === $.MTEXT) {
						return ns === NS.MATHML;
					} else if (tn === $.TITLE) {
						return ns === NS.SVG;
					}
					break;
				case 6:
					return (tn === $.APPLET || tn === $.OBJECT) && ns === NS.HTML;
				case 7:
					return (tn === $.CAPTION || tn === $.MARQUEE) && ns === NS.HTML;
				case 8:
					return tn === $.TEMPLATE && ns === NS.HTML;
				case 13:
					return tn === $.FOREIGN_OBJECT && ns === NS.SVG;
				case 14:
					return tn === $.ANNOTATION_XML && ns === NS.MATHML;
			}
			return false;
		}
		var OpenElementStack = class {
			constructor(document4, treeAdapter) {
				this.stackTop = -1;
				this.items = [];
				this.current = document4;
				this.currentTagName = null;
				this.currentTmplContent = null;
				this.tmplCount = 0;
				this.treeAdapter = treeAdapter;
			}
			_indexOf(element4) {
				let idx = -1;
				for (let i2 = this.stackTop; i2 >= 0; i2--) {
					if (this.items[i2] === element4) {
						idx = i2;
						break;
					}
				}
				return idx;
			}
			_isInTemplate() {
				return (
					this.currentTagName === $.TEMPLATE &&
					this.treeAdapter.getNamespaceURI(this.current) === NS.HTML
				);
			}
			_updateCurrentElement() {
				this.current = this.items[this.stackTop];
				this.currentTagName = this.current && this.treeAdapter.getTagName(this.current);
				this.currentTmplContent = this._isInTemplate()
					? this.treeAdapter.getTemplateContent(this.current)
					: null;
			}
			push(element4) {
				this.items[++this.stackTop] = element4;
				this._updateCurrentElement();
				if (this._isInTemplate()) {
					this.tmplCount++;
				}
			}
			pop() {
				this.stackTop--;
				if (this.tmplCount > 0 && this._isInTemplate()) {
					this.tmplCount--;
				}
				this._updateCurrentElement();
			}
			replace(oldElement, newElement) {
				const idx = this._indexOf(oldElement);
				this.items[idx] = newElement;
				if (idx === this.stackTop) {
					this._updateCurrentElement();
				}
			}
			insertAfter(referenceElement, newElement) {
				const insertionIdx = this._indexOf(referenceElement) + 1;
				this.items.splice(insertionIdx, 0, newElement);
				if (insertionIdx === ++this.stackTop) {
					this._updateCurrentElement();
				}
			}
			popUntilTagNamePopped(tagName) {
				while (this.stackTop > -1) {
					const tn = this.currentTagName;
					const ns = this.treeAdapter.getNamespaceURI(this.current);
					this.pop();
					if (tn === tagName && ns === NS.HTML) {
						break;
					}
				}
			}
			popUntilElementPopped(element4) {
				while (this.stackTop > -1) {
					const poppedElement = this.current;
					this.pop();
					if (poppedElement === element4) {
						break;
					}
				}
			}
			popUntilNumberedHeaderPopped() {
				while (this.stackTop > -1) {
					const tn = this.currentTagName;
					const ns = this.treeAdapter.getNamespaceURI(this.current);
					this.pop();
					if (
						tn === $.H1 ||
						tn === $.H2 ||
						tn === $.H3 ||
						tn === $.H4 ||
						tn === $.H5 ||
						(tn === $.H6 && ns === NS.HTML)
					) {
						break;
					}
				}
			}
			popUntilTableCellPopped() {
				while (this.stackTop > -1) {
					const tn = this.currentTagName;
					const ns = this.treeAdapter.getNamespaceURI(this.current);
					this.pop();
					if (tn === $.TD || (tn === $.TH && ns === NS.HTML)) {
						break;
					}
				}
			}
			popAllUpToHtmlElement() {
				this.stackTop = 0;
				this._updateCurrentElement();
			}
			clearBackToTableContext() {
				while (
					(this.currentTagName !== $.TABLE &&
						this.currentTagName !== $.TEMPLATE &&
						this.currentTagName !== $.HTML) ||
					this.treeAdapter.getNamespaceURI(this.current) !== NS.HTML
				) {
					this.pop();
				}
			}
			clearBackToTableBodyContext() {
				while (
					(this.currentTagName !== $.TBODY &&
						this.currentTagName !== $.TFOOT &&
						this.currentTagName !== $.THEAD &&
						this.currentTagName !== $.TEMPLATE &&
						this.currentTagName !== $.HTML) ||
					this.treeAdapter.getNamespaceURI(this.current) !== NS.HTML
				) {
					this.pop();
				}
			}
			clearBackToTableRowContext() {
				while (
					(this.currentTagName !== $.TR &&
						this.currentTagName !== $.TEMPLATE &&
						this.currentTagName !== $.HTML) ||
					this.treeAdapter.getNamespaceURI(this.current) !== NS.HTML
				) {
					this.pop();
				}
			}
			remove(element4) {
				for (let i2 = this.stackTop; i2 >= 0; i2--) {
					if (this.items[i2] === element4) {
						this.items.splice(i2, 1);
						this.stackTop--;
						this._updateCurrentElement();
						break;
					}
				}
			}
			tryPeekProperlyNestedBodyElement() {
				const element4 = this.items[1];
				return element4 && this.treeAdapter.getTagName(element4) === $.BODY ? element4 : null;
			}
			contains(element4) {
				return this._indexOf(element4) > -1;
			}
			getCommonAncestor(element4) {
				let elementIdx = this._indexOf(element4);
				return --elementIdx >= 0 ? this.items[elementIdx] : null;
			}
			isRootHtmlElementCurrent() {
				return this.stackTop === 0 && this.currentTagName === $.HTML;
			}
			hasInScope(tagName) {
				for (let i2 = this.stackTop; i2 >= 0; i2--) {
					const tn = this.treeAdapter.getTagName(this.items[i2]);
					const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
					if (tn === tagName && ns === NS.HTML) {
						return true;
					}
					if (isScopingElement(tn, ns)) {
						return false;
					}
				}
				return true;
			}
			hasNumberedHeaderInScope() {
				for (let i2 = this.stackTop; i2 >= 0; i2--) {
					const tn = this.treeAdapter.getTagName(this.items[i2]);
					const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
					if (
						(tn === $.H1 ||
							tn === $.H2 ||
							tn === $.H3 ||
							tn === $.H4 ||
							tn === $.H5 ||
							tn === $.H6) &&
						ns === NS.HTML
					) {
						return true;
					}
					if (isScopingElement(tn, ns)) {
						return false;
					}
				}
				return true;
			}
			hasInListItemScope(tagName) {
				for (let i2 = this.stackTop; i2 >= 0; i2--) {
					const tn = this.treeAdapter.getTagName(this.items[i2]);
					const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
					if (tn === tagName && ns === NS.HTML) {
						return true;
					}
					if (((tn === $.UL || tn === $.OL) && ns === NS.HTML) || isScopingElement(tn, ns)) {
						return false;
					}
				}
				return true;
			}
			hasInButtonScope(tagName) {
				for (let i2 = this.stackTop; i2 >= 0; i2--) {
					const tn = this.treeAdapter.getTagName(this.items[i2]);
					const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
					if (tn === tagName && ns === NS.HTML) {
						return true;
					}
					if ((tn === $.BUTTON && ns === NS.HTML) || isScopingElement(tn, ns)) {
						return false;
					}
				}
				return true;
			}
			hasInTableScope(tagName) {
				for (let i2 = this.stackTop; i2 >= 0; i2--) {
					const tn = this.treeAdapter.getTagName(this.items[i2]);
					const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
					if (ns !== NS.HTML) {
						continue;
					}
					if (tn === tagName) {
						return true;
					}
					if (tn === $.TABLE || tn === $.TEMPLATE || tn === $.HTML) {
						return false;
					}
				}
				return true;
			}
			hasTableBodyContextInTableScope() {
				for (let i2 = this.stackTop; i2 >= 0; i2--) {
					const tn = this.treeAdapter.getTagName(this.items[i2]);
					const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
					if (ns !== NS.HTML) {
						continue;
					}
					if (tn === $.TBODY || tn === $.THEAD || tn === $.TFOOT) {
						return true;
					}
					if (tn === $.TABLE || tn === $.HTML) {
						return false;
					}
				}
				return true;
			}
			hasInSelectScope(tagName) {
				for (let i2 = this.stackTop; i2 >= 0; i2--) {
					const tn = this.treeAdapter.getTagName(this.items[i2]);
					const ns = this.treeAdapter.getNamespaceURI(this.items[i2]);
					if (ns !== NS.HTML) {
						continue;
					}
					if (tn === tagName) {
						return true;
					}
					if (tn !== $.OPTION && tn !== $.OPTGROUP) {
						return false;
					}
				}
				return true;
			}
			generateImpliedEndTags() {
				while (isImpliedEndTagRequired(this.currentTagName)) {
					this.pop();
				}
			}
			generateImpliedEndTagsThoroughly() {
				while (isImpliedEndTagRequiredThoroughly(this.currentTagName)) {
					this.pop();
				}
			}
			generateImpliedEndTagsWithExclusion(exclusionTagName) {
				while (
					isImpliedEndTagRequired(this.currentTagName) &&
					this.currentTagName !== exclusionTagName
				) {
					this.pop();
				}
			}
		};
		module2.exports = OpenElementStack;
	}
});

// node_modules/parse5/lib/parser/formatting-element-list.js
var require_formatting_element_list = __commonJS({
	'node_modules/parse5/lib/parser/formatting-element-list.js'(exports, module2) {
		'use strict';
		var NOAH_ARK_CAPACITY = 3;
		var FormattingElementList = class {
			constructor(treeAdapter) {
				this.length = 0;
				this.entries = [];
				this.treeAdapter = treeAdapter;
				this.bookmark = null;
			}
			_getNoahArkConditionCandidates(newElement) {
				const candidates = [];
				if (this.length >= NOAH_ARK_CAPACITY) {
					const neAttrsLength = this.treeAdapter.getAttrList(newElement).length;
					const neTagName = this.treeAdapter.getTagName(newElement);
					const neNamespaceURI = this.treeAdapter.getNamespaceURI(newElement);
					for (let i2 = this.length - 1; i2 >= 0; i2--) {
						const entry5 = this.entries[i2];
						if (entry5.type === FormattingElementList.MARKER_ENTRY) {
							break;
						}
						const element4 = entry5.element;
						const elementAttrs = this.treeAdapter.getAttrList(element4);
						const isCandidate =
							this.treeAdapter.getTagName(element4) === neTagName &&
							this.treeAdapter.getNamespaceURI(element4) === neNamespaceURI &&
							elementAttrs.length === neAttrsLength;
						if (isCandidate) {
							candidates.push({ idx: i2, attrs: elementAttrs });
						}
					}
				}
				return candidates.length < NOAH_ARK_CAPACITY ? [] : candidates;
			}
			_ensureNoahArkCondition(newElement) {
				const candidates = this._getNoahArkConditionCandidates(newElement);
				let cLength = candidates.length;
				if (cLength) {
					const neAttrs = this.treeAdapter.getAttrList(newElement);
					const neAttrsLength = neAttrs.length;
					const neAttrsMap = /* @__PURE__ */ Object.create(null);
					for (let i2 = 0; i2 < neAttrsLength; i2++) {
						const neAttr = neAttrs[i2];
						neAttrsMap[neAttr.name] = neAttr.value;
					}
					for (let i2 = 0; i2 < neAttrsLength; i2++) {
						for (let j = 0; j < cLength; j++) {
							const cAttr = candidates[j].attrs[i2];
							if (neAttrsMap[cAttr.name] !== cAttr.value) {
								candidates.splice(j, 1);
								cLength--;
							}
							if (candidates.length < NOAH_ARK_CAPACITY) {
								return;
							}
						}
					}
					for (let i2 = cLength - 1; i2 >= NOAH_ARK_CAPACITY - 1; i2--) {
						this.entries.splice(candidates[i2].idx, 1);
						this.length--;
					}
				}
			}
			insertMarker() {
				this.entries.push({ type: FormattingElementList.MARKER_ENTRY });
				this.length++;
			}
			pushElement(element4, token) {
				this._ensureNoahArkCondition(element4);
				this.entries.push({
					type: FormattingElementList.ELEMENT_ENTRY,
					element: element4,
					token
				});
				this.length++;
			}
			insertElementAfterBookmark(element4, token) {
				let bookmarkIdx = this.length - 1;
				for (; bookmarkIdx >= 0; bookmarkIdx--) {
					if (this.entries[bookmarkIdx] === this.bookmark) {
						break;
					}
				}
				this.entries.splice(bookmarkIdx + 1, 0, {
					type: FormattingElementList.ELEMENT_ENTRY,
					element: element4,
					token
				});
				this.length++;
			}
			removeEntry(entry5) {
				for (let i2 = this.length - 1; i2 >= 0; i2--) {
					if (this.entries[i2] === entry5) {
						this.entries.splice(i2, 1);
						this.length--;
						break;
					}
				}
			}
			clearToLastMarker() {
				while (this.length) {
					const entry5 = this.entries.pop();
					this.length--;
					if (entry5.type === FormattingElementList.MARKER_ENTRY) {
						break;
					}
				}
			}
			getElementEntryInScopeWithTagName(tagName) {
				for (let i2 = this.length - 1; i2 >= 0; i2--) {
					const entry5 = this.entries[i2];
					if (entry5.type === FormattingElementList.MARKER_ENTRY) {
						return null;
					}
					if (this.treeAdapter.getTagName(entry5.element) === tagName) {
						return entry5;
					}
				}
				return null;
			}
			getElementEntry(element4) {
				for (let i2 = this.length - 1; i2 >= 0; i2--) {
					const entry5 = this.entries[i2];
					if (entry5.type === FormattingElementList.ELEMENT_ENTRY && entry5.element === element4) {
						return entry5;
					}
				}
				return null;
			}
		};
		FormattingElementList.MARKER_ENTRY = 'MARKER_ENTRY';
		FormattingElementList.ELEMENT_ENTRY = 'ELEMENT_ENTRY';
		module2.exports = FormattingElementList;
	}
});

// node_modules/parse5/lib/utils/mixin.js
var require_mixin = __commonJS({
	'node_modules/parse5/lib/utils/mixin.js'(exports, module2) {
		'use strict';
		var Mixin = class {
			constructor(host) {
				const originalMethods = {};
				const overriddenMethods = this._getOverriddenMethods(this, originalMethods);
				for (const key3 of Object.keys(overriddenMethods)) {
					if (typeof overriddenMethods[key3] === 'function') {
						originalMethods[key3] = host[key3];
						host[key3] = overriddenMethods[key3];
					}
				}
			}
			_getOverriddenMethods() {
				throw new Error('Not implemented');
			}
		};
		Mixin.install = function (host, Ctor, opts) {
			if (!host.__mixins) {
				host.__mixins = [];
			}
			for (let i2 = 0; i2 < host.__mixins.length; i2++) {
				if (host.__mixins[i2].constructor === Ctor) {
					return host.__mixins[i2];
				}
			}
			const mixin = new Ctor(host, opts);
			host.__mixins.push(mixin);
			return mixin;
		};
		module2.exports = Mixin;
	}
});

// node_modules/parse5/lib/extensions/position-tracking/preprocessor-mixin.js
var require_preprocessor_mixin = __commonJS({
	'node_modules/parse5/lib/extensions/position-tracking/preprocessor-mixin.js'(exports, module2) {
		'use strict';
		var Mixin = require_mixin();
		var PositionTrackingPreprocessorMixin = class extends Mixin {
			constructor(preprocessor) {
				super(preprocessor);
				this.preprocessor = preprocessor;
				this.isEol = false;
				this.lineStartPos = 0;
				this.droppedBufferSize = 0;
				this.offset = 0;
				this.col = 0;
				this.line = 1;
			}
			_getOverriddenMethods(mxn, orig) {
				return {
					advance() {
						const pos = this.pos + 1;
						const ch = this.html[pos];
						if (mxn.isEol) {
							mxn.isEol = false;
							mxn.line++;
							mxn.lineStartPos = pos;
						}
						if (ch === '\n' || (ch === '\r' && this.html[pos + 1] !== '\n')) {
							mxn.isEol = true;
						}
						mxn.col = pos - mxn.lineStartPos + 1;
						mxn.offset = mxn.droppedBufferSize + pos;
						return orig.advance.call(this);
					},
					retreat() {
						orig.retreat.call(this);
						mxn.isEol = false;
						mxn.col = this.pos - mxn.lineStartPos + 1;
					},
					dropParsedChunk() {
						const prevPos = this.pos;
						orig.dropParsedChunk.call(this);
						const reduction = prevPos - this.pos;
						mxn.lineStartPos -= reduction;
						mxn.droppedBufferSize += reduction;
						mxn.offset = mxn.droppedBufferSize + this.pos;
					}
				};
			}
		};
		module2.exports = PositionTrackingPreprocessorMixin;
	}
});

// node_modules/parse5/lib/extensions/location-info/tokenizer-mixin.js
var require_tokenizer_mixin = __commonJS({
	'node_modules/parse5/lib/extensions/location-info/tokenizer-mixin.js'(exports, module2) {
		'use strict';
		var Mixin = require_mixin();
		var Tokenizer = require_tokenizer();
		var PositionTrackingPreprocessorMixin = require_preprocessor_mixin();
		var LocationInfoTokenizerMixin = class extends Mixin {
			constructor(tokenizer) {
				super(tokenizer);
				this.tokenizer = tokenizer;
				this.posTracker = Mixin.install(tokenizer.preprocessor, PositionTrackingPreprocessorMixin);
				this.currentAttrLocation = null;
				this.ctLoc = null;
			}
			_getCurrentLocation() {
				return {
					startLine: this.posTracker.line,
					startCol: this.posTracker.col,
					startOffset: this.posTracker.offset,
					endLine: -1,
					endCol: -1,
					endOffset: -1
				};
			}
			_attachCurrentAttrLocationInfo() {
				this.currentAttrLocation.endLine = this.posTracker.line;
				this.currentAttrLocation.endCol = this.posTracker.col;
				this.currentAttrLocation.endOffset = this.posTracker.offset;
				const currentToken = this.tokenizer.currentToken;
				const currentAttr = this.tokenizer.currentAttr;
				if (!currentToken.location.attrs) {
					currentToken.location.attrs = /* @__PURE__ */ Object.create(null);
				}
				currentToken.location.attrs[currentAttr.name] = this.currentAttrLocation;
			}
			_getOverriddenMethods(mxn, orig) {
				const methods2 = {
					_createStartTagToken() {
						orig._createStartTagToken.call(this);
						this.currentToken.location = mxn.ctLoc;
					},
					_createEndTagToken() {
						orig._createEndTagToken.call(this);
						this.currentToken.location = mxn.ctLoc;
					},
					_createCommentToken() {
						orig._createCommentToken.call(this);
						this.currentToken.location = mxn.ctLoc;
					},
					_createDoctypeToken(initialName) {
						orig._createDoctypeToken.call(this, initialName);
						this.currentToken.location = mxn.ctLoc;
					},
					_createCharacterToken(type, ch) {
						orig._createCharacterToken.call(this, type, ch);
						this.currentCharacterToken.location = mxn.ctLoc;
					},
					_createEOFToken() {
						orig._createEOFToken.call(this);
						this.currentToken.location = mxn._getCurrentLocation();
					},
					_createAttr(attrNameFirstCh) {
						orig._createAttr.call(this, attrNameFirstCh);
						mxn.currentAttrLocation = mxn._getCurrentLocation();
					},
					_leaveAttrName(toState) {
						orig._leaveAttrName.call(this, toState);
						mxn._attachCurrentAttrLocationInfo();
					},
					_leaveAttrValue(toState) {
						orig._leaveAttrValue.call(this, toState);
						mxn._attachCurrentAttrLocationInfo();
					},
					_emitCurrentToken() {
						const ctLoc = this.currentToken.location;
						if (this.currentCharacterToken) {
							this.currentCharacterToken.location.endLine = ctLoc.startLine;
							this.currentCharacterToken.location.endCol = ctLoc.startCol;
							this.currentCharacterToken.location.endOffset = ctLoc.startOffset;
						}
						if (this.currentToken.type === Tokenizer.EOF_TOKEN) {
							ctLoc.endLine = ctLoc.startLine;
							ctLoc.endCol = ctLoc.startCol;
							ctLoc.endOffset = ctLoc.startOffset;
						} else {
							ctLoc.endLine = mxn.posTracker.line;
							ctLoc.endCol = mxn.posTracker.col + 1;
							ctLoc.endOffset = mxn.posTracker.offset + 1;
						}
						orig._emitCurrentToken.call(this);
					},
					_emitCurrentCharacterToken() {
						const ctLoc = this.currentCharacterToken && this.currentCharacterToken.location;
						if (ctLoc && ctLoc.endOffset === -1) {
							ctLoc.endLine = mxn.posTracker.line;
							ctLoc.endCol = mxn.posTracker.col;
							ctLoc.endOffset = mxn.posTracker.offset;
						}
						orig._emitCurrentCharacterToken.call(this);
					}
				};
				Object.keys(Tokenizer.MODE).forEach((modeName) => {
					const state = Tokenizer.MODE[modeName];
					methods2[state] = function (cp) {
						mxn.ctLoc = mxn._getCurrentLocation();
						orig[state].call(this, cp);
					};
				});
				return methods2;
			}
		};
		module2.exports = LocationInfoTokenizerMixin;
	}
});

// node_modules/parse5/lib/extensions/location-info/open-element-stack-mixin.js
var require_open_element_stack_mixin = __commonJS({
	'node_modules/parse5/lib/extensions/location-info/open-element-stack-mixin.js'(exports, module2) {
		'use strict';
		var Mixin = require_mixin();
		var LocationInfoOpenElementStackMixin = class extends Mixin {
			constructor(stack, opts) {
				super(stack);
				this.onItemPop = opts.onItemPop;
			}
			_getOverriddenMethods(mxn, orig) {
				return {
					pop() {
						mxn.onItemPop(this.current);
						orig.pop.call(this);
					},
					popAllUpToHtmlElement() {
						for (let i2 = this.stackTop; i2 > 0; i2--) {
							mxn.onItemPop(this.items[i2]);
						}
						orig.popAllUpToHtmlElement.call(this);
					},
					remove(element4) {
						mxn.onItemPop(this.current);
						orig.remove.call(this, element4);
					}
				};
			}
		};
		module2.exports = LocationInfoOpenElementStackMixin;
	}
});

// node_modules/parse5/lib/extensions/location-info/parser-mixin.js
var require_parser_mixin = __commonJS({
	'node_modules/parse5/lib/extensions/location-info/parser-mixin.js'(exports, module2) {
		'use strict';
		var Mixin = require_mixin();
		var Tokenizer = require_tokenizer();
		var LocationInfoTokenizerMixin = require_tokenizer_mixin();
		var LocationInfoOpenElementStackMixin = require_open_element_stack_mixin();
		var HTML = require_html();
		var $ = HTML.TAG_NAMES;
		var LocationInfoParserMixin = class extends Mixin {
			constructor(parser) {
				super(parser);
				this.parser = parser;
				this.treeAdapter = this.parser.treeAdapter;
				this.posTracker = null;
				this.lastStartTagToken = null;
				this.lastFosterParentingLocation = null;
				this.currentToken = null;
			}
			_setStartLocation(element4) {
				let loc = null;
				if (this.lastStartTagToken) {
					loc = Object.assign({}, this.lastStartTagToken.location);
					loc.startTag = this.lastStartTagToken.location;
				}
				this.treeAdapter.setNodeSourceCodeLocation(element4, loc);
			}
			_setEndLocation(element4, closingToken) {
				const loc = this.treeAdapter.getNodeSourceCodeLocation(element4);
				if (loc) {
					if (closingToken.location) {
						const ctLoc = closingToken.location;
						const tn = this.treeAdapter.getTagName(element4);
						const isClosingEndTag =
							closingToken.type === Tokenizer.END_TAG_TOKEN && tn === closingToken.tagName;
						const endLoc = {};
						if (isClosingEndTag) {
							endLoc.endTag = Object.assign({}, ctLoc);
							endLoc.endLine = ctLoc.endLine;
							endLoc.endCol = ctLoc.endCol;
							endLoc.endOffset = ctLoc.endOffset;
						} else {
							endLoc.endLine = ctLoc.startLine;
							endLoc.endCol = ctLoc.startCol;
							endLoc.endOffset = ctLoc.startOffset;
						}
						this.treeAdapter.updateNodeSourceCodeLocation(element4, endLoc);
					}
				}
			}
			_getOverriddenMethods(mxn, orig) {
				return {
					_bootstrap(document4, fragmentContext) {
						orig._bootstrap.call(this, document4, fragmentContext);
						mxn.lastStartTagToken = null;
						mxn.lastFosterParentingLocation = null;
						mxn.currentToken = null;
						const tokenizerMixin = Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);
						mxn.posTracker = tokenizerMixin.posTracker;
						Mixin.install(this.openElements, LocationInfoOpenElementStackMixin, {
							onItemPop: function (element4) {
								mxn._setEndLocation(element4, mxn.currentToken);
							}
						});
					},
					_runParsingLoop(scriptHandler) {
						orig._runParsingLoop.call(this, scriptHandler);
						for (let i2 = this.openElements.stackTop; i2 >= 0; i2--) {
							mxn._setEndLocation(this.openElements.items[i2], mxn.currentToken);
						}
					},
					_processTokenInForeignContent(token) {
						mxn.currentToken = token;
						orig._processTokenInForeignContent.call(this, token);
					},
					_processToken(token) {
						mxn.currentToken = token;
						orig._processToken.call(this, token);
						const requireExplicitUpdate =
							token.type === Tokenizer.END_TAG_TOKEN &&
							(token.tagName === $.HTML ||
								(token.tagName === $.BODY && this.openElements.hasInScope($.BODY)));
						if (requireExplicitUpdate) {
							for (let i2 = this.openElements.stackTop; i2 >= 0; i2--) {
								const element4 = this.openElements.items[i2];
								if (this.treeAdapter.getTagName(element4) === token.tagName) {
									mxn._setEndLocation(element4, token);
									break;
								}
							}
						}
					},
					_setDocumentType(token) {
						orig._setDocumentType.call(this, token);
						const documentChildren = this.treeAdapter.getChildNodes(this.document);
						const cnLength = documentChildren.length;
						for (let i2 = 0; i2 < cnLength; i2++) {
							const node = documentChildren[i2];
							if (this.treeAdapter.isDocumentTypeNode(node)) {
								this.treeAdapter.setNodeSourceCodeLocation(node, token.location);
								break;
							}
						}
					},
					_attachElementToTree(element4) {
						mxn._setStartLocation(element4);
						mxn.lastStartTagToken = null;
						orig._attachElementToTree.call(this, element4);
					},
					_appendElement(token, namespaceURI) {
						mxn.lastStartTagToken = token;
						orig._appendElement.call(this, token, namespaceURI);
					},
					_insertElement(token, namespaceURI) {
						mxn.lastStartTagToken = token;
						orig._insertElement.call(this, token, namespaceURI);
					},
					_insertTemplate(token) {
						mxn.lastStartTagToken = token;
						orig._insertTemplate.call(this, token);
						const tmplContent = this.treeAdapter.getTemplateContent(this.openElements.current);
						this.treeAdapter.setNodeSourceCodeLocation(tmplContent, null);
					},
					_insertFakeRootElement() {
						orig._insertFakeRootElement.call(this);
						this.treeAdapter.setNodeSourceCodeLocation(this.openElements.current, null);
					},
					_appendCommentNode(token, parent) {
						orig._appendCommentNode.call(this, token, parent);
						const children = this.treeAdapter.getChildNodes(parent);
						const commentNode = children[children.length - 1];
						this.treeAdapter.setNodeSourceCodeLocation(commentNode, token.location);
					},
					_findFosterParentingLocation() {
						mxn.lastFosterParentingLocation = orig._findFosterParentingLocation.call(this);
						return mxn.lastFosterParentingLocation;
					},
					_insertCharacters(token) {
						orig._insertCharacters.call(this, token);
						const hasFosterParent = this._shouldFosterParentOnInsertion();
						const parent =
							(hasFosterParent && mxn.lastFosterParentingLocation.parent) ||
							this.openElements.currentTmplContent ||
							this.openElements.current;
						const siblings2 = this.treeAdapter.getChildNodes(parent);
						const textNodeIdx =
							hasFosterParent && mxn.lastFosterParentingLocation.beforeElement
								? siblings2.indexOf(mxn.lastFosterParentingLocation.beforeElement) - 1
								: siblings2.length - 1;
						const textNode = siblings2[textNodeIdx];
						const tnLoc = this.treeAdapter.getNodeSourceCodeLocation(textNode);
						if (tnLoc) {
							const { endLine, endCol, endOffset } = token.location;
							this.treeAdapter.updateNodeSourceCodeLocation(textNode, {
								endLine,
								endCol,
								endOffset
							});
						} else {
							this.treeAdapter.setNodeSourceCodeLocation(textNode, token.location);
						}
					}
				};
			}
		};
		module2.exports = LocationInfoParserMixin;
	}
});

// node_modules/parse5/lib/extensions/error-reporting/mixin-base.js
var require_mixin_base = __commonJS({
	'node_modules/parse5/lib/extensions/error-reporting/mixin-base.js'(exports, module2) {
		'use strict';
		var Mixin = require_mixin();
		var ErrorReportingMixinBase = class extends Mixin {
			constructor(host, opts) {
				super(host);
				this.posTracker = null;
				this.onParseError = opts.onParseError;
			}
			_setErrorLocation(err) {
				err.startLine = err.endLine = this.posTracker.line;
				err.startCol = err.endCol = this.posTracker.col;
				err.startOffset = err.endOffset = this.posTracker.offset;
			}
			_reportError(code3) {
				const err = {
					code: code3,
					startLine: -1,
					startCol: -1,
					startOffset: -1,
					endLine: -1,
					endCol: -1,
					endOffset: -1
				};
				this._setErrorLocation(err);
				this.onParseError(err);
			}
			_getOverriddenMethods(mxn) {
				return {
					_err(code3) {
						mxn._reportError(code3);
					}
				};
			}
		};
		module2.exports = ErrorReportingMixinBase;
	}
});

// node_modules/parse5/lib/extensions/error-reporting/preprocessor-mixin.js
var require_preprocessor_mixin2 = __commonJS({
	'node_modules/parse5/lib/extensions/error-reporting/preprocessor-mixin.js'(exports, module2) {
		'use strict';
		var ErrorReportingMixinBase = require_mixin_base();
		var PositionTrackingPreprocessorMixin = require_preprocessor_mixin();
		var Mixin = require_mixin();
		var ErrorReportingPreprocessorMixin = class extends ErrorReportingMixinBase {
			constructor(preprocessor, opts) {
				super(preprocessor, opts);
				this.posTracker = Mixin.install(preprocessor, PositionTrackingPreprocessorMixin);
				this.lastErrOffset = -1;
			}
			_reportError(code3) {
				if (this.lastErrOffset !== this.posTracker.offset) {
					this.lastErrOffset = this.posTracker.offset;
					super._reportError(code3);
				}
			}
		};
		module2.exports = ErrorReportingPreprocessorMixin;
	}
});

// node_modules/parse5/lib/extensions/error-reporting/tokenizer-mixin.js
var require_tokenizer_mixin2 = __commonJS({
	'node_modules/parse5/lib/extensions/error-reporting/tokenizer-mixin.js'(exports, module2) {
		'use strict';
		var ErrorReportingMixinBase = require_mixin_base();
		var ErrorReportingPreprocessorMixin = require_preprocessor_mixin2();
		var Mixin = require_mixin();
		var ErrorReportingTokenizerMixin = class extends ErrorReportingMixinBase {
			constructor(tokenizer, opts) {
				super(tokenizer, opts);
				const preprocessorMixin = Mixin.install(
					tokenizer.preprocessor,
					ErrorReportingPreprocessorMixin,
					opts
				);
				this.posTracker = preprocessorMixin.posTracker;
			}
		};
		module2.exports = ErrorReportingTokenizerMixin;
	}
});

// node_modules/parse5/lib/extensions/error-reporting/parser-mixin.js
var require_parser_mixin2 = __commonJS({
	'node_modules/parse5/lib/extensions/error-reporting/parser-mixin.js'(exports, module2) {
		'use strict';
		var ErrorReportingMixinBase = require_mixin_base();
		var ErrorReportingTokenizerMixin = require_tokenizer_mixin2();
		var LocationInfoTokenizerMixin = require_tokenizer_mixin();
		var Mixin = require_mixin();
		var ErrorReportingParserMixin = class extends ErrorReportingMixinBase {
			constructor(parser, opts) {
				super(parser, opts);
				this.opts = opts;
				this.ctLoc = null;
				this.locBeforeToken = false;
			}
			_setErrorLocation(err) {
				if (this.ctLoc) {
					err.startLine = this.ctLoc.startLine;
					err.startCol = this.ctLoc.startCol;
					err.startOffset = this.ctLoc.startOffset;
					err.endLine = this.locBeforeToken ? this.ctLoc.startLine : this.ctLoc.endLine;
					err.endCol = this.locBeforeToken ? this.ctLoc.startCol : this.ctLoc.endCol;
					err.endOffset = this.locBeforeToken ? this.ctLoc.startOffset : this.ctLoc.endOffset;
				}
			}
			_getOverriddenMethods(mxn, orig) {
				return {
					_bootstrap(document4, fragmentContext) {
						orig._bootstrap.call(this, document4, fragmentContext);
						Mixin.install(this.tokenizer, ErrorReportingTokenizerMixin, mxn.opts);
						Mixin.install(this.tokenizer, LocationInfoTokenizerMixin);
					},
					_processInputToken(token) {
						mxn.ctLoc = token.location;
						orig._processInputToken.call(this, token);
					},
					_err(code3, options) {
						mxn.locBeforeToken = options && options.beforeToken;
						mxn._reportError(code3);
					}
				};
			}
		};
		module2.exports = ErrorReportingParserMixin;
	}
});

// node_modules/parse5/lib/tree-adapters/default.js
var require_default = __commonJS({
	'node_modules/parse5/lib/tree-adapters/default.js'(exports) {
		'use strict';
		var { DOCUMENT_MODE } = require_html();
		exports.createDocument = function () {
			return {
				nodeName: '#document',
				mode: DOCUMENT_MODE.NO_QUIRKS,
				childNodes: []
			};
		};
		exports.createDocumentFragment = function () {
			return {
				nodeName: '#document-fragment',
				childNodes: []
			};
		};
		exports.createElement = function (tagName, namespaceURI, attrs) {
			return {
				nodeName: tagName,
				tagName,
				attrs,
				namespaceURI,
				childNodes: [],
				parentNode: null
			};
		};
		exports.createCommentNode = function (data2) {
			return {
				nodeName: '#comment',
				data: data2,
				parentNode: null
			};
		};
		var createTextNode = function (value) {
			return {
				nodeName: '#text',
				value,
				parentNode: null
			};
		};
		var appendChild = (exports.appendChild = function (parentNode, newNode) {
			parentNode.childNodes.push(newNode);
			newNode.parentNode = parentNode;
		});
		var insertBefore = (exports.insertBefore = function (parentNode, newNode, referenceNode) {
			const insertionIdx = parentNode.childNodes.indexOf(referenceNode);
			parentNode.childNodes.splice(insertionIdx, 0, newNode);
			newNode.parentNode = parentNode;
		});
		exports.setTemplateContent = function (templateElement, contentElement) {
			templateElement.content = contentElement;
		};
		exports.getTemplateContent = function (templateElement) {
			return templateElement.content;
		};
		exports.setDocumentType = function (document4, name, publicId, systemId) {
			let doctypeNode = null;
			for (let i2 = 0; i2 < document4.childNodes.length; i2++) {
				if (document4.childNodes[i2].nodeName === '#documentType') {
					doctypeNode = document4.childNodes[i2];
					break;
				}
			}
			if (doctypeNode) {
				doctypeNode.name = name;
				doctypeNode.publicId = publicId;
				doctypeNode.systemId = systemId;
			} else {
				appendChild(document4, {
					nodeName: '#documentType',
					name,
					publicId,
					systemId
				});
			}
		};
		exports.setDocumentMode = function (document4, mode) {
			document4.mode = mode;
		};
		exports.getDocumentMode = function (document4) {
			return document4.mode;
		};
		exports.detachNode = function (node) {
			if (node.parentNode) {
				const idx = node.parentNode.childNodes.indexOf(node);
				node.parentNode.childNodes.splice(idx, 1);
				node.parentNode = null;
			}
		};
		exports.insertText = function (parentNode, text7) {
			if (parentNode.childNodes.length) {
				const prevNode = parentNode.childNodes[parentNode.childNodes.length - 1];
				if (prevNode.nodeName === '#text') {
					prevNode.value += text7;
					return;
				}
			}
			appendChild(parentNode, createTextNode(text7));
		};
		exports.insertTextBefore = function (parentNode, text7, referenceNode) {
			const prevNode = parentNode.childNodes[parentNode.childNodes.indexOf(referenceNode) - 1];
			if (prevNode && prevNode.nodeName === '#text') {
				prevNode.value += text7;
			} else {
				insertBefore(parentNode, createTextNode(text7), referenceNode);
			}
		};
		exports.adoptAttributes = function (recipient, attrs) {
			const recipientAttrsMap = [];
			for (let i2 = 0; i2 < recipient.attrs.length; i2++) {
				recipientAttrsMap.push(recipient.attrs[i2].name);
			}
			for (let j = 0; j < attrs.length; j++) {
				if (recipientAttrsMap.indexOf(attrs[j].name) === -1) {
					recipient.attrs.push(attrs[j]);
				}
			}
		};
		exports.getFirstChild = function (node) {
			return node.childNodes[0];
		};
		exports.getChildNodes = function (node) {
			return node.childNodes;
		};
		exports.getParentNode = function (node) {
			return node.parentNode;
		};
		exports.getAttrList = function (element4) {
			return element4.attrs;
		};
		exports.getTagName = function (element4) {
			return element4.tagName;
		};
		exports.getNamespaceURI = function (element4) {
			return element4.namespaceURI;
		};
		exports.getTextNodeContent = function (textNode) {
			return textNode.value;
		};
		exports.getCommentNodeContent = function (commentNode) {
			return commentNode.data;
		};
		exports.getDocumentTypeNodeName = function (doctypeNode) {
			return doctypeNode.name;
		};
		exports.getDocumentTypeNodePublicId = function (doctypeNode) {
			return doctypeNode.publicId;
		};
		exports.getDocumentTypeNodeSystemId = function (doctypeNode) {
			return doctypeNode.systemId;
		};
		exports.isTextNode = function (node) {
			return node.nodeName === '#text';
		};
		exports.isCommentNode = function (node) {
			return node.nodeName === '#comment';
		};
		exports.isDocumentTypeNode = function (node) {
			return node.nodeName === '#documentType';
		};
		exports.isElementNode = function (node) {
			return !!node.tagName;
		};
		exports.setNodeSourceCodeLocation = function (node, location2) {
			node.sourceCodeLocation = location2;
		};
		exports.getNodeSourceCodeLocation = function (node) {
			return node.sourceCodeLocation;
		};
		exports.updateNodeSourceCodeLocation = function (node, endLocation) {
			node.sourceCodeLocation = Object.assign(node.sourceCodeLocation, endLocation);
		};
	}
});

// node_modules/parse5/lib/utils/merge-options.js
var require_merge_options = __commonJS({
	'node_modules/parse5/lib/utils/merge-options.js'(exports, module2) {
		'use strict';
		module2.exports = function mergeOptions(defaults, options) {
			options = options || /* @__PURE__ */ Object.create(null);
			return [defaults, options].reduce((merged, optObj) => {
				Object.keys(optObj).forEach((key3) => {
					merged[key3] = optObj[key3];
				});
				return merged;
			}, /* @__PURE__ */ Object.create(null));
		};
	}
});

// node_modules/parse5/lib/common/doctype.js
var require_doctype = __commonJS({
	'node_modules/parse5/lib/common/doctype.js'(exports) {
		'use strict';
		var { DOCUMENT_MODE } = require_html();
		var VALID_DOCTYPE_NAME = 'html';
		var VALID_SYSTEM_ID = 'about:legacy-compat';
		var QUIRKS_MODE_SYSTEM_ID = 'http://www.ibm.com/data/dtd/v11/ibmxhtml1-transitional.dtd';
		var QUIRKS_MODE_PUBLIC_ID_PREFIXES = [
			'+//silmaril//dtd html pro v0r11 19970101//',
			'-//as//dtd html 3.0 aswedit + extensions//',
			'-//advasoft ltd//dtd html 3.0 aswedit + extensions//',
			'-//ietf//dtd html 2.0 level 1//',
			'-//ietf//dtd html 2.0 level 2//',
			'-//ietf//dtd html 2.0 strict level 1//',
			'-//ietf//dtd html 2.0 strict level 2//',
			'-//ietf//dtd html 2.0 strict//',
			'-//ietf//dtd html 2.0//',
			'-//ietf//dtd html 2.1e//',
			'-//ietf//dtd html 3.0//',
			'-//ietf//dtd html 3.2 final//',
			'-//ietf//dtd html 3.2//',
			'-//ietf//dtd html 3//',
			'-//ietf//dtd html level 0//',
			'-//ietf//dtd html level 1//',
			'-//ietf//dtd html level 2//',
			'-//ietf//dtd html level 3//',
			'-//ietf//dtd html strict level 0//',
			'-//ietf//dtd html strict level 1//',
			'-//ietf//dtd html strict level 2//',
			'-//ietf//dtd html strict level 3//',
			'-//ietf//dtd html strict//',
			'-//ietf//dtd html//',
			'-//metrius//dtd metrius presentational//',
			'-//microsoft//dtd internet explorer 2.0 html strict//',
			'-//microsoft//dtd internet explorer 2.0 html//',
			'-//microsoft//dtd internet explorer 2.0 tables//',
			'-//microsoft//dtd internet explorer 3.0 html strict//',
			'-//microsoft//dtd internet explorer 3.0 html//',
			'-//microsoft//dtd internet explorer 3.0 tables//',
			'-//netscape comm. corp.//dtd html//',
			'-//netscape comm. corp.//dtd strict html//',
			"-//o'reilly and associates//dtd html 2.0//",
			"-//o'reilly and associates//dtd html extended 1.0//",
			"-//o'reilly and associates//dtd html extended relaxed 1.0//",
			'-//sq//dtd html 2.0 hotmetal + extensions//',
			'-//softquad software//dtd hotmetal pro 6.0::19990601::extensions to html 4.0//',
			'-//softquad//dtd hotmetal pro 4.0::19971010::extensions to html 4.0//',
			'-//spyglass//dtd html 2.0 extended//',
			'-//sun microsystems corp.//dtd hotjava html//',
			'-//sun microsystems corp.//dtd hotjava strict html//',
			'-//w3c//dtd html 3 1995-03-24//',
			'-//w3c//dtd html 3.2 draft//',
			'-//w3c//dtd html 3.2 final//',
			'-//w3c//dtd html 3.2//',
			'-//w3c//dtd html 3.2s draft//',
			'-//w3c//dtd html 4.0 frameset//',
			'-//w3c//dtd html 4.0 transitional//',
			'-//w3c//dtd html experimental 19960712//',
			'-//w3c//dtd html experimental 970421//',
			'-//w3c//dtd w3 html//',
			'-//w3o//dtd w3 html 3.0//',
			'-//webtechs//dtd mozilla html 2.0//',
			'-//webtechs//dtd mozilla html//'
		];
		var QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES = QUIRKS_MODE_PUBLIC_ID_PREFIXES.concat([
			'-//w3c//dtd html 4.01 frameset//',
			'-//w3c//dtd html 4.01 transitional//'
		]);
		var QUIRKS_MODE_PUBLIC_IDS = [
			'-//w3o//dtd w3 html strict 3.0//en//',
			'-/w3c/dtd html 4.0 transitional/en',
			'html'
		];
		var LIMITED_QUIRKS_PUBLIC_ID_PREFIXES = [
			'-//w3c//dtd xhtml 1.0 frameset//',
			'-//w3c//dtd xhtml 1.0 transitional//'
		];
		var LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES = LIMITED_QUIRKS_PUBLIC_ID_PREFIXES.concat(
			['-//w3c//dtd html 4.01 frameset//', '-//w3c//dtd html 4.01 transitional//']
		);
		function enquoteDoctypeId(id) {
			const quote = id.indexOf('"') !== -1 ? "'" : '"';
			return quote + id + quote;
		}
		function hasPrefix(publicId, prefixes) {
			for (let i2 = 0; i2 < prefixes.length; i2++) {
				if (publicId.indexOf(prefixes[i2]) === 0) {
					return true;
				}
			}
			return false;
		}
		exports.isConforming = function (token) {
			return (
				token.name === VALID_DOCTYPE_NAME &&
				token.publicId === null &&
				(token.systemId === null || token.systemId === VALID_SYSTEM_ID)
			);
		};
		exports.getDocumentMode = function (token) {
			if (token.name !== VALID_DOCTYPE_NAME) {
				return DOCUMENT_MODE.QUIRKS;
			}
			const systemId = token.systemId;
			if (systemId && systemId.toLowerCase() === QUIRKS_MODE_SYSTEM_ID) {
				return DOCUMENT_MODE.QUIRKS;
			}
			let publicId = token.publicId;
			if (publicId !== null) {
				publicId = publicId.toLowerCase();
				if (QUIRKS_MODE_PUBLIC_IDS.indexOf(publicId) > -1) {
					return DOCUMENT_MODE.QUIRKS;
				}
				let prefixes =
					systemId === null
						? QUIRKS_MODE_NO_SYSTEM_ID_PUBLIC_ID_PREFIXES
						: QUIRKS_MODE_PUBLIC_ID_PREFIXES;
				if (hasPrefix(publicId, prefixes)) {
					return DOCUMENT_MODE.QUIRKS;
				}
				prefixes =
					systemId === null
						? LIMITED_QUIRKS_PUBLIC_ID_PREFIXES
						: LIMITED_QUIRKS_WITH_SYSTEM_ID_PUBLIC_ID_PREFIXES;
				if (hasPrefix(publicId, prefixes)) {
					return DOCUMENT_MODE.LIMITED_QUIRKS;
				}
			}
			return DOCUMENT_MODE.NO_QUIRKS;
		};
		exports.serializeContent = function (name, publicId, systemId) {
			let str = '!DOCTYPE ';
			if (name) {
				str += name;
			}
			if (publicId) {
				str += ' PUBLIC ' + enquoteDoctypeId(publicId);
			} else if (systemId) {
				str += ' SYSTEM';
			}
			if (systemId !== null) {
				str += ' ' + enquoteDoctypeId(systemId);
			}
			return str;
		};
	}
});

// node_modules/parse5/lib/common/foreign-content.js
var require_foreign_content = __commonJS({
	'node_modules/parse5/lib/common/foreign-content.js'(exports) {
		'use strict';
		var Tokenizer = require_tokenizer();
		var HTML = require_html();
		var $ = HTML.TAG_NAMES;
		var NS = HTML.NAMESPACES;
		var ATTRS = HTML.ATTRS;
		var MIME_TYPES = {
			TEXT_HTML: 'text/html',
			APPLICATION_XML: 'application/xhtml+xml'
		};
		var DEFINITION_URL_ATTR = 'definitionurl';
		var ADJUSTED_DEFINITION_URL_ATTR = 'definitionURL';
		var SVG_ATTRS_ADJUSTMENT_MAP = {
			attributename: 'attributeName',
			attributetype: 'attributeType',
			basefrequency: 'baseFrequency',
			baseprofile: 'baseProfile',
			calcmode: 'calcMode',
			clippathunits: 'clipPathUnits',
			diffuseconstant: 'diffuseConstant',
			edgemode: 'edgeMode',
			filterunits: 'filterUnits',
			glyphref: 'glyphRef',
			gradienttransform: 'gradientTransform',
			gradientunits: 'gradientUnits',
			kernelmatrix: 'kernelMatrix',
			kernelunitlength: 'kernelUnitLength',
			keypoints: 'keyPoints',
			keysplines: 'keySplines',
			keytimes: 'keyTimes',
			lengthadjust: 'lengthAdjust',
			limitingconeangle: 'limitingConeAngle',
			markerheight: 'markerHeight',
			markerunits: 'markerUnits',
			markerwidth: 'markerWidth',
			maskcontentunits: 'maskContentUnits',
			maskunits: 'maskUnits',
			numoctaves: 'numOctaves',
			pathlength: 'pathLength',
			patterncontentunits: 'patternContentUnits',
			patterntransform: 'patternTransform',
			patternunits: 'patternUnits',
			pointsatx: 'pointsAtX',
			pointsaty: 'pointsAtY',
			pointsatz: 'pointsAtZ',
			preservealpha: 'preserveAlpha',
			preserveaspectratio: 'preserveAspectRatio',
			primitiveunits: 'primitiveUnits',
			refx: 'refX',
			refy: 'refY',
			repeatcount: 'repeatCount',
			repeatdur: 'repeatDur',
			requiredextensions: 'requiredExtensions',
			requiredfeatures: 'requiredFeatures',
			specularconstant: 'specularConstant',
			specularexponent: 'specularExponent',
			spreadmethod: 'spreadMethod',
			startoffset: 'startOffset',
			stddeviation: 'stdDeviation',
			stitchtiles: 'stitchTiles',
			surfacescale: 'surfaceScale',
			systemlanguage: 'systemLanguage',
			tablevalues: 'tableValues',
			targetx: 'targetX',
			targety: 'targetY',
			textlength: 'textLength',
			viewbox: 'viewBox',
			viewtarget: 'viewTarget',
			xchannelselector: 'xChannelSelector',
			ychannelselector: 'yChannelSelector',
			zoomandpan: 'zoomAndPan'
		};
		var XML_ATTRS_ADJUSTMENT_MAP = {
			'xlink:actuate': { prefix: 'xlink', name: 'actuate', namespace: NS.XLINK },
			'xlink:arcrole': { prefix: 'xlink', name: 'arcrole', namespace: NS.XLINK },
			'xlink:href': { prefix: 'xlink', name: 'href', namespace: NS.XLINK },
			'xlink:role': { prefix: 'xlink', name: 'role', namespace: NS.XLINK },
			'xlink:show': { prefix: 'xlink', name: 'show', namespace: NS.XLINK },
			'xlink:title': { prefix: 'xlink', name: 'title', namespace: NS.XLINK },
			'xlink:type': { prefix: 'xlink', name: 'type', namespace: NS.XLINK },
			'xml:base': { prefix: 'xml', name: 'base', namespace: NS.XML },
			'xml:lang': { prefix: 'xml', name: 'lang', namespace: NS.XML },
			'xml:space': { prefix: 'xml', name: 'space', namespace: NS.XML },
			xmlns: { prefix: '', name: 'xmlns', namespace: NS.XMLNS },
			'xmlns:xlink': { prefix: 'xmlns', name: 'xlink', namespace: NS.XMLNS }
		};
		var SVG_TAG_NAMES_ADJUSTMENT_MAP = (exports.SVG_TAG_NAMES_ADJUSTMENT_MAP = {
			altglyph: 'altGlyph',
			altglyphdef: 'altGlyphDef',
			altglyphitem: 'altGlyphItem',
			animatecolor: 'animateColor',
			animatemotion: 'animateMotion',
			animatetransform: 'animateTransform',
			clippath: 'clipPath',
			feblend: 'feBlend',
			fecolormatrix: 'feColorMatrix',
			fecomponenttransfer: 'feComponentTransfer',
			fecomposite: 'feComposite',
			feconvolvematrix: 'feConvolveMatrix',
			fediffuselighting: 'feDiffuseLighting',
			fedisplacementmap: 'feDisplacementMap',
			fedistantlight: 'feDistantLight',
			feflood: 'feFlood',
			fefunca: 'feFuncA',
			fefuncb: 'feFuncB',
			fefuncg: 'feFuncG',
			fefuncr: 'feFuncR',
			fegaussianblur: 'feGaussianBlur',
			feimage: 'feImage',
			femerge: 'feMerge',
			femergenode: 'feMergeNode',
			femorphology: 'feMorphology',
			feoffset: 'feOffset',
			fepointlight: 'fePointLight',
			fespecularlighting: 'feSpecularLighting',
			fespotlight: 'feSpotLight',
			fetile: 'feTile',
			feturbulence: 'feTurbulence',
			foreignobject: 'foreignObject',
			glyphref: 'glyphRef',
			lineargradient: 'linearGradient',
			radialgradient: 'radialGradient',
			textpath: 'textPath'
		});
		var EXITS_FOREIGN_CONTENT = {
			[$.B]: true,
			[$.BIG]: true,
			[$.BLOCKQUOTE]: true,
			[$.BODY]: true,
			[$.BR]: true,
			[$.CENTER]: true,
			[$.CODE]: true,
			[$.DD]: true,
			[$.DIV]: true,
			[$.DL]: true,
			[$.DT]: true,
			[$.EM]: true,
			[$.EMBED]: true,
			[$.H1]: true,
			[$.H2]: true,
			[$.H3]: true,
			[$.H4]: true,
			[$.H5]: true,
			[$.H6]: true,
			[$.HEAD]: true,
			[$.HR]: true,
			[$.I]: true,
			[$.IMG]: true,
			[$.LI]: true,
			[$.LISTING]: true,
			[$.MENU]: true,
			[$.META]: true,
			[$.NOBR]: true,
			[$.OL]: true,
			[$.P]: true,
			[$.PRE]: true,
			[$.RUBY]: true,
			[$.S]: true,
			[$.SMALL]: true,
			[$.SPAN]: true,
			[$.STRONG]: true,
			[$.STRIKE]: true,
			[$.SUB]: true,
			[$.SUP]: true,
			[$.TABLE]: true,
			[$.TT]: true,
			[$.U]: true,
			[$.UL]: true,
			[$.VAR]: true
		};
		exports.causesExit = function (startTagToken) {
			const tn = startTagToken.tagName;
			const isFontWithAttrs =
				tn === $.FONT &&
				(Tokenizer.getTokenAttr(startTagToken, ATTRS.COLOR) !== null ||
					Tokenizer.getTokenAttr(startTagToken, ATTRS.SIZE) !== null ||
					Tokenizer.getTokenAttr(startTagToken, ATTRS.FACE) !== null);
			return isFontWithAttrs ? true : EXITS_FOREIGN_CONTENT[tn];
		};
		exports.adjustTokenMathMLAttrs = function (token) {
			for (let i2 = 0; i2 < token.attrs.length; i2++) {
				if (token.attrs[i2].name === DEFINITION_URL_ATTR) {
					token.attrs[i2].name = ADJUSTED_DEFINITION_URL_ATTR;
					break;
				}
			}
		};
		exports.adjustTokenSVGAttrs = function (token) {
			for (let i2 = 0; i2 < token.attrs.length; i2++) {
				const adjustedAttrName = SVG_ATTRS_ADJUSTMENT_MAP[token.attrs[i2].name];
				if (adjustedAttrName) {
					token.attrs[i2].name = adjustedAttrName;
				}
			}
		};
		exports.adjustTokenXMLAttrs = function (token) {
			for (let i2 = 0; i2 < token.attrs.length; i2++) {
				const adjustedAttrEntry = XML_ATTRS_ADJUSTMENT_MAP[token.attrs[i2].name];
				if (adjustedAttrEntry) {
					token.attrs[i2].prefix = adjustedAttrEntry.prefix;
					token.attrs[i2].name = adjustedAttrEntry.name;
					token.attrs[i2].namespace = adjustedAttrEntry.namespace;
				}
			}
		};
		exports.adjustTokenSVGTagName = function (token) {
			const adjustedTagName = SVG_TAG_NAMES_ADJUSTMENT_MAP[token.tagName];
			if (adjustedTagName) {
				token.tagName = adjustedTagName;
			}
		};
		function isMathMLTextIntegrationPoint(tn, ns) {
			return (
				ns === NS.MATHML &&
				(tn === $.MI || tn === $.MO || tn === $.MN || tn === $.MS || tn === $.MTEXT)
			);
		}
		function isHtmlIntegrationPoint(tn, ns, attrs) {
			if (ns === NS.MATHML && tn === $.ANNOTATION_XML) {
				for (let i2 = 0; i2 < attrs.length; i2++) {
					if (attrs[i2].name === ATTRS.ENCODING) {
						const value = attrs[i2].value.toLowerCase();
						return value === MIME_TYPES.TEXT_HTML || value === MIME_TYPES.APPLICATION_XML;
					}
				}
			}
			return ns === NS.SVG && (tn === $.FOREIGN_OBJECT || tn === $.DESC || tn === $.TITLE);
		}
		exports.isIntegrationPoint = function (tn, ns, attrs, foreignNS) {
			if ((!foreignNS || foreignNS === NS.HTML) && isHtmlIntegrationPoint(tn, ns, attrs)) {
				return true;
			}
			if ((!foreignNS || foreignNS === NS.MATHML) && isMathMLTextIntegrationPoint(tn, ns)) {
				return true;
			}
			return false;
		};
	}
});

// node_modules/parse5/lib/parser/index.js
var require_parser = __commonJS({
	'node_modules/parse5/lib/parser/index.js'(exports, module2) {
		'use strict';
		var Tokenizer = require_tokenizer();
		var OpenElementStack = require_open_element_stack();
		var FormattingElementList = require_formatting_element_list();
		var LocationInfoParserMixin = require_parser_mixin();
		var ErrorReportingParserMixin = require_parser_mixin2();
		var Mixin = require_mixin();
		var defaultTreeAdapter = require_default();
		var mergeOptions = require_merge_options();
		var doctype3 = require_doctype();
		var foreignContent = require_foreign_content();
		var ERR = require_error_codes();
		var unicode = require_unicode();
		var HTML = require_html();
		var $ = HTML.TAG_NAMES;
		var NS = HTML.NAMESPACES;
		var ATTRS = HTML.ATTRS;
		var DEFAULT_OPTIONS = {
			scriptingEnabled: true,
			sourceCodeLocationInfo: false,
			onParseError: null,
			treeAdapter: defaultTreeAdapter
		};
		var HIDDEN_INPUT_TYPE = 'hidden';
		var AA_OUTER_LOOP_ITER = 8;
		var AA_INNER_LOOP_ITER = 3;
		var INITIAL_MODE = 'INITIAL_MODE';
		var BEFORE_HTML_MODE = 'BEFORE_HTML_MODE';
		var BEFORE_HEAD_MODE = 'BEFORE_HEAD_MODE';
		var IN_HEAD_MODE = 'IN_HEAD_MODE';
		var IN_HEAD_NO_SCRIPT_MODE = 'IN_HEAD_NO_SCRIPT_MODE';
		var AFTER_HEAD_MODE = 'AFTER_HEAD_MODE';
		var IN_BODY_MODE = 'IN_BODY_MODE';
		var TEXT_MODE = 'TEXT_MODE';
		var IN_TABLE_MODE = 'IN_TABLE_MODE';
		var IN_TABLE_TEXT_MODE = 'IN_TABLE_TEXT_MODE';
		var IN_CAPTION_MODE = 'IN_CAPTION_MODE';
		var IN_COLUMN_GROUP_MODE = 'IN_COLUMN_GROUP_MODE';
		var IN_TABLE_BODY_MODE = 'IN_TABLE_BODY_MODE';
		var IN_ROW_MODE = 'IN_ROW_MODE';
		var IN_CELL_MODE = 'IN_CELL_MODE';
		var IN_SELECT_MODE = 'IN_SELECT_MODE';
		var IN_SELECT_IN_TABLE_MODE = 'IN_SELECT_IN_TABLE_MODE';
		var IN_TEMPLATE_MODE = 'IN_TEMPLATE_MODE';
		var AFTER_BODY_MODE = 'AFTER_BODY_MODE';
		var IN_FRAMESET_MODE = 'IN_FRAMESET_MODE';
		var AFTER_FRAMESET_MODE = 'AFTER_FRAMESET_MODE';
		var AFTER_AFTER_BODY_MODE = 'AFTER_AFTER_BODY_MODE';
		var AFTER_AFTER_FRAMESET_MODE = 'AFTER_AFTER_FRAMESET_MODE';
		var INSERTION_MODE_RESET_MAP = {
			[$.TR]: IN_ROW_MODE,
			[$.TBODY]: IN_TABLE_BODY_MODE,
			[$.THEAD]: IN_TABLE_BODY_MODE,
			[$.TFOOT]: IN_TABLE_BODY_MODE,
			[$.CAPTION]: IN_CAPTION_MODE,
			[$.COLGROUP]: IN_COLUMN_GROUP_MODE,
			[$.TABLE]: IN_TABLE_MODE,
			[$.BODY]: IN_BODY_MODE,
			[$.FRAMESET]: IN_FRAMESET_MODE
		};
		var TEMPLATE_INSERTION_MODE_SWITCH_MAP = {
			[$.CAPTION]: IN_TABLE_MODE,
			[$.COLGROUP]: IN_TABLE_MODE,
			[$.TBODY]: IN_TABLE_MODE,
			[$.TFOOT]: IN_TABLE_MODE,
			[$.THEAD]: IN_TABLE_MODE,
			[$.COL]: IN_COLUMN_GROUP_MODE,
			[$.TR]: IN_TABLE_BODY_MODE,
			[$.TD]: IN_ROW_MODE,
			[$.TH]: IN_ROW_MODE
		};
		var TOKEN_HANDLERS = {
			[INITIAL_MODE]: {
				[Tokenizer.CHARACTER_TOKEN]: tokenInInitialMode,
				[Tokenizer.NULL_CHARACTER_TOKEN]: tokenInInitialMode,
				[Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
				[Tokenizer.COMMENT_TOKEN]: appendComment,
				[Tokenizer.DOCTYPE_TOKEN]: doctypeInInitialMode,
				[Tokenizer.START_TAG_TOKEN]: tokenInInitialMode,
				[Tokenizer.END_TAG_TOKEN]: tokenInInitialMode,
				[Tokenizer.EOF_TOKEN]: tokenInInitialMode
			},
			[BEFORE_HTML_MODE]: {
				[Tokenizer.CHARACTER_TOKEN]: tokenBeforeHtml,
				[Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHtml,
				[Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
				[Tokenizer.COMMENT_TOKEN]: appendComment,
				[Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
				[Tokenizer.START_TAG_TOKEN]: startTagBeforeHtml,
				[Tokenizer.END_TAG_TOKEN]: endTagBeforeHtml,
				[Tokenizer.EOF_TOKEN]: tokenBeforeHtml
			},
			[BEFORE_HEAD_MODE]: {
				[Tokenizer.CHARACTER_TOKEN]: tokenBeforeHead,
				[Tokenizer.NULL_CHARACTER_TOKEN]: tokenBeforeHead,
				[Tokenizer.WHITESPACE_CHARACTER_TOKEN]: ignoreToken,
				[Tokenizer.COMMENT_TOKEN]: appendComment,
				[Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
				[Tokenizer.START_TAG_TOKEN]: startTagBeforeHead,
				[Tokenizer.END_TAG_TOKEN]: endTagBeforeHead,
				[Tokenizer.EOF_TOKEN]: tokenBeforeHead
			},
			[IN_HEAD_MODE]: {
				[Tokenizer.CHARACTER_TOKEN]: tokenInHead,
				[Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHead,
				[Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
				[Tokenizer.COMMENT_TOKEN]: appendComment,
				[Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
				[Tokenizer.START_TAG_TOKEN]: startTagInHead,
				[Tokenizer.END_TAG_TOKEN]: endTagInHead,
				[Tokenizer.EOF_TOKEN]: tokenInHead
			},
			[IN_HEAD_NO_SCRIPT_MODE]: {
				[Tokenizer.CHARACTER_TOKEN]: tokenInHeadNoScript,
				[Tokenizer.NULL_CHARACTER_TOKEN]: tokenInHeadNoScript,
				[Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
				[Tokenizer.COMMENT_TOKEN]: appendComment,
				[Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
				[Tokenizer.START_TAG_TOKEN]: startTagInHeadNoScript,
				[Tokenizer.END_TAG_TOKEN]: endTagInHeadNoScript,
				[Tokenizer.EOF_TOKEN]: tokenInHeadNoScript
			},
			[AFTER_HEAD_MODE]: {
				[Tokenizer.CHARACTER_TOKEN]: tokenAfterHead,
				[Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterHead,
				[Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
				[Tokenizer.COMMENT_TOKEN]: appendComment,
				[Tokenizer.DOCTYPE_TOKEN]: misplacedDoctype,
				[Tokenizer.START_TAG_TOKEN]: startTagAfterHead,
				[Tokenizer.END_TAG_TOKEN]: endTagAfterHead,
				[Tokenizer.EOF_TOKEN]: tokenAfterHead
			},
			[IN_BODY_MODE]: {
				[Tokenizer.CHARACTER_TOKEN]: characterInBody,
				[Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
				[Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
				[Tokenizer.COMMENT_TOKEN]: appendComment,
				[Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
				[Tokenizer.START_TAG_TOKEN]: startTagInBody,
				[Tokenizer.END_TAG_TOKEN]: endTagInBody,
				[Tokenizer.EOF_TOKEN]: eofInBody
			},
			[TEXT_MODE]: {
				[Tokenizer.CHARACTER_TOKEN]: insertCharacters,
				[Tokenizer.NULL_CHARACTER_TOKEN]: insertCharacters,
				[Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
				[Tokenizer.COMMENT_TOKEN]: ignoreToken,
				[Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
				[Tokenizer.START_TAG_TOKEN]: ignoreToken,
				[Tokenizer.END_TAG_TOKEN]: endTagInText,
				[Tokenizer.EOF_TOKEN]: eofInText
			},
			[IN_TABLE_MODE]: {
				[Tokenizer.CHARACTER_TOKEN]: characterInTable,
				[Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
				[Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
				[Tokenizer.COMMENT_TOKEN]: appendComment,
				[Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
				[Tokenizer.START_TAG_TOKEN]: startTagInTable,
				[Tokenizer.END_TAG_TOKEN]: endTagInTable,
				[Tokenizer.EOF_TOKEN]: eofInBody
			},
			[IN_TABLE_TEXT_MODE]: {
				[Tokenizer.CHARACTER_TOKEN]: characterInTableText,
				[Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
				[Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInTableText,
				[Tokenizer.COMMENT_TOKEN]: tokenInTableText,
				[Tokenizer.DOCTYPE_TOKEN]: tokenInTableText,
				[Tokenizer.START_TAG_TOKEN]: tokenInTableText,
				[Tokenizer.END_TAG_TOKEN]: tokenInTableText,
				[Tokenizer.EOF_TOKEN]: tokenInTableText
			},
			[IN_CAPTION_MODE]: {
				[Tokenizer.CHARACTER_TOKEN]: characterInBody,
				[Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
				[Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
				[Tokenizer.COMMENT_TOKEN]: appendComment,
				[Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
				[Tokenizer.START_TAG_TOKEN]: startTagInCaption,
				[Tokenizer.END_TAG_TOKEN]: endTagInCaption,
				[Tokenizer.EOF_TOKEN]: eofInBody
			},
			[IN_COLUMN_GROUP_MODE]: {
				[Tokenizer.CHARACTER_TOKEN]: tokenInColumnGroup,
				[Tokenizer.NULL_CHARACTER_TOKEN]: tokenInColumnGroup,
				[Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
				[Tokenizer.COMMENT_TOKEN]: appendComment,
				[Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
				[Tokenizer.START_TAG_TOKEN]: startTagInColumnGroup,
				[Tokenizer.END_TAG_TOKEN]: endTagInColumnGroup,
				[Tokenizer.EOF_TOKEN]: eofInBody
			},
			[IN_TABLE_BODY_MODE]: {
				[Tokenizer.CHARACTER_TOKEN]: characterInTable,
				[Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
				[Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
				[Tokenizer.COMMENT_TOKEN]: appendComment,
				[Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
				[Tokenizer.START_TAG_TOKEN]: startTagInTableBody,
				[Tokenizer.END_TAG_TOKEN]: endTagInTableBody,
				[Tokenizer.EOF_TOKEN]: eofInBody
			},
			[IN_ROW_MODE]: {
				[Tokenizer.CHARACTER_TOKEN]: characterInTable,
				[Tokenizer.NULL_CHARACTER_TOKEN]: characterInTable,
				[Tokenizer.WHITESPACE_CHARACTER_TOKEN]: characterInTable,
				[Tokenizer.COMMENT_TOKEN]: appendComment,
				[Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
				[Tokenizer.START_TAG_TOKEN]: startTagInRow,
				[Tokenizer.END_TAG_TOKEN]: endTagInRow,
				[Tokenizer.EOF_TOKEN]: eofInBody
			},
			[IN_CELL_MODE]: {
				[Tokenizer.CHARACTER_TOKEN]: characterInBody,
				[Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
				[Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
				[Tokenizer.COMMENT_TOKEN]: appendComment,
				[Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
				[Tokenizer.START_TAG_TOKEN]: startTagInCell,
				[Tokenizer.END_TAG_TOKEN]: endTagInCell,
				[Tokenizer.EOF_TOKEN]: eofInBody
			},
			[IN_SELECT_MODE]: {
				[Tokenizer.CHARACTER_TOKEN]: insertCharacters,
				[Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
				[Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
				[Tokenizer.COMMENT_TOKEN]: appendComment,
				[Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
				[Tokenizer.START_TAG_TOKEN]: startTagInSelect,
				[Tokenizer.END_TAG_TOKEN]: endTagInSelect,
				[Tokenizer.EOF_TOKEN]: eofInBody
			},
			[IN_SELECT_IN_TABLE_MODE]: {
				[Tokenizer.CHARACTER_TOKEN]: insertCharacters,
				[Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
				[Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
				[Tokenizer.COMMENT_TOKEN]: appendComment,
				[Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
				[Tokenizer.START_TAG_TOKEN]: startTagInSelectInTable,
				[Tokenizer.END_TAG_TOKEN]: endTagInSelectInTable,
				[Tokenizer.EOF_TOKEN]: eofInBody
			},
			[IN_TEMPLATE_MODE]: {
				[Tokenizer.CHARACTER_TOKEN]: characterInBody,
				[Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
				[Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
				[Tokenizer.COMMENT_TOKEN]: appendComment,
				[Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
				[Tokenizer.START_TAG_TOKEN]: startTagInTemplate,
				[Tokenizer.END_TAG_TOKEN]: endTagInTemplate,
				[Tokenizer.EOF_TOKEN]: eofInTemplate
			},
			[AFTER_BODY_MODE]: {
				[Tokenizer.CHARACTER_TOKEN]: tokenAfterBody,
				[Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterBody,
				[Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
				[Tokenizer.COMMENT_TOKEN]: appendCommentToRootHtmlElement,
				[Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
				[Tokenizer.START_TAG_TOKEN]: startTagAfterBody,
				[Tokenizer.END_TAG_TOKEN]: endTagAfterBody,
				[Tokenizer.EOF_TOKEN]: stopParsing
			},
			[IN_FRAMESET_MODE]: {
				[Tokenizer.CHARACTER_TOKEN]: ignoreToken,
				[Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
				[Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
				[Tokenizer.COMMENT_TOKEN]: appendComment,
				[Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
				[Tokenizer.START_TAG_TOKEN]: startTagInFrameset,
				[Tokenizer.END_TAG_TOKEN]: endTagInFrameset,
				[Tokenizer.EOF_TOKEN]: stopParsing
			},
			[AFTER_FRAMESET_MODE]: {
				[Tokenizer.CHARACTER_TOKEN]: ignoreToken,
				[Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
				[Tokenizer.WHITESPACE_CHARACTER_TOKEN]: insertCharacters,
				[Tokenizer.COMMENT_TOKEN]: appendComment,
				[Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
				[Tokenizer.START_TAG_TOKEN]: startTagAfterFrameset,
				[Tokenizer.END_TAG_TOKEN]: endTagAfterFrameset,
				[Tokenizer.EOF_TOKEN]: stopParsing
			},
			[AFTER_AFTER_BODY_MODE]: {
				[Tokenizer.CHARACTER_TOKEN]: tokenAfterAfterBody,
				[Tokenizer.NULL_CHARACTER_TOKEN]: tokenAfterAfterBody,
				[Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
				[Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,
				[Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
				[Tokenizer.START_TAG_TOKEN]: startTagAfterAfterBody,
				[Tokenizer.END_TAG_TOKEN]: tokenAfterAfterBody,
				[Tokenizer.EOF_TOKEN]: stopParsing
			},
			[AFTER_AFTER_FRAMESET_MODE]: {
				[Tokenizer.CHARACTER_TOKEN]: ignoreToken,
				[Tokenizer.NULL_CHARACTER_TOKEN]: ignoreToken,
				[Tokenizer.WHITESPACE_CHARACTER_TOKEN]: whitespaceCharacterInBody,
				[Tokenizer.COMMENT_TOKEN]: appendCommentToDocument,
				[Tokenizer.DOCTYPE_TOKEN]: ignoreToken,
				[Tokenizer.START_TAG_TOKEN]: startTagAfterAfterFrameset,
				[Tokenizer.END_TAG_TOKEN]: ignoreToken,
				[Tokenizer.EOF_TOKEN]: stopParsing
			}
		};
		var Parser2 = class {
			constructor(options) {
				this.options = mergeOptions(DEFAULT_OPTIONS, options);
				this.treeAdapter = this.options.treeAdapter;
				this.pendingScript = null;
				if (this.options.sourceCodeLocationInfo) {
					Mixin.install(this, LocationInfoParserMixin);
				}
				if (this.options.onParseError) {
					Mixin.install(this, ErrorReportingParserMixin, {
						onParseError: this.options.onParseError
					});
				}
			}
			parse(html9) {
				const document4 = this.treeAdapter.createDocument();
				this._bootstrap(document4, null);
				this.tokenizer.write(html9, true);
				this._runParsingLoop(null);
				return document4;
			}
			parseFragment(html9, fragmentContext) {
				if (!fragmentContext) {
					fragmentContext = this.treeAdapter.createElement($.TEMPLATE, NS.HTML, []);
				}
				const documentMock = this.treeAdapter.createElement('documentmock', NS.HTML, []);
				this._bootstrap(documentMock, fragmentContext);
				if (this.treeAdapter.getTagName(fragmentContext) === $.TEMPLATE) {
					this._pushTmplInsertionMode(IN_TEMPLATE_MODE);
				}
				this._initTokenizerForFragmentParsing();
				this._insertFakeRootElement();
				this._resetInsertionMode();
				this._findFormInFragmentContext();
				this.tokenizer.write(html9, true);
				this._runParsingLoop(null);
				const rootElement = this.treeAdapter.getFirstChild(documentMock);
				const fragment = this.treeAdapter.createDocumentFragment();
				this._adoptNodes(rootElement, fragment);
				return fragment;
			}
			_bootstrap(document4, fragmentContext) {
				this.tokenizer = new Tokenizer(this.options);
				this.stopped = false;
				this.insertionMode = INITIAL_MODE;
				this.originalInsertionMode = '';
				this.document = document4;
				this.fragmentContext = fragmentContext;
				this.headElement = null;
				this.formElement = null;
				this.openElements = new OpenElementStack(this.document, this.treeAdapter);
				this.activeFormattingElements = new FormattingElementList(this.treeAdapter);
				this.tmplInsertionModeStack = [];
				this.tmplInsertionModeStackTop = -1;
				this.currentTmplInsertionMode = null;
				this.pendingCharacterTokens = [];
				this.hasNonWhitespacePendingCharacterToken = false;
				this.framesetOk = true;
				this.skipNextNewLine = false;
				this.fosterParentingEnabled = false;
			}
			_err() {}
			_runParsingLoop(scriptHandler) {
				while (!this.stopped) {
					this._setupTokenizerCDATAMode();
					const token = this.tokenizer.getNextToken();
					if (token.type === Tokenizer.HIBERNATION_TOKEN) {
						break;
					}
					if (this.skipNextNewLine) {
						this.skipNextNewLine = false;
						if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN && token.chars[0] === '\n') {
							if (token.chars.length === 1) {
								continue;
							}
							token.chars = token.chars.substr(1);
						}
					}
					this._processInputToken(token);
					if (scriptHandler && this.pendingScript) {
						break;
					}
				}
			}
			runParsingLoopForCurrentChunk(writeCallback, scriptHandler) {
				this._runParsingLoop(scriptHandler);
				if (scriptHandler && this.pendingScript) {
					const script = this.pendingScript;
					this.pendingScript = null;
					scriptHandler(script);
					return;
				}
				if (writeCallback) {
					writeCallback();
				}
			}
			_setupTokenizerCDATAMode() {
				const current = this._getAdjustedCurrentElement();
				this.tokenizer.allowCDATA =
					current &&
					current !== this.document &&
					this.treeAdapter.getNamespaceURI(current) !== NS.HTML &&
					!this._isIntegrationPoint(current);
			}
			_switchToTextParsing(currentToken, nextTokenizerState) {
				this._insertElement(currentToken, NS.HTML);
				this.tokenizer.state = nextTokenizerState;
				this.originalInsertionMode = this.insertionMode;
				this.insertionMode = TEXT_MODE;
			}
			switchToPlaintextParsing() {
				this.insertionMode = TEXT_MODE;
				this.originalInsertionMode = IN_BODY_MODE;
				this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
			}
			_getAdjustedCurrentElement() {
				return this.openElements.stackTop === 0 && this.fragmentContext
					? this.fragmentContext
					: this.openElements.current;
			}
			_findFormInFragmentContext() {
				let node = this.fragmentContext;
				do {
					if (this.treeAdapter.getTagName(node) === $.FORM) {
						this.formElement = node;
						break;
					}
					node = this.treeAdapter.getParentNode(node);
				} while (node);
			}
			_initTokenizerForFragmentParsing() {
				if (this.treeAdapter.getNamespaceURI(this.fragmentContext) === NS.HTML) {
					const tn = this.treeAdapter.getTagName(this.fragmentContext);
					if (tn === $.TITLE || tn === $.TEXTAREA) {
						this.tokenizer.state = Tokenizer.MODE.RCDATA;
					} else if (
						tn === $.STYLE ||
						tn === $.XMP ||
						tn === $.IFRAME ||
						tn === $.NOEMBED ||
						tn === $.NOFRAMES ||
						tn === $.NOSCRIPT
					) {
						this.tokenizer.state = Tokenizer.MODE.RAWTEXT;
					} else if (tn === $.SCRIPT) {
						this.tokenizer.state = Tokenizer.MODE.SCRIPT_DATA;
					} else if (tn === $.PLAINTEXT) {
						this.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
					}
				}
			}
			_setDocumentType(token) {
				const name = token.name || '';
				const publicId = token.publicId || '';
				const systemId = token.systemId || '';
				this.treeAdapter.setDocumentType(this.document, name, publicId, systemId);
			}
			_attachElementToTree(element4) {
				if (this._shouldFosterParentOnInsertion()) {
					this._fosterParentElement(element4);
				} else {
					const parent = this.openElements.currentTmplContent || this.openElements.current;
					this.treeAdapter.appendChild(parent, element4);
				}
			}
			_appendElement(token, namespaceURI) {
				const element4 = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
				this._attachElementToTree(element4);
			}
			_insertElement(token, namespaceURI) {
				const element4 = this.treeAdapter.createElement(token.tagName, namespaceURI, token.attrs);
				this._attachElementToTree(element4);
				this.openElements.push(element4);
			}
			_insertFakeElement(tagName) {
				const element4 = this.treeAdapter.createElement(tagName, NS.HTML, []);
				this._attachElementToTree(element4);
				this.openElements.push(element4);
			}
			_insertTemplate(token) {
				const tmpl = this.treeAdapter.createElement(token.tagName, NS.HTML, token.attrs);
				const content3 = this.treeAdapter.createDocumentFragment();
				this.treeAdapter.setTemplateContent(tmpl, content3);
				this._attachElementToTree(tmpl);
				this.openElements.push(tmpl);
			}
			_insertFakeRootElement() {
				const element4 = this.treeAdapter.createElement($.HTML, NS.HTML, []);
				this.treeAdapter.appendChild(this.openElements.current, element4);
				this.openElements.push(element4);
			}
			_appendCommentNode(token, parent) {
				const commentNode = this.treeAdapter.createCommentNode(token.data);
				this.treeAdapter.appendChild(parent, commentNode);
			}
			_insertCharacters(token) {
				if (this._shouldFosterParentOnInsertion()) {
					this._fosterParentText(token.chars);
				} else {
					const parent = this.openElements.currentTmplContent || this.openElements.current;
					this.treeAdapter.insertText(parent, token.chars);
				}
			}
			_adoptNodes(donor, recipient) {
				for (
					let child = this.treeAdapter.getFirstChild(donor);
					child;
					child = this.treeAdapter.getFirstChild(donor)
				) {
					this.treeAdapter.detachNode(child);
					this.treeAdapter.appendChild(recipient, child);
				}
			}
			_shouldProcessTokenInForeignContent(token) {
				const current = this._getAdjustedCurrentElement();
				if (!current || current === this.document) {
					return false;
				}
				const ns = this.treeAdapter.getNamespaceURI(current);
				if (ns === NS.HTML) {
					return false;
				}
				if (
					this.treeAdapter.getTagName(current) === $.ANNOTATION_XML &&
					ns === NS.MATHML &&
					token.type === Tokenizer.START_TAG_TOKEN &&
					token.tagName === $.SVG
				) {
					return false;
				}
				const isCharacterToken =
					token.type === Tokenizer.CHARACTER_TOKEN ||
					token.type === Tokenizer.NULL_CHARACTER_TOKEN ||
					token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN;
				const isMathMLTextStartTag =
					token.type === Tokenizer.START_TAG_TOKEN &&
					token.tagName !== $.MGLYPH &&
					token.tagName !== $.MALIGNMARK;
				if (
					(isMathMLTextStartTag || isCharacterToken) &&
					this._isIntegrationPoint(current, NS.MATHML)
				) {
					return false;
				}
				if (
					(token.type === Tokenizer.START_TAG_TOKEN || isCharacterToken) &&
					this._isIntegrationPoint(current, NS.HTML)
				) {
					return false;
				}
				return token.type !== Tokenizer.EOF_TOKEN;
			}
			_processToken(token) {
				TOKEN_HANDLERS[this.insertionMode][token.type](this, token);
			}
			_processTokenInBodyMode(token) {
				TOKEN_HANDLERS[IN_BODY_MODE][token.type](this, token);
			}
			_processTokenInForeignContent(token) {
				if (token.type === Tokenizer.CHARACTER_TOKEN) {
					characterInForeignContent(this, token);
				} else if (token.type === Tokenizer.NULL_CHARACTER_TOKEN) {
					nullCharacterInForeignContent(this, token);
				} else if (token.type === Tokenizer.WHITESPACE_CHARACTER_TOKEN) {
					insertCharacters(this, token);
				} else if (token.type === Tokenizer.COMMENT_TOKEN) {
					appendComment(this, token);
				} else if (token.type === Tokenizer.START_TAG_TOKEN) {
					startTagInForeignContent(this, token);
				} else if (token.type === Tokenizer.END_TAG_TOKEN) {
					endTagInForeignContent(this, token);
				}
			}
			_processInputToken(token) {
				if (this._shouldProcessTokenInForeignContent(token)) {
					this._processTokenInForeignContent(token);
				} else {
					this._processToken(token);
				}
				if (
					token.type === Tokenizer.START_TAG_TOKEN &&
					token.selfClosing &&
					!token.ackSelfClosing
				) {
					this._err(ERR.nonVoidHtmlElementStartTagWithTrailingSolidus);
				}
			}
			_isIntegrationPoint(element4, foreignNS) {
				const tn = this.treeAdapter.getTagName(element4);
				const ns = this.treeAdapter.getNamespaceURI(element4);
				const attrs = this.treeAdapter.getAttrList(element4);
				return foreignContent.isIntegrationPoint(tn, ns, attrs, foreignNS);
			}
			_reconstructActiveFormattingElements() {
				const listLength = this.activeFormattingElements.length;
				if (listLength) {
					let unopenIdx = listLength;
					let entry5 = null;
					do {
						unopenIdx--;
						entry5 = this.activeFormattingElements.entries[unopenIdx];
						if (
							entry5.type === FormattingElementList.MARKER_ENTRY ||
							this.openElements.contains(entry5.element)
						) {
							unopenIdx++;
							break;
						}
					} while (unopenIdx > 0);
					for (let i2 = unopenIdx; i2 < listLength; i2++) {
						entry5 = this.activeFormattingElements.entries[i2];
						this._insertElement(entry5.token, this.treeAdapter.getNamespaceURI(entry5.element));
						entry5.element = this.openElements.current;
					}
				}
			}
			_closeTableCell() {
				this.openElements.generateImpliedEndTags();
				this.openElements.popUntilTableCellPopped();
				this.activeFormattingElements.clearToLastMarker();
				this.insertionMode = IN_ROW_MODE;
			}
			_closePElement() {
				this.openElements.generateImpliedEndTagsWithExclusion($.P);
				this.openElements.popUntilTagNamePopped($.P);
			}
			_resetInsertionMode() {
				for (let i2 = this.openElements.stackTop, last = false; i2 >= 0; i2--) {
					let element4 = this.openElements.items[i2];
					if (i2 === 0) {
						last = true;
						if (this.fragmentContext) {
							element4 = this.fragmentContext;
						}
					}
					const tn = this.treeAdapter.getTagName(element4);
					const newInsertionMode = INSERTION_MODE_RESET_MAP[tn];
					if (newInsertionMode) {
						this.insertionMode = newInsertionMode;
						break;
					} else if (!last && (tn === $.TD || tn === $.TH)) {
						this.insertionMode = IN_CELL_MODE;
						break;
					} else if (!last && tn === $.HEAD) {
						this.insertionMode = IN_HEAD_MODE;
						break;
					} else if (tn === $.SELECT) {
						this._resetInsertionModeForSelect(i2);
						break;
					} else if (tn === $.TEMPLATE) {
						this.insertionMode = this.currentTmplInsertionMode;
						break;
					} else if (tn === $.HTML) {
						this.insertionMode = this.headElement ? AFTER_HEAD_MODE : BEFORE_HEAD_MODE;
						break;
					} else if (last) {
						this.insertionMode = IN_BODY_MODE;
						break;
					}
				}
			}
			_resetInsertionModeForSelect(selectIdx) {
				if (selectIdx > 0) {
					for (let i2 = selectIdx - 1; i2 > 0; i2--) {
						const ancestor = this.openElements.items[i2];
						const tn = this.treeAdapter.getTagName(ancestor);
						if (tn === $.TEMPLATE) {
							break;
						} else if (tn === $.TABLE) {
							this.insertionMode = IN_SELECT_IN_TABLE_MODE;
							return;
						}
					}
				}
				this.insertionMode = IN_SELECT_MODE;
			}
			_pushTmplInsertionMode(mode) {
				this.tmplInsertionModeStack.push(mode);
				this.tmplInsertionModeStackTop++;
				this.currentTmplInsertionMode = mode;
			}
			_popTmplInsertionMode() {
				this.tmplInsertionModeStack.pop();
				this.tmplInsertionModeStackTop--;
				this.currentTmplInsertionMode = this.tmplInsertionModeStack[this.tmplInsertionModeStackTop];
			}
			_isElementCausesFosterParenting(element4) {
				const tn = this.treeAdapter.getTagName(element4);
				return tn === $.TABLE || tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD || tn === $.TR;
			}
			_shouldFosterParentOnInsertion() {
				return (
					this.fosterParentingEnabled &&
					this._isElementCausesFosterParenting(this.openElements.current)
				);
			}
			_findFosterParentingLocation() {
				const location2 = {
					parent: null,
					beforeElement: null
				};
				for (let i2 = this.openElements.stackTop; i2 >= 0; i2--) {
					const openElement = this.openElements.items[i2];
					const tn = this.treeAdapter.getTagName(openElement);
					const ns = this.treeAdapter.getNamespaceURI(openElement);
					if (tn === $.TEMPLATE && ns === NS.HTML) {
						location2.parent = this.treeAdapter.getTemplateContent(openElement);
						break;
					} else if (tn === $.TABLE) {
						location2.parent = this.treeAdapter.getParentNode(openElement);
						if (location2.parent) {
							location2.beforeElement = openElement;
						} else {
							location2.parent = this.openElements.items[i2 - 1];
						}
						break;
					}
				}
				if (!location2.parent) {
					location2.parent = this.openElements.items[0];
				}
				return location2;
			}
			_fosterParentElement(element4) {
				const location2 = this._findFosterParentingLocation();
				if (location2.beforeElement) {
					this.treeAdapter.insertBefore(location2.parent, element4, location2.beforeElement);
				} else {
					this.treeAdapter.appendChild(location2.parent, element4);
				}
			}
			_fosterParentText(chars2) {
				const location2 = this._findFosterParentingLocation();
				if (location2.beforeElement) {
					this.treeAdapter.insertTextBefore(location2.parent, chars2, location2.beforeElement);
				} else {
					this.treeAdapter.insertText(location2.parent, chars2);
				}
			}
			_isSpecialElement(element4) {
				const tn = this.treeAdapter.getTagName(element4);
				const ns = this.treeAdapter.getNamespaceURI(element4);
				return HTML.SPECIAL_ELEMENTS[ns][tn];
			}
		};
		module2.exports = Parser2;
		function aaObtainFormattingElementEntry(p2, token) {
			let formattingElementEntry = p2.activeFormattingElements.getElementEntryInScopeWithTagName(
				token.tagName
			);
			if (formattingElementEntry) {
				if (!p2.openElements.contains(formattingElementEntry.element)) {
					p2.activeFormattingElements.removeEntry(formattingElementEntry);
					formattingElementEntry = null;
				} else if (!p2.openElements.hasInScope(token.tagName)) {
					formattingElementEntry = null;
				}
			} else {
				genericEndTagInBody(p2, token);
			}
			return formattingElementEntry;
		}
		function aaObtainFurthestBlock(p2, formattingElementEntry) {
			let furthestBlock = null;
			for (let i2 = p2.openElements.stackTop; i2 >= 0; i2--) {
				const element4 = p2.openElements.items[i2];
				if (element4 === formattingElementEntry.element) {
					break;
				}
				if (p2._isSpecialElement(element4)) {
					furthestBlock = element4;
				}
			}
			if (!furthestBlock) {
				p2.openElements.popUntilElementPopped(formattingElementEntry.element);
				p2.activeFormattingElements.removeEntry(formattingElementEntry);
			}
			return furthestBlock;
		}
		function aaInnerLoop(p2, furthestBlock, formattingElement) {
			let lastElement = furthestBlock;
			let nextElement = p2.openElements.getCommonAncestor(furthestBlock);
			for (
				let i2 = 0, element4 = nextElement;
				element4 !== formattingElement;
				i2++, element4 = nextElement
			) {
				nextElement = p2.openElements.getCommonAncestor(element4);
				const elementEntry = p2.activeFormattingElements.getElementEntry(element4);
				const counterOverflow = elementEntry && i2 >= AA_INNER_LOOP_ITER;
				const shouldRemoveFromOpenElements = !elementEntry || counterOverflow;
				if (shouldRemoveFromOpenElements) {
					if (counterOverflow) {
						p2.activeFormattingElements.removeEntry(elementEntry);
					}
					p2.openElements.remove(element4);
				} else {
					element4 = aaRecreateElementFromEntry(p2, elementEntry);
					if (lastElement === furthestBlock) {
						p2.activeFormattingElements.bookmark = elementEntry;
					}
					p2.treeAdapter.detachNode(lastElement);
					p2.treeAdapter.appendChild(element4, lastElement);
					lastElement = element4;
				}
			}
			return lastElement;
		}
		function aaRecreateElementFromEntry(p2, elementEntry) {
			const ns = p2.treeAdapter.getNamespaceURI(elementEntry.element);
			const newElement = p2.treeAdapter.createElement(
				elementEntry.token.tagName,
				ns,
				elementEntry.token.attrs
			);
			p2.openElements.replace(elementEntry.element, newElement);
			elementEntry.element = newElement;
			return newElement;
		}
		function aaInsertLastNodeInCommonAncestor(p2, commonAncestor, lastElement) {
			if (p2._isElementCausesFosterParenting(commonAncestor)) {
				p2._fosterParentElement(lastElement);
			} else {
				const tn = p2.treeAdapter.getTagName(commonAncestor);
				const ns = p2.treeAdapter.getNamespaceURI(commonAncestor);
				if (tn === $.TEMPLATE && ns === NS.HTML) {
					commonAncestor = p2.treeAdapter.getTemplateContent(commonAncestor);
				}
				p2.treeAdapter.appendChild(commonAncestor, lastElement);
			}
		}
		function aaReplaceFormattingElement(p2, furthestBlock, formattingElementEntry) {
			const ns = p2.treeAdapter.getNamespaceURI(formattingElementEntry.element);
			const token = formattingElementEntry.token;
			const newElement = p2.treeAdapter.createElement(token.tagName, ns, token.attrs);
			p2._adoptNodes(furthestBlock, newElement);
			p2.treeAdapter.appendChild(furthestBlock, newElement);
			p2.activeFormattingElements.insertElementAfterBookmark(
				newElement,
				formattingElementEntry.token
			);
			p2.activeFormattingElements.removeEntry(formattingElementEntry);
			p2.openElements.remove(formattingElementEntry.element);
			p2.openElements.insertAfter(furthestBlock, newElement);
		}
		function callAdoptionAgency(p2, token) {
			let formattingElementEntry;
			for (let i2 = 0; i2 < AA_OUTER_LOOP_ITER; i2++) {
				formattingElementEntry = aaObtainFormattingElementEntry(p2, token, formattingElementEntry);
				if (!formattingElementEntry) {
					break;
				}
				const furthestBlock = aaObtainFurthestBlock(p2, formattingElementEntry);
				if (!furthestBlock) {
					break;
				}
				p2.activeFormattingElements.bookmark = formattingElementEntry;
				const lastElement = aaInnerLoop(p2, furthestBlock, formattingElementEntry.element);
				const commonAncestor = p2.openElements.getCommonAncestor(formattingElementEntry.element);
				p2.treeAdapter.detachNode(lastElement);
				aaInsertLastNodeInCommonAncestor(p2, commonAncestor, lastElement);
				aaReplaceFormattingElement(p2, furthestBlock, formattingElementEntry);
			}
		}
		function ignoreToken() {}
		function misplacedDoctype(p2) {
			p2._err(ERR.misplacedDoctype);
		}
		function appendComment(p2, token) {
			p2._appendCommentNode(token, p2.openElements.currentTmplContent || p2.openElements.current);
		}
		function appendCommentToRootHtmlElement(p2, token) {
			p2._appendCommentNode(token, p2.openElements.items[0]);
		}
		function appendCommentToDocument(p2, token) {
			p2._appendCommentNode(token, p2.document);
		}
		function insertCharacters(p2, token) {
			p2._insertCharacters(token);
		}
		function stopParsing(p2) {
			p2.stopped = true;
		}
		function doctypeInInitialMode(p2, token) {
			p2._setDocumentType(token);
			const mode = token.forceQuirks ? HTML.DOCUMENT_MODE.QUIRKS : doctype3.getDocumentMode(token);
			if (!doctype3.isConforming(token)) {
				p2._err(ERR.nonConformingDoctype);
			}
			p2.treeAdapter.setDocumentMode(p2.document, mode);
			p2.insertionMode = BEFORE_HTML_MODE;
		}
		function tokenInInitialMode(p2, token) {
			p2._err(ERR.missingDoctype, { beforeToken: true });
			p2.treeAdapter.setDocumentMode(p2.document, HTML.DOCUMENT_MODE.QUIRKS);
			p2.insertionMode = BEFORE_HTML_MODE;
			p2._processToken(token);
		}
		function startTagBeforeHtml(p2, token) {
			if (token.tagName === $.HTML) {
				p2._insertElement(token, NS.HTML);
				p2.insertionMode = BEFORE_HEAD_MODE;
			} else {
				tokenBeforeHtml(p2, token);
			}
		}
		function endTagBeforeHtml(p2, token) {
			const tn = token.tagName;
			if (tn === $.HTML || tn === $.HEAD || tn === $.BODY || tn === $.BR) {
				tokenBeforeHtml(p2, token);
			}
		}
		function tokenBeforeHtml(p2, token) {
			p2._insertFakeRootElement();
			p2.insertionMode = BEFORE_HEAD_MODE;
			p2._processToken(token);
		}
		function startTagBeforeHead(p2, token) {
			const tn = token.tagName;
			if (tn === $.HTML) {
				startTagInBody(p2, token);
			} else if (tn === $.HEAD) {
				p2._insertElement(token, NS.HTML);
				p2.headElement = p2.openElements.current;
				p2.insertionMode = IN_HEAD_MODE;
			} else {
				tokenBeforeHead(p2, token);
			}
		}
		function endTagBeforeHead(p2, token) {
			const tn = token.tagName;
			if (tn === $.HEAD || tn === $.BODY || tn === $.HTML || tn === $.BR) {
				tokenBeforeHead(p2, token);
			} else {
				p2._err(ERR.endTagWithoutMatchingOpenElement);
			}
		}
		function tokenBeforeHead(p2, token) {
			p2._insertFakeElement($.HEAD);
			p2.headElement = p2.openElements.current;
			p2.insertionMode = IN_HEAD_MODE;
			p2._processToken(token);
		}
		function startTagInHead(p2, token) {
			const tn = token.tagName;
			if (tn === $.HTML) {
				startTagInBody(p2, token);
			} else if (
				tn === $.BASE ||
				tn === $.BASEFONT ||
				tn === $.BGSOUND ||
				tn === $.LINK ||
				tn === $.META
			) {
				p2._appendElement(token, NS.HTML);
				token.ackSelfClosing = true;
			} else if (tn === $.TITLE) {
				p2._switchToTextParsing(token, Tokenizer.MODE.RCDATA);
			} else if (tn === $.NOSCRIPT) {
				if (p2.options.scriptingEnabled) {
					p2._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
				} else {
					p2._insertElement(token, NS.HTML);
					p2.insertionMode = IN_HEAD_NO_SCRIPT_MODE;
				}
			} else if (tn === $.NOFRAMES || tn === $.STYLE) {
				p2._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
			} else if (tn === $.SCRIPT) {
				p2._switchToTextParsing(token, Tokenizer.MODE.SCRIPT_DATA);
			} else if (tn === $.TEMPLATE) {
				p2._insertTemplate(token, NS.HTML);
				p2.activeFormattingElements.insertMarker();
				p2.framesetOk = false;
				p2.insertionMode = IN_TEMPLATE_MODE;
				p2._pushTmplInsertionMode(IN_TEMPLATE_MODE);
			} else if (tn === $.HEAD) {
				p2._err(ERR.misplacedStartTagForHeadElement);
			} else {
				tokenInHead(p2, token);
			}
		}
		function endTagInHead(p2, token) {
			const tn = token.tagName;
			if (tn === $.HEAD) {
				p2.openElements.pop();
				p2.insertionMode = AFTER_HEAD_MODE;
			} else if (tn === $.BODY || tn === $.BR || tn === $.HTML) {
				tokenInHead(p2, token);
			} else if (tn === $.TEMPLATE) {
				if (p2.openElements.tmplCount > 0) {
					p2.openElements.generateImpliedEndTagsThoroughly();
					if (p2.openElements.currentTagName !== $.TEMPLATE) {
						p2._err(ERR.closingOfElementWithOpenChildElements);
					}
					p2.openElements.popUntilTagNamePopped($.TEMPLATE);
					p2.activeFormattingElements.clearToLastMarker();
					p2._popTmplInsertionMode();
					p2._resetInsertionMode();
				} else {
					p2._err(ERR.endTagWithoutMatchingOpenElement);
				}
			} else {
				p2._err(ERR.endTagWithoutMatchingOpenElement);
			}
		}
		function tokenInHead(p2, token) {
			p2.openElements.pop();
			p2.insertionMode = AFTER_HEAD_MODE;
			p2._processToken(token);
		}
		function startTagInHeadNoScript(p2, token) {
			const tn = token.tagName;
			if (tn === $.HTML) {
				startTagInBody(p2, token);
			} else if (
				tn === $.BASEFONT ||
				tn === $.BGSOUND ||
				tn === $.HEAD ||
				tn === $.LINK ||
				tn === $.META ||
				tn === $.NOFRAMES ||
				tn === $.STYLE
			) {
				startTagInHead(p2, token);
			} else if (tn === $.NOSCRIPT) {
				p2._err(ERR.nestedNoscriptInHead);
			} else {
				tokenInHeadNoScript(p2, token);
			}
		}
		function endTagInHeadNoScript(p2, token) {
			const tn = token.tagName;
			if (tn === $.NOSCRIPT) {
				p2.openElements.pop();
				p2.insertionMode = IN_HEAD_MODE;
			} else if (tn === $.BR) {
				tokenInHeadNoScript(p2, token);
			} else {
				p2._err(ERR.endTagWithoutMatchingOpenElement);
			}
		}
		function tokenInHeadNoScript(p2, token) {
			const errCode =
				token.type === Tokenizer.EOF_TOKEN
					? ERR.openElementsLeftAfterEof
					: ERR.disallowedContentInNoscriptInHead;
			p2._err(errCode);
			p2.openElements.pop();
			p2.insertionMode = IN_HEAD_MODE;
			p2._processToken(token);
		}
		function startTagAfterHead(p2, token) {
			const tn = token.tagName;
			if (tn === $.HTML) {
				startTagInBody(p2, token);
			} else if (tn === $.BODY) {
				p2._insertElement(token, NS.HTML);
				p2.framesetOk = false;
				p2.insertionMode = IN_BODY_MODE;
			} else if (tn === $.FRAMESET) {
				p2._insertElement(token, NS.HTML);
				p2.insertionMode = IN_FRAMESET_MODE;
			} else if (
				tn === $.BASE ||
				tn === $.BASEFONT ||
				tn === $.BGSOUND ||
				tn === $.LINK ||
				tn === $.META ||
				tn === $.NOFRAMES ||
				tn === $.SCRIPT ||
				tn === $.STYLE ||
				tn === $.TEMPLATE ||
				tn === $.TITLE
			) {
				p2._err(ERR.abandonedHeadElementChild);
				p2.openElements.push(p2.headElement);
				startTagInHead(p2, token);
				p2.openElements.remove(p2.headElement);
			} else if (tn === $.HEAD) {
				p2._err(ERR.misplacedStartTagForHeadElement);
			} else {
				tokenAfterHead(p2, token);
			}
		}
		function endTagAfterHead(p2, token) {
			const tn = token.tagName;
			if (tn === $.BODY || tn === $.HTML || tn === $.BR) {
				tokenAfterHead(p2, token);
			} else if (tn === $.TEMPLATE) {
				endTagInHead(p2, token);
			} else {
				p2._err(ERR.endTagWithoutMatchingOpenElement);
			}
		}
		function tokenAfterHead(p2, token) {
			p2._insertFakeElement($.BODY);
			p2.insertionMode = IN_BODY_MODE;
			p2._processToken(token);
		}
		function whitespaceCharacterInBody(p2, token) {
			p2._reconstructActiveFormattingElements();
			p2._insertCharacters(token);
		}
		function characterInBody(p2, token) {
			p2._reconstructActiveFormattingElements();
			p2._insertCharacters(token);
			p2.framesetOk = false;
		}
		function htmlStartTagInBody(p2, token) {
			if (p2.openElements.tmplCount === 0) {
				p2.treeAdapter.adoptAttributes(p2.openElements.items[0], token.attrs);
			}
		}
		function bodyStartTagInBody(p2, token) {
			const bodyElement = p2.openElements.tryPeekProperlyNestedBodyElement();
			if (bodyElement && p2.openElements.tmplCount === 0) {
				p2.framesetOk = false;
				p2.treeAdapter.adoptAttributes(bodyElement, token.attrs);
			}
		}
		function framesetStartTagInBody(p2, token) {
			const bodyElement = p2.openElements.tryPeekProperlyNestedBodyElement();
			if (p2.framesetOk && bodyElement) {
				p2.treeAdapter.detachNode(bodyElement);
				p2.openElements.popAllUpToHtmlElement();
				p2._insertElement(token, NS.HTML);
				p2.insertionMode = IN_FRAMESET_MODE;
			}
		}
		function addressStartTagInBody(p2, token) {
			if (p2.openElements.hasInButtonScope($.P)) {
				p2._closePElement();
			}
			p2._insertElement(token, NS.HTML);
		}
		function numberedHeaderStartTagInBody(p2, token) {
			if (p2.openElements.hasInButtonScope($.P)) {
				p2._closePElement();
			}
			const tn = p2.openElements.currentTagName;
			if (tn === $.H1 || tn === $.H2 || tn === $.H3 || tn === $.H4 || tn === $.H5 || tn === $.H6) {
				p2.openElements.pop();
			}
			p2._insertElement(token, NS.HTML);
		}
		function preStartTagInBody(p2, token) {
			if (p2.openElements.hasInButtonScope($.P)) {
				p2._closePElement();
			}
			p2._insertElement(token, NS.HTML);
			p2.skipNextNewLine = true;
			p2.framesetOk = false;
		}
		function formStartTagInBody(p2, token) {
			const inTemplate = p2.openElements.tmplCount > 0;
			if (!p2.formElement || inTemplate) {
				if (p2.openElements.hasInButtonScope($.P)) {
					p2._closePElement();
				}
				p2._insertElement(token, NS.HTML);
				if (!inTemplate) {
					p2.formElement = p2.openElements.current;
				}
			}
		}
		function listItemStartTagInBody(p2, token) {
			p2.framesetOk = false;
			const tn = token.tagName;
			for (let i2 = p2.openElements.stackTop; i2 >= 0; i2--) {
				const element4 = p2.openElements.items[i2];
				const elementTn = p2.treeAdapter.getTagName(element4);
				let closeTn = null;
				if (tn === $.LI && elementTn === $.LI) {
					closeTn = $.LI;
				} else if ((tn === $.DD || tn === $.DT) && (elementTn === $.DD || elementTn === $.DT)) {
					closeTn = elementTn;
				}
				if (closeTn) {
					p2.openElements.generateImpliedEndTagsWithExclusion(closeTn);
					p2.openElements.popUntilTagNamePopped(closeTn);
					break;
				}
				if (
					elementTn !== $.ADDRESS &&
					elementTn !== $.DIV &&
					elementTn !== $.P &&
					p2._isSpecialElement(element4)
				) {
					break;
				}
			}
			if (p2.openElements.hasInButtonScope($.P)) {
				p2._closePElement();
			}
			p2._insertElement(token, NS.HTML);
		}
		function plaintextStartTagInBody(p2, token) {
			if (p2.openElements.hasInButtonScope($.P)) {
				p2._closePElement();
			}
			p2._insertElement(token, NS.HTML);
			p2.tokenizer.state = Tokenizer.MODE.PLAINTEXT;
		}
		function buttonStartTagInBody(p2, token) {
			if (p2.openElements.hasInScope($.BUTTON)) {
				p2.openElements.generateImpliedEndTags();
				p2.openElements.popUntilTagNamePopped($.BUTTON);
			}
			p2._reconstructActiveFormattingElements();
			p2._insertElement(token, NS.HTML);
			p2.framesetOk = false;
		}
		function aStartTagInBody(p2, token) {
			const activeElementEntry = p2.activeFormattingElements.getElementEntryInScopeWithTagName($.A);
			if (activeElementEntry) {
				callAdoptionAgency(p2, token);
				p2.openElements.remove(activeElementEntry.element);
				p2.activeFormattingElements.removeEntry(activeElementEntry);
			}
			p2._reconstructActiveFormattingElements();
			p2._insertElement(token, NS.HTML);
			p2.activeFormattingElements.pushElement(p2.openElements.current, token);
		}
		function bStartTagInBody(p2, token) {
			p2._reconstructActiveFormattingElements();
			p2._insertElement(token, NS.HTML);
			p2.activeFormattingElements.pushElement(p2.openElements.current, token);
		}
		function nobrStartTagInBody(p2, token) {
			p2._reconstructActiveFormattingElements();
			if (p2.openElements.hasInScope($.NOBR)) {
				callAdoptionAgency(p2, token);
				p2._reconstructActiveFormattingElements();
			}
			p2._insertElement(token, NS.HTML);
			p2.activeFormattingElements.pushElement(p2.openElements.current, token);
		}
		function appletStartTagInBody(p2, token) {
			p2._reconstructActiveFormattingElements();
			p2._insertElement(token, NS.HTML);
			p2.activeFormattingElements.insertMarker();
			p2.framesetOk = false;
		}
		function tableStartTagInBody(p2, token) {
			if (
				p2.treeAdapter.getDocumentMode(p2.document) !== HTML.DOCUMENT_MODE.QUIRKS &&
				p2.openElements.hasInButtonScope($.P)
			) {
				p2._closePElement();
			}
			p2._insertElement(token, NS.HTML);
			p2.framesetOk = false;
			p2.insertionMode = IN_TABLE_MODE;
		}
		function areaStartTagInBody(p2, token) {
			p2._reconstructActiveFormattingElements();
			p2._appendElement(token, NS.HTML);
			p2.framesetOk = false;
			token.ackSelfClosing = true;
		}
		function inputStartTagInBody(p2, token) {
			p2._reconstructActiveFormattingElements();
			p2._appendElement(token, NS.HTML);
			const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);
			if (!inputType || inputType.toLowerCase() !== HIDDEN_INPUT_TYPE) {
				p2.framesetOk = false;
			}
			token.ackSelfClosing = true;
		}
		function paramStartTagInBody(p2, token) {
			p2._appendElement(token, NS.HTML);
			token.ackSelfClosing = true;
		}
		function hrStartTagInBody(p2, token) {
			if (p2.openElements.hasInButtonScope($.P)) {
				p2._closePElement();
			}
			p2._appendElement(token, NS.HTML);
			p2.framesetOk = false;
			token.ackSelfClosing = true;
		}
		function imageStartTagInBody(p2, token) {
			token.tagName = $.IMG;
			areaStartTagInBody(p2, token);
		}
		function textareaStartTagInBody(p2, token) {
			p2._insertElement(token, NS.HTML);
			p2.skipNextNewLine = true;
			p2.tokenizer.state = Tokenizer.MODE.RCDATA;
			p2.originalInsertionMode = p2.insertionMode;
			p2.framesetOk = false;
			p2.insertionMode = TEXT_MODE;
		}
		function xmpStartTagInBody(p2, token) {
			if (p2.openElements.hasInButtonScope($.P)) {
				p2._closePElement();
			}
			p2._reconstructActiveFormattingElements();
			p2.framesetOk = false;
			p2._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
		}
		function iframeStartTagInBody(p2, token) {
			p2.framesetOk = false;
			p2._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
		}
		function noembedStartTagInBody(p2, token) {
			p2._switchToTextParsing(token, Tokenizer.MODE.RAWTEXT);
		}
		function selectStartTagInBody(p2, token) {
			p2._reconstructActiveFormattingElements();
			p2._insertElement(token, NS.HTML);
			p2.framesetOk = false;
			if (
				p2.insertionMode === IN_TABLE_MODE ||
				p2.insertionMode === IN_CAPTION_MODE ||
				p2.insertionMode === IN_TABLE_BODY_MODE ||
				p2.insertionMode === IN_ROW_MODE ||
				p2.insertionMode === IN_CELL_MODE
			) {
				p2.insertionMode = IN_SELECT_IN_TABLE_MODE;
			} else {
				p2.insertionMode = IN_SELECT_MODE;
			}
		}
		function optgroupStartTagInBody(p2, token) {
			if (p2.openElements.currentTagName === $.OPTION) {
				p2.openElements.pop();
			}
			p2._reconstructActiveFormattingElements();
			p2._insertElement(token, NS.HTML);
		}
		function rbStartTagInBody(p2, token) {
			if (p2.openElements.hasInScope($.RUBY)) {
				p2.openElements.generateImpliedEndTags();
			}
			p2._insertElement(token, NS.HTML);
		}
		function rtStartTagInBody(p2, token) {
			if (p2.openElements.hasInScope($.RUBY)) {
				p2.openElements.generateImpliedEndTagsWithExclusion($.RTC);
			}
			p2._insertElement(token, NS.HTML);
		}
		function menuStartTagInBody(p2, token) {
			if (p2.openElements.hasInButtonScope($.P)) {
				p2._closePElement();
			}
			p2._insertElement(token, NS.HTML);
		}
		function mathStartTagInBody(p2, token) {
			p2._reconstructActiveFormattingElements();
			foreignContent.adjustTokenMathMLAttrs(token);
			foreignContent.adjustTokenXMLAttrs(token);
			if (token.selfClosing) {
				p2._appendElement(token, NS.MATHML);
			} else {
				p2._insertElement(token, NS.MATHML);
			}
			token.ackSelfClosing = true;
		}
		function svgStartTagInBody(p2, token) {
			p2._reconstructActiveFormattingElements();
			foreignContent.adjustTokenSVGAttrs(token);
			foreignContent.adjustTokenXMLAttrs(token);
			if (token.selfClosing) {
				p2._appendElement(token, NS.SVG);
			} else {
				p2._insertElement(token, NS.SVG);
			}
			token.ackSelfClosing = true;
		}
		function genericStartTagInBody(p2, token) {
			p2._reconstructActiveFormattingElements();
			p2._insertElement(token, NS.HTML);
		}
		function startTagInBody(p2, token) {
			const tn = token.tagName;
			switch (tn.length) {
				case 1:
					if (tn === $.I || tn === $.S || tn === $.B || tn === $.U) {
						bStartTagInBody(p2, token);
					} else if (tn === $.P) {
						addressStartTagInBody(p2, token);
					} else if (tn === $.A) {
						aStartTagInBody(p2, token);
					} else {
						genericStartTagInBody(p2, token);
					}
					break;
				case 2:
					if (tn === $.DL || tn === $.OL || tn === $.UL) {
						addressStartTagInBody(p2, token);
					} else if (
						tn === $.H1 ||
						tn === $.H2 ||
						tn === $.H3 ||
						tn === $.H4 ||
						tn === $.H5 ||
						tn === $.H6
					) {
						numberedHeaderStartTagInBody(p2, token);
					} else if (tn === $.LI || tn === $.DD || tn === $.DT) {
						listItemStartTagInBody(p2, token);
					} else if (tn === $.EM || tn === $.TT) {
						bStartTagInBody(p2, token);
					} else if (tn === $.BR) {
						areaStartTagInBody(p2, token);
					} else if (tn === $.HR) {
						hrStartTagInBody(p2, token);
					} else if (tn === $.RB) {
						rbStartTagInBody(p2, token);
					} else if (tn === $.RT || tn === $.RP) {
						rtStartTagInBody(p2, token);
					} else if (tn !== $.TH && tn !== $.TD && tn !== $.TR) {
						genericStartTagInBody(p2, token);
					}
					break;
				case 3:
					if (tn === $.DIV || tn === $.DIR || tn === $.NAV) {
						addressStartTagInBody(p2, token);
					} else if (tn === $.PRE) {
						preStartTagInBody(p2, token);
					} else if (tn === $.BIG) {
						bStartTagInBody(p2, token);
					} else if (tn === $.IMG || tn === $.WBR) {
						areaStartTagInBody(p2, token);
					} else if (tn === $.XMP) {
						xmpStartTagInBody(p2, token);
					} else if (tn === $.SVG) {
						svgStartTagInBody(p2, token);
					} else if (tn === $.RTC) {
						rbStartTagInBody(p2, token);
					} else if (tn !== $.COL) {
						genericStartTagInBody(p2, token);
					}
					break;
				case 4:
					if (tn === $.HTML) {
						htmlStartTagInBody(p2, token);
					} else if (tn === $.BASE || tn === $.LINK || tn === $.META) {
						startTagInHead(p2, token);
					} else if (tn === $.BODY) {
						bodyStartTagInBody(p2, token);
					} else if (tn === $.MAIN || tn === $.MENU) {
						addressStartTagInBody(p2, token);
					} else if (tn === $.FORM) {
						formStartTagInBody(p2, token);
					} else if (tn === $.CODE || tn === $.FONT) {
						bStartTagInBody(p2, token);
					} else if (tn === $.NOBR) {
						nobrStartTagInBody(p2, token);
					} else if (tn === $.AREA) {
						areaStartTagInBody(p2, token);
					} else if (tn === $.MATH) {
						mathStartTagInBody(p2, token);
					} else if (tn === $.MENU) {
						menuStartTagInBody(p2, token);
					} else if (tn !== $.HEAD) {
						genericStartTagInBody(p2, token);
					}
					break;
				case 5:
					if (tn === $.STYLE || tn === $.TITLE) {
						startTagInHead(p2, token);
					} else if (tn === $.ASIDE) {
						addressStartTagInBody(p2, token);
					} else if (tn === $.SMALL) {
						bStartTagInBody(p2, token);
					} else if (tn === $.TABLE) {
						tableStartTagInBody(p2, token);
					} else if (tn === $.EMBED) {
						areaStartTagInBody(p2, token);
					} else if (tn === $.INPUT) {
						inputStartTagInBody(p2, token);
					} else if (tn === $.PARAM || tn === $.TRACK) {
						paramStartTagInBody(p2, token);
					} else if (tn === $.IMAGE) {
						imageStartTagInBody(p2, token);
					} else if (tn !== $.FRAME && tn !== $.TBODY && tn !== $.TFOOT && tn !== $.THEAD) {
						genericStartTagInBody(p2, token);
					}
					break;
				case 6:
					if (tn === $.SCRIPT) {
						startTagInHead(p2, token);
					} else if (
						tn === $.CENTER ||
						tn === $.FIGURE ||
						tn === $.FOOTER ||
						tn === $.HEADER ||
						tn === $.HGROUP ||
						tn === $.DIALOG
					) {
						addressStartTagInBody(p2, token);
					} else if (tn === $.BUTTON) {
						buttonStartTagInBody(p2, token);
					} else if (tn === $.STRIKE || tn === $.STRONG) {
						bStartTagInBody(p2, token);
					} else if (tn === $.APPLET || tn === $.OBJECT) {
						appletStartTagInBody(p2, token);
					} else if (tn === $.KEYGEN) {
						areaStartTagInBody(p2, token);
					} else if (tn === $.SOURCE) {
						paramStartTagInBody(p2, token);
					} else if (tn === $.IFRAME) {
						iframeStartTagInBody(p2, token);
					} else if (tn === $.SELECT) {
						selectStartTagInBody(p2, token);
					} else if (tn === $.OPTION) {
						optgroupStartTagInBody(p2, token);
					} else {
						genericStartTagInBody(p2, token);
					}
					break;
				case 7:
					if (tn === $.BGSOUND) {
						startTagInHead(p2, token);
					} else if (
						tn === $.DETAILS ||
						tn === $.ADDRESS ||
						tn === $.ARTICLE ||
						tn === $.SECTION ||
						tn === $.SUMMARY
					) {
						addressStartTagInBody(p2, token);
					} else if (tn === $.LISTING) {
						preStartTagInBody(p2, token);
					} else if (tn === $.MARQUEE) {
						appletStartTagInBody(p2, token);
					} else if (tn === $.NOEMBED) {
						noembedStartTagInBody(p2, token);
					} else if (tn !== $.CAPTION) {
						genericStartTagInBody(p2, token);
					}
					break;
				case 8:
					if (tn === $.BASEFONT) {
						startTagInHead(p2, token);
					} else if (tn === $.FRAMESET) {
						framesetStartTagInBody(p2, token);
					} else if (tn === $.FIELDSET) {
						addressStartTagInBody(p2, token);
					} else if (tn === $.TEXTAREA) {
						textareaStartTagInBody(p2, token);
					} else if (tn === $.TEMPLATE) {
						startTagInHead(p2, token);
					} else if (tn === $.NOSCRIPT) {
						if (p2.options.scriptingEnabled) {
							noembedStartTagInBody(p2, token);
						} else {
							genericStartTagInBody(p2, token);
						}
					} else if (tn === $.OPTGROUP) {
						optgroupStartTagInBody(p2, token);
					} else if (tn !== $.COLGROUP) {
						genericStartTagInBody(p2, token);
					}
					break;
				case 9:
					if (tn === $.PLAINTEXT) {
						plaintextStartTagInBody(p2, token);
					} else {
						genericStartTagInBody(p2, token);
					}
					break;
				case 10:
					if (tn === $.BLOCKQUOTE || tn === $.FIGCAPTION) {
						addressStartTagInBody(p2, token);
					} else {
						genericStartTagInBody(p2, token);
					}
					break;
				default:
					genericStartTagInBody(p2, token);
			}
		}
		function bodyEndTagInBody(p2) {
			if (p2.openElements.hasInScope($.BODY)) {
				p2.insertionMode = AFTER_BODY_MODE;
			}
		}
		function htmlEndTagInBody(p2, token) {
			if (p2.openElements.hasInScope($.BODY)) {
				p2.insertionMode = AFTER_BODY_MODE;
				p2._processToken(token);
			}
		}
		function addressEndTagInBody(p2, token) {
			const tn = token.tagName;
			if (p2.openElements.hasInScope(tn)) {
				p2.openElements.generateImpliedEndTags();
				p2.openElements.popUntilTagNamePopped(tn);
			}
		}
		function formEndTagInBody(p2) {
			const inTemplate = p2.openElements.tmplCount > 0;
			const formElement = p2.formElement;
			if (!inTemplate) {
				p2.formElement = null;
			}
			if ((formElement || inTemplate) && p2.openElements.hasInScope($.FORM)) {
				p2.openElements.generateImpliedEndTags();
				if (inTemplate) {
					p2.openElements.popUntilTagNamePopped($.FORM);
				} else {
					p2.openElements.remove(formElement);
				}
			}
		}
		function pEndTagInBody(p2) {
			if (!p2.openElements.hasInButtonScope($.P)) {
				p2._insertFakeElement($.P);
			}
			p2._closePElement();
		}
		function liEndTagInBody(p2) {
			if (p2.openElements.hasInListItemScope($.LI)) {
				p2.openElements.generateImpliedEndTagsWithExclusion($.LI);
				p2.openElements.popUntilTagNamePopped($.LI);
			}
		}
		function ddEndTagInBody(p2, token) {
			const tn = token.tagName;
			if (p2.openElements.hasInScope(tn)) {
				p2.openElements.generateImpliedEndTagsWithExclusion(tn);
				p2.openElements.popUntilTagNamePopped(tn);
			}
		}
		function numberedHeaderEndTagInBody(p2) {
			if (p2.openElements.hasNumberedHeaderInScope()) {
				p2.openElements.generateImpliedEndTags();
				p2.openElements.popUntilNumberedHeaderPopped();
			}
		}
		function appletEndTagInBody(p2, token) {
			const tn = token.tagName;
			if (p2.openElements.hasInScope(tn)) {
				p2.openElements.generateImpliedEndTags();
				p2.openElements.popUntilTagNamePopped(tn);
				p2.activeFormattingElements.clearToLastMarker();
			}
		}
		function brEndTagInBody(p2) {
			p2._reconstructActiveFormattingElements();
			p2._insertFakeElement($.BR);
			p2.openElements.pop();
			p2.framesetOk = false;
		}
		function genericEndTagInBody(p2, token) {
			const tn = token.tagName;
			for (let i2 = p2.openElements.stackTop; i2 > 0; i2--) {
				const element4 = p2.openElements.items[i2];
				if (p2.treeAdapter.getTagName(element4) === tn) {
					p2.openElements.generateImpliedEndTagsWithExclusion(tn);
					p2.openElements.popUntilElementPopped(element4);
					break;
				}
				if (p2._isSpecialElement(element4)) {
					break;
				}
			}
		}
		function endTagInBody(p2, token) {
			const tn = token.tagName;
			switch (tn.length) {
				case 1:
					if (tn === $.A || tn === $.B || tn === $.I || tn === $.S || tn === $.U) {
						callAdoptionAgency(p2, token);
					} else if (tn === $.P) {
						pEndTagInBody(p2, token);
					} else {
						genericEndTagInBody(p2, token);
					}
					break;
				case 2:
					if (tn === $.DL || tn === $.UL || tn === $.OL) {
						addressEndTagInBody(p2, token);
					} else if (tn === $.LI) {
						liEndTagInBody(p2, token);
					} else if (tn === $.DD || tn === $.DT) {
						ddEndTagInBody(p2, token);
					} else if (
						tn === $.H1 ||
						tn === $.H2 ||
						tn === $.H3 ||
						tn === $.H4 ||
						tn === $.H5 ||
						tn === $.H6
					) {
						numberedHeaderEndTagInBody(p2, token);
					} else if (tn === $.BR) {
						brEndTagInBody(p2, token);
					} else if (tn === $.EM || tn === $.TT) {
						callAdoptionAgency(p2, token);
					} else {
						genericEndTagInBody(p2, token);
					}
					break;
				case 3:
					if (tn === $.BIG) {
						callAdoptionAgency(p2, token);
					} else if (tn === $.DIR || tn === $.DIV || tn === $.NAV || tn === $.PRE) {
						addressEndTagInBody(p2, token);
					} else {
						genericEndTagInBody(p2, token);
					}
					break;
				case 4:
					if (tn === $.BODY) {
						bodyEndTagInBody(p2, token);
					} else if (tn === $.HTML) {
						htmlEndTagInBody(p2, token);
					} else if (tn === $.FORM) {
						formEndTagInBody(p2, token);
					} else if (tn === $.CODE || tn === $.FONT || tn === $.NOBR) {
						callAdoptionAgency(p2, token);
					} else if (tn === $.MAIN || tn === $.MENU) {
						addressEndTagInBody(p2, token);
					} else {
						genericEndTagInBody(p2, token);
					}
					break;
				case 5:
					if (tn === $.ASIDE) {
						addressEndTagInBody(p2, token);
					} else if (tn === $.SMALL) {
						callAdoptionAgency(p2, token);
					} else {
						genericEndTagInBody(p2, token);
					}
					break;
				case 6:
					if (
						tn === $.CENTER ||
						tn === $.FIGURE ||
						tn === $.FOOTER ||
						tn === $.HEADER ||
						tn === $.HGROUP ||
						tn === $.DIALOG
					) {
						addressEndTagInBody(p2, token);
					} else if (tn === $.APPLET || tn === $.OBJECT) {
						appletEndTagInBody(p2, token);
					} else if (tn === $.STRIKE || tn === $.STRONG) {
						callAdoptionAgency(p2, token);
					} else {
						genericEndTagInBody(p2, token);
					}
					break;
				case 7:
					if (
						tn === $.ADDRESS ||
						tn === $.ARTICLE ||
						tn === $.DETAILS ||
						tn === $.SECTION ||
						tn === $.SUMMARY ||
						tn === $.LISTING
					) {
						addressEndTagInBody(p2, token);
					} else if (tn === $.MARQUEE) {
						appletEndTagInBody(p2, token);
					} else {
						genericEndTagInBody(p2, token);
					}
					break;
				case 8:
					if (tn === $.FIELDSET) {
						addressEndTagInBody(p2, token);
					} else if (tn === $.TEMPLATE) {
						endTagInHead(p2, token);
					} else {
						genericEndTagInBody(p2, token);
					}
					break;
				case 10:
					if (tn === $.BLOCKQUOTE || tn === $.FIGCAPTION) {
						addressEndTagInBody(p2, token);
					} else {
						genericEndTagInBody(p2, token);
					}
					break;
				default:
					genericEndTagInBody(p2, token);
			}
		}
		function eofInBody(p2, token) {
			if (p2.tmplInsertionModeStackTop > -1) {
				eofInTemplate(p2, token);
			} else {
				p2.stopped = true;
			}
		}
		function endTagInText(p2, token) {
			if (token.tagName === $.SCRIPT) {
				p2.pendingScript = p2.openElements.current;
			}
			p2.openElements.pop();
			p2.insertionMode = p2.originalInsertionMode;
		}
		function eofInText(p2, token) {
			p2._err(ERR.eofInElementThatCanContainOnlyText);
			p2.openElements.pop();
			p2.insertionMode = p2.originalInsertionMode;
			p2._processToken(token);
		}
		function characterInTable(p2, token) {
			const curTn = p2.openElements.currentTagName;
			if (
				curTn === $.TABLE ||
				curTn === $.TBODY ||
				curTn === $.TFOOT ||
				curTn === $.THEAD ||
				curTn === $.TR
			) {
				p2.pendingCharacterTokens = [];
				p2.hasNonWhitespacePendingCharacterToken = false;
				p2.originalInsertionMode = p2.insertionMode;
				p2.insertionMode = IN_TABLE_TEXT_MODE;
				p2._processToken(token);
			} else {
				tokenInTable(p2, token);
			}
		}
		function captionStartTagInTable(p2, token) {
			p2.openElements.clearBackToTableContext();
			p2.activeFormattingElements.insertMarker();
			p2._insertElement(token, NS.HTML);
			p2.insertionMode = IN_CAPTION_MODE;
		}
		function colgroupStartTagInTable(p2, token) {
			p2.openElements.clearBackToTableContext();
			p2._insertElement(token, NS.HTML);
			p2.insertionMode = IN_COLUMN_GROUP_MODE;
		}
		function colStartTagInTable(p2, token) {
			p2.openElements.clearBackToTableContext();
			p2._insertFakeElement($.COLGROUP);
			p2.insertionMode = IN_COLUMN_GROUP_MODE;
			p2._processToken(token);
		}
		function tbodyStartTagInTable(p2, token) {
			p2.openElements.clearBackToTableContext();
			p2._insertElement(token, NS.HTML);
			p2.insertionMode = IN_TABLE_BODY_MODE;
		}
		function tdStartTagInTable(p2, token) {
			p2.openElements.clearBackToTableContext();
			p2._insertFakeElement($.TBODY);
			p2.insertionMode = IN_TABLE_BODY_MODE;
			p2._processToken(token);
		}
		function tableStartTagInTable(p2, token) {
			if (p2.openElements.hasInTableScope($.TABLE)) {
				p2.openElements.popUntilTagNamePopped($.TABLE);
				p2._resetInsertionMode();
				p2._processToken(token);
			}
		}
		function inputStartTagInTable(p2, token) {
			const inputType = Tokenizer.getTokenAttr(token, ATTRS.TYPE);
			if (inputType && inputType.toLowerCase() === HIDDEN_INPUT_TYPE) {
				p2._appendElement(token, NS.HTML);
			} else {
				tokenInTable(p2, token);
			}
			token.ackSelfClosing = true;
		}
		function formStartTagInTable(p2, token) {
			if (!p2.formElement && p2.openElements.tmplCount === 0) {
				p2._insertElement(token, NS.HTML);
				p2.formElement = p2.openElements.current;
				p2.openElements.pop();
			}
		}
		function startTagInTable(p2, token) {
			const tn = token.tagName;
			switch (tn.length) {
				case 2:
					if (tn === $.TD || tn === $.TH || tn === $.TR) {
						tdStartTagInTable(p2, token);
					} else {
						tokenInTable(p2, token);
					}
					break;
				case 3:
					if (tn === $.COL) {
						colStartTagInTable(p2, token);
					} else {
						tokenInTable(p2, token);
					}
					break;
				case 4:
					if (tn === $.FORM) {
						formStartTagInTable(p2, token);
					} else {
						tokenInTable(p2, token);
					}
					break;
				case 5:
					if (tn === $.TABLE) {
						tableStartTagInTable(p2, token);
					} else if (tn === $.STYLE) {
						startTagInHead(p2, token);
					} else if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
						tbodyStartTagInTable(p2, token);
					} else if (tn === $.INPUT) {
						inputStartTagInTable(p2, token);
					} else {
						tokenInTable(p2, token);
					}
					break;
				case 6:
					if (tn === $.SCRIPT) {
						startTagInHead(p2, token);
					} else {
						tokenInTable(p2, token);
					}
					break;
				case 7:
					if (tn === $.CAPTION) {
						captionStartTagInTable(p2, token);
					} else {
						tokenInTable(p2, token);
					}
					break;
				case 8:
					if (tn === $.COLGROUP) {
						colgroupStartTagInTable(p2, token);
					} else if (tn === $.TEMPLATE) {
						startTagInHead(p2, token);
					} else {
						tokenInTable(p2, token);
					}
					break;
				default:
					tokenInTable(p2, token);
			}
		}
		function endTagInTable(p2, token) {
			const tn = token.tagName;
			if (tn === $.TABLE) {
				if (p2.openElements.hasInTableScope($.TABLE)) {
					p2.openElements.popUntilTagNamePopped($.TABLE);
					p2._resetInsertionMode();
				}
			} else if (tn === $.TEMPLATE) {
				endTagInHead(p2, token);
			} else if (
				tn !== $.BODY &&
				tn !== $.CAPTION &&
				tn !== $.COL &&
				tn !== $.COLGROUP &&
				tn !== $.HTML &&
				tn !== $.TBODY &&
				tn !== $.TD &&
				tn !== $.TFOOT &&
				tn !== $.TH &&
				tn !== $.THEAD &&
				tn !== $.TR
			) {
				tokenInTable(p2, token);
			}
		}
		function tokenInTable(p2, token) {
			const savedFosterParentingState = p2.fosterParentingEnabled;
			p2.fosterParentingEnabled = true;
			p2._processTokenInBodyMode(token);
			p2.fosterParentingEnabled = savedFosterParentingState;
		}
		function whitespaceCharacterInTableText(p2, token) {
			p2.pendingCharacterTokens.push(token);
		}
		function characterInTableText(p2, token) {
			p2.pendingCharacterTokens.push(token);
			p2.hasNonWhitespacePendingCharacterToken = true;
		}
		function tokenInTableText(p2, token) {
			let i2 = 0;
			if (p2.hasNonWhitespacePendingCharacterToken) {
				for (; i2 < p2.pendingCharacterTokens.length; i2++) {
					tokenInTable(p2, p2.pendingCharacterTokens[i2]);
				}
			} else {
				for (; i2 < p2.pendingCharacterTokens.length; i2++) {
					p2._insertCharacters(p2.pendingCharacterTokens[i2]);
				}
			}
			p2.insertionMode = p2.originalInsertionMode;
			p2._processToken(token);
		}
		function startTagInCaption(p2, token) {
			const tn = token.tagName;
			if (
				tn === $.CAPTION ||
				tn === $.COL ||
				tn === $.COLGROUP ||
				tn === $.TBODY ||
				tn === $.TD ||
				tn === $.TFOOT ||
				tn === $.TH ||
				tn === $.THEAD ||
				tn === $.TR
			) {
				if (p2.openElements.hasInTableScope($.CAPTION)) {
					p2.openElements.generateImpliedEndTags();
					p2.openElements.popUntilTagNamePopped($.CAPTION);
					p2.activeFormattingElements.clearToLastMarker();
					p2.insertionMode = IN_TABLE_MODE;
					p2._processToken(token);
				}
			} else {
				startTagInBody(p2, token);
			}
		}
		function endTagInCaption(p2, token) {
			const tn = token.tagName;
			if (tn === $.CAPTION || tn === $.TABLE) {
				if (p2.openElements.hasInTableScope($.CAPTION)) {
					p2.openElements.generateImpliedEndTags();
					p2.openElements.popUntilTagNamePopped($.CAPTION);
					p2.activeFormattingElements.clearToLastMarker();
					p2.insertionMode = IN_TABLE_MODE;
					if (tn === $.TABLE) {
						p2._processToken(token);
					}
				}
			} else if (
				tn !== $.BODY &&
				tn !== $.COL &&
				tn !== $.COLGROUP &&
				tn !== $.HTML &&
				tn !== $.TBODY &&
				tn !== $.TD &&
				tn !== $.TFOOT &&
				tn !== $.TH &&
				tn !== $.THEAD &&
				tn !== $.TR
			) {
				endTagInBody(p2, token);
			}
		}
		function startTagInColumnGroup(p2, token) {
			const tn = token.tagName;
			if (tn === $.HTML) {
				startTagInBody(p2, token);
			} else if (tn === $.COL) {
				p2._appendElement(token, NS.HTML);
				token.ackSelfClosing = true;
			} else if (tn === $.TEMPLATE) {
				startTagInHead(p2, token);
			} else {
				tokenInColumnGroup(p2, token);
			}
		}
		function endTagInColumnGroup(p2, token) {
			const tn = token.tagName;
			if (tn === $.COLGROUP) {
				if (p2.openElements.currentTagName === $.COLGROUP) {
					p2.openElements.pop();
					p2.insertionMode = IN_TABLE_MODE;
				}
			} else if (tn === $.TEMPLATE) {
				endTagInHead(p2, token);
			} else if (tn !== $.COL) {
				tokenInColumnGroup(p2, token);
			}
		}
		function tokenInColumnGroup(p2, token) {
			if (p2.openElements.currentTagName === $.COLGROUP) {
				p2.openElements.pop();
				p2.insertionMode = IN_TABLE_MODE;
				p2._processToken(token);
			}
		}
		function startTagInTableBody(p2, token) {
			const tn = token.tagName;
			if (tn === $.TR) {
				p2.openElements.clearBackToTableBodyContext();
				p2._insertElement(token, NS.HTML);
				p2.insertionMode = IN_ROW_MODE;
			} else if (tn === $.TH || tn === $.TD) {
				p2.openElements.clearBackToTableBodyContext();
				p2._insertFakeElement($.TR);
				p2.insertionMode = IN_ROW_MODE;
				p2._processToken(token);
			} else if (
				tn === $.CAPTION ||
				tn === $.COL ||
				tn === $.COLGROUP ||
				tn === $.TBODY ||
				tn === $.TFOOT ||
				tn === $.THEAD
			) {
				if (p2.openElements.hasTableBodyContextInTableScope()) {
					p2.openElements.clearBackToTableBodyContext();
					p2.openElements.pop();
					p2.insertionMode = IN_TABLE_MODE;
					p2._processToken(token);
				}
			} else {
				startTagInTable(p2, token);
			}
		}
		function endTagInTableBody(p2, token) {
			const tn = token.tagName;
			if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
				if (p2.openElements.hasInTableScope(tn)) {
					p2.openElements.clearBackToTableBodyContext();
					p2.openElements.pop();
					p2.insertionMode = IN_TABLE_MODE;
				}
			} else if (tn === $.TABLE) {
				if (p2.openElements.hasTableBodyContextInTableScope()) {
					p2.openElements.clearBackToTableBodyContext();
					p2.openElements.pop();
					p2.insertionMode = IN_TABLE_MODE;
					p2._processToken(token);
				}
			} else if (
				(tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP) ||
				(tn !== $.HTML && tn !== $.TD && tn !== $.TH && tn !== $.TR)
			) {
				endTagInTable(p2, token);
			}
		}
		function startTagInRow(p2, token) {
			const tn = token.tagName;
			if (tn === $.TH || tn === $.TD) {
				p2.openElements.clearBackToTableRowContext();
				p2._insertElement(token, NS.HTML);
				p2.insertionMode = IN_CELL_MODE;
				p2.activeFormattingElements.insertMarker();
			} else if (
				tn === $.CAPTION ||
				tn === $.COL ||
				tn === $.COLGROUP ||
				tn === $.TBODY ||
				tn === $.TFOOT ||
				tn === $.THEAD ||
				tn === $.TR
			) {
				if (p2.openElements.hasInTableScope($.TR)) {
					p2.openElements.clearBackToTableRowContext();
					p2.openElements.pop();
					p2.insertionMode = IN_TABLE_BODY_MODE;
					p2._processToken(token);
				}
			} else {
				startTagInTable(p2, token);
			}
		}
		function endTagInRow(p2, token) {
			const tn = token.tagName;
			if (tn === $.TR) {
				if (p2.openElements.hasInTableScope($.TR)) {
					p2.openElements.clearBackToTableRowContext();
					p2.openElements.pop();
					p2.insertionMode = IN_TABLE_BODY_MODE;
				}
			} else if (tn === $.TABLE) {
				if (p2.openElements.hasInTableScope($.TR)) {
					p2.openElements.clearBackToTableRowContext();
					p2.openElements.pop();
					p2.insertionMode = IN_TABLE_BODY_MODE;
					p2._processToken(token);
				}
			} else if (tn === $.TBODY || tn === $.TFOOT || tn === $.THEAD) {
				if (p2.openElements.hasInTableScope(tn) || p2.openElements.hasInTableScope($.TR)) {
					p2.openElements.clearBackToTableRowContext();
					p2.openElements.pop();
					p2.insertionMode = IN_TABLE_BODY_MODE;
					p2._processToken(token);
				}
			} else if (
				(tn !== $.BODY && tn !== $.CAPTION && tn !== $.COL && tn !== $.COLGROUP) ||
				(tn !== $.HTML && tn !== $.TD && tn !== $.TH)
			) {
				endTagInTable(p2, token);
			}
		}
		function startTagInCell(p2, token) {
			const tn = token.tagName;
			if (
				tn === $.CAPTION ||
				tn === $.COL ||
				tn === $.COLGROUP ||
				tn === $.TBODY ||
				tn === $.TD ||
				tn === $.TFOOT ||
				tn === $.TH ||
				tn === $.THEAD ||
				tn === $.TR
			) {
				if (p2.openElements.hasInTableScope($.TD) || p2.openElements.hasInTableScope($.TH)) {
					p2._closeTableCell();
					p2._processToken(token);
				}
			} else {
				startTagInBody(p2, token);
			}
		}
		function endTagInCell(p2, token) {
			const tn = token.tagName;
			if (tn === $.TD || tn === $.TH) {
				if (p2.openElements.hasInTableScope(tn)) {
					p2.openElements.generateImpliedEndTags();
					p2.openElements.popUntilTagNamePopped(tn);
					p2.activeFormattingElements.clearToLastMarker();
					p2.insertionMode = IN_ROW_MODE;
				}
			} else if (
				tn === $.TABLE ||
				tn === $.TBODY ||
				tn === $.TFOOT ||
				tn === $.THEAD ||
				tn === $.TR
			) {
				if (p2.openElements.hasInTableScope(tn)) {
					p2._closeTableCell();
					p2._processToken(token);
				}
			} else if (
				tn !== $.BODY &&
				tn !== $.CAPTION &&
				tn !== $.COL &&
				tn !== $.COLGROUP &&
				tn !== $.HTML
			) {
				endTagInBody(p2, token);
			}
		}
		function startTagInSelect(p2, token) {
			const tn = token.tagName;
			if (tn === $.HTML) {
				startTagInBody(p2, token);
			} else if (tn === $.OPTION) {
				if (p2.openElements.currentTagName === $.OPTION) {
					p2.openElements.pop();
				}
				p2._insertElement(token, NS.HTML);
			} else if (tn === $.OPTGROUP) {
				if (p2.openElements.currentTagName === $.OPTION) {
					p2.openElements.pop();
				}
				if (p2.openElements.currentTagName === $.OPTGROUP) {
					p2.openElements.pop();
				}
				p2._insertElement(token, NS.HTML);
			} else if (tn === $.INPUT || tn === $.KEYGEN || tn === $.TEXTAREA || tn === $.SELECT) {
				if (p2.openElements.hasInSelectScope($.SELECT)) {
					p2.openElements.popUntilTagNamePopped($.SELECT);
					p2._resetInsertionMode();
					if (tn !== $.SELECT) {
						p2._processToken(token);
					}
				}
			} else if (tn === $.SCRIPT || tn === $.TEMPLATE) {
				startTagInHead(p2, token);
			}
		}
		function endTagInSelect(p2, token) {
			const tn = token.tagName;
			if (tn === $.OPTGROUP) {
				const prevOpenElement = p2.openElements.items[p2.openElements.stackTop - 1];
				const prevOpenElementTn = prevOpenElement && p2.treeAdapter.getTagName(prevOpenElement);
				if (p2.openElements.currentTagName === $.OPTION && prevOpenElementTn === $.OPTGROUP) {
					p2.openElements.pop();
				}
				if (p2.openElements.currentTagName === $.OPTGROUP) {
					p2.openElements.pop();
				}
			} else if (tn === $.OPTION) {
				if (p2.openElements.currentTagName === $.OPTION) {
					p2.openElements.pop();
				}
			} else if (tn === $.SELECT && p2.openElements.hasInSelectScope($.SELECT)) {
				p2.openElements.popUntilTagNamePopped($.SELECT);
				p2._resetInsertionMode();
			} else if (tn === $.TEMPLATE) {
				endTagInHead(p2, token);
			}
		}
		function startTagInSelectInTable(p2, token) {
			const tn = token.tagName;
			if (
				tn === $.CAPTION ||
				tn === $.TABLE ||
				tn === $.TBODY ||
				tn === $.TFOOT ||
				tn === $.THEAD ||
				tn === $.TR ||
				tn === $.TD ||
				tn === $.TH
			) {
				p2.openElements.popUntilTagNamePopped($.SELECT);
				p2._resetInsertionMode();
				p2._processToken(token);
			} else {
				startTagInSelect(p2, token);
			}
		}
		function endTagInSelectInTable(p2, token) {
			const tn = token.tagName;
			if (
				tn === $.CAPTION ||
				tn === $.TABLE ||
				tn === $.TBODY ||
				tn === $.TFOOT ||
				tn === $.THEAD ||
				tn === $.TR ||
				tn === $.TD ||
				tn === $.TH
			) {
				if (p2.openElements.hasInTableScope(tn)) {
					p2.openElements.popUntilTagNamePopped($.SELECT);
					p2._resetInsertionMode();
					p2._processToken(token);
				}
			} else {
				endTagInSelect(p2, token);
			}
		}
		function startTagInTemplate(p2, token) {
			const tn = token.tagName;
			if (
				tn === $.BASE ||
				tn === $.BASEFONT ||
				tn === $.BGSOUND ||
				tn === $.LINK ||
				tn === $.META ||
				tn === $.NOFRAMES ||
				tn === $.SCRIPT ||
				tn === $.STYLE ||
				tn === $.TEMPLATE ||
				tn === $.TITLE
			) {
				startTagInHead(p2, token);
			} else {
				const newInsertionMode = TEMPLATE_INSERTION_MODE_SWITCH_MAP[tn] || IN_BODY_MODE;
				p2._popTmplInsertionMode();
				p2._pushTmplInsertionMode(newInsertionMode);
				p2.insertionMode = newInsertionMode;
				p2._processToken(token);
			}
		}
		function endTagInTemplate(p2, token) {
			if (token.tagName === $.TEMPLATE) {
				endTagInHead(p2, token);
			}
		}
		function eofInTemplate(p2, token) {
			if (p2.openElements.tmplCount > 0) {
				p2.openElements.popUntilTagNamePopped($.TEMPLATE);
				p2.activeFormattingElements.clearToLastMarker();
				p2._popTmplInsertionMode();
				p2._resetInsertionMode();
				p2._processToken(token);
			} else {
				p2.stopped = true;
			}
		}
		function startTagAfterBody(p2, token) {
			if (token.tagName === $.HTML) {
				startTagInBody(p2, token);
			} else {
				tokenAfterBody(p2, token);
			}
		}
		function endTagAfterBody(p2, token) {
			if (token.tagName === $.HTML) {
				if (!p2.fragmentContext) {
					p2.insertionMode = AFTER_AFTER_BODY_MODE;
				}
			} else {
				tokenAfterBody(p2, token);
			}
		}
		function tokenAfterBody(p2, token) {
			p2.insertionMode = IN_BODY_MODE;
			p2._processToken(token);
		}
		function startTagInFrameset(p2, token) {
			const tn = token.tagName;
			if (tn === $.HTML) {
				startTagInBody(p2, token);
			} else if (tn === $.FRAMESET) {
				p2._insertElement(token, NS.HTML);
			} else if (tn === $.FRAME) {
				p2._appendElement(token, NS.HTML);
				token.ackSelfClosing = true;
			} else if (tn === $.NOFRAMES) {
				startTagInHead(p2, token);
			}
		}
		function endTagInFrameset(p2, token) {
			if (token.tagName === $.FRAMESET && !p2.openElements.isRootHtmlElementCurrent()) {
				p2.openElements.pop();
				if (!p2.fragmentContext && p2.openElements.currentTagName !== $.FRAMESET) {
					p2.insertionMode = AFTER_FRAMESET_MODE;
				}
			}
		}
		function startTagAfterFrameset(p2, token) {
			const tn = token.tagName;
			if (tn === $.HTML) {
				startTagInBody(p2, token);
			} else if (tn === $.NOFRAMES) {
				startTagInHead(p2, token);
			}
		}
		function endTagAfterFrameset(p2, token) {
			if (token.tagName === $.HTML) {
				p2.insertionMode = AFTER_AFTER_FRAMESET_MODE;
			}
		}
		function startTagAfterAfterBody(p2, token) {
			if (token.tagName === $.HTML) {
				startTagInBody(p2, token);
			} else {
				tokenAfterAfterBody(p2, token);
			}
		}
		function tokenAfterAfterBody(p2, token) {
			p2.insertionMode = IN_BODY_MODE;
			p2._processToken(token);
		}
		function startTagAfterAfterFrameset(p2, token) {
			const tn = token.tagName;
			if (tn === $.HTML) {
				startTagInBody(p2, token);
			} else if (tn === $.NOFRAMES) {
				startTagInHead(p2, token);
			}
		}
		function nullCharacterInForeignContent(p2, token) {
			token.chars = unicode.REPLACEMENT_CHARACTER;
			p2._insertCharacters(token);
		}
		function characterInForeignContent(p2, token) {
			p2._insertCharacters(token);
			p2.framesetOk = false;
		}
		function startTagInForeignContent(p2, token) {
			if (foreignContent.causesExit(token) && !p2.fragmentContext) {
				while (
					p2.treeAdapter.getNamespaceURI(p2.openElements.current) !== NS.HTML &&
					!p2._isIntegrationPoint(p2.openElements.current)
				) {
					p2.openElements.pop();
				}
				p2._processToken(token);
			} else {
				const current = p2._getAdjustedCurrentElement();
				const currentNs = p2.treeAdapter.getNamespaceURI(current);
				if (currentNs === NS.MATHML) {
					foreignContent.adjustTokenMathMLAttrs(token);
				} else if (currentNs === NS.SVG) {
					foreignContent.adjustTokenSVGTagName(token);
					foreignContent.adjustTokenSVGAttrs(token);
				}
				foreignContent.adjustTokenXMLAttrs(token);
				if (token.selfClosing) {
					p2._appendElement(token, currentNs);
				} else {
					p2._insertElement(token, currentNs);
				}
				token.ackSelfClosing = true;
			}
		}
		function endTagInForeignContent(p2, token) {
			for (let i2 = p2.openElements.stackTop; i2 > 0; i2--) {
				const element4 = p2.openElements.items[i2];
				if (p2.treeAdapter.getNamespaceURI(element4) === NS.HTML) {
					p2._processToken(token);
					break;
				}
				if (p2.treeAdapter.getTagName(element4).toLowerCase() === token.tagName) {
					p2.openElements.popUntilElementPopped(element4);
					break;
				}
			}
		}
	}
});

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/util/schema.js
var Schema2;
var init_schema3 = __esm({
	'node_modules/hast-util-from-parse5/node_modules/property-information/lib/util/schema.js'() {
		Schema2 = class {
			constructor(property, normal, space) {
				this.property = property;
				this.normal = normal;
				if (space) {
					this.space = space;
				}
			}
		};
		Schema2.prototype.property = {};
		Schema2.prototype.normal = {};
		Schema2.prototype.space = null;
	}
});

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/util/merge.js
function merge2(definitions2, space) {
	const property = {};
	const normal = {};
	let index6 = -1;
	while (++index6 < definitions2.length) {
		Object.assign(property, definitions2[index6].property);
		Object.assign(normal, definitions2[index6].normal);
	}
	return new Schema2(property, normal, space);
}
var init_merge2 = __esm({
	'node_modules/hast-util-from-parse5/node_modules/property-information/lib/util/merge.js'() {
		init_schema3();
	}
});

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/normalize.js
function normalize7(value) {
	return value.toLowerCase();
}
var init_normalize2 = __esm({
	'node_modules/hast-util-from-parse5/node_modules/property-information/lib/normalize.js'() {}
});

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/util/info.js
var Info2;
var init_info2 = __esm({
	'node_modules/hast-util-from-parse5/node_modules/property-information/lib/util/info.js'() {
		Info2 = class {
			constructor(property, attribute) {
				this.property = property;
				this.attribute = attribute;
			}
		};
		Info2.prototype.space = null;
		Info2.prototype.boolean = false;
		Info2.prototype.booleanish = false;
		Info2.prototype.overloadedBoolean = false;
		Info2.prototype.number = false;
		Info2.prototype.commaSeparated = false;
		Info2.prototype.spaceSeparated = false;
		Info2.prototype.commaOrSpaceSeparated = false;
		Info2.prototype.mustUseProperty = false;
		Info2.prototype.defined = false;
	}
});

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/util/types.js
var types_exports2 = {};
__export(types_exports2, {
	boolean: () => boolean2,
	booleanish: () => booleanish2,
	commaOrSpaceSeparated: () => commaOrSpaceSeparated2,
	commaSeparated: () => commaSeparated2,
	number: () => number2,
	overloadedBoolean: () => overloadedBoolean2,
	spaceSeparated: () => spaceSeparated2
});
function increment2() {
	return 2 ** ++powers2;
}
var powers2,
	boolean2,
	booleanish2,
	overloadedBoolean2,
	number2,
	spaceSeparated2,
	commaSeparated2,
	commaOrSpaceSeparated2;
var init_types2 = __esm({
	'node_modules/hast-util-from-parse5/node_modules/property-information/lib/util/types.js'() {
		powers2 = 0;
		boolean2 = increment2();
		booleanish2 = increment2();
		overloadedBoolean2 = increment2();
		number2 = increment2();
		spaceSeparated2 = increment2();
		commaSeparated2 = increment2();
		commaOrSpaceSeparated2 = increment2();
	}
});

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/util/defined-info.js
function mark2(values, key3, value) {
	if (value) {
		values[key3] = value;
	}
}
var checks2, DefinedInfo2;
var init_defined_info2 = __esm({
	'node_modules/hast-util-from-parse5/node_modules/property-information/lib/util/defined-info.js'() {
		init_info2();
		init_types2();
		checks2 = Object.keys(types_exports2);
		DefinedInfo2 = class extends Info2 {
			constructor(property, attribute, mask, space) {
				let index6 = -1;
				super(property, attribute);
				mark2(this, 'space', space);
				if (typeof mask === 'number') {
					while (++index6 < checks2.length) {
						const check = checks2[index6];
						mark2(this, checks2[index6], (mask & types_exports2[check]) === types_exports2[check]);
					}
				}
			}
		};
		DefinedInfo2.prototype.defined = true;
	}
});

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/util/create.js
function create2(definition3) {
	const property = {};
	const normal = {};
	let prop;
	for (prop in definition3.properties) {
		if (own13.call(definition3.properties, prop)) {
			const value = definition3.properties[prop];
			const info = new DefinedInfo2(
				prop,
				definition3.transform(definition3.attributes || {}, prop),
				value,
				definition3.space
			);
			if (definition3.mustUseProperty && definition3.mustUseProperty.includes(prop)) {
				info.mustUseProperty = true;
			}
			property[prop] = info;
			normal[normalize7(prop)] = prop;
			normal[normalize7(info.attribute)] = prop;
		}
	}
	return new Schema2(property, normal, definition3.space);
}
var own13;
var init_create2 = __esm({
	'node_modules/hast-util-from-parse5/node_modules/property-information/lib/util/create.js'() {
		init_normalize2();
		init_schema3();
		init_defined_info2();
		own13 = {}.hasOwnProperty;
	}
});

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/xlink.js
var xlink2;
var init_xlink2 = __esm({
	'node_modules/hast-util-from-parse5/node_modules/property-information/lib/xlink.js'() {
		init_create2();
		xlink2 = create2({
			space: 'xlink',
			transform(_, prop) {
				return 'xlink:' + prop.slice(5).toLowerCase();
			},
			properties: {
				xLinkActuate: null,
				xLinkArcRole: null,
				xLinkHref: null,
				xLinkRole: null,
				xLinkShow: null,
				xLinkTitle: null,
				xLinkType: null
			}
		});
	}
});

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/xml.js
var xml2;
var init_xml2 = __esm({
	'node_modules/hast-util-from-parse5/node_modules/property-information/lib/xml.js'() {
		init_create2();
		xml2 = create2({
			space: 'xml',
			transform(_, prop) {
				return 'xml:' + prop.slice(3).toLowerCase();
			},
			properties: { xmlLang: null, xmlBase: null, xmlSpace: null }
		});
	}
});

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/util/case-sensitive-transform.js
function caseSensitiveTransform2(attributes, attribute) {
	return attribute in attributes ? attributes[attribute] : attribute;
}
var init_case_sensitive_transform2 = __esm({
	'node_modules/hast-util-from-parse5/node_modules/property-information/lib/util/case-sensitive-transform.js'() {}
});

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/util/case-insensitive-transform.js
function caseInsensitiveTransform2(attributes, property) {
	return caseSensitiveTransform2(attributes, property.toLowerCase());
}
var init_case_insensitive_transform2 = __esm({
	'node_modules/hast-util-from-parse5/node_modules/property-information/lib/util/case-insensitive-transform.js'() {
		init_case_sensitive_transform2();
	}
});

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/xmlns.js
var xmlns2;
var init_xmlns2 = __esm({
	'node_modules/hast-util-from-parse5/node_modules/property-information/lib/xmlns.js'() {
		init_create2();
		init_case_insensitive_transform2();
		xmlns2 = create2({
			space: 'xmlns',
			attributes: { xmlnsxlink: 'xmlns:xlink' },
			transform: caseInsensitiveTransform2,
			properties: { xmlns: null, xmlnsXLink: null }
		});
	}
});

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/aria.js
var aria2;
var init_aria2 = __esm({
	'node_modules/hast-util-from-parse5/node_modules/property-information/lib/aria.js'() {
		init_types2();
		init_create2();
		aria2 = create2({
			transform(_, prop) {
				return prop === 'role' ? prop : 'aria-' + prop.slice(4).toLowerCase();
			},
			properties: {
				ariaActiveDescendant: null,
				ariaAtomic: booleanish2,
				ariaAutoComplete: null,
				ariaBusy: booleanish2,
				ariaChecked: booleanish2,
				ariaColCount: number2,
				ariaColIndex: number2,
				ariaColSpan: number2,
				ariaControls: spaceSeparated2,
				ariaCurrent: null,
				ariaDescribedBy: spaceSeparated2,
				ariaDetails: null,
				ariaDisabled: booleanish2,
				ariaDropEffect: spaceSeparated2,
				ariaErrorMessage: null,
				ariaExpanded: booleanish2,
				ariaFlowTo: spaceSeparated2,
				ariaGrabbed: booleanish2,
				ariaHasPopup: null,
				ariaHidden: booleanish2,
				ariaInvalid: null,
				ariaKeyShortcuts: null,
				ariaLabel: null,
				ariaLabelledBy: spaceSeparated2,
				ariaLevel: number2,
				ariaLive: null,
				ariaModal: booleanish2,
				ariaMultiLine: booleanish2,
				ariaMultiSelectable: booleanish2,
				ariaOrientation: null,
				ariaOwns: spaceSeparated2,
				ariaPlaceholder: null,
				ariaPosInSet: number2,
				ariaPressed: booleanish2,
				ariaReadOnly: booleanish2,
				ariaRelevant: null,
				ariaRequired: booleanish2,
				ariaRoleDescription: spaceSeparated2,
				ariaRowCount: number2,
				ariaRowIndex: number2,
				ariaRowSpan: number2,
				ariaSelected: booleanish2,
				ariaSetSize: number2,
				ariaSort: null,
				ariaValueMax: number2,
				ariaValueMin: number2,
				ariaValueNow: number2,
				ariaValueText: null,
				role: null
			}
		});
	}
});

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/html.js
var html7;
var init_html4 = __esm({
	'node_modules/hast-util-from-parse5/node_modules/property-information/lib/html.js'() {
		init_types2();
		init_create2();
		init_case_insensitive_transform2();
		html7 = create2({
			space: 'html',
			attributes: {
				acceptcharset: 'accept-charset',
				classname: 'class',
				htmlfor: 'for',
				httpequiv: 'http-equiv'
			},
			transform: caseInsensitiveTransform2,
			mustUseProperty: ['checked', 'multiple', 'muted', 'selected'],
			properties: {
				abbr: null,
				accept: commaSeparated2,
				acceptCharset: spaceSeparated2,
				accessKey: spaceSeparated2,
				action: null,
				allow: null,
				allowFullScreen: boolean2,
				allowPaymentRequest: boolean2,
				allowUserMedia: boolean2,
				alt: null,
				as: null,
				async: boolean2,
				autoCapitalize: null,
				autoComplete: spaceSeparated2,
				autoFocus: boolean2,
				autoPlay: boolean2,
				capture: boolean2,
				charSet: null,
				checked: boolean2,
				cite: null,
				className: spaceSeparated2,
				cols: number2,
				colSpan: null,
				content: null,
				contentEditable: booleanish2,
				controls: boolean2,
				controlsList: spaceSeparated2,
				coords: number2 | commaSeparated2,
				crossOrigin: null,
				data: null,
				dateTime: null,
				decoding: null,
				default: boolean2,
				defer: boolean2,
				dir: null,
				dirName: null,
				disabled: boolean2,
				download: overloadedBoolean2,
				draggable: booleanish2,
				encType: null,
				enterKeyHint: null,
				form: null,
				formAction: null,
				formEncType: null,
				formMethod: null,
				formNoValidate: boolean2,
				formTarget: null,
				headers: spaceSeparated2,
				height: number2,
				hidden: boolean2,
				high: number2,
				href: null,
				hrefLang: null,
				htmlFor: spaceSeparated2,
				httpEquiv: spaceSeparated2,
				id: null,
				imageSizes: null,
				imageSrcSet: null,
				inputMode: null,
				integrity: null,
				is: null,
				isMap: boolean2,
				itemId: null,
				itemProp: spaceSeparated2,
				itemRef: spaceSeparated2,
				itemScope: boolean2,
				itemType: spaceSeparated2,
				kind: null,
				label: null,
				lang: null,
				language: null,
				list: null,
				loading: null,
				loop: boolean2,
				low: number2,
				manifest: null,
				max: null,
				maxLength: number2,
				media: null,
				method: null,
				min: null,
				minLength: number2,
				multiple: boolean2,
				muted: boolean2,
				name: null,
				nonce: null,
				noModule: boolean2,
				noValidate: boolean2,
				onAbort: null,
				onAfterPrint: null,
				onAuxClick: null,
				onBeforePrint: null,
				onBeforeUnload: null,
				onBlur: null,
				onCancel: null,
				onCanPlay: null,
				onCanPlayThrough: null,
				onChange: null,
				onClick: null,
				onClose: null,
				onContextLost: null,
				onContextMenu: null,
				onContextRestored: null,
				onCopy: null,
				onCueChange: null,
				onCut: null,
				onDblClick: null,
				onDrag: null,
				onDragEnd: null,
				onDragEnter: null,
				onDragExit: null,
				onDragLeave: null,
				onDragOver: null,
				onDragStart: null,
				onDrop: null,
				onDurationChange: null,
				onEmptied: null,
				onEnded: null,
				onError: null,
				onFocus: null,
				onFormData: null,
				onHashChange: null,
				onInput: null,
				onInvalid: null,
				onKeyDown: null,
				onKeyPress: null,
				onKeyUp: null,
				onLanguageChange: null,
				onLoad: null,
				onLoadedData: null,
				onLoadedMetadata: null,
				onLoadEnd: null,
				onLoadStart: null,
				onMessage: null,
				onMessageError: null,
				onMouseDown: null,
				onMouseEnter: null,
				onMouseLeave: null,
				onMouseMove: null,
				onMouseOut: null,
				onMouseOver: null,
				onMouseUp: null,
				onOffline: null,
				onOnline: null,
				onPageHide: null,
				onPageShow: null,
				onPaste: null,
				onPause: null,
				onPlay: null,
				onPlaying: null,
				onPopState: null,
				onProgress: null,
				onRateChange: null,
				onRejectionHandled: null,
				onReset: null,
				onResize: null,
				onScroll: null,
				onSecurityPolicyViolation: null,
				onSeeked: null,
				onSeeking: null,
				onSelect: null,
				onSlotChange: null,
				onStalled: null,
				onStorage: null,
				onSubmit: null,
				onSuspend: null,
				onTimeUpdate: null,
				onToggle: null,
				onUnhandledRejection: null,
				onUnload: null,
				onVolumeChange: null,
				onWaiting: null,
				onWheel: null,
				open: boolean2,
				optimum: number2,
				pattern: null,
				ping: spaceSeparated2,
				placeholder: null,
				playsInline: boolean2,
				poster: null,
				preload: null,
				readOnly: boolean2,
				referrerPolicy: null,
				rel: spaceSeparated2,
				required: boolean2,
				reversed: boolean2,
				rows: number2,
				rowSpan: number2,
				sandbox: spaceSeparated2,
				scope: null,
				scoped: boolean2,
				seamless: boolean2,
				selected: boolean2,
				shape: null,
				size: number2,
				sizes: null,
				slot: null,
				span: number2,
				spellCheck: booleanish2,
				src: null,
				srcDoc: null,
				srcLang: null,
				srcSet: null,
				start: number2,
				step: null,
				style: null,
				tabIndex: number2,
				target: null,
				title: null,
				translate: null,
				type: null,
				typeMustMatch: boolean2,
				useMap: null,
				value: booleanish2,
				width: number2,
				wrap: null,
				align: null,
				aLink: null,
				archive: spaceSeparated2,
				axis: null,
				background: null,
				bgColor: null,
				border: number2,
				borderColor: null,
				bottomMargin: number2,
				cellPadding: null,
				cellSpacing: null,
				char: null,
				charOff: null,
				classId: null,
				clear: null,
				code: null,
				codeBase: null,
				codeType: null,
				color: null,
				compact: boolean2,
				declare: boolean2,
				event: null,
				face: null,
				frame: null,
				frameBorder: null,
				hSpace: number2,
				leftMargin: number2,
				link: null,
				longDesc: null,
				lowSrc: null,
				marginHeight: number2,
				marginWidth: number2,
				noResize: boolean2,
				noHref: boolean2,
				noShade: boolean2,
				noWrap: boolean2,
				object: null,
				profile: null,
				prompt: null,
				rev: null,
				rightMargin: number2,
				rules: null,
				scheme: null,
				scrolling: booleanish2,
				standby: null,
				summary: null,
				text: null,
				topMargin: number2,
				valueType: null,
				version: null,
				vAlign: null,
				vLink: null,
				vSpace: number2,
				allowTransparency: null,
				autoCorrect: null,
				autoSave: null,
				disablePictureInPicture: boolean2,
				disableRemotePlayback: boolean2,
				prefix: null,
				property: null,
				results: number2,
				security: null,
				unselectable: null
			}
		});
	}
});

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/svg.js
var svg3;
var init_svg2 = __esm({
	'node_modules/hast-util-from-parse5/node_modules/property-information/lib/svg.js'() {
		init_types2();
		init_create2();
		init_case_sensitive_transform2();
		svg3 = create2({
			space: 'svg',
			attributes: {
				accentHeight: 'accent-height',
				alignmentBaseline: 'alignment-baseline',
				arabicForm: 'arabic-form',
				baselineShift: 'baseline-shift',
				capHeight: 'cap-height',
				className: 'class',
				clipPath: 'clip-path',
				clipRule: 'clip-rule',
				colorInterpolation: 'color-interpolation',
				colorInterpolationFilters: 'color-interpolation-filters',
				colorProfile: 'color-profile',
				colorRendering: 'color-rendering',
				crossOrigin: 'crossorigin',
				dataType: 'datatype',
				dominantBaseline: 'dominant-baseline',
				enableBackground: 'enable-background',
				fillOpacity: 'fill-opacity',
				fillRule: 'fill-rule',
				floodColor: 'flood-color',
				floodOpacity: 'flood-opacity',
				fontFamily: 'font-family',
				fontSize: 'font-size',
				fontSizeAdjust: 'font-size-adjust',
				fontStretch: 'font-stretch',
				fontStyle: 'font-style',
				fontVariant: 'font-variant',
				fontWeight: 'font-weight',
				glyphName: 'glyph-name',
				glyphOrientationHorizontal: 'glyph-orientation-horizontal',
				glyphOrientationVertical: 'glyph-orientation-vertical',
				hrefLang: 'hreflang',
				horizAdvX: 'horiz-adv-x',
				horizOriginX: 'horiz-origin-x',
				horizOriginY: 'horiz-origin-y',
				imageRendering: 'image-rendering',
				letterSpacing: 'letter-spacing',
				lightingColor: 'lighting-color',
				markerEnd: 'marker-end',
				markerMid: 'marker-mid',
				markerStart: 'marker-start',
				navDown: 'nav-down',
				navDownLeft: 'nav-down-left',
				navDownRight: 'nav-down-right',
				navLeft: 'nav-left',
				navNext: 'nav-next',
				navPrev: 'nav-prev',
				navRight: 'nav-right',
				navUp: 'nav-up',
				navUpLeft: 'nav-up-left',
				navUpRight: 'nav-up-right',
				onAbort: 'onabort',
				onActivate: 'onactivate',
				onAfterPrint: 'onafterprint',
				onBeforePrint: 'onbeforeprint',
				onBegin: 'onbegin',
				onCancel: 'oncancel',
				onCanPlay: 'oncanplay',
				onCanPlayThrough: 'oncanplaythrough',
				onChange: 'onchange',
				onClick: 'onclick',
				onClose: 'onclose',
				onCopy: 'oncopy',
				onCueChange: 'oncuechange',
				onCut: 'oncut',
				onDblClick: 'ondblclick',
				onDrag: 'ondrag',
				onDragEnd: 'ondragend',
				onDragEnter: 'ondragenter',
				onDragExit: 'ondragexit',
				onDragLeave: 'ondragleave',
				onDragOver: 'ondragover',
				onDragStart: 'ondragstart',
				onDrop: 'ondrop',
				onDurationChange: 'ondurationchange',
				onEmptied: 'onemptied',
				onEnd: 'onend',
				onEnded: 'onended',
				onError: 'onerror',
				onFocus: 'onfocus',
				onFocusIn: 'onfocusin',
				onFocusOut: 'onfocusout',
				onHashChange: 'onhashchange',
				onInput: 'oninput',
				onInvalid: 'oninvalid',
				onKeyDown: 'onkeydown',
				onKeyPress: 'onkeypress',
				onKeyUp: 'onkeyup',
				onLoad: 'onload',
				onLoadedData: 'onloadeddata',
				onLoadedMetadata: 'onloadedmetadata',
				onLoadStart: 'onloadstart',
				onMessage: 'onmessage',
				onMouseDown: 'onmousedown',
				onMouseEnter: 'onmouseenter',
				onMouseLeave: 'onmouseleave',
				onMouseMove: 'onmousemove',
				onMouseOut: 'onmouseout',
				onMouseOver: 'onmouseover',
				onMouseUp: 'onmouseup',
				onMouseWheel: 'onmousewheel',
				onOffline: 'onoffline',
				onOnline: 'ononline',
				onPageHide: 'onpagehide',
				onPageShow: 'onpageshow',
				onPaste: 'onpaste',
				onPause: 'onpause',
				onPlay: 'onplay',
				onPlaying: 'onplaying',
				onPopState: 'onpopstate',
				onProgress: 'onprogress',
				onRateChange: 'onratechange',
				onRepeat: 'onrepeat',
				onReset: 'onreset',
				onResize: 'onresize',
				onScroll: 'onscroll',
				onSeeked: 'onseeked',
				onSeeking: 'onseeking',
				onSelect: 'onselect',
				onShow: 'onshow',
				onStalled: 'onstalled',
				onStorage: 'onstorage',
				onSubmit: 'onsubmit',
				onSuspend: 'onsuspend',
				onTimeUpdate: 'ontimeupdate',
				onToggle: 'ontoggle',
				onUnload: 'onunload',
				onVolumeChange: 'onvolumechange',
				onWaiting: 'onwaiting',
				onZoom: 'onzoom',
				overlinePosition: 'overline-position',
				overlineThickness: 'overline-thickness',
				paintOrder: 'paint-order',
				panose1: 'panose-1',
				pointerEvents: 'pointer-events',
				referrerPolicy: 'referrerpolicy',
				renderingIntent: 'rendering-intent',
				shapeRendering: 'shape-rendering',
				stopColor: 'stop-color',
				stopOpacity: 'stop-opacity',
				strikethroughPosition: 'strikethrough-position',
				strikethroughThickness: 'strikethrough-thickness',
				strokeDashArray: 'stroke-dasharray',
				strokeDashOffset: 'stroke-dashoffset',
				strokeLineCap: 'stroke-linecap',
				strokeLineJoin: 'stroke-linejoin',
				strokeMiterLimit: 'stroke-miterlimit',
				strokeOpacity: 'stroke-opacity',
				strokeWidth: 'stroke-width',
				tabIndex: 'tabindex',
				textAnchor: 'text-anchor',
				textDecoration: 'text-decoration',
				textRendering: 'text-rendering',
				typeOf: 'typeof',
				underlinePosition: 'underline-position',
				underlineThickness: 'underline-thickness',
				unicodeBidi: 'unicode-bidi',
				unicodeRange: 'unicode-range',
				unitsPerEm: 'units-per-em',
				vAlphabetic: 'v-alphabetic',
				vHanging: 'v-hanging',
				vIdeographic: 'v-ideographic',
				vMathematical: 'v-mathematical',
				vectorEffect: 'vector-effect',
				vertAdvY: 'vert-adv-y',
				vertOriginX: 'vert-origin-x',
				vertOriginY: 'vert-origin-y',
				wordSpacing: 'word-spacing',
				writingMode: 'writing-mode',
				xHeight: 'x-height',
				playbackOrder: 'playbackorder',
				timelineBegin: 'timelinebegin'
			},
			transform: caseSensitiveTransform2,
			properties: {
				about: commaOrSpaceSeparated2,
				accentHeight: number2,
				accumulate: null,
				additive: null,
				alignmentBaseline: null,
				alphabetic: number2,
				amplitude: number2,
				arabicForm: null,
				ascent: number2,
				attributeName: null,
				attributeType: null,
				azimuth: number2,
				bandwidth: null,
				baselineShift: null,
				baseFrequency: null,
				baseProfile: null,
				bbox: null,
				begin: null,
				bias: number2,
				by: null,
				calcMode: null,
				capHeight: number2,
				className: spaceSeparated2,
				clip: null,
				clipPath: null,
				clipPathUnits: null,
				clipRule: null,
				color: null,
				colorInterpolation: null,
				colorInterpolationFilters: null,
				colorProfile: null,
				colorRendering: null,
				content: null,
				contentScriptType: null,
				contentStyleType: null,
				crossOrigin: null,
				cursor: null,
				cx: null,
				cy: null,
				d: null,
				dataType: null,
				defaultAction: null,
				descent: number2,
				diffuseConstant: number2,
				direction: null,
				display: null,
				dur: null,
				divisor: number2,
				dominantBaseline: null,
				download: boolean2,
				dx: null,
				dy: null,
				edgeMode: null,
				editable: null,
				elevation: number2,
				enableBackground: null,
				end: null,
				event: null,
				exponent: number2,
				externalResourcesRequired: null,
				fill: null,
				fillOpacity: number2,
				fillRule: null,
				filter: null,
				filterRes: null,
				filterUnits: null,
				floodColor: null,
				floodOpacity: null,
				focusable: null,
				focusHighlight: null,
				fontFamily: null,
				fontSize: null,
				fontSizeAdjust: null,
				fontStretch: null,
				fontStyle: null,
				fontVariant: null,
				fontWeight: null,
				format: null,
				fr: null,
				from: null,
				fx: null,
				fy: null,
				g1: commaSeparated2,
				g2: commaSeparated2,
				glyphName: commaSeparated2,
				glyphOrientationHorizontal: null,
				glyphOrientationVertical: null,
				glyphRef: null,
				gradientTransform: null,
				gradientUnits: null,
				handler: null,
				hanging: number2,
				hatchContentUnits: null,
				hatchUnits: null,
				height: null,
				href: null,
				hrefLang: null,
				horizAdvX: number2,
				horizOriginX: number2,
				horizOriginY: number2,
				id: null,
				ideographic: number2,
				imageRendering: null,
				initialVisibility: null,
				in: null,
				in2: null,
				intercept: number2,
				k: number2,
				k1: number2,
				k2: number2,
				k3: number2,
				k4: number2,
				kernelMatrix: commaOrSpaceSeparated2,
				kernelUnitLength: null,
				keyPoints: null,
				keySplines: null,
				keyTimes: null,
				kerning: null,
				lang: null,
				lengthAdjust: null,
				letterSpacing: null,
				lightingColor: null,
				limitingConeAngle: number2,
				local: null,
				markerEnd: null,
				markerMid: null,
				markerStart: null,
				markerHeight: null,
				markerUnits: null,
				markerWidth: null,
				mask: null,
				maskContentUnits: null,
				maskUnits: null,
				mathematical: null,
				max: null,
				media: null,
				mediaCharacterEncoding: null,
				mediaContentEncodings: null,
				mediaSize: number2,
				mediaTime: null,
				method: null,
				min: null,
				mode: null,
				name: null,
				navDown: null,
				navDownLeft: null,
				navDownRight: null,
				navLeft: null,
				navNext: null,
				navPrev: null,
				navRight: null,
				navUp: null,
				navUpLeft: null,
				navUpRight: null,
				numOctaves: null,
				observer: null,
				offset: null,
				onAbort: null,
				onActivate: null,
				onAfterPrint: null,
				onBeforePrint: null,
				onBegin: null,
				onCancel: null,
				onCanPlay: null,
				onCanPlayThrough: null,
				onChange: null,
				onClick: null,
				onClose: null,
				onCopy: null,
				onCueChange: null,
				onCut: null,
				onDblClick: null,
				onDrag: null,
				onDragEnd: null,
				onDragEnter: null,
				onDragExit: null,
				onDragLeave: null,
				onDragOver: null,
				onDragStart: null,
				onDrop: null,
				onDurationChange: null,
				onEmptied: null,
				onEnd: null,
				onEnded: null,
				onError: null,
				onFocus: null,
				onFocusIn: null,
				onFocusOut: null,
				onHashChange: null,
				onInput: null,
				onInvalid: null,
				onKeyDown: null,
				onKeyPress: null,
				onKeyUp: null,
				onLoad: null,
				onLoadedData: null,
				onLoadedMetadata: null,
				onLoadStart: null,
				onMessage: null,
				onMouseDown: null,
				onMouseEnter: null,
				onMouseLeave: null,
				onMouseMove: null,
				onMouseOut: null,
				onMouseOver: null,
				onMouseUp: null,
				onMouseWheel: null,
				onOffline: null,
				onOnline: null,
				onPageHide: null,
				onPageShow: null,
				onPaste: null,
				onPause: null,
				onPlay: null,
				onPlaying: null,
				onPopState: null,
				onProgress: null,
				onRateChange: null,
				onRepeat: null,
				onReset: null,
				onResize: null,
				onScroll: null,
				onSeeked: null,
				onSeeking: null,
				onSelect: null,
				onShow: null,
				onStalled: null,
				onStorage: null,
				onSubmit: null,
				onSuspend: null,
				onTimeUpdate: null,
				onToggle: null,
				onUnload: null,
				onVolumeChange: null,
				onWaiting: null,
				onZoom: null,
				opacity: null,
				operator: null,
				order: null,
				orient: null,
				orientation: null,
				origin: null,
				overflow: null,
				overlay: null,
				overlinePosition: number2,
				overlineThickness: number2,
				paintOrder: null,
				panose1: null,
				path: null,
				pathLength: number2,
				patternContentUnits: null,
				patternTransform: null,
				patternUnits: null,
				phase: null,
				ping: spaceSeparated2,
				pitch: null,
				playbackOrder: null,
				pointerEvents: null,
				points: null,
				pointsAtX: number2,
				pointsAtY: number2,
				pointsAtZ: number2,
				preserveAlpha: null,
				preserveAspectRatio: null,
				primitiveUnits: null,
				propagate: null,
				property: commaOrSpaceSeparated2,
				r: null,
				radius: null,
				referrerPolicy: null,
				refX: null,
				refY: null,
				rel: commaOrSpaceSeparated2,
				rev: commaOrSpaceSeparated2,
				renderingIntent: null,
				repeatCount: null,
				repeatDur: null,
				requiredExtensions: commaOrSpaceSeparated2,
				requiredFeatures: commaOrSpaceSeparated2,
				requiredFonts: commaOrSpaceSeparated2,
				requiredFormats: commaOrSpaceSeparated2,
				resource: null,
				restart: null,
				result: null,
				rotate: null,
				rx: null,
				ry: null,
				scale: null,
				seed: null,
				shapeRendering: null,
				side: null,
				slope: null,
				snapshotTime: null,
				specularConstant: number2,
				specularExponent: number2,
				spreadMethod: null,
				spacing: null,
				startOffset: null,
				stdDeviation: null,
				stemh: null,
				stemv: null,
				stitchTiles: null,
				stopColor: null,
				stopOpacity: null,
				strikethroughPosition: number2,
				strikethroughThickness: number2,
				string: null,
				stroke: null,
				strokeDashArray: commaOrSpaceSeparated2,
				strokeDashOffset: null,
				strokeLineCap: null,
				strokeLineJoin: null,
				strokeMiterLimit: number2,
				strokeOpacity: number2,
				strokeWidth: null,
				style: null,
				surfaceScale: number2,
				syncBehavior: null,
				syncBehaviorDefault: null,
				syncMaster: null,
				syncTolerance: null,
				syncToleranceDefault: null,
				systemLanguage: commaOrSpaceSeparated2,
				tabIndex: number2,
				tableValues: null,
				target: null,
				targetX: number2,
				targetY: number2,
				textAnchor: null,
				textDecoration: null,
				textRendering: null,
				textLength: null,
				timelineBegin: null,
				title: null,
				transformBehavior: null,
				type: null,
				typeOf: commaOrSpaceSeparated2,
				to: null,
				transform: null,
				u1: null,
				u2: null,
				underlinePosition: number2,
				underlineThickness: number2,
				unicode: null,
				unicodeBidi: null,
				unicodeRange: null,
				unitsPerEm: number2,
				values: null,
				vAlphabetic: number2,
				vMathematical: number2,
				vectorEffect: null,
				vHanging: number2,
				vIdeographic: number2,
				version: null,
				vertAdvY: number2,
				vertOriginX: number2,
				vertOriginY: number2,
				viewBox: null,
				viewTarget: null,
				visibility: null,
				width: null,
				widths: null,
				wordSpacing: null,
				writingMode: null,
				x: null,
				x1: null,
				x2: null,
				xChannelSelector: null,
				xHeight: number2,
				y: null,
				y1: null,
				y2: null,
				yChannelSelector: null,
				z: null,
				zoomAndPan: null
			}
		});
	}
});

// node_modules/hast-util-from-parse5/node_modules/property-information/lib/find.js
function find2(schema, value) {
	const normal = normalize7(value);
	let prop = value;
	let Type = Info2;
	if (normal in schema.normal) {
		return schema.property[schema.normal[normal]];
	}
	if (normal.length > 4 && normal.slice(0, 4) === 'data' && valid2.test(value)) {
		if (value.charAt(4) === '-') {
			const rest = value.slice(5).replace(dash2, camelcase2);
			prop = 'data' + rest.charAt(0).toUpperCase() + rest.slice(1);
		} else {
			const rest = value.slice(4);
			if (!dash2.test(rest)) {
				let dashes = rest.replace(cap2, kebab2);
				if (dashes.charAt(0) !== '-') {
					dashes = '-' + dashes;
				}
				value = 'data' + dashes;
			}
		}
		Type = DefinedInfo2;
	}
	return new Type(prop, value);
}
function kebab2($0) {
	return '-' + $0.toLowerCase();
}
function camelcase2($0) {
	return $0.charAt(1).toUpperCase();
}
var valid2, dash2, cap2;
var init_find2 = __esm({
	'node_modules/hast-util-from-parse5/node_modules/property-information/lib/find.js'() {
		init_normalize2();
		init_defined_info2();
		init_info2();
		valid2 = /^data[-\w.:]+$/i;
		dash2 = /-[a-z]/g;
		cap2 = /[A-Z]/g;
	}
});

// node_modules/hast-util-from-parse5/node_modules/property-information/index.js
var html8, svg4;
var init_property_information2 = __esm({
	'node_modules/hast-util-from-parse5/node_modules/property-information/index.js'() {
		init_merge2();
		init_xlink2();
		init_xml2();
		init_xmlns2();
		init_aria2();
		init_html4();
		init_svg2();
		init_find2();
		init_normalize2();
		html8 = merge2([xml2, xlink2, xmlns2, aria2, html7], 'html');
		svg4 = merge2([xml2, xlink2, xmlns2, aria2, svg3], 'svg');
	}
});

// node_modules/hast-util-from-parse5/node_modules/hast-util-parse-selector/index.js
var search2, parseSelector;
var init_hast_util_parse_selector = __esm({
	'node_modules/hast-util-from-parse5/node_modules/hast-util-parse-selector/index.js'() {
		search2 = /[#.]/g;
		parseSelector = function (selector, defaultTagName = 'div') {
			var value = selector || '';
			var props = {};
			var start = 0;
			var subvalue;
			var previous2;
			var match;
			while (start < value.length) {
				search2.lastIndex = start;
				match = search2.exec(value);
				subvalue = value.slice(start, match ? match.index : value.length);
				if (subvalue) {
					if (!previous2) {
						defaultTagName = subvalue;
					} else if (previous2 === '#') {
						props.id = subvalue;
					} else if (Array.isArray(props.className)) {
						props.className.push(subvalue);
					} else {
						props.className = [subvalue];
					}
					start += subvalue.length;
				}
				if (match) {
					previous2 = match[0];
					start++;
				}
			}
			return {
				type: 'element',
				tagName: defaultTagName,
				properties: props,
				children: []
			};
		};
	}
});

// node_modules/hast-util-from-parse5/node_modules/space-separated-tokens/index.js
function parse4(value) {
	const input = String(value || '').trim();
	return input ? input.split(/[ \t\n\r\f]+/g) : [];
}
var init_space_separated_tokens2 = __esm({
	'node_modules/hast-util-from-parse5/node_modules/space-separated-tokens/index.js'() {}
});

// node_modules/hast-util-from-parse5/node_modules/comma-separated-tokens/index.js
function parse5(value) {
	var tokens = [];
	var input = String(value || '');
	var index6 = input.indexOf(',');
	var start = 0;
	var end;
	var token;
	while (!end) {
		if (index6 === -1) {
			index6 = input.length;
			end = true;
		}
		token = input.slice(start, index6).trim();
		if (token || !end) {
			tokens.push(token);
		}
		start = index6 + 1;
		index6 = input.indexOf(',', start);
	}
	return tokens;
}
var init_comma_separated_tokens2 = __esm({
	'node_modules/hast-util-from-parse5/node_modules/comma-separated-tokens/index.js'() {}
});

// node_modules/hast-util-from-parse5/node_modules/hastscript/lib/core.js
function core2(schema, defaultTagName, caseSensitive) {
	const adjust = caseSensitive && createAdjustMap(caseSensitive);
	const h3 = function (selector, properties2, ...children) {
		let index6 = -1;
		let node;
		if (selector === void 0 || selector === null) {
			node = { type: 'root', children: [] };
			children.unshift(properties2);
		} else {
			node = parseSelector(selector, defaultTagName);
			node.tagName = node.tagName.toLowerCase();
			if (adjust && own14.call(adjust, node.tagName)) {
				node.tagName = adjust[node.tagName];
			}
			if (isProperties(properties2, node.tagName)) {
				let key3;
				for (key3 in properties2) {
					if (own14.call(properties2, key3)) {
						addProperty(schema, node.properties, key3, properties2[key3]);
					}
				}
			} else {
				children.unshift(properties2);
			}
		}
		while (++index6 < children.length) {
			addChild(node.children, children[index6]);
		}
		if (node.type === 'element' && node.tagName === 'template') {
			node.content = { type: 'root', children: node.children };
			node.children = [];
		}
		return node;
	};
	return h3;
}
function isProperties(value, name) {
	if (value === null || value === void 0 || typeof value !== 'object' || Array.isArray(value)) {
		return false;
	}
	if (name === 'input' || !value.type || typeof value.type !== 'string') {
		return true;
	}
	if ('children' in value && Array.isArray(value.children)) {
		return false;
	}
	if (name === 'button') {
		return buttonTypes.has(value.type.toLowerCase());
	}
	return !('value' in value);
}
function addProperty(schema, properties2, key3, value) {
	const info = find2(schema, key3);
	let index6 = -1;
	let result;
	if (value === void 0 || value === null) return;
	if (typeof value === 'number') {
		if (Number.isNaN(value)) return;
		result = value;
	} else if (typeof value === 'boolean') {
		result = value;
	} else if (typeof value === 'string') {
		if (info.spaceSeparated) {
			result = parse4(value);
		} else if (info.commaSeparated) {
			result = parse5(value);
		} else if (info.commaOrSpaceSeparated) {
			result = parse4(parse5(value).join(' '));
		} else {
			result = parsePrimitive(info, info.property, value);
		}
	} else if (Array.isArray(value)) {
		result = value.concat();
	} else {
		result = info.property === 'style' ? style(value) : String(value);
	}
	if (Array.isArray(result)) {
		const finalResult = [];
		while (++index6 < result.length) {
			finalResult[index6] = parsePrimitive(info, info.property, result[index6]);
		}
		result = finalResult;
	}
	if (info.property === 'className' && Array.isArray(properties2.className)) {
		result = properties2.className.concat(result);
	}
	properties2[info.property] = result;
}
function addChild(nodes2, value) {
	let index6 = -1;
	if (value === void 0 || value === null) {
	} else if (typeof value === 'string' || typeof value === 'number') {
		nodes2.push({ type: 'text', value: String(value) });
	} else if (Array.isArray(value)) {
		while (++index6 < value.length) {
			addChild(nodes2, value[index6]);
		}
	} else if (typeof value === 'object' && 'type' in value) {
		if (value.type === 'root') {
			addChild(nodes2, value.children);
		} else {
			nodes2.push(value);
		}
	} else {
		throw new Error('Expected node, nodes, or string, got `' + value + '`');
	}
}
function parsePrimitive(info, name, value) {
	if (typeof value === 'string') {
		if (info.number && value && !Number.isNaN(Number(value))) {
			return Number(value);
		}
		if (
			(info.boolean || info.overloadedBoolean) &&
			(value === '' || normalize7(value) === normalize7(name))
		) {
			return true;
		}
	}
	return value;
}
function style(value) {
	const result = [];
	let key3;
	for (key3 in value) {
		if (own14.call(value, key3)) {
			result.push([key3, value[key3]].join(': '));
		}
	}
	return result.join('; ');
}
function createAdjustMap(values) {
	const result = {};
	let index6 = -1;
	while (++index6 < values.length) {
		result[values[index6].toLowerCase()] = values[index6];
	}
	return result;
}
var buttonTypes, own14;
var init_core2 = __esm({
	'node_modules/hast-util-from-parse5/node_modules/hastscript/lib/core.js'() {
		init_property_information2();
		init_hast_util_parse_selector();
		init_space_separated_tokens2();
		init_comma_separated_tokens2();
		buttonTypes = /* @__PURE__ */ new Set(['menu', 'submit', 'reset', 'button']);
		own14 = {}.hasOwnProperty;
	}
});

// node_modules/hast-util-from-parse5/node_modules/hastscript/lib/html.js
var h2;
var init_html5 = __esm({
	'node_modules/hast-util-from-parse5/node_modules/hastscript/lib/html.js'() {
		init_property_information2();
		init_core2();
		h2 = core2(html8, 'div');
	}
});

// node_modules/hast-util-from-parse5/node_modules/hastscript/lib/svg-case-sensitive-tag-names.js
var svgCaseSensitiveTagNames;
var init_svg_case_sensitive_tag_names = __esm({
	'node_modules/hast-util-from-parse5/node_modules/hastscript/lib/svg-case-sensitive-tag-names.js'() {
		svgCaseSensitiveTagNames = [
			'altGlyph',
			'altGlyphDef',
			'altGlyphItem',
			'animateColor',
			'animateMotion',
			'animateTransform',
			'clipPath',
			'feBlend',
			'feColorMatrix',
			'feComponentTransfer',
			'feComposite',
			'feConvolveMatrix',
			'feDiffuseLighting',
			'feDisplacementMap',
			'feDistantLight',
			'feDropShadow',
			'feFlood',
			'feFuncA',
			'feFuncB',
			'feFuncG',
			'feFuncR',
			'feGaussianBlur',
			'feImage',
			'feMerge',
			'feMergeNode',
			'feMorphology',
			'feOffset',
			'fePointLight',
			'feSpecularLighting',
			'feSpotLight',
			'feTile',
			'feTurbulence',
			'foreignObject',
			'glyphRef',
			'linearGradient',
			'radialGradient',
			'solidColor',
			'textArea',
			'textPath'
		];
	}
});

// node_modules/hast-util-from-parse5/node_modules/hastscript/lib/svg.js
var s3;
var init_svg3 = __esm({
	'node_modules/hast-util-from-parse5/node_modules/hastscript/lib/svg.js'() {
		init_property_information2();
		init_core2();
		init_svg_case_sensitive_tag_names();
		s3 = core2(svg4, 'g', svgCaseSensitiveTagNames);
	}
});

// node_modules/hast-util-from-parse5/node_modules/hastscript/lib/index.js
var init_lib11 = __esm({
	'node_modules/hast-util-from-parse5/node_modules/hastscript/lib/index.js'() {
		init_html5();
		init_svg3();
	}
});

// node_modules/hast-util-from-parse5/node_modules/hastscript/index.js
var init_hastscript = __esm({
	'node_modules/hast-util-from-parse5/node_modules/hastscript/index.js'() {
		init_lib11();
	}
});

// node_modules/vfile-location/index.js
function location(file2) {
	var value = String(file2);
	var indices = [];
	var search3 = /\r?\n|\r/g;
	while (search3.test(value)) {
		indices.push(search3.lastIndex);
	}
	indices.push(value.length + 1);
	return { toPoint, toOffset };
	function toPoint(offset) {
		var index6 = -1;
		if (offset > -1 && offset < indices[indices.length - 1]) {
			while (++index6 < indices.length) {
				if (indices[index6] > offset) {
					return {
						line: index6 + 1,
						column: offset - (indices[index6 - 1] || 0) + 1,
						offset
					};
				}
			}
		}
		return { line: void 0, column: void 0, offset: void 0 };
	}
	function toOffset(point4) {
		var line = point4 && point4.line;
		var column = point4 && point4.column;
		var offset;
		if (
			typeof line === 'number' &&
			typeof column === 'number' &&
			!Number.isNaN(line) &&
			!Number.isNaN(column) &&
			line - 1 in indices
		) {
			offset = (indices[line - 2] || 0) + column - 1 || 0;
		}
		return offset > -1 && offset < indices[indices.length - 1] ? offset : -1;
	}
}
var init_vfile_location = __esm({
	'node_modules/vfile-location/index.js'() {}
});

// node_modules/web-namespaces/index.js
var webNamespaces;
var init_web_namespaces = __esm({
	'node_modules/web-namespaces/index.js'() {
		webNamespaces = {
			html: 'http://www.w3.org/1999/xhtml',
			mathml: 'http://www.w3.org/1998/Math/MathML',
			svg: 'http://www.w3.org/2000/svg',
			xlink: 'http://www.w3.org/1999/xlink',
			xml: 'http://www.w3.org/XML/1998/namespace',
			xmlns: 'http://www.w3.org/2000/xmlns/'
		};
	}
});

// node_modules/hast-util-from-parse5/lib/index.js
function fromParse5(ast, options = {}) {
	let settings;
	let file2;
	if (isFile(options)) {
		file2 = options;
		settings = {};
	} else {
		file2 = options.file;
		settings = options;
	}
	return transform(
		{
			schema: settings.space === 'svg' ? svg4 : html8,
			file: file2,
			verbose: settings.verbose,
			location: false
		},
		ast
	);
}
function transform(ctx, ast) {
	const schema = ctx.schema;
	const fn = own15.call(map3, ast.nodeName) ? map3[ast.nodeName] : element3;
	let children;
	if ('tagName' in ast) {
		ctx.schema = ast.namespaceURI === webNamespaces.svg ? svg4 : html8;
	}
	if ('childNodes' in ast) {
		children = nodes(ctx, ast.childNodes);
	}
	const result = fn(ctx, ast, children);
	if ('sourceCodeLocation' in ast && ast.sourceCodeLocation && ctx.file) {
		const position3 = createLocation(ctx, result, ast.sourceCodeLocation);
		if (position3) {
			ctx.location = true;
			result.position = position3;
		}
	}
	ctx.schema = schema;
	return result;
}
function nodes(ctx, children) {
	let index6 = -1;
	const result = [];
	while (++index6 < children.length) {
		result[index6] = transform(ctx, children[index6]);
	}
	return result;
}
function root3(ctx, ast, children) {
	const result = {
		type: 'root',
		children,
		data: { quirksMode: ast.mode === 'quirks' || ast.mode === 'limited-quirks' }
	};
	if (ctx.file && ctx.location) {
		const doc = String(ctx.file);
		const loc = location(doc);
		result.position = {
			start: loc.toPoint(0),
			end: loc.toPoint(doc.length)
		};
	}
	return result;
}
function doctype2() {
	return { type: 'doctype' };
}
function text6(_, ast) {
	return { type: 'text', value: ast.value };
}
function comment3(_, ast) {
	return { type: 'comment', value: ast.data };
}
function element3(ctx, ast, children) {
	const fn = ctx.schema.space === 'svg' ? s3 : h2;
	let index6 = -1;
	const props = {};
	while (++index6 < ast.attrs.length) {
		const attribute = ast.attrs[index6];
		props[(attribute.prefix ? attribute.prefix + ':' : '') + attribute.name] = attribute.value;
	}
	const result = fn(ast.tagName, props, children);
	if (result.tagName === 'template' && 'content' in ast) {
		const pos = ast.sourceCodeLocation;
		const startTag = pos && pos.startTag && position2(pos.startTag);
		const endTag = pos && pos.endTag && position2(pos.endTag);
		const content3 = transform(ctx, ast.content);
		if (startTag && endTag && ctx.file) {
			content3.position = { start: startTag.end, end: endTag.start };
		}
		result.content = content3;
	}
	return result;
}
function createLocation(ctx, node, location2) {
	const result = position2(location2);
	if (node.type === 'element') {
		const tail = node.children[node.children.length - 1];
		if (result && !location2.endTag && tail && tail.position && tail.position.end) {
			result.end = Object.assign({}, tail.position.end);
		}
		if (ctx.verbose) {
			const props = {};
			let key3;
			for (key3 in location2.attrs) {
				if (own15.call(location2.attrs, key3)) {
					props[find2(ctx.schema, key3).property] = position2(location2.attrs[key3]);
				}
			}
			node.data = {
				position: {
					opening: position2(location2.startTag),
					closing: location2.endTag ? position2(location2.endTag) : null,
					properties: props
				}
			};
		}
	}
	return result;
}
function position2(loc) {
	const start = point3({
		line: loc.startLine,
		column: loc.startCol,
		offset: loc.startOffset
	});
	const end = point3({
		line: loc.endLine,
		column: loc.endCol,
		offset: loc.endOffset
	});
	return start || end ? { start, end } : null;
}
function point3(point4) {
	return point4.line && point4.column ? point4 : null;
}
function isFile(value) {
	return 'messages' in value;
}
var own15, map3;
var init_lib12 = __esm({
	'node_modules/hast-util-from-parse5/lib/index.js'() {
		init_hastscript();
		init_property_information2();
		init_vfile_location();
		init_web_namespaces();
		own15 = {}.hasOwnProperty;
		map3 = {
			'#document': root3,
			'#document-fragment': root3,
			'#text': text6,
			'#comment': comment3,
			'#documentType': doctype2
		};
	}
});

// node_modules/hast-util-from-parse5/index.js
var init_hast_util_from_parse5 = __esm({
	'node_modules/hast-util-from-parse5/index.js'() {
		init_lib12();
	}
});

// node_modules/rehype-parse/lib/errors.js
var errors2;
var init_errors = __esm({
	'node_modules/rehype-parse/lib/errors.js'() {
		errors2 = {
			abandonedHeadElementChild: {
				reason: 'Unexpected metadata element after head',
				description: 'Unexpected element after head. Expected the element before `</head>`',
				url: false
			},
			abruptClosingOfEmptyComment: {
				reason: 'Unexpected abruptly closed empty comment',
				description: 'Unexpected `>` or `->`. Expected `-->` to close comments'
			},
			abruptDoctypePublicIdentifier: {
				reason: 'Unexpected abruptly closed public identifier',
				description: 'Unexpected `>`. Expected a closing `"` or `\'` after the public identifier'
			},
			abruptDoctypeSystemIdentifier: {
				reason: 'Unexpected abruptly closed system identifier',
				description:
					'Unexpected `>`. Expected a closing `"` or `\'` after the identifier identifier'
			},
			absenceOfDigitsInNumericCharacterReference: {
				reason: 'Unexpected non-digit at start of numeric character reference',
				description:
					'Unexpected `%c`. Expected `[0-9]` for decimal references or `[0-9a-fA-F]` for hexadecimal references'
			},
			cdataInHtmlContent: {
				reason: 'Unexpected CDATA section in HTML',
				description:
					'Unexpected `<![CDATA[` in HTML. Remove it, use a comment, or encode special characters instead'
			},
			characterReferenceOutsideUnicodeRange: {
				reason: 'Unexpected too big numeric character reference',
				description:
					'Unexpectedly high character reference. Expected character references to be at most hexadecimal 10ffff (or decimal 1114111)'
			},
			closingOfElementWithOpenChildElements: {
				reason: 'Unexpected closing tag with open child elements',
				description: 'Unexpectedly closing tag. Expected other tags to be closed first',
				url: false
			},
			controlCharacterInInputStream: {
				reason: 'Unexpected control character',
				description:
					'Unexpected control character `%x`. Expected a non-control code point, 0x00, or ASCII whitespace'
			},
			controlCharacterReference: {
				reason: 'Unexpected control character reference',
				description:
					'Unexpectedly control character in reference. Expected a non-control code point, 0x00, or ASCII whitespace'
			},
			disallowedContentInNoscriptInHead: {
				reason: 'Disallowed content inside `<noscript>` in `<head>`',
				description: 'Unexpected text character `%c`. Only use text in `<noscript>`s in `<body>`',
				url: false
			},
			duplicateAttribute: {
				reason: 'Unexpected duplicate attribute',
				description: 'Unexpectedly double attribute. Expected attributes to occur only once'
			},
			endTagWithAttributes: {
				reason: 'Unexpected attribute on closing tag',
				description: 'Unexpected attribute. Expected `>` instead'
			},
			endTagWithTrailingSolidus: {
				reason: 'Unexpected slash at end of closing tag',
				description: 'Unexpected `%c-1`. Expected `>` instead'
			},
			endTagWithoutMatchingOpenElement: {
				reason: 'Unexpected unopened end tag',
				description: 'Unexpected end tag. Expected no end tag or another end tag',
				url: false
			},
			eofBeforeTagName: {
				reason: 'Unexpected end of file',
				description: 'Unexpected end of file. Expected tag name instead'
			},
			eofInCdata: {
				reason: 'Unexpected end of file in CDATA',
				description: 'Unexpected end of file. Expected `]]>` to close the CDATA'
			},
			eofInComment: {
				reason: 'Unexpected end of file in comment',
				description: 'Unexpected end of file. Expected `-->` to close the comment'
			},
			eofInDoctype: {
				reason: 'Unexpected end of file in doctype',
				description: 'Unexpected end of file. Expected a valid doctype (such as `<!doctype html>`)'
			},
			eofInElementThatCanContainOnlyText: {
				reason: 'Unexpected end of file in element that can only contain text',
				description: 'Unexpected end of file. Expected text or a closing tag',
				url: false
			},
			eofInScriptHtmlCommentLikeText: {
				reason: 'Unexpected end of file in comment inside script',
				description: 'Unexpected end of file. Expected `-->` to close the comment'
			},
			eofInTag: {
				reason: 'Unexpected end of file in tag',
				description: 'Unexpected end of file. Expected `>` to close the tag'
			},
			incorrectlyClosedComment: {
				reason: 'Incorrectly closed comment',
				description: 'Unexpected `%c-1`. Expected `-->` to close the comment'
			},
			incorrectlyOpenedComment: {
				reason: 'Incorrectly opened comment',
				description: 'Unexpected `%c`. Expected `<!--` to open the comment'
			},
			invalidCharacterSequenceAfterDoctypeName: {
				reason: 'Invalid sequence after doctype name',
				description: 'Unexpected sequence at `%c`. Expected `public` or `system`'
			},
			invalidFirstCharacterOfTagName: {
				reason: 'Invalid first character in tag name',
				description: 'Unexpected `%c`. Expected an ASCII letter instead'
			},
			misplacedDoctype: {
				reason: 'Misplaced doctype',
				description: 'Unexpected doctype. Expected doctype before head',
				url: false
			},
			misplacedStartTagForHeadElement: {
				reason: 'Misplaced `<head>` start tag',
				description: 'Unexpected start tag `<head>`. Expected `<head>` directly after doctype',
				url: false
			},
			missingAttributeValue: {
				reason: 'Missing attribute value',
				description: 'Unexpected `%c-1`. Expected an attribute value or no `%c-1` instead'
			},
			missingDoctype: {
				reason: 'Missing doctype before other content',
				description: 'Expected a `<!doctype html>` before anything else',
				url: false
			},
			missingDoctypeName: {
				reason: 'Missing doctype name',
				description: 'Unexpected doctype end at `%c`. Expected `html` instead'
			},
			missingDoctypePublicIdentifier: {
				reason: 'Missing public identifier in doctype',
				description: 'Unexpected `%c`. Expected identifier for `public` instead'
			},
			missingDoctypeSystemIdentifier: {
				reason: 'Missing system identifier in doctype',
				description:
					'Unexpected `%c`. Expected identifier for `system` instead (suggested: `"about:legacy-compat"`)'
			},
			missingEndTagName: {
				reason: 'Missing name in end tag',
				description: 'Unexpected `%c`. Expected an ASCII letter instead'
			},
			missingQuoteBeforeDoctypePublicIdentifier: {
				reason: 'Missing quote before public identifier in doctype',
				description: 'Unexpected `%c`. Expected `"` or `\'` instead'
			},
			missingQuoteBeforeDoctypeSystemIdentifier: {
				reason: 'Missing quote before system identifier in doctype',
				description: 'Unexpected `%c`. Expected `"` or `\'` instead'
			},
			missingSemicolonAfterCharacterReference: {
				reason: 'Missing semicolon after character reference',
				description: 'Unexpected `%c`. Expected `;` instead'
			},
			missingWhitespaceAfterDoctypePublicKeyword: {
				reason: 'Missing whitespace after public identifier in doctype',
				description: 'Unexpected `%c`. Expected ASCII whitespace instead'
			},
			missingWhitespaceAfterDoctypeSystemKeyword: {
				reason: 'Missing whitespace after system identifier in doctype',
				description: 'Unexpected `%c`. Expected ASCII whitespace instead'
			},
			missingWhitespaceBeforeDoctypeName: {
				reason: 'Missing whitespace before doctype name',
				description: 'Unexpected `%c`. Expected ASCII whitespace instead'
			},
			missingWhitespaceBetweenAttributes: {
				reason: 'Missing whitespace between attributes',
				description: 'Unexpected `%c`. Expected ASCII whitespace instead'
			},
			missingWhitespaceBetweenDoctypePublicAndSystemIdentifiers: {
				reason: 'Missing whitespace between public and system identifiers in doctype',
				description: 'Unexpected `%c`. Expected ASCII whitespace instead'
			},
			nestedComment: {
				reason: 'Unexpected nested comment',
				description: 'Unexpected `<!--`. Expected `-->`'
			},
			nestedNoscriptInHead: {
				reason: 'Unexpected nested `<noscript>` in `<head>`',
				description: 'Unexpected `<noscript>`. Expected a closing tag or a meta element',
				url: false
			},
			nonConformingDoctype: {
				reason: 'Unexpected non-conforming doctype declaration',
				description: 'Expected `<!doctype html>` or `<!doctype html system "about:legacy-compat">`',
				url: false
			},
			nonVoidHtmlElementStartTagWithTrailingSolidus: {
				reason: 'Unexpected trailing slash on start tag of non-void element',
				description: 'Unexpected `/`. Expected `>` instead'
			},
			noncharacterCharacterReference: {
				reason: 'Unexpected noncharacter code point referenced by character reference',
				description: 'Unexpected code point. Do not use noncharacters in HTML'
			},
			noncharacterInInputStream: {
				reason: 'Unexpected noncharacter character',
				description: 'Unexpected code point `%x`. Do not use noncharacters in HTML'
			},
			nullCharacterReference: {
				reason: 'Unexpected NULL character referenced by character reference',
				description: 'Unexpected code point. Do not use NULL characters in HTML'
			},
			openElementsLeftAfterEof: {
				reason: 'Unexpected end of file',
				description: 'Unexpected end of file. Expected closing tag instead',
				url: false
			},
			surrogateCharacterReference: {
				reason: 'Unexpected surrogate character referenced by character reference',
				description: 'Unexpected code point. Do not use lone surrogate characters in HTML'
			},
			surrogateInInputStream: {
				reason: 'Unexpected surrogate character',
				description: 'Unexpected code point `%x`. Do not use lone surrogate characters in HTML'
			},
			unexpectedCharacterAfterDoctypeSystemIdentifier: {
				reason: 'Invalid character after system identifier in doctype',
				description: 'Unexpected character at `%c`. Expected `>`'
			},
			unexpectedCharacterInAttributeName: {
				reason: 'Unexpected character in attribute name',
				description:
					'Unexpected `%c`. Expected whitespace, `/`, `>`, `=`, or probably an ASCII letter'
			},
			unexpectedCharacterInUnquotedAttributeValue: {
				reason: 'Unexpected character in unquoted attribute value',
				description: 'Unexpected `%c`. Quote the attribute value to include it'
			},
			unexpectedEqualsSignBeforeAttributeName: {
				reason: 'Unexpected equals sign before attribute name',
				description: 'Unexpected `%c`. Add an attribute name before it'
			},
			unexpectedNullCharacter: {
				reason: 'Unexpected NULL character',
				description: 'Unexpected code point `%x`. Do not use NULL characters in HTML'
			},
			unexpectedQuestionMarkInsteadOfTagName: {
				reason: 'Unexpected question mark instead of tag name',
				description: 'Unexpected `%c`. Expected an ASCII letter instead'
			},
			unexpectedSolidusInTag: {
				reason: 'Unexpected slash in tag',
				description: 'Unexpected `%c-1`. Expected it followed by `>` or in a quoted attribute value'
			},
			unknownNamedCharacterReference: {
				reason: 'Unexpected unknown named character reference',
				description: 'Unexpected character reference. Expected known named character references'
			}
		};
	}
});

// node_modules/rehype-parse/lib/index.js
function rehypeParse(options) {
	const processorSettings = this.data('settings');
	const settings = Object.assign({}, processorSettings, options);
	Object.assign(this, { Parser: parser });
	function parser(doc, file2) {
		const fn = settings.fragment ? 'parseFragment' : 'parse';
		const onParseError = settings.emitParseErrors ? onerror : null;
		const parse52 = new import_parser.default({
			sourceCodeLocationInfo: true,
			onParseError,
			scriptingEnabled: false
		});
		return fromParse5(parse52[fn](doc), {
			space: settings.space,
			file: file2,
			verbose: settings.verbose
		});
		function onerror(error2) {
			const code3 = error2.code;
			const name = camelcase3(code3);
			const setting = settings[name];
			const config = setting === void 0 || setting === null ? true : setting;
			const level = typeof config === 'number' ? config : config ? 1 : 0;
			const start = {
				line: error2.startLine,
				column: error2.startCol,
				offset: error2.startOffset
			};
			const end = {
				line: error2.endLine,
				column: error2.endCol,
				offset: error2.endOffset
			};
			if (level) {
				const info = errors2[name] || { reason: '', description: '', url: '' };
				const message = file2.message(format2(info.reason), { start, end });
				message.source = 'parse-error';
				message.ruleId = code3;
				message.fatal = fatalities[level];
				message.note = format2(info.description);
				message.url = 'url' in info && info.url === false ? null : base3 + code3;
			}
			function format2(value) {
				return value
					.replace(/%c(?:-(\d+))?/g, (_, $1) => {
						const offset = $1 ? -Number.parseInt($1, 10) : 0;
						const char = doc.charAt(error2.startOffset + offset);
						return char === '`' ? '` ` `' : char;
					})
					.replace(
						/%x/g,
						() => '0x' + doc.charCodeAt(error2.startOffset).toString(16).toUpperCase()
					);
			}
		}
	}
}
function camelcase3(value) {
	return value.replace(/-[a-z]/g, ($0) => $0.charAt(1).toUpperCase());
}
var import_parser, base3, fatalities;
var init_lib13 = __esm({
	'node_modules/rehype-parse/lib/index.js'() {
		import_parser = __toESM(require_parser(), 1);
		init_hast_util_from_parse5();
		init_errors();
		base3 = 'https://html.spec.whatwg.org/multipage/parsing.html#parse-error-';
		fatalities = { 2: true, 1: false, 0: null };
	}
});

// node_modules/rehype-parse/index.js
var init_rehype_parse = __esm({
	'node_modules/rehype-parse/index.js'() {
		init_lib13();
	}
});

// node_modules/rehype-stringify/lib/index.js
function rehypeStringify(config) {
	const processorSettings = this.data('settings');
	const settings = Object.assign({}, processorSettings, config);
	Object.assign(this, { Compiler: compiler2 });
	function compiler2(tree) {
		return toHtml(tree, settings);
	}
}
var init_lib14 = __esm({
	'node_modules/rehype-stringify/lib/index.js'() {
		init_hast_util_to_html();
	}
});

// node_modules/rehype-stringify/index.js
var init_rehype_stringify = __esm({
	'node_modules/rehype-stringify/index.js'() {
		init_lib14();
	}
});

// node_modules/rehype/index.js
var rehype;
var init_rehype = __esm({
	'node_modules/rehype/index.js'() {
		init_unified();
		init_rehype_parse();
		init_rehype_stringify();
		rehype = unified().use(rehypeParse).use(rehypeStringify).freeze();
	}
});

// node_modules/unist-util-visit-parents/node_modules/unist-util-is/convert.js
var require_convert = __commonJS({
	'node_modules/unist-util-visit-parents/node_modules/unist-util-is/convert.js'(exports, module2) {
		'use strict';
		module2.exports = convert2;
		function convert2(test) {
			if (test == null) {
				return ok2;
			}
			if (typeof test === 'string') {
				return typeFactory2(test);
			}
			if (typeof test === 'object') {
				return 'length' in test ? anyFactory3(test) : allFactory(test);
			}
			if (typeof test === 'function') {
				return test;
			}
			throw new Error('Expected function, string, or object as test');
		}
		function allFactory(test) {
			return all5;
			function all5(node) {
				var key3;
				for (key3 in test) {
					if (node[key3] !== test[key3]) return false;
				}
				return true;
			}
		}
		function anyFactory3(tests) {
			var checks3 = [];
			var index6 = -1;
			while (++index6 < tests.length) {
				checks3[index6] = convert2(tests[index6]);
			}
			return any;
			function any() {
				var index7 = -1;
				while (++index7 < checks3.length) {
					if (checks3[index7].apply(this, arguments)) {
						return true;
					}
				}
				return false;
			}
		}
		function typeFactory2(test) {
			return type;
			function type(node) {
				return Boolean(node && node.type === test);
			}
		}
		function ok2() {
			return true;
		}
	}
});

// node_modules/unist-util-visit-parents/color.js
var require_color = __commonJS({
	'node_modules/unist-util-visit-parents/color.js'(exports, module2) {
		module2.exports = color4;
		function color4(d) {
			return '\x1B[33m' + d + '\x1B[39m';
		}
	}
});

// node_modules/unist-util-visit-parents/index.js
var require_unist_util_visit_parents = __commonJS({
	'node_modules/unist-util-visit-parents/index.js'(exports, module2) {
		'use strict';
		module2.exports = visitParents4;
		var convert2 = require_convert();
		var color4 = require_color();
		var CONTINUE4 = true;
		var SKIP4 = 'skip';
		var EXIT4 = false;
		visitParents4.CONTINUE = CONTINUE4;
		visitParents4.SKIP = SKIP4;
		visitParents4.EXIT = EXIT4;
		function visitParents4(tree, test, visitor, reverse) {
			var step;
			var is;
			if (typeof test === 'function' && typeof visitor !== 'function') {
				reverse = visitor;
				visitor = test;
				test = null;
			}
			is = convert2(test);
			step = reverse ? -1 : 1;
			factory2(tree, null, [])();
			function factory2(node, index6, parents) {
				var value = typeof node === 'object' && node !== null ? node : {};
				var name;
				if (typeof value.type === 'string') {
					name =
						typeof value.tagName === 'string'
							? value.tagName
							: typeof value.name === 'string'
							? value.name
							: void 0;
					visit4.displayName = 'node (' + color4(value.type + (name ? '<' + name + '>' : '')) + ')';
				}
				return visit4;
				function visit4() {
					var grandparents = parents.concat(node);
					var result = [];
					var subresult;
					var offset;
					if (!test || is(node, index6, parents[parents.length - 1] || null)) {
						result = toResult4(visitor(node, parents));
						if (result[0] === EXIT4) {
							return result;
						}
					}
					if (node.children && result[0] !== SKIP4) {
						offset = (reverse ? node.children.length : -1) + step;
						while (offset > -1 && offset < node.children.length) {
							subresult = factory2(node.children[offset], offset, grandparents)();
							if (subresult[0] === EXIT4) {
								return subresult;
							}
							offset = typeof subresult[1] === 'number' ? subresult[1] : offset + step;
						}
					}
					return result;
				}
			}
		}
		function toResult4(value) {
			if (value !== null && typeof value === 'object' && 'length' in value) {
				return value;
			}
			if (typeof value === 'number') {
				return [CONTINUE4, value];
			}
			return [value];
		}
	}
});

// node_modules/unist-util-visit/index.js
var require_unist_util_visit = __commonJS({
	'node_modules/unist-util-visit/index.js'(exports, module2) {
		'use strict';
		module2.exports = visit4;
		var visitParents4 = require_unist_util_visit_parents();
		var CONTINUE4 = visitParents4.CONTINUE;
		var SKIP4 = visitParents4.SKIP;
		var EXIT4 = visitParents4.EXIT;
		visit4.CONTINUE = CONTINUE4;
		visit4.SKIP = SKIP4;
		visit4.EXIT = EXIT4;
		function visit4(tree, test, visitor, reverse) {
			if (typeof test === 'function' && typeof visitor !== 'function') {
				reverse = visitor;
				visitor = test;
				test = null;
			}
			visitParents4(tree, test, overload, reverse);
			function overload(node, parents) {
				var parent = parents[parents.length - 1];
				var index6 = parent ? parent.children.indexOf(node) : null;
				return visitor(node, index6, parent);
			}
		}
	}
});

// node_modules/hast-util-to-string/index.js
var require_hast_util_to_string = __commonJS({
	'node_modules/hast-util-to-string/index.js'(exports, module2) {
		'use strict';
		module2.exports = toString2;
		function toString2(node) {
			if ('children' in node) {
				return all5(node);
			}
			return 'value' in node ? node.value : '';
		}
		function one5(node) {
			if (node.type === 'text') {
				return node.value;
			}
			return node.children ? all5(node) : '';
		}
		function all5(node) {
			var children = node.children;
			var length = children.length;
			var index6 = -1;
			var result = [];
			while (++index6 < length) {
				result[index6] = one5(children[index6]);
			}
			return result.join('');
		}
	}
});

// node_modules/xtend/immutable.js
var require_immutable = __commonJS({
	'node_modules/xtend/immutable.js'(exports, module2) {
		module2.exports = extend2;
		var hasOwnProperty2 = Object.prototype.hasOwnProperty;
		function extend2() {
			var target = {};
			for (var i2 = 0; i2 < arguments.length; i2++) {
				var source = arguments[i2];
				for (var key3 in source) {
					if (hasOwnProperty2.call(source, key3)) {
						target[key3] = source[key3];
					}
				}
			}
			return target;
		}
	}
});

// node_modules/property-information/lib/util/schema.js
var require_schema2 = __commonJS({
	'node_modules/property-information/lib/util/schema.js'(exports, module2) {
		'use strict';
		module2.exports = Schema3;
		var proto = Schema3.prototype;
		proto.space = null;
		proto.normal = {};
		proto.property = {};
		function Schema3(property, normal, space) {
			this.property = property;
			this.normal = normal;
			if (space) {
				this.space = space;
			}
		}
	}
});

// node_modules/property-information/lib/util/merge.js
var require_merge2 = __commonJS({
	'node_modules/property-information/lib/util/merge.js'(exports, module2) {
		'use strict';
		var xtend = require_immutable();
		var Schema3 = require_schema2();
		module2.exports = merge3;
		function merge3(definitions2) {
			var length = definitions2.length;
			var property = [];
			var normal = [];
			var index6 = -1;
			var info;
			var space;
			while (++index6 < length) {
				info = definitions2[index6];
				property.push(info.property);
				normal.push(info.normal);
				space = info.space;
			}
			return new Schema3(xtend.apply(null, property), xtend.apply(null, normal), space);
		}
	}
});

// node_modules/property-information/normalize.js
var require_normalize = __commonJS({
	'node_modules/property-information/normalize.js'(exports, module2) {
		'use strict';
		module2.exports = normalize8;
		function normalize8(value) {
			return value.toLowerCase();
		}
	}
});

// node_modules/property-information/lib/util/info.js
var require_info = __commonJS({
	'node_modules/property-information/lib/util/info.js'(exports, module2) {
		'use strict';
		module2.exports = Info3;
		var proto = Info3.prototype;
		proto.space = null;
		proto.attribute = null;
		proto.property = null;
		proto.boolean = false;
		proto.booleanish = false;
		proto.overloadedBoolean = false;
		proto.number = false;
		proto.commaSeparated = false;
		proto.spaceSeparated = false;
		proto.commaOrSpaceSeparated = false;
		proto.mustUseProperty = false;
		proto.defined = false;
		function Info3(property, attribute) {
			this.property = property;
			this.attribute = attribute;
		}
	}
});

// node_modules/property-information/lib/util/types.js
var require_types = __commonJS({
	'node_modules/property-information/lib/util/types.js'(exports) {
		'use strict';
		var powers3 = 0;
		exports.boolean = increment3();
		exports.booleanish = increment3();
		exports.overloadedBoolean = increment3();
		exports.number = increment3();
		exports.spaceSeparated = increment3();
		exports.commaSeparated = increment3();
		exports.commaOrSpaceSeparated = increment3();
		function increment3() {
			return Math.pow(2, ++powers3);
		}
	}
});

// node_modules/property-information/lib/util/defined-info.js
var require_defined_info = __commonJS({
	'node_modules/property-information/lib/util/defined-info.js'(exports, module2) {
		'use strict';
		var Info3 = require_info();
		var types2 = require_types();
		module2.exports = DefinedInfo3;
		DefinedInfo3.prototype = new Info3();
		DefinedInfo3.prototype.defined = true;
		var checks3 = [
			'boolean',
			'booleanish',
			'overloadedBoolean',
			'number',
			'commaSeparated',
			'spaceSeparated',
			'commaOrSpaceSeparated'
		];
		var checksLength = checks3.length;
		function DefinedInfo3(property, attribute, mask, space) {
			var index6 = -1;
			var check;
			mark3(this, 'space', space);
			Info3.call(this, property, attribute);
			while (++index6 < checksLength) {
				check = checks3[index6];
				mark3(this, check, (mask & types2[check]) === types2[check]);
			}
		}
		function mark3(values, key3, value) {
			if (value) {
				values[key3] = value;
			}
		}
	}
});

// node_modules/property-information/lib/util/create.js
var require_create = __commonJS({
	'node_modules/property-information/lib/util/create.js'(exports, module2) {
		'use strict';
		var normalize8 = require_normalize();
		var Schema3 = require_schema2();
		var DefinedInfo3 = require_defined_info();
		module2.exports = create3;
		function create3(definition3) {
			var space = definition3.space;
			var mustUseProperty = definition3.mustUseProperty || [];
			var attributes = definition3.attributes || {};
			var props = definition3.properties;
			var transform2 = definition3.transform;
			var property = {};
			var normal = {};
			var prop;
			var info;
			for (prop in props) {
				info = new DefinedInfo3(prop, transform2(attributes, prop), props[prop], space);
				if (mustUseProperty.indexOf(prop) !== -1) {
					info.mustUseProperty = true;
				}
				property[prop] = info;
				normal[normalize8(prop)] = prop;
				normal[normalize8(info.attribute)] = prop;
			}
			return new Schema3(property, normal, space);
		}
	}
});

// node_modules/property-information/lib/xlink.js
var require_xlink = __commonJS({
	'node_modules/property-information/lib/xlink.js'(exports, module2) {
		'use strict';
		var create3 = require_create();
		module2.exports = create3({
			space: 'xlink',
			transform: xlinkTransform,
			properties: {
				xLinkActuate: null,
				xLinkArcRole: null,
				xLinkHref: null,
				xLinkRole: null,
				xLinkShow: null,
				xLinkTitle: null,
				xLinkType: null
			}
		});
		function xlinkTransform(_, prop) {
			return 'xlink:' + prop.slice(5).toLowerCase();
		}
	}
});

// node_modules/property-information/lib/xml.js
var require_xml = __commonJS({
	'node_modules/property-information/lib/xml.js'(exports, module2) {
		'use strict';
		var create3 = require_create();
		module2.exports = create3({
			space: 'xml',
			transform: xmlTransform,
			properties: {
				xmlLang: null,
				xmlBase: null,
				xmlSpace: null
			}
		});
		function xmlTransform(_, prop) {
			return 'xml:' + prop.slice(3).toLowerCase();
		}
	}
});

// node_modules/property-information/lib/util/case-sensitive-transform.js
var require_case_sensitive_transform = __commonJS({
	'node_modules/property-information/lib/util/case-sensitive-transform.js'(exports, module2) {
		'use strict';
		module2.exports = caseSensitiveTransform3;
		function caseSensitiveTransform3(attributes, attribute) {
			return attribute in attributes ? attributes[attribute] : attribute;
		}
	}
});

// node_modules/property-information/lib/util/case-insensitive-transform.js
var require_case_insensitive_transform = __commonJS({
	'node_modules/property-information/lib/util/case-insensitive-transform.js'(exports, module2) {
		'use strict';
		var caseSensitiveTransform3 = require_case_sensitive_transform();
		module2.exports = caseInsensitiveTransform3;
		function caseInsensitiveTransform3(attributes, property) {
			return caseSensitiveTransform3(attributes, property.toLowerCase());
		}
	}
});

// node_modules/property-information/lib/xmlns.js
var require_xmlns = __commonJS({
	'node_modules/property-information/lib/xmlns.js'(exports, module2) {
		'use strict';
		var create3 = require_create();
		var caseInsensitiveTransform3 = require_case_insensitive_transform();
		module2.exports = create3({
			space: 'xmlns',
			attributes: {
				xmlnsxlink: 'xmlns:xlink'
			},
			transform: caseInsensitiveTransform3,
			properties: {
				xmlns: null,
				xmlnsXLink: null
			}
		});
	}
});

// node_modules/property-information/lib/aria.js
var require_aria = __commonJS({
	'node_modules/property-information/lib/aria.js'(exports, module2) {
		'use strict';
		var types2 = require_types();
		var create3 = require_create();
		var booleanish3 = types2.booleanish;
		var number3 = types2.number;
		var spaceSeparated3 = types2.spaceSeparated;
		module2.exports = create3({
			transform: ariaTransform,
			properties: {
				ariaActiveDescendant: null,
				ariaAtomic: booleanish3,
				ariaAutoComplete: null,
				ariaBusy: booleanish3,
				ariaChecked: booleanish3,
				ariaColCount: number3,
				ariaColIndex: number3,
				ariaColSpan: number3,
				ariaControls: spaceSeparated3,
				ariaCurrent: null,
				ariaDescribedBy: spaceSeparated3,
				ariaDetails: null,
				ariaDisabled: booleanish3,
				ariaDropEffect: spaceSeparated3,
				ariaErrorMessage: null,
				ariaExpanded: booleanish3,
				ariaFlowTo: spaceSeparated3,
				ariaGrabbed: booleanish3,
				ariaHasPopup: null,
				ariaHidden: booleanish3,
				ariaInvalid: null,
				ariaKeyShortcuts: null,
				ariaLabel: null,
				ariaLabelledBy: spaceSeparated3,
				ariaLevel: number3,
				ariaLive: null,
				ariaModal: booleanish3,
				ariaMultiLine: booleanish3,
				ariaMultiSelectable: booleanish3,
				ariaOrientation: null,
				ariaOwns: spaceSeparated3,
				ariaPlaceholder: null,
				ariaPosInSet: number3,
				ariaPressed: booleanish3,
				ariaReadOnly: booleanish3,
				ariaRelevant: null,
				ariaRequired: booleanish3,
				ariaRoleDescription: spaceSeparated3,
				ariaRowCount: number3,
				ariaRowIndex: number3,
				ariaRowSpan: number3,
				ariaSelected: booleanish3,
				ariaSetSize: number3,
				ariaSort: null,
				ariaValueMax: number3,
				ariaValueMin: number3,
				ariaValueNow: number3,
				ariaValueText: null,
				role: null
			}
		});
		function ariaTransform(_, prop) {
			return prop === 'role' ? prop : 'aria-' + prop.slice(4).toLowerCase();
		}
	}
});

// node_modules/property-information/lib/html.js
var require_html2 = __commonJS({
	'node_modules/property-information/lib/html.js'(exports, module2) {
		'use strict';
		var types2 = require_types();
		var create3 = require_create();
		var caseInsensitiveTransform3 = require_case_insensitive_transform();
		var boolean3 = types2.boolean;
		var overloadedBoolean3 = types2.overloadedBoolean;
		var booleanish3 = types2.booleanish;
		var number3 = types2.number;
		var spaceSeparated3 = types2.spaceSeparated;
		var commaSeparated3 = types2.commaSeparated;
		module2.exports = create3({
			space: 'html',
			attributes: {
				acceptcharset: 'accept-charset',
				classname: 'class',
				htmlfor: 'for',
				httpequiv: 'http-equiv'
			},
			transform: caseInsensitiveTransform3,
			mustUseProperty: ['checked', 'multiple', 'muted', 'selected'],
			properties: {
				abbr: null,
				accept: commaSeparated3,
				acceptCharset: spaceSeparated3,
				accessKey: spaceSeparated3,
				action: null,
				allow: null,
				allowFullScreen: boolean3,
				allowPaymentRequest: boolean3,
				allowUserMedia: boolean3,
				alt: null,
				as: null,
				async: boolean3,
				autoCapitalize: null,
				autoComplete: spaceSeparated3,
				autoFocus: boolean3,
				autoPlay: boolean3,
				capture: boolean3,
				charSet: null,
				checked: boolean3,
				cite: null,
				className: spaceSeparated3,
				cols: number3,
				colSpan: null,
				content: null,
				contentEditable: booleanish3,
				controls: boolean3,
				controlsList: spaceSeparated3,
				coords: number3 | commaSeparated3,
				crossOrigin: null,
				data: null,
				dateTime: null,
				decoding: null,
				default: boolean3,
				defer: boolean3,
				dir: null,
				dirName: null,
				disabled: boolean3,
				download: overloadedBoolean3,
				draggable: booleanish3,
				encType: null,
				enterKeyHint: null,
				form: null,
				formAction: null,
				formEncType: null,
				formMethod: null,
				formNoValidate: boolean3,
				formTarget: null,
				headers: spaceSeparated3,
				height: number3,
				hidden: boolean3,
				high: number3,
				href: null,
				hrefLang: null,
				htmlFor: spaceSeparated3,
				httpEquiv: spaceSeparated3,
				id: null,
				imageSizes: null,
				imageSrcSet: commaSeparated3,
				inputMode: null,
				integrity: null,
				is: null,
				isMap: boolean3,
				itemId: null,
				itemProp: spaceSeparated3,
				itemRef: spaceSeparated3,
				itemScope: boolean3,
				itemType: spaceSeparated3,
				kind: null,
				label: null,
				lang: null,
				language: null,
				list: null,
				loading: null,
				loop: boolean3,
				low: number3,
				manifest: null,
				max: null,
				maxLength: number3,
				media: null,
				method: null,
				min: null,
				minLength: number3,
				multiple: boolean3,
				muted: boolean3,
				name: null,
				nonce: null,
				noModule: boolean3,
				noValidate: boolean3,
				onAbort: null,
				onAfterPrint: null,
				onAuxClick: null,
				onBeforePrint: null,
				onBeforeUnload: null,
				onBlur: null,
				onCancel: null,
				onCanPlay: null,
				onCanPlayThrough: null,
				onChange: null,
				onClick: null,
				onClose: null,
				onContextMenu: null,
				onCopy: null,
				onCueChange: null,
				onCut: null,
				onDblClick: null,
				onDrag: null,
				onDragEnd: null,
				onDragEnter: null,
				onDragExit: null,
				onDragLeave: null,
				onDragOver: null,
				onDragStart: null,
				onDrop: null,
				onDurationChange: null,
				onEmptied: null,
				onEnded: null,
				onError: null,
				onFocus: null,
				onFormData: null,
				onHashChange: null,
				onInput: null,
				onInvalid: null,
				onKeyDown: null,
				onKeyPress: null,
				onKeyUp: null,
				onLanguageChange: null,
				onLoad: null,
				onLoadedData: null,
				onLoadedMetadata: null,
				onLoadEnd: null,
				onLoadStart: null,
				onMessage: null,
				onMessageError: null,
				onMouseDown: null,
				onMouseEnter: null,
				onMouseLeave: null,
				onMouseMove: null,
				onMouseOut: null,
				onMouseOver: null,
				onMouseUp: null,
				onOffline: null,
				onOnline: null,
				onPageHide: null,
				onPageShow: null,
				onPaste: null,
				onPause: null,
				onPlay: null,
				onPlaying: null,
				onPopState: null,
				onProgress: null,
				onRateChange: null,
				onRejectionHandled: null,
				onReset: null,
				onResize: null,
				onScroll: null,
				onSecurityPolicyViolation: null,
				onSeeked: null,
				onSeeking: null,
				onSelect: null,
				onSlotChange: null,
				onStalled: null,
				onStorage: null,
				onSubmit: null,
				onSuspend: null,
				onTimeUpdate: null,
				onToggle: null,
				onUnhandledRejection: null,
				onUnload: null,
				onVolumeChange: null,
				onWaiting: null,
				onWheel: null,
				open: boolean3,
				optimum: number3,
				pattern: null,
				ping: spaceSeparated3,
				placeholder: null,
				playsInline: boolean3,
				poster: null,
				preload: null,
				readOnly: boolean3,
				referrerPolicy: null,
				rel: spaceSeparated3,
				required: boolean3,
				reversed: boolean3,
				rows: number3,
				rowSpan: number3,
				sandbox: spaceSeparated3,
				scope: null,
				scoped: boolean3,
				seamless: boolean3,
				selected: boolean3,
				shape: null,
				size: number3,
				sizes: null,
				slot: null,
				span: number3,
				spellCheck: booleanish3,
				src: null,
				srcDoc: null,
				srcLang: null,
				srcSet: commaSeparated3,
				start: number3,
				step: null,
				style: null,
				tabIndex: number3,
				target: null,
				title: null,
				translate: null,
				type: null,
				typeMustMatch: boolean3,
				useMap: null,
				value: booleanish3,
				width: number3,
				wrap: null,
				align: null,
				aLink: null,
				archive: spaceSeparated3,
				axis: null,
				background: null,
				bgColor: null,
				border: number3,
				borderColor: null,
				bottomMargin: number3,
				cellPadding: null,
				cellSpacing: null,
				char: null,
				charOff: null,
				classId: null,
				clear: null,
				code: null,
				codeBase: null,
				codeType: null,
				color: null,
				compact: boolean3,
				declare: boolean3,
				event: null,
				face: null,
				frame: null,
				frameBorder: null,
				hSpace: number3,
				leftMargin: number3,
				link: null,
				longDesc: null,
				lowSrc: null,
				marginHeight: number3,
				marginWidth: number3,
				noResize: boolean3,
				noHref: boolean3,
				noShade: boolean3,
				noWrap: boolean3,
				object: null,
				profile: null,
				prompt: null,
				rev: null,
				rightMargin: number3,
				rules: null,
				scheme: null,
				scrolling: booleanish3,
				standby: null,
				summary: null,
				text: null,
				topMargin: number3,
				valueType: null,
				version: null,
				vAlign: null,
				vLink: null,
				vSpace: number3,
				allowTransparency: null,
				autoCorrect: null,
				autoSave: null,
				disablePictureInPicture: boolean3,
				disableRemotePlayback: boolean3,
				prefix: null,
				property: null,
				results: number3,
				security: null,
				unselectable: null
			}
		});
	}
});

// node_modules/property-information/html.js
var require_html3 = __commonJS({
	'node_modules/property-information/html.js'(exports, module2) {
		'use strict';
		var merge3 = require_merge2();
		var xlink3 = require_xlink();
		var xml3 = require_xml();
		var xmlns3 = require_xmlns();
		var aria3 = require_aria();
		var html9 = require_html2();
		module2.exports = merge3([xml3, xlink3, xmlns3, aria3, html9]);
	}
});

// node_modules/property-information/find.js
var require_find = __commonJS({
	'node_modules/property-information/find.js'(exports, module2) {
		'use strict';
		var normalize8 = require_normalize();
		var DefinedInfo3 = require_defined_info();
		var Info3 = require_info();
		var data2 = 'data';
		module2.exports = find3;
		var valid3 = /^data[-\w.:]+$/i;
		var dash3 = /-[a-z]/g;
		var cap3 = /[A-Z]/g;
		function find3(schema, value) {
			var normal = normalize8(value);
			var prop = value;
			var Type = Info3;
			if (normal in schema.normal) {
				return schema.property[schema.normal[normal]];
			}
			if (normal.length > 4 && normal.slice(0, 4) === data2 && valid3.test(value)) {
				if (value.charAt(4) === '-') {
					prop = datasetToProperty(value);
				} else {
					value = datasetToAttribute(value);
				}
				Type = DefinedInfo3;
			}
			return new Type(prop, value);
		}
		function datasetToProperty(attribute) {
			var value = attribute.slice(5).replace(dash3, camelcase4);
			return data2 + value.charAt(0).toUpperCase() + value.slice(1);
		}
		function datasetToAttribute(property) {
			var value = property.slice(4);
			if (dash3.test(value)) {
				return property;
			}
			value = value.replace(cap3, kebab3);
			if (value.charAt(0) !== '-') {
				value = '-' + value;
			}
			return data2 + value;
		}
		function kebab3($0) {
			return '-' + $0.toLowerCase();
		}
		function camelcase4($0) {
			return $0.charAt(1).toUpperCase();
		}
	}
});

// node_modules/hast-util-parse-selector/index.js
var require_hast_util_parse_selector = __commonJS({
	'node_modules/hast-util-parse-selector/index.js'(exports, module2) {
		'use strict';
		module2.exports = parse6;
		var search3 = /[#.]/g;
		function parse6(selector, defaultTagName) {
			var value = selector || '';
			var name = defaultTagName || 'div';
			var props = {};
			var start = 0;
			var subvalue;
			var previous2;
			var match;
			while (start < value.length) {
				search3.lastIndex = start;
				match = search3.exec(value);
				subvalue = value.slice(start, match ? match.index : value.length);
				if (subvalue) {
					if (!previous2) {
						name = subvalue;
					} else if (previous2 === '#') {
						props.id = subvalue;
					} else if (props.className) {
						props.className.push(subvalue);
					} else {
						props.className = [subvalue];
					}
					start += subvalue.length;
				}
				if (match) {
					previous2 = match[0];
					start++;
				}
			}
			return { type: 'element', tagName: name, properties: props, children: [] };
		}
	}
});

// node_modules/space-separated-tokens/index.js
var require_space_separated_tokens = __commonJS({
	'node_modules/space-separated-tokens/index.js'(exports) {
		'use strict';
		exports.parse = parse6;
		exports.stringify = stringify3;
		var empty = '';
		var space = ' ';
		var whiteSpace = /[ \t\n\r\f]+/g;
		function parse6(value) {
			var input = String(value || empty).trim();
			return input === empty ? [] : input.split(whiteSpace);
		}
		function stringify3(values) {
			return values.join(space).trim();
		}
	}
});

// node_modules/comma-separated-tokens/index.js
var require_comma_separated_tokens = __commonJS({
	'node_modules/comma-separated-tokens/index.js'(exports) {
		'use strict';
		exports.parse = parse6;
		exports.stringify = stringify3;
		var comma = ',';
		var space = ' ';
		var empty = '';
		function parse6(value) {
			var values = [];
			var input = String(value || empty);
			var index6 = input.indexOf(comma);
			var lastIndex = 0;
			var end = false;
			var val;
			while (!end) {
				if (index6 === -1) {
					index6 = input.length;
					end = true;
				}
				val = input.slice(lastIndex, index6).trim();
				if (val || !end) {
					values.push(val);
				}
				lastIndex = index6 + 1;
				index6 = input.indexOf(comma, lastIndex);
			}
			return values;
		}
		function stringify3(values, options) {
			var settings = options || {};
			var left = settings.padLeft === false ? empty : space;
			var right = settings.padRight ? space : empty;
			if (values[values.length - 1] === empty) {
				values = values.concat(empty);
			}
			return values.join(right + comma + left).trim();
		}
	}
});

// node_modules/hastscript/factory.js
var require_factory = __commonJS({
	'node_modules/hastscript/factory.js'(exports, module2) {
		'use strict';
		var find3 = require_find();
		var normalize8 = require_normalize();
		var parseSelector2 = require_hast_util_parse_selector();
		var spaces = require_space_separated_tokens().parse;
		var commas = require_comma_separated_tokens().parse;
		module2.exports = factory2;
		var own16 = {}.hasOwnProperty;
		function factory2(schema, defaultTagName, caseSensitive) {
			var adjust = caseSensitive ? createAdjustMap2(caseSensitive) : null;
			return h3;
			function h3(selector, properties2) {
				var node = parseSelector2(selector, defaultTagName);
				var children = Array.prototype.slice.call(arguments, 2);
				var name = node.tagName.toLowerCase();
				var property;
				node.tagName = adjust && own16.call(adjust, name) ? adjust[name] : name;
				if (properties2 && isChildren(properties2, node)) {
					children.unshift(properties2);
					properties2 = null;
				}
				if (properties2) {
					for (property in properties2) {
						addProperty2(node.properties, property, properties2[property]);
					}
				}
				addChild2(node.children, children);
				if (node.tagName === 'template') {
					node.content = { type: 'root', children: node.children };
					node.children = [];
				}
				return node;
			}
			function addProperty2(properties2, key3, value) {
				var info;
				var property;
				var result;
				if (value === null || value === void 0 || value !== value) {
					return;
				}
				info = find3(schema, key3);
				property = info.property;
				result = value;
				if (typeof result === 'string') {
					if (info.spaceSeparated) {
						result = spaces(result);
					} else if (info.commaSeparated) {
						result = commas(result);
					} else if (info.commaOrSpaceSeparated) {
						result = spaces(commas(result).join(' '));
					}
				}
				if (property === 'style' && typeof value !== 'string') {
					result = style2(result);
				}
				if (property === 'className' && properties2.className) {
					result = properties2.className.concat(result);
				}
				properties2[property] = parsePrimitives(info, property, result);
			}
		}
		function isChildren(value, node) {
			return typeof value === 'string' || 'length' in value || isNode(node.tagName, value);
		}
		function isNode(tagName, value) {
			var type = value.type;
			if (tagName === 'input' || !type || typeof type !== 'string') {
				return false;
			}
			if (typeof value.children === 'object' && 'length' in value.children) {
				return true;
			}
			type = type.toLowerCase();
			if (tagName === 'button') {
				return type !== 'menu' && type !== 'submit' && type !== 'reset' && type !== 'button';
			}
			return 'value' in value;
		}
		function addChild2(nodes2, value) {
			var index6;
			var length;
			if (typeof value === 'string' || typeof value === 'number') {
				nodes2.push({ type: 'text', value: String(value) });
				return;
			}
			if (typeof value === 'object' && 'length' in value) {
				index6 = -1;
				length = value.length;
				while (++index6 < length) {
					addChild2(nodes2, value[index6]);
				}
				return;
			}
			if (typeof value !== 'object' || !('type' in value)) {
				throw new Error('Expected node, nodes, or string, got `' + value + '`');
			}
			nodes2.push(value);
		}
		function parsePrimitives(info, name, value) {
			var index6;
			var length;
			var result;
			if (typeof value !== 'object' || !('length' in value)) {
				return parsePrimitive2(info, name, value);
			}
			length = value.length;
			index6 = -1;
			result = [];
			while (++index6 < length) {
				result[index6] = parsePrimitive2(info, name, value[index6]);
			}
			return result;
		}
		function parsePrimitive2(info, name, value) {
			var result = value;
			if (info.number || info.positiveNumber) {
				if (!isNaN(result) && result !== '') {
					result = Number(result);
				}
			} else if (info.boolean || info.overloadedBoolean) {
				if (
					typeof result === 'string' &&
					(result === '' || normalize8(value) === normalize8(name))
				) {
					result = true;
				}
			}
			return result;
		}
		function style2(value) {
			var result = [];
			var key3;
			for (key3 in value) {
				result.push([key3, value[key3]].join(': '));
			}
			return result.join('; ');
		}
		function createAdjustMap2(values) {
			var length = values.length;
			var index6 = -1;
			var result = {};
			var value;
			while (++index6 < length) {
				value = values[index6];
				result[value.toLowerCase()] = value;
			}
			return result;
		}
	}
});

// node_modules/hastscript/html.js
var require_html4 = __commonJS({
	'node_modules/hastscript/html.js'(exports, module2) {
		'use strict';
		var schema = require_html3();
		var factory2 = require_factory();
		var html9 = factory2(schema, 'div');
		html9.displayName = 'html';
		module2.exports = html9;
	}
});

// node_modules/hastscript/index.js
var require_hastscript = __commonJS({
	'node_modules/hastscript/index.js'(exports, module2) {
		'use strict';
		module2.exports = require_html4();
	}
});

// node_modules/character-entities-legacy/index.json
var require_character_entities_legacy = __commonJS({
	'node_modules/character-entities-legacy/index.json'(exports, module2) {
		module2.exports = {
			AElig: '\xC6',
			AMP: '&',
			Aacute: '\xC1',
			Acirc: '\xC2',
			Agrave: '\xC0',
			Aring: '\xC5',
			Atilde: '\xC3',
			Auml: '\xC4',
			COPY: '\xA9',
			Ccedil: '\xC7',
			ETH: '\xD0',
			Eacute: '\xC9',
			Ecirc: '\xCA',
			Egrave: '\xC8',
			Euml: '\xCB',
			GT: '>',
			Iacute: '\xCD',
			Icirc: '\xCE',
			Igrave: '\xCC',
			Iuml: '\xCF',
			LT: '<',
			Ntilde: '\xD1',
			Oacute: '\xD3',
			Ocirc: '\xD4',
			Ograve: '\xD2',
			Oslash: '\xD8',
			Otilde: '\xD5',
			Ouml: '\xD6',
			QUOT: '"',
			REG: '\xAE',
			THORN: '\xDE',
			Uacute: '\xDA',
			Ucirc: '\xDB',
			Ugrave: '\xD9',
			Uuml: '\xDC',
			Yacute: '\xDD',
			aacute: '\xE1',
			acirc: '\xE2',
			acute: '\xB4',
			aelig: '\xE6',
			agrave: '\xE0',
			amp: '&',
			aring: '\xE5',
			atilde: '\xE3',
			auml: '\xE4',
			brvbar: '\xA6',
			ccedil: '\xE7',
			cedil: '\xB8',
			cent: '\xA2',
			copy: '\xA9',
			curren: '\xA4',
			deg: '\xB0',
			divide: '\xF7',
			eacute: '\xE9',
			ecirc: '\xEA',
			egrave: '\xE8',
			eth: '\xF0',
			euml: '\xEB',
			frac12: '\xBD',
			frac14: '\xBC',
			frac34: '\xBE',
			gt: '>',
			iacute: '\xED',
			icirc: '\xEE',
			iexcl: '\xA1',
			igrave: '\xEC',
			iquest: '\xBF',
			iuml: '\xEF',
			laquo: '\xAB',
			lt: '<',
			macr: '\xAF',
			micro: '\xB5',
			middot: '\xB7',
			nbsp: '\xA0',
			not: '\xAC',
			ntilde: '\xF1',
			oacute: '\xF3',
			ocirc: '\xF4',
			ograve: '\xF2',
			ordf: '\xAA',
			ordm: '\xBA',
			oslash: '\xF8',
			otilde: '\xF5',
			ouml: '\xF6',
			para: '\xB6',
			plusmn: '\xB1',
			pound: '\xA3',
			quot: '"',
			raquo: '\xBB',
			reg: '\xAE',
			sect: '\xA7',
			shy: '\xAD',
			sup1: '\xB9',
			sup2: '\xB2',
			sup3: '\xB3',
			szlig: '\xDF',
			thorn: '\xFE',
			times: '\xD7',
			uacute: '\xFA',
			ucirc: '\xFB',
			ugrave: '\xF9',
			uml: '\xA8',
			uuml: '\xFC',
			yacute: '\xFD',
			yen: '\xA5',
			yuml: '\xFF'
		};
	}
});

// node_modules/character-reference-invalid/index.json
var require_character_reference_invalid = __commonJS({
	'node_modules/character-reference-invalid/index.json'(exports, module2) {
		module2.exports = {
			0: '\uFFFD',
			128: '\u20AC',
			130: '\u201A',
			131: '\u0192',
			132: '\u201E',
			133: '\u2026',
			134: '\u2020',
			135: '\u2021',
			136: '\u02C6',
			137: '\u2030',
			138: '\u0160',
			139: '\u2039',
			140: '\u0152',
			142: '\u017D',
			145: '\u2018',
			146: '\u2019',
			147: '\u201C',
			148: '\u201D',
			149: '\u2022',
			150: '\u2013',
			151: '\u2014',
			152: '\u02DC',
			153: '\u2122',
			154: '\u0161',
			155: '\u203A',
			156: '\u0153',
			158: '\u017E',
			159: '\u0178'
		};
	}
});

// node_modules/is-decimal/index.js
var require_is_decimal = __commonJS({
	'node_modules/is-decimal/index.js'(exports, module2) {
		'use strict';
		module2.exports = decimal;
		function decimal(character) {
			var code3 = typeof character === 'string' ? character.charCodeAt(0) : character;
			return code3 >= 48 && code3 <= 57;
		}
	}
});

// node_modules/is-hexadecimal/index.js
var require_is_hexadecimal = __commonJS({
	'node_modules/is-hexadecimal/index.js'(exports, module2) {
		'use strict';
		module2.exports = hexadecimal;
		function hexadecimal(character) {
			var code3 = typeof character === 'string' ? character.charCodeAt(0) : character;
			return (
				(code3 >= 97 && code3 <= 102) ||
				(code3 >= 65 && code3 <= 70) ||
				(code3 >= 48 && code3 <= 57)
			);
		}
	}
});

// node_modules/is-alphabetical/index.js
var require_is_alphabetical = __commonJS({
	'node_modules/is-alphabetical/index.js'(exports, module2) {
		'use strict';
		module2.exports = alphabetical;
		function alphabetical(character) {
			var code3 = typeof character === 'string' ? character.charCodeAt(0) : character;
			return (code3 >= 97 && code3 <= 122) || (code3 >= 65 && code3 <= 90);
		}
	}
});

// node_modules/is-alphanumerical/index.js
var require_is_alphanumerical = __commonJS({
	'node_modules/is-alphanumerical/index.js'(exports, module2) {
		'use strict';
		var alphabetical = require_is_alphabetical();
		var decimal = require_is_decimal();
		module2.exports = alphanumerical;
		function alphanumerical(character) {
			return alphabetical(character) || decimal(character);
		}
	}
});

// node_modules/character-entities/index.json
var require_character_entities = __commonJS({
	'node_modules/character-entities/index.json'(exports, module2) {
		module2.exports = {
			AEli: '\xC6',
			AElig: '\xC6',
			AM: '&',
			AMP: '&',
			Aacut: '\xC1',
			Aacute: '\xC1',
			Abreve: '\u0102',
			Acir: '\xC2',
			Acirc: '\xC2',
			Acy: '\u0410',
			Afr: '\u{1D504}',
			Agrav: '\xC0',
			Agrave: '\xC0',
			Alpha: '\u0391',
			Amacr: '\u0100',
			And: '\u2A53',
			Aogon: '\u0104',
			Aopf: '\u{1D538}',
			ApplyFunction: '\u2061',
			Arin: '\xC5',
			Aring: '\xC5',
			Ascr: '\u{1D49C}',
			Assign: '\u2254',
			Atild: '\xC3',
			Atilde: '\xC3',
			Aum: '\xC4',
			Auml: '\xC4',
			Backslash: '\u2216',
			Barv: '\u2AE7',
			Barwed: '\u2306',
			Bcy: '\u0411',
			Because: '\u2235',
			Bernoullis: '\u212C',
			Beta: '\u0392',
			Bfr: '\u{1D505}',
			Bopf: '\u{1D539}',
			Breve: '\u02D8',
			Bscr: '\u212C',
			Bumpeq: '\u224E',
			CHcy: '\u0427',
			COP: '\xA9',
			COPY: '\xA9',
			Cacute: '\u0106',
			Cap: '\u22D2',
			CapitalDifferentialD: '\u2145',
			Cayleys: '\u212D',
			Ccaron: '\u010C',
			Ccedi: '\xC7',
			Ccedil: '\xC7',
			Ccirc: '\u0108',
			Cconint: '\u2230',
			Cdot: '\u010A',
			Cedilla: '\xB8',
			CenterDot: '\xB7',
			Cfr: '\u212D',
			Chi: '\u03A7',
			CircleDot: '\u2299',
			CircleMinus: '\u2296',
			CirclePlus: '\u2295',
			CircleTimes: '\u2297',
			ClockwiseContourIntegral: '\u2232',
			CloseCurlyDoubleQuote: '\u201D',
			CloseCurlyQuote: '\u2019',
			Colon: '\u2237',
			Colone: '\u2A74',
			Congruent: '\u2261',
			Conint: '\u222F',
			ContourIntegral: '\u222E',
			Copf: '\u2102',
			Coproduct: '\u2210',
			CounterClockwiseContourIntegral: '\u2233',
			Cross: '\u2A2F',
			Cscr: '\u{1D49E}',
			Cup: '\u22D3',
			CupCap: '\u224D',
			DD: '\u2145',
			DDotrahd: '\u2911',
			DJcy: '\u0402',
			DScy: '\u0405',
			DZcy: '\u040F',
			Dagger: '\u2021',
			Darr: '\u21A1',
			Dashv: '\u2AE4',
			Dcaron: '\u010E',
			Dcy: '\u0414',
			Del: '\u2207',
			Delta: '\u0394',
			Dfr: '\u{1D507}',
			DiacriticalAcute: '\xB4',
			DiacriticalDot: '\u02D9',
			DiacriticalDoubleAcute: '\u02DD',
			DiacriticalGrave: '`',
			DiacriticalTilde: '\u02DC',
			Diamond: '\u22C4',
			DifferentialD: '\u2146',
			Dopf: '\u{1D53B}',
			Dot: '\xA8',
			DotDot: '\u20DC',
			DotEqual: '\u2250',
			DoubleContourIntegral: '\u222F',
			DoubleDot: '\xA8',
			DoubleDownArrow: '\u21D3',
			DoubleLeftArrow: '\u21D0',
			DoubleLeftRightArrow: '\u21D4',
			DoubleLeftTee: '\u2AE4',
			DoubleLongLeftArrow: '\u27F8',
			DoubleLongLeftRightArrow: '\u27FA',
			DoubleLongRightArrow: '\u27F9',
			DoubleRightArrow: '\u21D2',
			DoubleRightTee: '\u22A8',
			DoubleUpArrow: '\u21D1',
			DoubleUpDownArrow: '\u21D5',
			DoubleVerticalBar: '\u2225',
			DownArrow: '\u2193',
			DownArrowBar: '\u2913',
			DownArrowUpArrow: '\u21F5',
			DownBreve: '\u0311',
			DownLeftRightVector: '\u2950',
			DownLeftTeeVector: '\u295E',
			DownLeftVector: '\u21BD',
			DownLeftVectorBar: '\u2956',
			DownRightTeeVector: '\u295F',
			DownRightVector: '\u21C1',
			DownRightVectorBar: '\u2957',
			DownTee: '\u22A4',
			DownTeeArrow: '\u21A7',
			Downarrow: '\u21D3',
			Dscr: '\u{1D49F}',
			Dstrok: '\u0110',
			ENG: '\u014A',
			ET: '\xD0',
			ETH: '\xD0',
			Eacut: '\xC9',
			Eacute: '\xC9',
			Ecaron: '\u011A',
			Ecir: '\xCA',
			Ecirc: '\xCA',
			Ecy: '\u042D',
			Edot: '\u0116',
			Efr: '\u{1D508}',
			Egrav: '\xC8',
			Egrave: '\xC8',
			Element: '\u2208',
			Emacr: '\u0112',
			EmptySmallSquare: '\u25FB',
			EmptyVerySmallSquare: '\u25AB',
			Eogon: '\u0118',
			Eopf: '\u{1D53C}',
			Epsilon: '\u0395',
			Equal: '\u2A75',
			EqualTilde: '\u2242',
			Equilibrium: '\u21CC',
			Escr: '\u2130',
			Esim: '\u2A73',
			Eta: '\u0397',
			Eum: '\xCB',
			Euml: '\xCB',
			Exists: '\u2203',
			ExponentialE: '\u2147',
			Fcy: '\u0424',
			Ffr: '\u{1D509}',
			FilledSmallSquare: '\u25FC',
			FilledVerySmallSquare: '\u25AA',
			Fopf: '\u{1D53D}',
			ForAll: '\u2200',
			Fouriertrf: '\u2131',
			Fscr: '\u2131',
			GJcy: '\u0403',
			G: '>',
			GT: '>',
			Gamma: '\u0393',
			Gammad: '\u03DC',
			Gbreve: '\u011E',
			Gcedil: '\u0122',
			Gcirc: '\u011C',
			Gcy: '\u0413',
			Gdot: '\u0120',
			Gfr: '\u{1D50A}',
			Gg: '\u22D9',
			Gopf: '\u{1D53E}',
			GreaterEqual: '\u2265',
			GreaterEqualLess: '\u22DB',
			GreaterFullEqual: '\u2267',
			GreaterGreater: '\u2AA2',
			GreaterLess: '\u2277',
			GreaterSlantEqual: '\u2A7E',
			GreaterTilde: '\u2273',
			Gscr: '\u{1D4A2}',
			Gt: '\u226B',
			HARDcy: '\u042A',
			Hacek: '\u02C7',
			Hat: '^',
			Hcirc: '\u0124',
			Hfr: '\u210C',
			HilbertSpace: '\u210B',
			Hopf: '\u210D',
			HorizontalLine: '\u2500',
			Hscr: '\u210B',
			Hstrok: '\u0126',
			HumpDownHump: '\u224E',
			HumpEqual: '\u224F',
			IEcy: '\u0415',
			IJlig: '\u0132',
			IOcy: '\u0401',
			Iacut: '\xCD',
			Iacute: '\xCD',
			Icir: '\xCE',
			Icirc: '\xCE',
			Icy: '\u0418',
			Idot: '\u0130',
			Ifr: '\u2111',
			Igrav: '\xCC',
			Igrave: '\xCC',
			Im: '\u2111',
			Imacr: '\u012A',
			ImaginaryI: '\u2148',
			Implies: '\u21D2',
			Int: '\u222C',
			Integral: '\u222B',
			Intersection: '\u22C2',
			InvisibleComma: '\u2063',
			InvisibleTimes: '\u2062',
			Iogon: '\u012E',
			Iopf: '\u{1D540}',
			Iota: '\u0399',
			Iscr: '\u2110',
			Itilde: '\u0128',
			Iukcy: '\u0406',
			Ium: '\xCF',
			Iuml: '\xCF',
			Jcirc: '\u0134',
			Jcy: '\u0419',
			Jfr: '\u{1D50D}',
			Jopf: '\u{1D541}',
			Jscr: '\u{1D4A5}',
			Jsercy: '\u0408',
			Jukcy: '\u0404',
			KHcy: '\u0425',
			KJcy: '\u040C',
			Kappa: '\u039A',
			Kcedil: '\u0136',
			Kcy: '\u041A',
			Kfr: '\u{1D50E}',
			Kopf: '\u{1D542}',
			Kscr: '\u{1D4A6}',
			LJcy: '\u0409',
			L: '<',
			LT: '<',
			Lacute: '\u0139',
			Lambda: '\u039B',
			Lang: '\u27EA',
			Laplacetrf: '\u2112',
			Larr: '\u219E',
			Lcaron: '\u013D',
			Lcedil: '\u013B',
			Lcy: '\u041B',
			LeftAngleBracket: '\u27E8',
			LeftArrow: '\u2190',
			LeftArrowBar: '\u21E4',
			LeftArrowRightArrow: '\u21C6',
			LeftCeiling: '\u2308',
			LeftDoubleBracket: '\u27E6',
			LeftDownTeeVector: '\u2961',
			LeftDownVector: '\u21C3',
			LeftDownVectorBar: '\u2959',
			LeftFloor: '\u230A',
			LeftRightArrow: '\u2194',
			LeftRightVector: '\u294E',
			LeftTee: '\u22A3',
			LeftTeeArrow: '\u21A4',
			LeftTeeVector: '\u295A',
			LeftTriangle: '\u22B2',
			LeftTriangleBar: '\u29CF',
			LeftTriangleEqual: '\u22B4',
			LeftUpDownVector: '\u2951',
			LeftUpTeeVector: '\u2960',
			LeftUpVector: '\u21BF',
			LeftUpVectorBar: '\u2958',
			LeftVector: '\u21BC',
			LeftVectorBar: '\u2952',
			Leftarrow: '\u21D0',
			Leftrightarrow: '\u21D4',
			LessEqualGreater: '\u22DA',
			LessFullEqual: '\u2266',
			LessGreater: '\u2276',
			LessLess: '\u2AA1',
			LessSlantEqual: '\u2A7D',
			LessTilde: '\u2272',
			Lfr: '\u{1D50F}',
			Ll: '\u22D8',
			Lleftarrow: '\u21DA',
			Lmidot: '\u013F',
			LongLeftArrow: '\u27F5',
			LongLeftRightArrow: '\u27F7',
			LongRightArrow: '\u27F6',
			Longleftarrow: '\u27F8',
			Longleftrightarrow: '\u27FA',
			Longrightarrow: '\u27F9',
			Lopf: '\u{1D543}',
			LowerLeftArrow: '\u2199',
			LowerRightArrow: '\u2198',
			Lscr: '\u2112',
			Lsh: '\u21B0',
			Lstrok: '\u0141',
			Lt: '\u226A',
			Map: '\u2905',
			Mcy: '\u041C',
			MediumSpace: '\u205F',
			Mellintrf: '\u2133',
			Mfr: '\u{1D510}',
			MinusPlus: '\u2213',
			Mopf: '\u{1D544}',
			Mscr: '\u2133',
			Mu: '\u039C',
			NJcy: '\u040A',
			Nacute: '\u0143',
			Ncaron: '\u0147',
			Ncedil: '\u0145',
			Ncy: '\u041D',
			NegativeMediumSpace: '\u200B',
			NegativeThickSpace: '\u200B',
			NegativeThinSpace: '\u200B',
			NegativeVeryThinSpace: '\u200B',
			NestedGreaterGreater: '\u226B',
			NestedLessLess: '\u226A',
			NewLine: '\n',
			Nfr: '\u{1D511}',
			NoBreak: '\u2060',
			NonBreakingSpace: '\xA0',
			Nopf: '\u2115',
			Not: '\u2AEC',
			NotCongruent: '\u2262',
			NotCupCap: '\u226D',
			NotDoubleVerticalBar: '\u2226',
			NotElement: '\u2209',
			NotEqual: '\u2260',
			NotEqualTilde: '\u2242\u0338',
			NotExists: '\u2204',
			NotGreater: '\u226F',
			NotGreaterEqual: '\u2271',
			NotGreaterFullEqual: '\u2267\u0338',
			NotGreaterGreater: '\u226B\u0338',
			NotGreaterLess: '\u2279',
			NotGreaterSlantEqual: '\u2A7E\u0338',
			NotGreaterTilde: '\u2275',
			NotHumpDownHump: '\u224E\u0338',
			NotHumpEqual: '\u224F\u0338',
			NotLeftTriangle: '\u22EA',
			NotLeftTriangleBar: '\u29CF\u0338',
			NotLeftTriangleEqual: '\u22EC',
			NotLess: '\u226E',
			NotLessEqual: '\u2270',
			NotLessGreater: '\u2278',
			NotLessLess: '\u226A\u0338',
			NotLessSlantEqual: '\u2A7D\u0338',
			NotLessTilde: '\u2274',
			NotNestedGreaterGreater: '\u2AA2\u0338',
			NotNestedLessLess: '\u2AA1\u0338',
			NotPrecedes: '\u2280',
			NotPrecedesEqual: '\u2AAF\u0338',
			NotPrecedesSlantEqual: '\u22E0',
			NotReverseElement: '\u220C',
			NotRightTriangle: '\u22EB',
			NotRightTriangleBar: '\u29D0\u0338',
			NotRightTriangleEqual: '\u22ED',
			NotSquareSubset: '\u228F\u0338',
			NotSquareSubsetEqual: '\u22E2',
			NotSquareSuperset: '\u2290\u0338',
			NotSquareSupersetEqual: '\u22E3',
			NotSubset: '\u2282\u20D2',
			NotSubsetEqual: '\u2288',
			NotSucceeds: '\u2281',
			NotSucceedsEqual: '\u2AB0\u0338',
			NotSucceedsSlantEqual: '\u22E1',
			NotSucceedsTilde: '\u227F\u0338',
			NotSuperset: '\u2283\u20D2',
			NotSupersetEqual: '\u2289',
			NotTilde: '\u2241',
			NotTildeEqual: '\u2244',
			NotTildeFullEqual: '\u2247',
			NotTildeTilde: '\u2249',
			NotVerticalBar: '\u2224',
			Nscr: '\u{1D4A9}',
			Ntild: '\xD1',
			Ntilde: '\xD1',
			Nu: '\u039D',
			OElig: '\u0152',
			Oacut: '\xD3',
			Oacute: '\xD3',
			Ocir: '\xD4',
			Ocirc: '\xD4',
			Ocy: '\u041E',
			Odblac: '\u0150',
			Ofr: '\u{1D512}',
			Ograv: '\xD2',
			Ograve: '\xD2',
			Omacr: '\u014C',
			Omega: '\u03A9',
			Omicron: '\u039F',
			Oopf: '\u{1D546}',
			OpenCurlyDoubleQuote: '\u201C',
			OpenCurlyQuote: '\u2018',
			Or: '\u2A54',
			Oscr: '\u{1D4AA}',
			Oslas: '\xD8',
			Oslash: '\xD8',
			Otild: '\xD5',
			Otilde: '\xD5',
			Otimes: '\u2A37',
			Oum: '\xD6',
			Ouml: '\xD6',
			OverBar: '\u203E',
			OverBrace: '\u23DE',
			OverBracket: '\u23B4',
			OverParenthesis: '\u23DC',
			PartialD: '\u2202',
			Pcy: '\u041F',
			Pfr: '\u{1D513}',
			Phi: '\u03A6',
			Pi: '\u03A0',
			PlusMinus: '\xB1',
			Poincareplane: '\u210C',
			Popf: '\u2119',
			Pr: '\u2ABB',
			Precedes: '\u227A',
			PrecedesEqual: '\u2AAF',
			PrecedesSlantEqual: '\u227C',
			PrecedesTilde: '\u227E',
			Prime: '\u2033',
			Product: '\u220F',
			Proportion: '\u2237',
			Proportional: '\u221D',
			Pscr: '\u{1D4AB}',
			Psi: '\u03A8',
			QUO: '"',
			QUOT: '"',
			Qfr: '\u{1D514}',
			Qopf: '\u211A',
			Qscr: '\u{1D4AC}',
			RBarr: '\u2910',
			RE: '\xAE',
			REG: '\xAE',
			Racute: '\u0154',
			Rang: '\u27EB',
			Rarr: '\u21A0',
			Rarrtl: '\u2916',
			Rcaron: '\u0158',
			Rcedil: '\u0156',
			Rcy: '\u0420',
			Re: '\u211C',
			ReverseElement: '\u220B',
			ReverseEquilibrium: '\u21CB',
			ReverseUpEquilibrium: '\u296F',
			Rfr: '\u211C',
			Rho: '\u03A1',
			RightAngleBracket: '\u27E9',
			RightArrow: '\u2192',
			RightArrowBar: '\u21E5',
			RightArrowLeftArrow: '\u21C4',
			RightCeiling: '\u2309',
			RightDoubleBracket: '\u27E7',
			RightDownTeeVector: '\u295D',
			RightDownVector: '\u21C2',
			RightDownVectorBar: '\u2955',
			RightFloor: '\u230B',
			RightTee: '\u22A2',
			RightTeeArrow: '\u21A6',
			RightTeeVector: '\u295B',
			RightTriangle: '\u22B3',
			RightTriangleBar: '\u29D0',
			RightTriangleEqual: '\u22B5',
			RightUpDownVector: '\u294F',
			RightUpTeeVector: '\u295C',
			RightUpVector: '\u21BE',
			RightUpVectorBar: '\u2954',
			RightVector: '\u21C0',
			RightVectorBar: '\u2953',
			Rightarrow: '\u21D2',
			Ropf: '\u211D',
			RoundImplies: '\u2970',
			Rrightarrow: '\u21DB',
			Rscr: '\u211B',
			Rsh: '\u21B1',
			RuleDelayed: '\u29F4',
			SHCHcy: '\u0429',
			SHcy: '\u0428',
			SOFTcy: '\u042C',
			Sacute: '\u015A',
			Sc: '\u2ABC',
			Scaron: '\u0160',
			Scedil: '\u015E',
			Scirc: '\u015C',
			Scy: '\u0421',
			Sfr: '\u{1D516}',
			ShortDownArrow: '\u2193',
			ShortLeftArrow: '\u2190',
			ShortRightArrow: '\u2192',
			ShortUpArrow: '\u2191',
			Sigma: '\u03A3',
			SmallCircle: '\u2218',
			Sopf: '\u{1D54A}',
			Sqrt: '\u221A',
			Square: '\u25A1',
			SquareIntersection: '\u2293',
			SquareSubset: '\u228F',
			SquareSubsetEqual: '\u2291',
			SquareSuperset: '\u2290',
			SquareSupersetEqual: '\u2292',
			SquareUnion: '\u2294',
			Sscr: '\u{1D4AE}',
			Star: '\u22C6',
			Sub: '\u22D0',
			Subset: '\u22D0',
			SubsetEqual: '\u2286',
			Succeeds: '\u227B',
			SucceedsEqual: '\u2AB0',
			SucceedsSlantEqual: '\u227D',
			SucceedsTilde: '\u227F',
			SuchThat: '\u220B',
			Sum: '\u2211',
			Sup: '\u22D1',
			Superset: '\u2283',
			SupersetEqual: '\u2287',
			Supset: '\u22D1',
			THOR: '\xDE',
			THORN: '\xDE',
			TRADE: '\u2122',
			TSHcy: '\u040B',
			TScy: '\u0426',
			Tab: '	',
			Tau: '\u03A4',
			Tcaron: '\u0164',
			Tcedil: '\u0162',
			Tcy: '\u0422',
			Tfr: '\u{1D517}',
			Therefore: '\u2234',
			Theta: '\u0398',
			ThickSpace: '\u205F\u200A',
			ThinSpace: '\u2009',
			Tilde: '\u223C',
			TildeEqual: '\u2243',
			TildeFullEqual: '\u2245',
			TildeTilde: '\u2248',
			Topf: '\u{1D54B}',
			TripleDot: '\u20DB',
			Tscr: '\u{1D4AF}',
			Tstrok: '\u0166',
			Uacut: '\xDA',
			Uacute: '\xDA',
			Uarr: '\u219F',
			Uarrocir: '\u2949',
			Ubrcy: '\u040E',
			Ubreve: '\u016C',
			Ucir: '\xDB',
			Ucirc: '\xDB',
			Ucy: '\u0423',
			Udblac: '\u0170',
			Ufr: '\u{1D518}',
			Ugrav: '\xD9',
			Ugrave: '\xD9',
			Umacr: '\u016A',
			UnderBar: '_',
			UnderBrace: '\u23DF',
			UnderBracket: '\u23B5',
			UnderParenthesis: '\u23DD',
			Union: '\u22C3',
			UnionPlus: '\u228E',
			Uogon: '\u0172',
			Uopf: '\u{1D54C}',
			UpArrow: '\u2191',
			UpArrowBar: '\u2912',
			UpArrowDownArrow: '\u21C5',
			UpDownArrow: '\u2195',
			UpEquilibrium: '\u296E',
			UpTee: '\u22A5',
			UpTeeArrow: '\u21A5',
			Uparrow: '\u21D1',
			Updownarrow: '\u21D5',
			UpperLeftArrow: '\u2196',
			UpperRightArrow: '\u2197',
			Upsi: '\u03D2',
			Upsilon: '\u03A5',
			Uring: '\u016E',
			Uscr: '\u{1D4B0}',
			Utilde: '\u0168',
			Uum: '\xDC',
			Uuml: '\xDC',
			VDash: '\u22AB',
			Vbar: '\u2AEB',
			Vcy: '\u0412',
			Vdash: '\u22A9',
			Vdashl: '\u2AE6',
			Vee: '\u22C1',
			Verbar: '\u2016',
			Vert: '\u2016',
			VerticalBar: '\u2223',
			VerticalLine: '|',
			VerticalSeparator: '\u2758',
			VerticalTilde: '\u2240',
			VeryThinSpace: '\u200A',
			Vfr: '\u{1D519}',
			Vopf: '\u{1D54D}',
			Vscr: '\u{1D4B1}',
			Vvdash: '\u22AA',
			Wcirc: '\u0174',
			Wedge: '\u22C0',
			Wfr: '\u{1D51A}',
			Wopf: '\u{1D54E}',
			Wscr: '\u{1D4B2}',
			Xfr: '\u{1D51B}',
			Xi: '\u039E',
			Xopf: '\u{1D54F}',
			Xscr: '\u{1D4B3}',
			YAcy: '\u042F',
			YIcy: '\u0407',
			YUcy: '\u042E',
			Yacut: '\xDD',
			Yacute: '\xDD',
			Ycirc: '\u0176',
			Ycy: '\u042B',
			Yfr: '\u{1D51C}',
			Yopf: '\u{1D550}',
			Yscr: '\u{1D4B4}',
			Yuml: '\u0178',
			ZHcy: '\u0416',
			Zacute: '\u0179',
			Zcaron: '\u017D',
			Zcy: '\u0417',
			Zdot: '\u017B',
			ZeroWidthSpace: '\u200B',
			Zeta: '\u0396',
			Zfr: '\u2128',
			Zopf: '\u2124',
			Zscr: '\u{1D4B5}',
			aacut: '\xE1',
			aacute: '\xE1',
			abreve: '\u0103',
			ac: '\u223E',
			acE: '\u223E\u0333',
			acd: '\u223F',
			acir: '\xE2',
			acirc: '\xE2',
			acut: '\xB4',
			acute: '\xB4',
			acy: '\u0430',
			aeli: '\xE6',
			aelig: '\xE6',
			af: '\u2061',
			afr: '\u{1D51E}',
			agrav: '\xE0',
			agrave: '\xE0',
			alefsym: '\u2135',
			aleph: '\u2135',
			alpha: '\u03B1',
			amacr: '\u0101',
			amalg: '\u2A3F',
			am: '&',
			amp: '&',
			and: '\u2227',
			andand: '\u2A55',
			andd: '\u2A5C',
			andslope: '\u2A58',
			andv: '\u2A5A',
			ang: '\u2220',
			ange: '\u29A4',
			angle: '\u2220',
			angmsd: '\u2221',
			angmsdaa: '\u29A8',
			angmsdab: '\u29A9',
			angmsdac: '\u29AA',
			angmsdad: '\u29AB',
			angmsdae: '\u29AC',
			angmsdaf: '\u29AD',
			angmsdag: '\u29AE',
			angmsdah: '\u29AF',
			angrt: '\u221F',
			angrtvb: '\u22BE',
			angrtvbd: '\u299D',
			angsph: '\u2222',
			angst: '\xC5',
			angzarr: '\u237C',
			aogon: '\u0105',
			aopf: '\u{1D552}',
			ap: '\u2248',
			apE: '\u2A70',
			apacir: '\u2A6F',
			ape: '\u224A',
			apid: '\u224B',
			apos: "'",
			approx: '\u2248',
			approxeq: '\u224A',
			arin: '\xE5',
			aring: '\xE5',
			ascr: '\u{1D4B6}',
			ast: '*',
			asymp: '\u2248',
			asympeq: '\u224D',
			atild: '\xE3',
			atilde: '\xE3',
			aum: '\xE4',
			auml: '\xE4',
			awconint: '\u2233',
			awint: '\u2A11',
			bNot: '\u2AED',
			backcong: '\u224C',
			backepsilon: '\u03F6',
			backprime: '\u2035',
			backsim: '\u223D',
			backsimeq: '\u22CD',
			barvee: '\u22BD',
			barwed: '\u2305',
			barwedge: '\u2305',
			bbrk: '\u23B5',
			bbrktbrk: '\u23B6',
			bcong: '\u224C',
			bcy: '\u0431',
			bdquo: '\u201E',
			becaus: '\u2235',
			because: '\u2235',
			bemptyv: '\u29B0',
			bepsi: '\u03F6',
			bernou: '\u212C',
			beta: '\u03B2',
			beth: '\u2136',
			between: '\u226C',
			bfr: '\u{1D51F}',
			bigcap: '\u22C2',
			bigcirc: '\u25EF',
			bigcup: '\u22C3',
			bigodot: '\u2A00',
			bigoplus: '\u2A01',
			bigotimes: '\u2A02',
			bigsqcup: '\u2A06',
			bigstar: '\u2605',
			bigtriangledown: '\u25BD',
			bigtriangleup: '\u25B3',
			biguplus: '\u2A04',
			bigvee: '\u22C1',
			bigwedge: '\u22C0',
			bkarow: '\u290D',
			blacklozenge: '\u29EB',
			blacksquare: '\u25AA',
			blacktriangle: '\u25B4',
			blacktriangledown: '\u25BE',
			blacktriangleleft: '\u25C2',
			blacktriangleright: '\u25B8',
			blank: '\u2423',
			blk12: '\u2592',
			blk14: '\u2591',
			blk34: '\u2593',
			block: '\u2588',
			bne: '=\u20E5',
			bnequiv: '\u2261\u20E5',
			bnot: '\u2310',
			bopf: '\u{1D553}',
			bot: '\u22A5',
			bottom: '\u22A5',
			bowtie: '\u22C8',
			boxDL: '\u2557',
			boxDR: '\u2554',
			boxDl: '\u2556',
			boxDr: '\u2553',
			boxH: '\u2550',
			boxHD: '\u2566',
			boxHU: '\u2569',
			boxHd: '\u2564',
			boxHu: '\u2567',
			boxUL: '\u255D',
			boxUR: '\u255A',
			boxUl: '\u255C',
			boxUr: '\u2559',
			boxV: '\u2551',
			boxVH: '\u256C',
			boxVL: '\u2563',
			boxVR: '\u2560',
			boxVh: '\u256B',
			boxVl: '\u2562',
			boxVr: '\u255F',
			boxbox: '\u29C9',
			boxdL: '\u2555',
			boxdR: '\u2552',
			boxdl: '\u2510',
			boxdr: '\u250C',
			boxh: '\u2500',
			boxhD: '\u2565',
			boxhU: '\u2568',
			boxhd: '\u252C',
			boxhu: '\u2534',
			boxminus: '\u229F',
			boxplus: '\u229E',
			boxtimes: '\u22A0',
			boxuL: '\u255B',
			boxuR: '\u2558',
			boxul: '\u2518',
			boxur: '\u2514',
			boxv: '\u2502',
			boxvH: '\u256A',
			boxvL: '\u2561',
			boxvR: '\u255E',
			boxvh: '\u253C',
			boxvl: '\u2524',
			boxvr: '\u251C',
			bprime: '\u2035',
			breve: '\u02D8',
			brvba: '\xA6',
			brvbar: '\xA6',
			bscr: '\u{1D4B7}',
			bsemi: '\u204F',
			bsim: '\u223D',
			bsime: '\u22CD',
			bsol: '\\',
			bsolb: '\u29C5',
			bsolhsub: '\u27C8',
			bull: '\u2022',
			bullet: '\u2022',
			bump: '\u224E',
			bumpE: '\u2AAE',
			bumpe: '\u224F',
			bumpeq: '\u224F',
			cacute: '\u0107',
			cap: '\u2229',
			capand: '\u2A44',
			capbrcup: '\u2A49',
			capcap: '\u2A4B',
			capcup: '\u2A47',
			capdot: '\u2A40',
			caps: '\u2229\uFE00',
			caret: '\u2041',
			caron: '\u02C7',
			ccaps: '\u2A4D',
			ccaron: '\u010D',
			ccedi: '\xE7',
			ccedil: '\xE7',
			ccirc: '\u0109',
			ccups: '\u2A4C',
			ccupssm: '\u2A50',
			cdot: '\u010B',
			cedi: '\xB8',
			cedil: '\xB8',
			cemptyv: '\u29B2',
			cen: '\xA2',
			cent: '\xA2',
			centerdot: '\xB7',
			cfr: '\u{1D520}',
			chcy: '\u0447',
			check: '\u2713',
			checkmark: '\u2713',
			chi: '\u03C7',
			cir: '\u25CB',
			cirE: '\u29C3',
			circ: '\u02C6',
			circeq: '\u2257',
			circlearrowleft: '\u21BA',
			circlearrowright: '\u21BB',
			circledR: '\xAE',
			circledS: '\u24C8',
			circledast: '\u229B',
			circledcirc: '\u229A',
			circleddash: '\u229D',
			cire: '\u2257',
			cirfnint: '\u2A10',
			cirmid: '\u2AEF',
			cirscir: '\u29C2',
			clubs: '\u2663',
			clubsuit: '\u2663',
			colon: ':',
			colone: '\u2254',
			coloneq: '\u2254',
			comma: ',',
			commat: '@',
			comp: '\u2201',
			compfn: '\u2218',
			complement: '\u2201',
			complexes: '\u2102',
			cong: '\u2245',
			congdot: '\u2A6D',
			conint: '\u222E',
			copf: '\u{1D554}',
			coprod: '\u2210',
			cop: '\xA9',
			copy: '\xA9',
			copysr: '\u2117',
			crarr: '\u21B5',
			cross: '\u2717',
			cscr: '\u{1D4B8}',
			csub: '\u2ACF',
			csube: '\u2AD1',
			csup: '\u2AD0',
			csupe: '\u2AD2',
			ctdot: '\u22EF',
			cudarrl: '\u2938',
			cudarrr: '\u2935',
			cuepr: '\u22DE',
			cuesc: '\u22DF',
			cularr: '\u21B6',
			cularrp: '\u293D',
			cup: '\u222A',
			cupbrcap: '\u2A48',
			cupcap: '\u2A46',
			cupcup: '\u2A4A',
			cupdot: '\u228D',
			cupor: '\u2A45',
			cups: '\u222A\uFE00',
			curarr: '\u21B7',
			curarrm: '\u293C',
			curlyeqprec: '\u22DE',
			curlyeqsucc: '\u22DF',
			curlyvee: '\u22CE',
			curlywedge: '\u22CF',
			curre: '\xA4',
			curren: '\xA4',
			curvearrowleft: '\u21B6',
			curvearrowright: '\u21B7',
			cuvee: '\u22CE',
			cuwed: '\u22CF',
			cwconint: '\u2232',
			cwint: '\u2231',
			cylcty: '\u232D',
			dArr: '\u21D3',
			dHar: '\u2965',
			dagger: '\u2020',
			daleth: '\u2138',
			darr: '\u2193',
			dash: '\u2010',
			dashv: '\u22A3',
			dbkarow: '\u290F',
			dblac: '\u02DD',
			dcaron: '\u010F',
			dcy: '\u0434',
			dd: '\u2146',
			ddagger: '\u2021',
			ddarr: '\u21CA',
			ddotseq: '\u2A77',
			de: '\xB0',
			deg: '\xB0',
			delta: '\u03B4',
			demptyv: '\u29B1',
			dfisht: '\u297F',
			dfr: '\u{1D521}',
			dharl: '\u21C3',
			dharr: '\u21C2',
			diam: '\u22C4',
			diamond: '\u22C4',
			diamondsuit: '\u2666',
			diams: '\u2666',
			die: '\xA8',
			digamma: '\u03DD',
			disin: '\u22F2',
			div: '\xF7',
			divid: '\xF7',
			divide: '\xF7',
			divideontimes: '\u22C7',
			divonx: '\u22C7',
			djcy: '\u0452',
			dlcorn: '\u231E',
			dlcrop: '\u230D',
			dollar: '$',
			dopf: '\u{1D555}',
			dot: '\u02D9',
			doteq: '\u2250',
			doteqdot: '\u2251',
			dotminus: '\u2238',
			dotplus: '\u2214',
			dotsquare: '\u22A1',
			doublebarwedge: '\u2306',
			downarrow: '\u2193',
			downdownarrows: '\u21CA',
			downharpoonleft: '\u21C3',
			downharpoonright: '\u21C2',
			drbkarow: '\u2910',
			drcorn: '\u231F',
			drcrop: '\u230C',
			dscr: '\u{1D4B9}',
			dscy: '\u0455',
			dsol: '\u29F6',
			dstrok: '\u0111',
			dtdot: '\u22F1',
			dtri: '\u25BF',
			dtrif: '\u25BE',
			duarr: '\u21F5',
			duhar: '\u296F',
			dwangle: '\u29A6',
			dzcy: '\u045F',
			dzigrarr: '\u27FF',
			eDDot: '\u2A77',
			eDot: '\u2251',
			eacut: '\xE9',
			eacute: '\xE9',
			easter: '\u2A6E',
			ecaron: '\u011B',
			ecir: '\xEA',
			ecirc: '\xEA',
			ecolon: '\u2255',
			ecy: '\u044D',
			edot: '\u0117',
			ee: '\u2147',
			efDot: '\u2252',
			efr: '\u{1D522}',
			eg: '\u2A9A',
			egrav: '\xE8',
			egrave: '\xE8',
			egs: '\u2A96',
			egsdot: '\u2A98',
			el: '\u2A99',
			elinters: '\u23E7',
			ell: '\u2113',
			els: '\u2A95',
			elsdot: '\u2A97',
			emacr: '\u0113',
			empty: '\u2205',
			emptyset: '\u2205',
			emptyv: '\u2205',
			emsp13: '\u2004',
			emsp14: '\u2005',
			emsp: '\u2003',
			eng: '\u014B',
			ensp: '\u2002',
			eogon: '\u0119',
			eopf: '\u{1D556}',
			epar: '\u22D5',
			eparsl: '\u29E3',
			eplus: '\u2A71',
			epsi: '\u03B5',
			epsilon: '\u03B5',
			epsiv: '\u03F5',
			eqcirc: '\u2256',
			eqcolon: '\u2255',
			eqsim: '\u2242',
			eqslantgtr: '\u2A96',
			eqslantless: '\u2A95',
			equals: '=',
			equest: '\u225F',
			equiv: '\u2261',
			equivDD: '\u2A78',
			eqvparsl: '\u29E5',
			erDot: '\u2253',
			erarr: '\u2971',
			escr: '\u212F',
			esdot: '\u2250',
			esim: '\u2242',
			eta: '\u03B7',
			et: '\xF0',
			eth: '\xF0',
			eum: '\xEB',
			euml: '\xEB',
			euro: '\u20AC',
			excl: '!',
			exist: '\u2203',
			expectation: '\u2130',
			exponentiale: '\u2147',
			fallingdotseq: '\u2252',
			fcy: '\u0444',
			female: '\u2640',
			ffilig: '\uFB03',
			fflig: '\uFB00',
			ffllig: '\uFB04',
			ffr: '\u{1D523}',
			filig: '\uFB01',
			fjlig: 'fj',
			flat: '\u266D',
			fllig: '\uFB02',
			fltns: '\u25B1',
			fnof: '\u0192',
			fopf: '\u{1D557}',
			forall: '\u2200',
			fork: '\u22D4',
			forkv: '\u2AD9',
			fpartint: '\u2A0D',
			frac1: '\xBC',
			frac12: '\xBD',
			frac13: '\u2153',
			frac14: '\xBC',
			frac15: '\u2155',
			frac16: '\u2159',
			frac18: '\u215B',
			frac23: '\u2154',
			frac25: '\u2156',
			frac3: '\xBE',
			frac34: '\xBE',
			frac35: '\u2157',
			frac38: '\u215C',
			frac45: '\u2158',
			frac56: '\u215A',
			frac58: '\u215D',
			frac78: '\u215E',
			frasl: '\u2044',
			frown: '\u2322',
			fscr: '\u{1D4BB}',
			gE: '\u2267',
			gEl: '\u2A8C',
			gacute: '\u01F5',
			gamma: '\u03B3',
			gammad: '\u03DD',
			gap: '\u2A86',
			gbreve: '\u011F',
			gcirc: '\u011D',
			gcy: '\u0433',
			gdot: '\u0121',
			ge: '\u2265',
			gel: '\u22DB',
			geq: '\u2265',
			geqq: '\u2267',
			geqslant: '\u2A7E',
			ges: '\u2A7E',
			gescc: '\u2AA9',
			gesdot: '\u2A80',
			gesdoto: '\u2A82',
			gesdotol: '\u2A84',
			gesl: '\u22DB\uFE00',
			gesles: '\u2A94',
			gfr: '\u{1D524}',
			gg: '\u226B',
			ggg: '\u22D9',
			gimel: '\u2137',
			gjcy: '\u0453',
			gl: '\u2277',
			glE: '\u2A92',
			gla: '\u2AA5',
			glj: '\u2AA4',
			gnE: '\u2269',
			gnap: '\u2A8A',
			gnapprox: '\u2A8A',
			gne: '\u2A88',
			gneq: '\u2A88',
			gneqq: '\u2269',
			gnsim: '\u22E7',
			gopf: '\u{1D558}',
			grave: '`',
			gscr: '\u210A',
			gsim: '\u2273',
			gsime: '\u2A8E',
			gsiml: '\u2A90',
			g: '>',
			gt: '>',
			gtcc: '\u2AA7',
			gtcir: '\u2A7A',
			gtdot: '\u22D7',
			gtlPar: '\u2995',
			gtquest: '\u2A7C',
			gtrapprox: '\u2A86',
			gtrarr: '\u2978',
			gtrdot: '\u22D7',
			gtreqless: '\u22DB',
			gtreqqless: '\u2A8C',
			gtrless: '\u2277',
			gtrsim: '\u2273',
			gvertneqq: '\u2269\uFE00',
			gvnE: '\u2269\uFE00',
			hArr: '\u21D4',
			hairsp: '\u200A',
			half: '\xBD',
			hamilt: '\u210B',
			hardcy: '\u044A',
			harr: '\u2194',
			harrcir: '\u2948',
			harrw: '\u21AD',
			hbar: '\u210F',
			hcirc: '\u0125',
			hearts: '\u2665',
			heartsuit: '\u2665',
			hellip: '\u2026',
			hercon: '\u22B9',
			hfr: '\u{1D525}',
			hksearow: '\u2925',
			hkswarow: '\u2926',
			hoarr: '\u21FF',
			homtht: '\u223B',
			hookleftarrow: '\u21A9',
			hookrightarrow: '\u21AA',
			hopf: '\u{1D559}',
			horbar: '\u2015',
			hscr: '\u{1D4BD}',
			hslash: '\u210F',
			hstrok: '\u0127',
			hybull: '\u2043',
			hyphen: '\u2010',
			iacut: '\xED',
			iacute: '\xED',
			ic: '\u2063',
			icir: '\xEE',
			icirc: '\xEE',
			icy: '\u0438',
			iecy: '\u0435',
			iexc: '\xA1',
			iexcl: '\xA1',
			iff: '\u21D4',
			ifr: '\u{1D526}',
			igrav: '\xEC',
			igrave: '\xEC',
			ii: '\u2148',
			iiiint: '\u2A0C',
			iiint: '\u222D',
			iinfin: '\u29DC',
			iiota: '\u2129',
			ijlig: '\u0133',
			imacr: '\u012B',
			image: '\u2111',
			imagline: '\u2110',
			imagpart: '\u2111',
			imath: '\u0131',
			imof: '\u22B7',
			imped: '\u01B5',
			in: '\u2208',
			incare: '\u2105',
			infin: '\u221E',
			infintie: '\u29DD',
			inodot: '\u0131',
			int: '\u222B',
			intcal: '\u22BA',
			integers: '\u2124',
			intercal: '\u22BA',
			intlarhk: '\u2A17',
			intprod: '\u2A3C',
			iocy: '\u0451',
			iogon: '\u012F',
			iopf: '\u{1D55A}',
			iota: '\u03B9',
			iprod: '\u2A3C',
			iques: '\xBF',
			iquest: '\xBF',
			iscr: '\u{1D4BE}',
			isin: '\u2208',
			isinE: '\u22F9',
			isindot: '\u22F5',
			isins: '\u22F4',
			isinsv: '\u22F3',
			isinv: '\u2208',
			it: '\u2062',
			itilde: '\u0129',
			iukcy: '\u0456',
			ium: '\xEF',
			iuml: '\xEF',
			jcirc: '\u0135',
			jcy: '\u0439',
			jfr: '\u{1D527}',
			jmath: '\u0237',
			jopf: '\u{1D55B}',
			jscr: '\u{1D4BF}',
			jsercy: '\u0458',
			jukcy: '\u0454',
			kappa: '\u03BA',
			kappav: '\u03F0',
			kcedil: '\u0137',
			kcy: '\u043A',
			kfr: '\u{1D528}',
			kgreen: '\u0138',
			khcy: '\u0445',
			kjcy: '\u045C',
			kopf: '\u{1D55C}',
			kscr: '\u{1D4C0}',
			lAarr: '\u21DA',
			lArr: '\u21D0',
			lAtail: '\u291B',
			lBarr: '\u290E',
			lE: '\u2266',
			lEg: '\u2A8B',
			lHar: '\u2962',
			lacute: '\u013A',
			laemptyv: '\u29B4',
			lagran: '\u2112',
			lambda: '\u03BB',
			lang: '\u27E8',
			langd: '\u2991',
			langle: '\u27E8',
			lap: '\u2A85',
			laqu: '\xAB',
			laquo: '\xAB',
			larr: '\u2190',
			larrb: '\u21E4',
			larrbfs: '\u291F',
			larrfs: '\u291D',
			larrhk: '\u21A9',
			larrlp: '\u21AB',
			larrpl: '\u2939',
			larrsim: '\u2973',
			larrtl: '\u21A2',
			lat: '\u2AAB',
			latail: '\u2919',
			late: '\u2AAD',
			lates: '\u2AAD\uFE00',
			lbarr: '\u290C',
			lbbrk: '\u2772',
			lbrace: '{',
			lbrack: '[',
			lbrke: '\u298B',
			lbrksld: '\u298F',
			lbrkslu: '\u298D',
			lcaron: '\u013E',
			lcedil: '\u013C',
			lceil: '\u2308',
			lcub: '{',
			lcy: '\u043B',
			ldca: '\u2936',
			ldquo: '\u201C',
			ldquor: '\u201E',
			ldrdhar: '\u2967',
			ldrushar: '\u294B',
			ldsh: '\u21B2',
			le: '\u2264',
			leftarrow: '\u2190',
			leftarrowtail: '\u21A2',
			leftharpoondown: '\u21BD',
			leftharpoonup: '\u21BC',
			leftleftarrows: '\u21C7',
			leftrightarrow: '\u2194',
			leftrightarrows: '\u21C6',
			leftrightharpoons: '\u21CB',
			leftrightsquigarrow: '\u21AD',
			leftthreetimes: '\u22CB',
			leg: '\u22DA',
			leq: '\u2264',
			leqq: '\u2266',
			leqslant: '\u2A7D',
			les: '\u2A7D',
			lescc: '\u2AA8',
			lesdot: '\u2A7F',
			lesdoto: '\u2A81',
			lesdotor: '\u2A83',
			lesg: '\u22DA\uFE00',
			lesges: '\u2A93',
			lessapprox: '\u2A85',
			lessdot: '\u22D6',
			lesseqgtr: '\u22DA',
			lesseqqgtr: '\u2A8B',
			lessgtr: '\u2276',
			lesssim: '\u2272',
			lfisht: '\u297C',
			lfloor: '\u230A',
			lfr: '\u{1D529}',
			lg: '\u2276',
			lgE: '\u2A91',
			lhard: '\u21BD',
			lharu: '\u21BC',
			lharul: '\u296A',
			lhblk: '\u2584',
			ljcy: '\u0459',
			ll: '\u226A',
			llarr: '\u21C7',
			llcorner: '\u231E',
			llhard: '\u296B',
			lltri: '\u25FA',
			lmidot: '\u0140',
			lmoust: '\u23B0',
			lmoustache: '\u23B0',
			lnE: '\u2268',
			lnap: '\u2A89',
			lnapprox: '\u2A89',
			lne: '\u2A87',
			lneq: '\u2A87',
			lneqq: '\u2268',
			lnsim: '\u22E6',
			loang: '\u27EC',
			loarr: '\u21FD',
			lobrk: '\u27E6',
			longleftarrow: '\u27F5',
			longleftrightarrow: '\u27F7',
			longmapsto: '\u27FC',
			longrightarrow: '\u27F6',
			looparrowleft: '\u21AB',
			looparrowright: '\u21AC',
			lopar: '\u2985',
			lopf: '\u{1D55D}',
			loplus: '\u2A2D',
			lotimes: '\u2A34',
			lowast: '\u2217',
			lowbar: '_',
			loz: '\u25CA',
			lozenge: '\u25CA',
			lozf: '\u29EB',
			lpar: '(',
			lparlt: '\u2993',
			lrarr: '\u21C6',
			lrcorner: '\u231F',
			lrhar: '\u21CB',
			lrhard: '\u296D',
			lrm: '\u200E',
			lrtri: '\u22BF',
			lsaquo: '\u2039',
			lscr: '\u{1D4C1}',
			lsh: '\u21B0',
			lsim: '\u2272',
			lsime: '\u2A8D',
			lsimg: '\u2A8F',
			lsqb: '[',
			lsquo: '\u2018',
			lsquor: '\u201A',
			lstrok: '\u0142',
			l: '<',
			lt: '<',
			ltcc: '\u2AA6',
			ltcir: '\u2A79',
			ltdot: '\u22D6',
			lthree: '\u22CB',
			ltimes: '\u22C9',
			ltlarr: '\u2976',
			ltquest: '\u2A7B',
			ltrPar: '\u2996',
			ltri: '\u25C3',
			ltrie: '\u22B4',
			ltrif: '\u25C2',
			lurdshar: '\u294A',
			luruhar: '\u2966',
			lvertneqq: '\u2268\uFE00',
			lvnE: '\u2268\uFE00',
			mDDot: '\u223A',
			mac: '\xAF',
			macr: '\xAF',
			male: '\u2642',
			malt: '\u2720',
			maltese: '\u2720',
			map: '\u21A6',
			mapsto: '\u21A6',
			mapstodown: '\u21A7',
			mapstoleft: '\u21A4',
			mapstoup: '\u21A5',
			marker: '\u25AE',
			mcomma: '\u2A29',
			mcy: '\u043C',
			mdash: '\u2014',
			measuredangle: '\u2221',
			mfr: '\u{1D52A}',
			mho: '\u2127',
			micr: '\xB5',
			micro: '\xB5',
			mid: '\u2223',
			midast: '*',
			midcir: '\u2AF0',
			middo: '\xB7',
			middot: '\xB7',
			minus: '\u2212',
			minusb: '\u229F',
			minusd: '\u2238',
			minusdu: '\u2A2A',
			mlcp: '\u2ADB',
			mldr: '\u2026',
			mnplus: '\u2213',
			models: '\u22A7',
			mopf: '\u{1D55E}',
			mp: '\u2213',
			mscr: '\u{1D4C2}',
			mstpos: '\u223E',
			mu: '\u03BC',
			multimap: '\u22B8',
			mumap: '\u22B8',
			nGg: '\u22D9\u0338',
			nGt: '\u226B\u20D2',
			nGtv: '\u226B\u0338',
			nLeftarrow: '\u21CD',
			nLeftrightarrow: '\u21CE',
			nLl: '\u22D8\u0338',
			nLt: '\u226A\u20D2',
			nLtv: '\u226A\u0338',
			nRightarrow: '\u21CF',
			nVDash: '\u22AF',
			nVdash: '\u22AE',
			nabla: '\u2207',
			nacute: '\u0144',
			nang: '\u2220\u20D2',
			nap: '\u2249',
			napE: '\u2A70\u0338',
			napid: '\u224B\u0338',
			napos: '\u0149',
			napprox: '\u2249',
			natur: '\u266E',
			natural: '\u266E',
			naturals: '\u2115',
			nbs: '\xA0',
			nbsp: '\xA0',
			nbump: '\u224E\u0338',
			nbumpe: '\u224F\u0338',
			ncap: '\u2A43',
			ncaron: '\u0148',
			ncedil: '\u0146',
			ncong: '\u2247',
			ncongdot: '\u2A6D\u0338',
			ncup: '\u2A42',
			ncy: '\u043D',
			ndash: '\u2013',
			ne: '\u2260',
			neArr: '\u21D7',
			nearhk: '\u2924',
			nearr: '\u2197',
			nearrow: '\u2197',
			nedot: '\u2250\u0338',
			nequiv: '\u2262',
			nesear: '\u2928',
			nesim: '\u2242\u0338',
			nexist: '\u2204',
			nexists: '\u2204',
			nfr: '\u{1D52B}',
			ngE: '\u2267\u0338',
			nge: '\u2271',
			ngeq: '\u2271',
			ngeqq: '\u2267\u0338',
			ngeqslant: '\u2A7E\u0338',
			nges: '\u2A7E\u0338',
			ngsim: '\u2275',
			ngt: '\u226F',
			ngtr: '\u226F',
			nhArr: '\u21CE',
			nharr: '\u21AE',
			nhpar: '\u2AF2',
			ni: '\u220B',
			nis: '\u22FC',
			nisd: '\u22FA',
			niv: '\u220B',
			njcy: '\u045A',
			nlArr: '\u21CD',
			nlE: '\u2266\u0338',
			nlarr: '\u219A',
			nldr: '\u2025',
			nle: '\u2270',
			nleftarrow: '\u219A',
			nleftrightarrow: '\u21AE',
			nleq: '\u2270',
			nleqq: '\u2266\u0338',
			nleqslant: '\u2A7D\u0338',
			nles: '\u2A7D\u0338',
			nless: '\u226E',
			nlsim: '\u2274',
			nlt: '\u226E',
			nltri: '\u22EA',
			nltrie: '\u22EC',
			nmid: '\u2224',
			nopf: '\u{1D55F}',
			no: '\xAC',
			not: '\xAC',
			notin: '\u2209',
			notinE: '\u22F9\u0338',
			notindot: '\u22F5\u0338',
			notinva: '\u2209',
			notinvb: '\u22F7',
			notinvc: '\u22F6',
			notni: '\u220C',
			notniva: '\u220C',
			notnivb: '\u22FE',
			notnivc: '\u22FD',
			npar: '\u2226',
			nparallel: '\u2226',
			nparsl: '\u2AFD\u20E5',
			npart: '\u2202\u0338',
			npolint: '\u2A14',
			npr: '\u2280',
			nprcue: '\u22E0',
			npre: '\u2AAF\u0338',
			nprec: '\u2280',
			npreceq: '\u2AAF\u0338',
			nrArr: '\u21CF',
			nrarr: '\u219B',
			nrarrc: '\u2933\u0338',
			nrarrw: '\u219D\u0338',
			nrightarrow: '\u219B',
			nrtri: '\u22EB',
			nrtrie: '\u22ED',
			nsc: '\u2281',
			nsccue: '\u22E1',
			nsce: '\u2AB0\u0338',
			nscr: '\u{1D4C3}',
			nshortmid: '\u2224',
			nshortparallel: '\u2226',
			nsim: '\u2241',
			nsime: '\u2244',
			nsimeq: '\u2244',
			nsmid: '\u2224',
			nspar: '\u2226',
			nsqsube: '\u22E2',
			nsqsupe: '\u22E3',
			nsub: '\u2284',
			nsubE: '\u2AC5\u0338',
			nsube: '\u2288',
			nsubset: '\u2282\u20D2',
			nsubseteq: '\u2288',
			nsubseteqq: '\u2AC5\u0338',
			nsucc: '\u2281',
			nsucceq: '\u2AB0\u0338',
			nsup: '\u2285',
			nsupE: '\u2AC6\u0338',
			nsupe: '\u2289',
			nsupset: '\u2283\u20D2',
			nsupseteq: '\u2289',
			nsupseteqq: '\u2AC6\u0338',
			ntgl: '\u2279',
			ntild: '\xF1',
			ntilde: '\xF1',
			ntlg: '\u2278',
			ntriangleleft: '\u22EA',
			ntrianglelefteq: '\u22EC',
			ntriangleright: '\u22EB',
			ntrianglerighteq: '\u22ED',
			nu: '\u03BD',
			num: '#',
			numero: '\u2116',
			numsp: '\u2007',
			nvDash: '\u22AD',
			nvHarr: '\u2904',
			nvap: '\u224D\u20D2',
			nvdash: '\u22AC',
			nvge: '\u2265\u20D2',
			nvgt: '>\u20D2',
			nvinfin: '\u29DE',
			nvlArr: '\u2902',
			nvle: '\u2264\u20D2',
			nvlt: '<\u20D2',
			nvltrie: '\u22B4\u20D2',
			nvrArr: '\u2903',
			nvrtrie: '\u22B5\u20D2',
			nvsim: '\u223C\u20D2',
			nwArr: '\u21D6',
			nwarhk: '\u2923',
			nwarr: '\u2196',
			nwarrow: '\u2196',
			nwnear: '\u2927',
			oS: '\u24C8',
			oacut: '\xF3',
			oacute: '\xF3',
			oast: '\u229B',
			ocir: '\xF4',
			ocirc: '\xF4',
			ocy: '\u043E',
			odash: '\u229D',
			odblac: '\u0151',
			odiv: '\u2A38',
			odot: '\u2299',
			odsold: '\u29BC',
			oelig: '\u0153',
			ofcir: '\u29BF',
			ofr: '\u{1D52C}',
			ogon: '\u02DB',
			ograv: '\xF2',
			ograve: '\xF2',
			ogt: '\u29C1',
			ohbar: '\u29B5',
			ohm: '\u03A9',
			oint: '\u222E',
			olarr: '\u21BA',
			olcir: '\u29BE',
			olcross: '\u29BB',
			oline: '\u203E',
			olt: '\u29C0',
			omacr: '\u014D',
			omega: '\u03C9',
			omicron: '\u03BF',
			omid: '\u29B6',
			ominus: '\u2296',
			oopf: '\u{1D560}',
			opar: '\u29B7',
			operp: '\u29B9',
			oplus: '\u2295',
			or: '\u2228',
			orarr: '\u21BB',
			ord: '\xBA',
			order: '\u2134',
			orderof: '\u2134',
			ordf: '\xAA',
			ordm: '\xBA',
			origof: '\u22B6',
			oror: '\u2A56',
			orslope: '\u2A57',
			orv: '\u2A5B',
			oscr: '\u2134',
			oslas: '\xF8',
			oslash: '\xF8',
			osol: '\u2298',
			otild: '\xF5',
			otilde: '\xF5',
			otimes: '\u2297',
			otimesas: '\u2A36',
			oum: '\xF6',
			ouml: '\xF6',
			ovbar: '\u233D',
			par: '\xB6',
			para: '\xB6',
			parallel: '\u2225',
			parsim: '\u2AF3',
			parsl: '\u2AFD',
			part: '\u2202',
			pcy: '\u043F',
			percnt: '%',
			period: '.',
			permil: '\u2030',
			perp: '\u22A5',
			pertenk: '\u2031',
			pfr: '\u{1D52D}',
			phi: '\u03C6',
			phiv: '\u03D5',
			phmmat: '\u2133',
			phone: '\u260E',
			pi: '\u03C0',
			pitchfork: '\u22D4',
			piv: '\u03D6',
			planck: '\u210F',
			planckh: '\u210E',
			plankv: '\u210F',
			plus: '+',
			plusacir: '\u2A23',
			plusb: '\u229E',
			pluscir: '\u2A22',
			plusdo: '\u2214',
			plusdu: '\u2A25',
			pluse: '\u2A72',
			plusm: '\xB1',
			plusmn: '\xB1',
			plussim: '\u2A26',
			plustwo: '\u2A27',
			pm: '\xB1',
			pointint: '\u2A15',
			popf: '\u{1D561}',
			poun: '\xA3',
			pound: '\xA3',
			pr: '\u227A',
			prE: '\u2AB3',
			prap: '\u2AB7',
			prcue: '\u227C',
			pre: '\u2AAF',
			prec: '\u227A',
			precapprox: '\u2AB7',
			preccurlyeq: '\u227C',
			preceq: '\u2AAF',
			precnapprox: '\u2AB9',
			precneqq: '\u2AB5',
			precnsim: '\u22E8',
			precsim: '\u227E',
			prime: '\u2032',
			primes: '\u2119',
			prnE: '\u2AB5',
			prnap: '\u2AB9',
			prnsim: '\u22E8',
			prod: '\u220F',
			profalar: '\u232E',
			profline: '\u2312',
			profsurf: '\u2313',
			prop: '\u221D',
			propto: '\u221D',
			prsim: '\u227E',
			prurel: '\u22B0',
			pscr: '\u{1D4C5}',
			psi: '\u03C8',
			puncsp: '\u2008',
			qfr: '\u{1D52E}',
			qint: '\u2A0C',
			qopf: '\u{1D562}',
			qprime: '\u2057',
			qscr: '\u{1D4C6}',
			quaternions: '\u210D',
			quatint: '\u2A16',
			quest: '?',
			questeq: '\u225F',
			quo: '"',
			quot: '"',
			rAarr: '\u21DB',
			rArr: '\u21D2',
			rAtail: '\u291C',
			rBarr: '\u290F',
			rHar: '\u2964',
			race: '\u223D\u0331',
			racute: '\u0155',
			radic: '\u221A',
			raemptyv: '\u29B3',
			rang: '\u27E9',
			rangd: '\u2992',
			range: '\u29A5',
			rangle: '\u27E9',
			raqu: '\xBB',
			raquo: '\xBB',
			rarr: '\u2192',
			rarrap: '\u2975',
			rarrb: '\u21E5',
			rarrbfs: '\u2920',
			rarrc: '\u2933',
			rarrfs: '\u291E',
			rarrhk: '\u21AA',
			rarrlp: '\u21AC',
			rarrpl: '\u2945',
			rarrsim: '\u2974',
			rarrtl: '\u21A3',
			rarrw: '\u219D',
			ratail: '\u291A',
			ratio: '\u2236',
			rationals: '\u211A',
			rbarr: '\u290D',
			rbbrk: '\u2773',
			rbrace: '}',
			rbrack: ']',
			rbrke: '\u298C',
			rbrksld: '\u298E',
			rbrkslu: '\u2990',
			rcaron: '\u0159',
			rcedil: '\u0157',
			rceil: '\u2309',
			rcub: '}',
			rcy: '\u0440',
			rdca: '\u2937',
			rdldhar: '\u2969',
			rdquo: '\u201D',
			rdquor: '\u201D',
			rdsh: '\u21B3',
			real: '\u211C',
			realine: '\u211B',
			realpart: '\u211C',
			reals: '\u211D',
			rect: '\u25AD',
			re: '\xAE',
			reg: '\xAE',
			rfisht: '\u297D',
			rfloor: '\u230B',
			rfr: '\u{1D52F}',
			rhard: '\u21C1',
			rharu: '\u21C0',
			rharul: '\u296C',
			rho: '\u03C1',
			rhov: '\u03F1',
			rightarrow: '\u2192',
			rightarrowtail: '\u21A3',
			rightharpoondown: '\u21C1',
			rightharpoonup: '\u21C0',
			rightleftarrows: '\u21C4',
			rightleftharpoons: '\u21CC',
			rightrightarrows: '\u21C9',
			rightsquigarrow: '\u219D',
			rightthreetimes: '\u22CC',
			ring: '\u02DA',
			risingdotseq: '\u2253',
			rlarr: '\u21C4',
			rlhar: '\u21CC',
			rlm: '\u200F',
			rmoust: '\u23B1',
			rmoustache: '\u23B1',
			rnmid: '\u2AEE',
			roang: '\u27ED',
			roarr: '\u21FE',
			robrk: '\u27E7',
			ropar: '\u2986',
			ropf: '\u{1D563}',
			roplus: '\u2A2E',
			rotimes: '\u2A35',
			rpar: ')',
			rpargt: '\u2994',
			rppolint: '\u2A12',
			rrarr: '\u21C9',
			rsaquo: '\u203A',
			rscr: '\u{1D4C7}',
			rsh: '\u21B1',
			rsqb: ']',
			rsquo: '\u2019',
			rsquor: '\u2019',
			rthree: '\u22CC',
			rtimes: '\u22CA',
			rtri: '\u25B9',
			rtrie: '\u22B5',
			rtrif: '\u25B8',
			rtriltri: '\u29CE',
			ruluhar: '\u2968',
			rx: '\u211E',
			sacute: '\u015B',
			sbquo: '\u201A',
			sc: '\u227B',
			scE: '\u2AB4',
			scap: '\u2AB8',
			scaron: '\u0161',
			sccue: '\u227D',
			sce: '\u2AB0',
			scedil: '\u015F',
			scirc: '\u015D',
			scnE: '\u2AB6',
			scnap: '\u2ABA',
			scnsim: '\u22E9',
			scpolint: '\u2A13',
			scsim: '\u227F',
			scy: '\u0441',
			sdot: '\u22C5',
			sdotb: '\u22A1',
			sdote: '\u2A66',
			seArr: '\u21D8',
			searhk: '\u2925',
			searr: '\u2198',
			searrow: '\u2198',
			sec: '\xA7',
			sect: '\xA7',
			semi: ';',
			seswar: '\u2929',
			setminus: '\u2216',
			setmn: '\u2216',
			sext: '\u2736',
			sfr: '\u{1D530}',
			sfrown: '\u2322',
			sharp: '\u266F',
			shchcy: '\u0449',
			shcy: '\u0448',
			shortmid: '\u2223',
			shortparallel: '\u2225',
			sh: '\xAD',
			shy: '\xAD',
			sigma: '\u03C3',
			sigmaf: '\u03C2',
			sigmav: '\u03C2',
			sim: '\u223C',
			simdot: '\u2A6A',
			sime: '\u2243',
			simeq: '\u2243',
			simg: '\u2A9E',
			simgE: '\u2AA0',
			siml: '\u2A9D',
			simlE: '\u2A9F',
			simne: '\u2246',
			simplus: '\u2A24',
			simrarr: '\u2972',
			slarr: '\u2190',
			smallsetminus: '\u2216',
			smashp: '\u2A33',
			smeparsl: '\u29E4',
			smid: '\u2223',
			smile: '\u2323',
			smt: '\u2AAA',
			smte: '\u2AAC',
			smtes: '\u2AAC\uFE00',
			softcy: '\u044C',
			sol: '/',
			solb: '\u29C4',
			solbar: '\u233F',
			sopf: '\u{1D564}',
			spades: '\u2660',
			spadesuit: '\u2660',
			spar: '\u2225',
			sqcap: '\u2293',
			sqcaps: '\u2293\uFE00',
			sqcup: '\u2294',
			sqcups: '\u2294\uFE00',
			sqsub: '\u228F',
			sqsube: '\u2291',
			sqsubset: '\u228F',
			sqsubseteq: '\u2291',
			sqsup: '\u2290',
			sqsupe: '\u2292',
			sqsupset: '\u2290',
			sqsupseteq: '\u2292',
			squ: '\u25A1',
			square: '\u25A1',
			squarf: '\u25AA',
			squf: '\u25AA',
			srarr: '\u2192',
			sscr: '\u{1D4C8}',
			ssetmn: '\u2216',
			ssmile: '\u2323',
			sstarf: '\u22C6',
			star: '\u2606',
			starf: '\u2605',
			straightepsilon: '\u03F5',
			straightphi: '\u03D5',
			strns: '\xAF',
			sub: '\u2282',
			subE: '\u2AC5',
			subdot: '\u2ABD',
			sube: '\u2286',
			subedot: '\u2AC3',
			submult: '\u2AC1',
			subnE: '\u2ACB',
			subne: '\u228A',
			subplus: '\u2ABF',
			subrarr: '\u2979',
			subset: '\u2282',
			subseteq: '\u2286',
			subseteqq: '\u2AC5',
			subsetneq: '\u228A',
			subsetneqq: '\u2ACB',
			subsim: '\u2AC7',
			subsub: '\u2AD5',
			subsup: '\u2AD3',
			succ: '\u227B',
			succapprox: '\u2AB8',
			succcurlyeq: '\u227D',
			succeq: '\u2AB0',
			succnapprox: '\u2ABA',
			succneqq: '\u2AB6',
			succnsim: '\u22E9',
			succsim: '\u227F',
			sum: '\u2211',
			sung: '\u266A',
			sup: '\u2283',
			sup1: '\xB9',
			sup2: '\xB2',
			sup3: '\xB3',
			supE: '\u2AC6',
			supdot: '\u2ABE',
			supdsub: '\u2AD8',
			supe: '\u2287',
			supedot: '\u2AC4',
			suphsol: '\u27C9',
			suphsub: '\u2AD7',
			suplarr: '\u297B',
			supmult: '\u2AC2',
			supnE: '\u2ACC',
			supne: '\u228B',
			supplus: '\u2AC0',
			supset: '\u2283',
			supseteq: '\u2287',
			supseteqq: '\u2AC6',
			supsetneq: '\u228B',
			supsetneqq: '\u2ACC',
			supsim: '\u2AC8',
			supsub: '\u2AD4',
			supsup: '\u2AD6',
			swArr: '\u21D9',
			swarhk: '\u2926',
			swarr: '\u2199',
			swarrow: '\u2199',
			swnwar: '\u292A',
			szli: '\xDF',
			szlig: '\xDF',
			target: '\u2316',
			tau: '\u03C4',
			tbrk: '\u23B4',
			tcaron: '\u0165',
			tcedil: '\u0163',
			tcy: '\u0442',
			tdot: '\u20DB',
			telrec: '\u2315',
			tfr: '\u{1D531}',
			there4: '\u2234',
			therefore: '\u2234',
			theta: '\u03B8',
			thetasym: '\u03D1',
			thetav: '\u03D1',
			thickapprox: '\u2248',
			thicksim: '\u223C',
			thinsp: '\u2009',
			thkap: '\u2248',
			thksim: '\u223C',
			thor: '\xFE',
			thorn: '\xFE',
			tilde: '\u02DC',
			time: '\xD7',
			times: '\xD7',
			timesb: '\u22A0',
			timesbar: '\u2A31',
			timesd: '\u2A30',
			tint: '\u222D',
			toea: '\u2928',
			top: '\u22A4',
			topbot: '\u2336',
			topcir: '\u2AF1',
			topf: '\u{1D565}',
			topfork: '\u2ADA',
			tosa: '\u2929',
			tprime: '\u2034',
			trade: '\u2122',
			triangle: '\u25B5',
			triangledown: '\u25BF',
			triangleleft: '\u25C3',
			trianglelefteq: '\u22B4',
			triangleq: '\u225C',
			triangleright: '\u25B9',
			trianglerighteq: '\u22B5',
			tridot: '\u25EC',
			trie: '\u225C',
			triminus: '\u2A3A',
			triplus: '\u2A39',
			trisb: '\u29CD',
			tritime: '\u2A3B',
			trpezium: '\u23E2',
			tscr: '\u{1D4C9}',
			tscy: '\u0446',
			tshcy: '\u045B',
			tstrok: '\u0167',
			twixt: '\u226C',
			twoheadleftarrow: '\u219E',
			twoheadrightarrow: '\u21A0',
			uArr: '\u21D1',
			uHar: '\u2963',
			uacut: '\xFA',
			uacute: '\xFA',
			uarr: '\u2191',
			ubrcy: '\u045E',
			ubreve: '\u016D',
			ucir: '\xFB',
			ucirc: '\xFB',
			ucy: '\u0443',
			udarr: '\u21C5',
			udblac: '\u0171',
			udhar: '\u296E',
			ufisht: '\u297E',
			ufr: '\u{1D532}',
			ugrav: '\xF9',
			ugrave: '\xF9',
			uharl: '\u21BF',
			uharr: '\u21BE',
			uhblk: '\u2580',
			ulcorn: '\u231C',
			ulcorner: '\u231C',
			ulcrop: '\u230F',
			ultri: '\u25F8',
			umacr: '\u016B',
			um: '\xA8',
			uml: '\xA8',
			uogon: '\u0173',
			uopf: '\u{1D566}',
			uparrow: '\u2191',
			updownarrow: '\u2195',
			upharpoonleft: '\u21BF',
			upharpoonright: '\u21BE',
			uplus: '\u228E',
			upsi: '\u03C5',
			upsih: '\u03D2',
			upsilon: '\u03C5',
			upuparrows: '\u21C8',
			urcorn: '\u231D',
			urcorner: '\u231D',
			urcrop: '\u230E',
			uring: '\u016F',
			urtri: '\u25F9',
			uscr: '\u{1D4CA}',
			utdot: '\u22F0',
			utilde: '\u0169',
			utri: '\u25B5',
			utrif: '\u25B4',
			uuarr: '\u21C8',
			uum: '\xFC',
			uuml: '\xFC',
			uwangle: '\u29A7',
			vArr: '\u21D5',
			vBar: '\u2AE8',
			vBarv: '\u2AE9',
			vDash: '\u22A8',
			vangrt: '\u299C',
			varepsilon: '\u03F5',
			varkappa: '\u03F0',
			varnothing: '\u2205',
			varphi: '\u03D5',
			varpi: '\u03D6',
			varpropto: '\u221D',
			varr: '\u2195',
			varrho: '\u03F1',
			varsigma: '\u03C2',
			varsubsetneq: '\u228A\uFE00',
			varsubsetneqq: '\u2ACB\uFE00',
			varsupsetneq: '\u228B\uFE00',
			varsupsetneqq: '\u2ACC\uFE00',
			vartheta: '\u03D1',
			vartriangleleft: '\u22B2',
			vartriangleright: '\u22B3',
			vcy: '\u0432',
			vdash: '\u22A2',
			vee: '\u2228',
			veebar: '\u22BB',
			veeeq: '\u225A',
			vellip: '\u22EE',
			verbar: '|',
			vert: '|',
			vfr: '\u{1D533}',
			vltri: '\u22B2',
			vnsub: '\u2282\u20D2',
			vnsup: '\u2283\u20D2',
			vopf: '\u{1D567}',
			vprop: '\u221D',
			vrtri: '\u22B3',
			vscr: '\u{1D4CB}',
			vsubnE: '\u2ACB\uFE00',
			vsubne: '\u228A\uFE00',
			vsupnE: '\u2ACC\uFE00',
			vsupne: '\u228B\uFE00',
			vzigzag: '\u299A',
			wcirc: '\u0175',
			wedbar: '\u2A5F',
			wedge: '\u2227',
			wedgeq: '\u2259',
			weierp: '\u2118',
			wfr: '\u{1D534}',
			wopf: '\u{1D568}',
			wp: '\u2118',
			wr: '\u2240',
			wreath: '\u2240',
			wscr: '\u{1D4CC}',
			xcap: '\u22C2',
			xcirc: '\u25EF',
			xcup: '\u22C3',
			xdtri: '\u25BD',
			xfr: '\u{1D535}',
			xhArr: '\u27FA',
			xharr: '\u27F7',
			xi: '\u03BE',
			xlArr: '\u27F8',
			xlarr: '\u27F5',
			xmap: '\u27FC',
			xnis: '\u22FB',
			xodot: '\u2A00',
			xopf: '\u{1D569}',
			xoplus: '\u2A01',
			xotime: '\u2A02',
			xrArr: '\u27F9',
			xrarr: '\u27F6',
			xscr: '\u{1D4CD}',
			xsqcup: '\u2A06',
			xuplus: '\u2A04',
			xutri: '\u25B3',
			xvee: '\u22C1',
			xwedge: '\u22C0',
			yacut: '\xFD',
			yacute: '\xFD',
			yacy: '\u044F',
			ycirc: '\u0177',
			ycy: '\u044B',
			ye: '\xA5',
			yen: '\xA5',
			yfr: '\u{1D536}',
			yicy: '\u0457',
			yopf: '\u{1D56A}',
			yscr: '\u{1D4CE}',
			yucy: '\u044E',
			yum: '\xFF',
			yuml: '\xFF',
			zacute: '\u017A',
			zcaron: '\u017E',
			zcy: '\u0437',
			zdot: '\u017C',
			zeetrf: '\u2128',
			zeta: '\u03B6',
			zfr: '\u{1D537}',
			zhcy: '\u0436',
			zigrarr: '\u21DD',
			zopf: '\u{1D56B}',
			zscr: '\u{1D4CF}',
			zwj: '\u200D',
			zwnj: '\u200C'
		};
	}
});

// node_modules/parse-entities/decode-entity.js
var require_decode_entity = __commonJS({
	'node_modules/parse-entities/decode-entity.js'(exports, module2) {
		'use strict';
		var characterEntities2 = require_character_entities();
		module2.exports = decodeEntity;
		var own16 = {}.hasOwnProperty;
		function decodeEntity(characters2) {
			return own16.call(characterEntities2, characters2) ? characterEntities2[characters2] : false;
		}
	}
});

// node_modules/parse-entities/index.js
var require_parse_entities = __commonJS({
	'node_modules/parse-entities/index.js'(exports, module2) {
		'use strict';
		var legacy = require_character_entities_legacy();
		var invalid2 = require_character_reference_invalid();
		var decimal = require_is_decimal();
		var hexadecimal = require_is_hexadecimal();
		var alphanumerical = require_is_alphanumerical();
		var decodeEntity = require_decode_entity();
		module2.exports = parseEntities;
		var own16 = {}.hasOwnProperty;
		var fromCharCode = String.fromCharCode;
		var noop3 = Function.prototype;
		var defaults = {
			warning: null,
			reference: null,
			text: null,
			warningContext: null,
			referenceContext: null,
			textContext: null,
			position: {},
			additional: null,
			attribute: false,
			nonTerminated: true
		};
		var tab = 9;
		var lineFeed = 10;
		var formFeed = 12;
		var space = 32;
		var ampersand = 38;
		var semicolon = 59;
		var lessThan = 60;
		var equalsTo = 61;
		var numberSign = 35;
		var uppercaseX = 88;
		var lowercaseX = 120;
		var replacementCharacter = 65533;
		var name = 'named';
		var hexa = 'hexadecimal';
		var deci = 'decimal';
		var bases = {};
		bases[hexa] = 16;
		bases[deci] = 10;
		var tests = {};
		tests[name] = alphanumerical;
		tests[deci] = decimal;
		tests[hexa] = hexadecimal;
		var namedNotTerminated = 1;
		var numericNotTerminated = 2;
		var namedEmpty = 3;
		var numericEmpty = 4;
		var namedUnknown = 5;
		var numericDisallowed = 6;
		var numericProhibited = 7;
		var messages = {};
		messages[namedNotTerminated] = 'Named character references must be terminated by a semicolon';
		messages[numericNotTerminated] =
			'Numeric character references must be terminated by a semicolon';
		messages[namedEmpty] = 'Named character references cannot be empty';
		messages[numericEmpty] = 'Numeric character references cannot be empty';
		messages[namedUnknown] = 'Named character references must be known';
		messages[numericDisallowed] = 'Numeric character references cannot be disallowed';
		messages[numericProhibited] =
			'Numeric character references cannot be outside the permissible Unicode range';
		function parseEntities(value, options) {
			var settings = {};
			var option2;
			var key3;
			if (!options) {
				options = {};
			}
			for (key3 in defaults) {
				option2 = options[key3];
				settings[key3] = option2 === null || option2 === void 0 ? defaults[key3] : option2;
			}
			if (settings.position.indent || settings.position.start) {
				settings.indent = settings.position.indent || [];
				settings.position = settings.position.start;
			}
			return parse6(value, settings);
		}
		function parse6(value, settings) {
			var additional = settings.additional;
			var nonTerminated = settings.nonTerminated;
			var handleText = settings.text;
			var handleReference = settings.reference;
			var handleWarning = settings.warning;
			var textContext = settings.textContext;
			var referenceContext = settings.referenceContext;
			var warningContext = settings.warningContext;
			var pos = settings.position;
			var indent = settings.indent || [];
			var length = value.length;
			var index6 = 0;
			var lines = -1;
			var column = pos.column || 1;
			var line = pos.line || 1;
			var queue = '';
			var result = [];
			var entityCharacters;
			var namedEntity;
			var terminated;
			var characters2;
			var character;
			var reference;
			var following;
			var warning;
			var reason;
			var output;
			var entity;
			var begin;
			var start;
			var type;
			var test;
			var prev;
			var next;
			var diff;
			var end;
			if (typeof additional === 'string') {
				additional = additional.charCodeAt(0);
			}
			prev = now();
			warning = handleWarning ? parseError : noop3;
			index6--;
			length++;
			while (++index6 < length) {
				if (character === lineFeed) {
					column = indent[lines] || 1;
				}
				character = value.charCodeAt(index6);
				if (character === ampersand) {
					following = value.charCodeAt(index6 + 1);
					if (
						following === tab ||
						following === lineFeed ||
						following === formFeed ||
						following === space ||
						following === ampersand ||
						following === lessThan ||
						following !== following ||
						(additional && following === additional)
					) {
						queue += fromCharCode(character);
						column++;
						continue;
					}
					start = index6 + 1;
					begin = start;
					end = start;
					if (following === numberSign) {
						end = ++begin;
						following = value.charCodeAt(end);
						if (following === uppercaseX || following === lowercaseX) {
							type = hexa;
							end = ++begin;
						} else {
							type = deci;
						}
					} else {
						type = name;
					}
					entityCharacters = '';
					entity = '';
					characters2 = '';
					test = tests[type];
					end--;
					while (++end < length) {
						following = value.charCodeAt(end);
						if (!test(following)) {
							break;
						}
						characters2 += fromCharCode(following);
						if (type === name && own16.call(legacy, characters2)) {
							entityCharacters = characters2;
							entity = legacy[characters2];
						}
					}
					terminated = value.charCodeAt(end) === semicolon;
					if (terminated) {
						end++;
						namedEntity = type === name ? decodeEntity(characters2) : false;
						if (namedEntity) {
							entityCharacters = characters2;
							entity = namedEntity;
						}
					}
					diff = 1 + end - start;
					if (!terminated && !nonTerminated) {
					} else if (!characters2) {
						if (type !== name) {
							warning(numericEmpty, diff);
						}
					} else if (type === name) {
						if (terminated && !entity) {
							warning(namedUnknown, 1);
						} else {
							if (entityCharacters !== characters2) {
								end = begin + entityCharacters.length;
								diff = 1 + end - begin;
								terminated = false;
							}
							if (!terminated) {
								reason = entityCharacters ? namedNotTerminated : namedEmpty;
								if (settings.attribute) {
									following = value.charCodeAt(end);
									if (following === equalsTo) {
										warning(reason, diff);
										entity = null;
									} else if (alphanumerical(following)) {
										entity = null;
									} else {
										warning(reason, diff);
									}
								} else {
									warning(reason, diff);
								}
							}
						}
						reference = entity;
					} else {
						if (!terminated) {
							warning(numericNotTerminated, diff);
						}
						reference = parseInt(characters2, bases[type]);
						if (prohibited(reference)) {
							warning(numericProhibited, diff);
							reference = fromCharCode(replacementCharacter);
						} else if (reference in invalid2) {
							warning(numericDisallowed, diff);
							reference = invalid2[reference];
						} else {
							output = '';
							if (disallowed(reference)) {
								warning(numericDisallowed, diff);
							}
							if (reference > 65535) {
								reference -= 65536;
								output += fromCharCode((reference >>> (10 & 1023)) | 55296);
								reference = 56320 | (reference & 1023);
							}
							reference = output + fromCharCode(reference);
						}
					}
					if (reference) {
						flush();
						prev = now();
						index6 = end - 1;
						column += end - start + 1;
						result.push(reference);
						next = now();
						next.offset++;
						if (handleReference) {
							handleReference.call(
								referenceContext,
								reference,
								{ start: prev, end: next },
								value.slice(start - 1, end)
							);
						}
						prev = next;
					} else {
						characters2 = value.slice(start - 1, end);
						queue += characters2;
						column += characters2.length;
						index6 = end - 1;
					}
				} else {
					if (character === 10) {
						line++;
						lines++;
						column = 0;
					}
					if (character === character) {
						queue += fromCharCode(character);
						column++;
					} else {
						flush();
					}
				}
			}
			return result.join('');
			function now() {
				return {
					line,
					column,
					offset: index6 + (pos.offset || 0)
				};
			}
			function parseError(code3, offset) {
				var position3 = now();
				position3.column += offset;
				position3.offset += offset;
				handleWarning.call(warningContext, messages[code3], position3, code3);
			}
			function flush() {
				if (queue) {
					result.push(queue);
					if (handleText) {
						handleText.call(textContext, queue, { start: prev, end: now() });
					}
					queue = '';
				}
			}
		}
		function prohibited(code3) {
			return (code3 >= 55296 && code3 <= 57343) || code3 > 1114111;
		}
		function disallowed(code3) {
			return (
				(code3 >= 1 && code3 <= 8) ||
				code3 === 11 ||
				(code3 >= 13 && code3 <= 31) ||
				(code3 >= 127 && code3 <= 159) ||
				(code3 >= 64976 && code3 <= 65007) ||
				(code3 & 65535) === 65535 ||
				(code3 & 65535) === 65534
			);
		}
	}
});

// node_modules/prismjs/components/prism-core.js
var require_prism_core = __commonJS({
	'node_modules/prismjs/components/prism-core.js'(exports, module2) {
		var _self =
			typeof window !== 'undefined'
				? window
				: typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope
				? self
				: {};
		var Prism = (function (_self2) {
			var lang = /(?:^|\s)lang(?:uage)?-([\w-]+)(?=\s|$)/i;
			var uniqueId = 0;
			var plainTextGrammar = {};
			var _ = {
				manual: _self2.Prism && _self2.Prism.manual,
				disableWorkerMessageHandler: _self2.Prism && _self2.Prism.disableWorkerMessageHandler,
				util: {
					encode: function encode4(tokens) {
						if (tokens instanceof Token) {
							return new Token(tokens.type, encode4(tokens.content), tokens.alias);
						} else if (Array.isArray(tokens)) {
							return tokens.map(encode4);
						} else {
							return tokens
								.replace(/&/g, '&amp;')
								.replace(/</g, '&lt;')
								.replace(/\u00a0/g, ' ');
						}
					},
					type: function (o) {
						return Object.prototype.toString.call(o).slice(8, -1);
					},
					objId: function (obj) {
						if (!obj['__id']) {
							Object.defineProperty(obj, '__id', { value: ++uniqueId });
						}
						return obj['__id'];
					},
					clone: function deepClone2(o, visited) {
						visited = visited || {};
						var clone2;
						var id;
						switch (_.util.type(o)) {
							case 'Object':
								id = _.util.objId(o);
								if (visited[id]) {
									return visited[id];
								}
								clone2 = {};
								visited[id] = clone2;
								for (var key3 in o) {
									if (o.hasOwnProperty(key3)) {
										clone2[key3] = deepClone2(o[key3], visited);
									}
								}
								return clone2;
							case 'Array':
								id = _.util.objId(o);
								if (visited[id]) {
									return visited[id];
								}
								clone2 = [];
								visited[id] = clone2;
								o.forEach(function (v, i2) {
									clone2[i2] = deepClone2(v, visited);
								});
								return clone2;
							default:
								return o;
						}
					},
					getLanguage: function (element4) {
						while (element4) {
							var m2 = lang.exec(element4.className);
							if (m2) {
								return m2[1].toLowerCase();
							}
							element4 = element4.parentElement;
						}
						return 'none';
					},
					setLanguage: function (element4, language) {
						element4.className = element4.className.replace(RegExp(lang, 'gi'), '');
						element4.classList.add('language-' + language);
					},
					currentScript: function () {
						if (typeof document === 'undefined') {
							return null;
						}
						if ('currentScript' in document && 1 < 2) {
							return document.currentScript;
						}
						try {
							throw new Error();
						} catch (err) {
							var src = (/at [^(\r\n]*\((.*):[^:]+:[^:]+\)$/i.exec(err.stack) || [])[1];
							if (src) {
								var scripts = document.getElementsByTagName('script');
								for (var i2 in scripts) {
									if (scripts[i2].src == src) {
										return scripts[i2];
									}
								}
							}
							return null;
						}
					},
					isActive: function (element4, className, defaultActivation) {
						var no = 'no-' + className;
						while (element4) {
							var classList = element4.classList;
							if (classList.contains(className)) {
								return true;
							}
							if (classList.contains(no)) {
								return false;
							}
							element4 = element4.parentElement;
						}
						return !!defaultActivation;
					}
				},
				languages: {
					plain: plainTextGrammar,
					plaintext: plainTextGrammar,
					text: plainTextGrammar,
					txt: plainTextGrammar,
					extend: function (id, redef) {
						var lang2 = _.util.clone(_.languages[id]);
						for (var key3 in redef) {
							lang2[key3] = redef[key3];
						}
						return lang2;
					},
					insertBefore: function (inside, before, insert, root4) {
						root4 = root4 || _.languages;
						var grammar = root4[inside];
						var ret = {};
						for (var token in grammar) {
							if (grammar.hasOwnProperty(token)) {
								if (token == before) {
									for (var newToken in insert) {
										if (insert.hasOwnProperty(newToken)) {
											ret[newToken] = insert[newToken];
										}
									}
								}
								if (!insert.hasOwnProperty(token)) {
									ret[token] = grammar[token];
								}
							}
						}
						var old = root4[inside];
						root4[inside] = ret;
						_.languages.DFS(_.languages, function (key3, value) {
							if (value === old && key3 != inside) {
								this[key3] = ret;
							}
						});
						return ret;
					},
					DFS: function DFS(o, callback, type, visited) {
						visited = visited || {};
						var objId = _.util.objId;
						for (var i2 in o) {
							if (o.hasOwnProperty(i2)) {
								callback.call(o, i2, o[i2], type || i2);
								var property = o[i2];
								var propertyType = _.util.type(property);
								if (propertyType === 'Object' && !visited[objId(property)]) {
									visited[objId(property)] = true;
									DFS(property, callback, null, visited);
								} else if (propertyType === 'Array' && !visited[objId(property)]) {
									visited[objId(property)] = true;
									DFS(property, callback, i2, visited);
								}
							}
						}
					}
				},
				plugins: {},
				highlightAll: function (async, callback) {
					_.highlightAllUnder(document, async, callback);
				},
				highlightAllUnder: function (container, async, callback) {
					var env = {
						callback,
						container,
						selector:
							'code[class*="language-"], [class*="language-"] code, code[class*="lang-"], [class*="lang-"] code'
					};
					_.hooks.run('before-highlightall', env);
					env.elements = Array.prototype.slice.apply(env.container.querySelectorAll(env.selector));
					_.hooks.run('before-all-elements-highlight', env);
					for (var i2 = 0, element4; (element4 = env.elements[i2++]); ) {
						_.highlightElement(element4, async === true, env.callback);
					}
				},
				highlightElement: function (element4, async, callback) {
					var language = _.util.getLanguage(element4);
					var grammar = _.languages[language];
					_.util.setLanguage(element4, language);
					var parent = element4.parentElement;
					if (parent && parent.nodeName.toLowerCase() === 'pre') {
						_.util.setLanguage(parent, language);
					}
					var code3 = element4.textContent;
					var env = {
						element: element4,
						language,
						grammar,
						code: code3
					};
					function insertHighlightedCode(highlightedCode) {
						env.highlightedCode = highlightedCode;
						_.hooks.run('before-insert', env);
						env.element.innerHTML = env.highlightedCode;
						_.hooks.run('after-highlight', env);
						_.hooks.run('complete', env);
						callback && callback.call(env.element);
					}
					_.hooks.run('before-sanity-check', env);
					parent = env.element.parentElement;
					if (
						parent &&
						parent.nodeName.toLowerCase() === 'pre' &&
						!parent.hasAttribute('tabindex')
					) {
						parent.setAttribute('tabindex', '0');
					}
					if (!env.code) {
						_.hooks.run('complete', env);
						callback && callback.call(env.element);
						return;
					}
					_.hooks.run('before-highlight', env);
					if (!env.grammar) {
						insertHighlightedCode(_.util.encode(env.code));
						return;
					}
					if (async && _self2.Worker) {
						var worker = new Worker(_.filename);
						worker.onmessage = function (evt) {
							insertHighlightedCode(evt.data);
						};
						worker.postMessage(
							JSON.stringify({
								language: env.language,
								code: env.code,
								immediateClose: true
							})
						);
					} else {
						insertHighlightedCode(_.highlight(env.code, env.grammar, env.language));
					}
				},
				highlight: function (text7, grammar, language) {
					var env = {
						code: text7,
						grammar,
						language
					};
					_.hooks.run('before-tokenize', env);
					if (!env.grammar) {
						throw new Error('The language "' + env.language + '" has no grammar.');
					}
					env.tokens = _.tokenize(env.code, env.grammar);
					_.hooks.run('after-tokenize', env);
					return Token.stringify(_.util.encode(env.tokens), env.language);
				},
				tokenize: function (text7, grammar) {
					var rest = grammar.rest;
					if (rest) {
						for (var token in rest) {
							grammar[token] = rest[token];
						}
						delete grammar.rest;
					}
					var tokenList = new LinkedList();
					addAfter(tokenList, tokenList.head, text7);
					matchGrammar(text7, tokenList, grammar, tokenList.head, 0);
					return toArray(tokenList);
				},
				hooks: {
					all: {},
					add: function (name, callback) {
						var hooks = _.hooks.all;
						hooks[name] = hooks[name] || [];
						hooks[name].push(callback);
					},
					run: function (name, env) {
						var callbacks = _.hooks.all[name];
						if (!callbacks || !callbacks.length) {
							return;
						}
						for (var i2 = 0, callback; (callback = callbacks[i2++]); ) {
							callback(env);
						}
					}
				},
				Token
			};
			_self2.Prism = _;
			function Token(type, content3, alias, matchedStr) {
				this.type = type;
				this.content = content3;
				this.alias = alias;
				this.length = (matchedStr || '').length | 0;
			}
			Token.stringify = function stringify3(o, language) {
				if (typeof o == 'string') {
					return o;
				}
				if (Array.isArray(o)) {
					var s4 = '';
					o.forEach(function (e2) {
						s4 += stringify3(e2, language);
					});
					return s4;
				}
				var env = {
					type: o.type,
					content: stringify3(o.content, language),
					tag: 'span',
					classes: ['token', o.type],
					attributes: {},
					language
				};
				var aliases = o.alias;
				if (aliases) {
					if (Array.isArray(aliases)) {
						Array.prototype.push.apply(env.classes, aliases);
					} else {
						env.classes.push(aliases);
					}
				}
				_.hooks.run('wrap', env);
				var attributes = '';
				for (var name in env.attributes) {
					attributes +=
						' ' + name + '="' + (env.attributes[name] || '').replace(/"/g, '&quot;') + '"';
				}
				return (
					'<' +
					env.tag +
					' class="' +
					env.classes.join(' ') +
					'"' +
					attributes +
					'>' +
					env.content +
					'</' +
					env.tag +
					'>'
				);
			};
			function matchPattern(pattern, pos, text7, lookbehind) {
				pattern.lastIndex = pos;
				var match = pattern.exec(text7);
				if (match && lookbehind && match[1]) {
					var lookbehindLength = match[1].length;
					match.index += lookbehindLength;
					match[0] = match[0].slice(lookbehindLength);
				}
				return match;
			}
			function matchGrammar(text7, tokenList, grammar, startNode, startPos, rematch) {
				for (var token in grammar) {
					if (!grammar.hasOwnProperty(token) || !grammar[token]) {
						continue;
					}
					var patterns = grammar[token];
					patterns = Array.isArray(patterns) ? patterns : [patterns];
					for (var j = 0; j < patterns.length; ++j) {
						if (rematch && rematch.cause == token + ',' + j) {
							return;
						}
						var patternObj = patterns[j];
						var inside = patternObj.inside;
						var lookbehind = !!patternObj.lookbehind;
						var greedy = !!patternObj.greedy;
						var alias = patternObj.alias;
						if (greedy && !patternObj.pattern.global) {
							var flags = patternObj.pattern.toString().match(/[imsuy]*$/)[0];
							patternObj.pattern = RegExp(patternObj.pattern.source, flags + 'g');
						}
						var pattern = patternObj.pattern || patternObj;
						for (
							var currentNode = startNode.next, pos = startPos;
							currentNode !== tokenList.tail;
							pos += currentNode.value.length, currentNode = currentNode.next
						) {
							if (rematch && pos >= rematch.reach) {
								break;
							}
							var str = currentNode.value;
							if (tokenList.length > text7.length) {
								return;
							}
							if (str instanceof Token) {
								continue;
							}
							var removeCount = 1;
							var match;
							if (greedy) {
								match = matchPattern(pattern, pos, text7, lookbehind);
								if (!match || match.index >= text7.length) {
									break;
								}
								var from = match.index;
								var to = match.index + match[0].length;
								var p2 = pos;
								p2 += currentNode.value.length;
								while (from >= p2) {
									currentNode = currentNode.next;
									p2 += currentNode.value.length;
								}
								p2 -= currentNode.value.length;
								pos = p2;
								if (currentNode.value instanceof Token) {
									continue;
								}
								for (
									var k = currentNode;
									k !== tokenList.tail && (p2 < to || typeof k.value === 'string');
									k = k.next
								) {
									removeCount++;
									p2 += k.value.length;
								}
								removeCount--;
								str = text7.slice(pos, p2);
								match.index -= pos;
							} else {
								match = matchPattern(pattern, 0, str, lookbehind);
								if (!match) {
									continue;
								}
							}
							var from = match.index;
							var matchStr = match[0];
							var before = str.slice(0, from);
							var after = str.slice(from + matchStr.length);
							var reach = pos + str.length;
							if (rematch && reach > rematch.reach) {
								rematch.reach = reach;
							}
							var removeFrom = currentNode.prev;
							if (before) {
								removeFrom = addAfter(tokenList, removeFrom, before);
								pos += before.length;
							}
							removeRange(tokenList, removeFrom, removeCount);
							var wrapped = new Token(
								token,
								inside ? _.tokenize(matchStr, inside) : matchStr,
								alias,
								matchStr
							);
							currentNode = addAfter(tokenList, removeFrom, wrapped);
							if (after) {
								addAfter(tokenList, currentNode, after);
							}
							if (removeCount > 1) {
								var nestedRematch = {
									cause: token + ',' + j,
									reach
								};
								matchGrammar(text7, tokenList, grammar, currentNode.prev, pos, nestedRematch);
								if (rematch && nestedRematch.reach > rematch.reach) {
									rematch.reach = nestedRematch.reach;
								}
							}
						}
					}
				}
			}
			function LinkedList() {
				var head2 = { value: null, prev: null, next: null };
				var tail = { value: null, prev: head2, next: null };
				head2.next = tail;
				this.head = head2;
				this.tail = tail;
				this.length = 0;
			}
			function addAfter(list4, node, value) {
				var next = node.next;
				var newNode = { value, prev: node, next };
				node.next = newNode;
				next.prev = newNode;
				list4.length++;
				return newNode;
			}
			function removeRange(list4, node, count) {
				var next = node.next;
				for (var i2 = 0; i2 < count && next !== list4.tail; i2++) {
					next = next.next;
				}
				node.next = next;
				next.prev = node;
				list4.length -= i2;
			}
			function toArray(list4) {
				var array2 = [];
				var node = list4.head.next;
				while (node !== list4.tail) {
					array2.push(node.value);
					node = node.next;
				}
				return array2;
			}
			if (!_self2.document) {
				if (!_self2.addEventListener) {
					return _;
				}
				if (!_.disableWorkerMessageHandler) {
					_self2.addEventListener(
						'message',
						function (evt) {
							var message = JSON.parse(evt.data);
							var lang2 = message.language;
							var code3 = message.code;
							var immediateClose = message.immediateClose;
							_self2.postMessage(_.highlight(code3, _.languages[lang2], lang2));
							if (immediateClose) {
								_self2.close();
							}
						},
						false
					);
				}
				return _;
			}
			var script = _.util.currentScript();
			if (script) {
				_.filename = script.src;
				if (script.hasAttribute('data-manual')) {
					_.manual = true;
				}
			}
			function highlightAutomaticallyCallback() {
				if (!_.manual) {
					_.highlightAll();
				}
			}
			if (!_.manual) {
				var readyState = document.readyState;
				if (readyState === 'loading' || (readyState === 'interactive' && script && script.defer)) {
					document.addEventListener('DOMContentLoaded', highlightAutomaticallyCallback);
				} else {
					if (window.requestAnimationFrame) {
						window.requestAnimationFrame(highlightAutomaticallyCallback);
					} else {
						window.setTimeout(highlightAutomaticallyCallback, 16);
					}
				}
			}
			return _;
		})(_self);
		if (typeof module2 !== 'undefined' && module2.exports) {
			module2.exports = Prism;
		}
		if (typeof global !== 'undefined') {
			global.Prism = Prism;
		}
	}
});

// node_modules/refractor/lang/markup.js
var require_markup = __commonJS({
	'node_modules/refractor/lang/markup.js'(exports, module2) {
		'use strict';
		module2.exports = markup;
		markup.displayName = 'markup';
		markup.aliases = ['html', 'mathml', 'svg', 'xml', 'ssml', 'atom', 'rss'];
		function markup(Prism) {
			Prism.languages.markup = {
				comment: {
					pattern: /<!--(?:(?!<!--)[\s\S])*?-->/,
					greedy: true
				},
				prolog: {
					pattern: /<\?[\s\S]+?\?>/,
					greedy: true
				},
				doctype: {
					pattern:
						/<!DOCTYPE(?:[^>"'[\]]|"[^"]*"|'[^']*')+(?:\[(?:[^<"'\]]|"[^"]*"|'[^']*'|<(?!!--)|<!--(?:[^-]|-(?!->))*-->)*\]\s*)?>/i,
					greedy: true,
					inside: {
						'internal-subset': {
							pattern: /(^[^\[]*\[)[\s\S]+(?=\]>$)/,
							lookbehind: true,
							greedy: true,
							inside: null
						},
						string: {
							pattern: /"[^"]*"|'[^']*'/,
							greedy: true
						},
						punctuation: /^<!|>$|[[\]]/,
						'doctype-tag': /^DOCTYPE/i,
						name: /[^\s<>'"]+/
					}
				},
				cdata: {
					pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
					greedy: true
				},
				tag: {
					pattern:
						/<\/?(?!\d)[^\s>\/=$<%]+(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?\s*\/?>/,
					greedy: true,
					inside: {
						tag: {
							pattern: /^<\/?[^\s>\/]+/,
							inside: {
								punctuation: /^<\/?/,
								namespace: /^[^\s>\/:]+:/
							}
						},
						'special-attr': [],
						'attr-value': {
							pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+)/,
							inside: {
								punctuation: [
									{
										pattern: /^=/,
										alias: 'attr-equals'
									},
									/"|'/
								]
							}
						},
						punctuation: /\/?>/,
						'attr-name': {
							pattern: /[^\s>\/]+/,
							inside: {
								namespace: /^[^\s>\/:]+:/
							}
						}
					}
				},
				entity: [
					{
						pattern: /&[\da-z]{1,8};/i,
						alias: 'named-entity'
					},
					/&#x?[\da-f]{1,8};/i
				]
			};
			Prism.languages.markup['tag'].inside['attr-value'].inside['entity'] =
				Prism.languages.markup['entity'];
			Prism.languages.markup['doctype'].inside['internal-subset'].inside = Prism.languages.markup;
			Prism.hooks.add('wrap', function (env) {
				if (env.type === 'entity') {
					env.attributes['title'] = env.content.value.replace(/&amp;/, '&');
				}
			});
			Object.defineProperty(Prism.languages.markup.tag, 'addInlined', {
				value: function addInlined(tagName, lang) {
					var includedCdataInside = {};
					includedCdataInside['language-' + lang] = {
						pattern: /(^<!\[CDATA\[)[\s\S]+?(?=\]\]>$)/i,
						lookbehind: true,
						inside: Prism.languages[lang]
					};
					includedCdataInside['cdata'] = /^<!\[CDATA\[|\]\]>$/i;
					var inside = {
						'included-cdata': {
							pattern: /<!\[CDATA\[[\s\S]*?\]\]>/i,
							inside: includedCdataInside
						}
					};
					inside['language-' + lang] = {
						pattern: /[\s\S]+/,
						inside: Prism.languages[lang]
					};
					var def = {};
					def[tagName] = {
						pattern: RegExp(
							/(<__[^>]*>)(?:<!\[CDATA\[(?:[^\]]|\](?!\]>))*\]\]>|(?!<!\[CDATA\[)[\s\S])*?(?=<\/__>)/.source.replace(
								/__/g,
								function () {
									return tagName;
								}
							),
							'i'
						),
						lookbehind: true,
						greedy: true,
						inside
					};
					Prism.languages.insertBefore('markup', 'cdata', def);
				}
			});
			Object.defineProperty(Prism.languages.markup.tag, 'addAttribute', {
				value: function (attrName, lang) {
					Prism.languages.markup.tag.inside['special-attr'].push({
						pattern: RegExp(
							/(^|["'\s])/.source +
								'(?:' +
								attrName +
								')' +
								/\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))/.source,
							'i'
						),
						lookbehind: true,
						inside: {
							'attr-name': /^[^\s=]+/,
							'attr-value': {
								pattern: /=[\s\S]+/,
								inside: {
									value: {
										pattern: /(^=\s*(["']|(?!["'])))\S[\s\S]*(?=\2$)/,
										lookbehind: true,
										alias: [lang, 'language-' + lang],
										inside: Prism.languages[lang]
									},
									punctuation: [
										{
											pattern: /^=/,
											alias: 'attr-equals'
										},
										/"|'/
									]
								}
							}
						}
					});
				}
			});
			Prism.languages.html = Prism.languages.markup;
			Prism.languages.mathml = Prism.languages.markup;
			Prism.languages.svg = Prism.languages.markup;
			Prism.languages.xml = Prism.languages.extend('markup', {});
			Prism.languages.ssml = Prism.languages.xml;
			Prism.languages.atom = Prism.languages.xml;
			Prism.languages.rss = Prism.languages.xml;
		}
	}
});

// node_modules/refractor/lang/css.js
var require_css = __commonJS({
	'node_modules/refractor/lang/css.js'(exports, module2) {
		'use strict';
		module2.exports = css8;
		css8.displayName = 'css';
		css8.aliases = [];
		function css8(Prism) {
			(function (Prism2) {
				var string3 = /(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/;
				Prism2.languages.css = {
					comment: /\/\*[\s\S]*?\*\//,
					atrule: {
						pattern: /@[\w-](?:[^;{\s]|\s+(?![\s{]))*(?:;|(?=\s*\{))/,
						inside: {
							rule: /^@[\w-]+/,
							'selector-function-argument': {
								pattern:
									/(\bselector\s*\(\s*(?![\s)]))(?:[^()\s]|\s+(?![\s)])|\((?:[^()]|\([^()]*\))*\))+(?=\s*\))/,
								lookbehind: true,
								alias: 'selector'
							},
							keyword: {
								pattern: /(^|[^\w-])(?:and|not|only|or)(?![\w-])/,
								lookbehind: true
							}
						}
					},
					url: {
						pattern: RegExp(
							'\\burl\\((?:' + string3.source + '|' + /(?:[^\\\r\n()"']|\\[\s\S])*/.source + ')\\)',
							'i'
						),
						greedy: true,
						inside: {
							function: /^url/i,
							punctuation: /^\(|\)$/,
							string: {
								pattern: RegExp('^' + string3.source + '$'),
								alias: 'url'
							}
						}
					},
					selector: {
						pattern: RegExp(
							`(^|[{}\\s])[^{}\\s](?:[^{};"'\\s]|\\s+(?![\\s{])|` + string3.source + ')*(?=\\s*\\{)'
						),
						lookbehind: true
					},
					string: {
						pattern: string3,
						greedy: true
					},
					property: {
						pattern:
							/(^|[^-\w\xA0-\uFFFF])(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*(?=\s*:)/i,
						lookbehind: true
					},
					important: /!important\b/i,
					function: {
						pattern: /(^|[^-a-z0-9])[-a-z0-9]+(?=\()/i,
						lookbehind: true
					},
					punctuation: /[(){};:,]/
				};
				Prism2.languages.css['atrule'].inside.rest = Prism2.languages.css;
				var markup = Prism2.languages.markup;
				if (markup) {
					markup.tag.addInlined('style', 'css');
					markup.tag.addAttribute('style', 'css');
				}
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/clike.js
var require_clike = __commonJS({
	'node_modules/refractor/lang/clike.js'(exports, module2) {
		'use strict';
		module2.exports = clike;
		clike.displayName = 'clike';
		clike.aliases = [];
		function clike(Prism) {
			Prism.languages.clike = {
				comment: [
					{
						pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
						lookbehind: true,
						greedy: true
					},
					{
						pattern: /(^|[^\\:])\/\/.*/,
						lookbehind: true,
						greedy: true
					}
				],
				string: {
					pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
					greedy: true
				},
				'class-name': {
					pattern:
						/(\b(?:class|extends|implements|instanceof|interface|new|trait)\s+|\bcatch\s+\()[\w.\\]+/i,
					lookbehind: true,
					inside: {
						punctuation: /[.\\]/
					}
				},
				keyword:
					/\b(?:break|catch|continue|do|else|finally|for|function|if|in|instanceof|new|null|return|throw|try|while)\b/,
				boolean: /\b(?:false|true)\b/,
				function: /\b\w+(?=\()/,
				number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
				operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/,
				punctuation: /[{}[\];(),.:]/
			};
		}
	}
});

// node_modules/refractor/lang/javascript.js
var require_javascript = __commonJS({
	'node_modules/refractor/lang/javascript.js'(exports, module2) {
		'use strict';
		module2.exports = javascript;
		javascript.displayName = 'javascript';
		javascript.aliases = ['js'];
		function javascript(Prism) {
			Prism.languages.javascript = Prism.languages.extend('clike', {
				'class-name': [
					Prism.languages.clike['class-name'],
					{
						pattern:
							/(^|[^$\w\xA0-\uFFFF])(?!\s)[_$A-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\.(?:constructor|prototype))/,
						lookbehind: true
					}
				],
				keyword: [
					{
						pattern: /((?:^|\})\s*)catch\b/,
						lookbehind: true
					},
					{
						pattern:
							/(^|[^.]|\.\.\.\s*)\b(?:as|assert(?=\s*\{)|async(?=\s*(?:function\b|\(|[$\w\xA0-\uFFFF]|$))|await|break|case|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally(?=\s*(?:\{|$))|for|from(?=\s*(?:['"]|$))|function|(?:get|set)(?=\s*(?:[#\[$\w\xA0-\uFFFF]|$))|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)\b/,
						lookbehind: true
					}
				],
				function:
					/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*(?:\.\s*(?:apply|bind|call)\s*)?\()/,
				number: {
					pattern: RegExp(
						/(^|[^\w$])/.source +
							'(?:' +
							(/NaN|Infinity/.source +
								'|' +
								/0[bB][01]+(?:_[01]+)*n?/.source +
								'|' +
								/0[oO][0-7]+(?:_[0-7]+)*n?/.source +
								'|' +
								/0[xX][\dA-Fa-f]+(?:_[\dA-Fa-f]+)*n?/.source +
								'|' +
								/\d+(?:_\d+)*n/.source +
								'|' +
								/(?:\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[Ee][+-]?\d+(?:_\d+)*)?/
									.source) +
							')' +
							/(?![\w$])/.source
					),
					lookbehind: true
				},
				operator:
					/--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/
			});
			Prism.languages.javascript['class-name'][0].pattern =
				/(\b(?:class|extends|implements|instanceof|interface|new)\s+)[\w.\\]+/;
			Prism.languages.insertBefore('javascript', 'keyword', {
				regex: {
					pattern:
						/((?:^|[^$\w\xA0-\uFFFF."'\])\s]|\b(?:return|yield))\s*)\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[dgimyus]{0,7}(?=(?:\s|\/\*(?:[^*]|\*(?!\/))*\*\/)*(?:$|[\r\n,.;:})\]]|\/\/))/,
					lookbehind: true,
					greedy: true,
					inside: {
						'regex-source': {
							pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
							lookbehind: true,
							alias: 'language-regex',
							inside: Prism.languages.regex
						},
						'regex-delimiter': /^\/|\/$/,
						'regex-flags': /^[a-z]+$/
					}
				},
				'function-variable': {
					pattern:
						/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:async\s*)?(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
					alias: 'function'
				},
				parameter: [
					{
						pattern:
							/(function(?:\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)?\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\))/,
						lookbehind: true,
						inside: Prism.languages.javascript
					},
					{
						pattern:
							/(^|[^$\w\xA0-\uFFFF])(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=>)/i,
						lookbehind: true,
						inside: Prism.languages.javascript
					},
					{
						pattern: /(\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*=>)/,
						lookbehind: true,
						inside: Prism.languages.javascript
					},
					{
						pattern:
							/((?:\b|\s|^)(?!(?:as|async|await|break|case|catch|class|const|continue|debugger|default|delete|do|else|enum|export|extends|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|new|null|of|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|undefined|var|void|while|with|yield)(?![$\w\xA0-\uFFFF]))(?:(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*)\(\s*|\]\s*\(\s*)(?!\s)(?:[^()\s]|\s+(?![\s)])|\([^()]*\))+(?=\s*\)\s*\{)/,
						lookbehind: true,
						inside: Prism.languages.javascript
					}
				],
				constant: /\b[A-Z](?:[A-Z_]|\dx?)*\b/
			});
			Prism.languages.insertBefore('javascript', 'string', {
				hashbang: {
					pattern: /^#!.*/,
					greedy: true,
					alias: 'comment'
				},
				'template-string': {
					pattern: /`(?:\\[\s\S]|\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}|(?!\$\{)[^\\`])*`/,
					greedy: true,
					inside: {
						'template-punctuation': {
							pattern: /^`|`$/,
							alias: 'string'
						},
						interpolation: {
							pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
							lookbehind: true,
							inside: {
								'interpolation-punctuation': {
									pattern: /^\$\{|\}$/,
									alias: 'punctuation'
								},
								rest: Prism.languages.javascript
							}
						},
						string: /[\s\S]+/
					}
				},
				'string-property': {
					pattern: /((?:^|[,{])[ \t]*)(["'])(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2(?=\s*:)/m,
					lookbehind: true,
					greedy: true,
					alias: 'property'
				}
			});
			Prism.languages.insertBefore('javascript', 'operator', {
				'literal-property': {
					pattern:
						/((?:^|[,{])[ \t]*)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/m,
					lookbehind: true,
					alias: 'property'
				}
			});
			if (Prism.languages.markup) {
				Prism.languages.markup.tag.addInlined('script', 'javascript');
				Prism.languages.markup.tag.addAttribute(
					/on(?:abort|blur|change|click|composition(?:end|start|update)|dblclick|error|focus(?:in|out)?|key(?:down|up)|load|mouse(?:down|enter|leave|move|out|over|up)|reset|resize|scroll|select|slotchange|submit|unload|wheel)/
						.source,
					'javascript'
				);
			}
			Prism.languages.js = Prism.languages.javascript;
		}
	}
});

// node_modules/refractor/core.js
var require_core2 = __commonJS({
	'node_modules/refractor/core.js'(exports, module2) {
		'use strict';
		var ctx =
			typeof globalThis === 'object'
				? globalThis
				: typeof self === 'object'
				? self
				: typeof window === 'object'
				? window
				: typeof global === 'object'
				? global
				: {};
		var restore = capture();
		ctx.Prism = { manual: true, disableWorkerMessageHandler: true };
		var h3 = require_hastscript();
		var decode3 = require_parse_entities();
		var Prism = require_prism_core();
		var markup = require_markup();
		var css8 = require_css();
		var clike = require_clike();
		var js5 = require_javascript();
		restore();
		var own16 = {}.hasOwnProperty;
		function Refractor() {}
		Refractor.prototype = Prism;
		var refract = new Refractor();
		module2.exports = refract;
		refract.highlight = highlight;
		refract.register = register;
		refract.alias = alias;
		refract.registered = registered;
		refract.listLanguages = listLanguages;
		register(markup);
		register(css8);
		register(clike);
		register(js5);
		refract.util.encode = encode4;
		refract.Token.stringify = stringify3;
		function register(grammar) {
			if (typeof grammar !== 'function' || !grammar.displayName) {
				throw new Error('Expected `function` for `grammar`, got `' + grammar + '`');
			}
			if (refract.languages[grammar.displayName] === void 0) {
				grammar(refract);
			}
		}
		function alias(name, alias2) {
			var languages = refract.languages;
			var map4 = name;
			var key3;
			var list4;
			var length;
			var index6;
			if (alias2) {
				map4 = {};
				map4[name] = alias2;
			}
			for (key3 in map4) {
				list4 = map4[key3];
				list4 = typeof list4 === 'string' ? [list4] : list4;
				length = list4.length;
				index6 = -1;
				while (++index6 < length) {
					languages[list4[index6]] = languages[key3];
				}
			}
		}
		function highlight(value, name) {
			var sup = Prism.highlight;
			var grammar;
			if (typeof value !== 'string') {
				throw new Error('Expected `string` for `value`, got `' + value + '`');
			}
			if (refract.util.type(name) === 'Object') {
				grammar = name;
				name = null;
			} else {
				if (typeof name !== 'string') {
					throw new Error('Expected `string` for `name`, got `' + name + '`');
				}
				if (own16.call(refract.languages, name)) {
					grammar = refract.languages[name];
				} else {
					throw new Error('Unknown language: `' + name + '` is not registered');
				}
			}
			return sup.call(this, value, grammar, name);
		}
		function registered(language) {
			if (typeof language !== 'string') {
				throw new Error('Expected `string` for `language`, got `' + language + '`');
			}
			return own16.call(refract.languages, language);
		}
		function listLanguages() {
			var languages = refract.languages;
			var list4 = [];
			var language;
			for (language in languages) {
				if (own16.call(languages, language) && typeof languages[language] === 'object') {
					list4.push(language);
				}
			}
			return list4;
		}
		function stringify3(value, language, parent) {
			var env;
			if (typeof value === 'string') {
				return { type: 'text', value };
			}
			if (refract.util.type(value) === 'Array') {
				return stringifyAll(value, language);
			}
			env = {
				type: value.type,
				content: refract.Token.stringify(value.content, language, parent),
				tag: 'span',
				classes: ['token', value.type],
				attributes: {},
				language,
				parent
			};
			if (value.alias) {
				env.classes = env.classes.concat(value.alias);
			}
			refract.hooks.run('wrap', env);
			return h3(env.tag + '.' + env.classes.join('.'), attributes(env.attributes), env.content);
		}
		function stringifyAll(values, language) {
			var result = [];
			var length = values.length;
			var index6 = -1;
			var value;
			while (++index6 < length) {
				value = values[index6];
				if (value !== '' && value !== null && value !== void 0) {
					result.push(value);
				}
			}
			index6 = -1;
			length = result.length;
			while (++index6 < length) {
				value = result[index6];
				result[index6] = refract.Token.stringify(value, language, result);
			}
			return result;
		}
		function encode4(tokens) {
			return tokens;
		}
		function attributes(attrs) {
			var key3;
			for (key3 in attrs) {
				attrs[key3] = decode3(attrs[key3]);
			}
			return attrs;
		}
		function capture() {
			var defined = 'Prism' in ctx;
			var current = defined ? ctx.Prism : void 0;
			return restore2;
			function restore2() {
				if (defined) {
					ctx.Prism = current;
				} else {
					delete ctx.Prism;
				}
				defined = void 0;
				current = void 0;
			}
		}
	}
});

// node_modules/refractor/lang/abap.js
var require_abap = __commonJS({
	'node_modules/refractor/lang/abap.js'(exports, module2) {
		'use strict';
		module2.exports = abap;
		abap.displayName = 'abap';
		abap.aliases = [];
		function abap(Prism) {
			Prism.languages.abap = {
				comment: /^\*.*/m,
				string: /(`|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
				'string-template': {
					pattern: /([|}])(?:\\.|[^\\|{\r\n])*(?=[|{])/,
					lookbehind: true,
					alias: 'string'
				},
				'eol-comment': {
					pattern: /(^|\s)".*/m,
					lookbehind: true,
					alias: 'comment'
				},
				keyword: {
					pattern:
						/(\s|\.|^)(?:SCIENTIFIC_WITH_LEADING_ZERO|SCALE_PRESERVING_SCIENTIFIC|RMC_COMMUNICATION_FAILURE|END-ENHANCEMENT-SECTION|MULTIPLY-CORRESPONDING|SUBTRACT-CORRESPONDING|VERIFICATION-MESSAGE|DIVIDE-CORRESPONDING|ENHANCEMENT-SECTION|CURRENCY_CONVERSION|RMC_SYSTEM_FAILURE|START-OF-SELECTION|MOVE-CORRESPONDING|RMC_INVALID_STATUS|CUSTOMER-FUNCTION|END-OF-DEFINITION|ENHANCEMENT-POINT|SYSTEM-EXCEPTIONS|ADD-CORRESPONDING|SCALE_PRESERVING|SELECTION-SCREEN|CURSOR-SELECTION|END-OF-SELECTION|LOAD-OF-PROGRAM|SCROLL-BOUNDARY|SELECTION-TABLE|EXCEPTION-TABLE|IMPLEMENTATIONS|PARAMETER-TABLE|RIGHT-JUSTIFIED|UNIT_CONVERSION|AUTHORITY-CHECK|LIST-PROCESSING|SIGN_AS_POSTFIX|COL_BACKGROUND|IMPLEMENTATION|INTERFACE-POOL|TRANSFORMATION|IDENTIFICATION|ENDENHANCEMENT|LINE-SELECTION|INITIALIZATION|LEFT-JUSTIFIED|SELECT-OPTIONS|SELECTION-SETS|COMMUNICATION|CORRESPONDING|DECIMAL_SHIFT|PRINT-CONTROL|VALUE-REQUEST|CHAIN-REQUEST|FUNCTION-POOL|FIELD-SYMBOLS|FUNCTIONALITY|INVERTED-DATE|SELECTION-SET|CLASS-METHODS|OUTPUT-LENGTH|CLASS-CODING|COL_NEGATIVE|ERRORMESSAGE|FIELD-GROUPS|HELP-REQUEST|NO-EXTENSION|NO-TOPOFPAGE|REDEFINITION|DISPLAY-MODE|ENDINTERFACE|EXIT-COMMAND|FIELD-SYMBOL|NO-SCROLLING|SHORTDUMP-ID|ACCESSPOLICY|CLASS-EVENTS|COL_POSITIVE|DECLARATIONS|ENHANCEMENTS|FILTER-TABLE|SWITCHSTATES|SYNTAX-CHECK|TRANSPORTING|ASYNCHRONOUS|SYNTAX-TRACE|TOKENIZATION|USER-COMMAND|WITH-HEADING|ABAP-SOURCE|BREAK-POINT|CHAIN-INPUT|COMPRESSION|FIXED-POINT|NEW-SECTION|NON-UNICODE|OCCURRENCES|RESPONSIBLE|SYSTEM-CALL|TRACE-TABLE|ABBREVIATED|CHAR-TO-HEX|END-OF-FILE|ENDFUNCTION|ENVIRONMENT|ASSOCIATION|COL_HEADING|EDITOR-CALL|END-OF-PAGE|ENGINEERING|IMPLEMENTED|INTENSIFIED|RADIOBUTTON|SYSTEM-EXIT|TOP-OF-PAGE|TRANSACTION|APPLICATION|CONCATENATE|DESTINATION|ENHANCEMENT|IMMEDIATELY|NO-GROUPING|PRECOMPILED|REPLACEMENT|TITLE-LINES|ACTIVATION|BYTE-ORDER|CLASS-POOL|CONNECTION|CONVERSION|DEFINITION|DEPARTMENT|EXPIRATION|INHERITING|MESSAGE-ID|NO-HEADING|PERFORMING|QUEUE-ONLY|RIGHTSPACE|SCIENTIFIC|STATUSINFO|STRUCTURES|SYNCPOINTS|WITH-TITLE|ATTRIBUTES|BOUNDARIES|CLASS-DATA|COL_NORMAL|DD\/MM\/YYYY|DESCENDING|INTERFACES|LINE-COUNT|MM\/DD\/YYYY|NON-UNIQUE|PRESERVING|SELECTIONS|STATEMENTS|SUBROUTINE|TRUNCATION|TYPE-POOLS|ARITHMETIC|BACKGROUND|ENDPROVIDE|EXCEPTIONS|IDENTIFIER|INDEX-LINE|OBLIGATORY|PARAMETERS|PERCENTAGE|PUSHBUTTON|RESOLUTION|COMPONENTS|DEALLOCATE|DISCONNECT|DUPLICATES|FIRST-LINE|HEAD-LINES|NO-DISPLAY|OCCURRENCE|RESPECTING|RETURNCODE|SUBMATCHES|TRACE-FILE|ASCENDING|BYPASSING|ENDMODULE|EXCEPTION|EXCLUDING|EXPORTING|INCREMENT|MATCHCODE|PARAMETER|PARTIALLY|PREFERRED|REFERENCE|REPLACING|RETURNING|SELECTION|SEPARATED|SPECIFIED|STATEMENT|TIMESTAMP|TYPE-POOL|ACCEPTING|APPENDAGE|ASSIGNING|COL_GROUP|COMPARING|CONSTANTS|DANGEROUS|IMPORTING|INSTANCES|LEFTSPACE|LOG-POINT|QUICKINFO|READ-ONLY|SCROLLING|SQLSCRIPT|STEP-LOOP|TOP-LINES|TRANSLATE|APPENDING|AUTHORITY|CHARACTER|COMPONENT|CONDITION|DIRECTORY|DUPLICATE|MESSAGING|RECEIVING|SUBSCREEN|ACCORDING|COL_TOTAL|END-LINES|ENDMETHOD|ENDSELECT|EXPANDING|EXTENSION|INCLUDING|INFOTYPES|INTERFACE|INTERVALS|LINE-SIZE|PF-STATUS|PROCEDURE|PROTECTED|REQUESTED|RESUMABLE|RIGHTPLUS|SAP-SPOOL|SECONDARY|STRUCTURE|SUBSTRING|TABLEVIEW|NUMOFCHAR|ADJACENT|ANALYSIS|ASSIGNED|BACKWARD|CHANNELS|CHECKBOX|CONTINUE|CRITICAL|DATAINFO|DD\/MM\/YY|DURATION|ENCODING|ENDCLASS|FUNCTION|LEFTPLUS|LINEFEED|MM\/DD\/YY|OVERFLOW|RECEIVED|SKIPPING|SORTABLE|STANDARD|SUBTRACT|SUPPRESS|TABSTRIP|TITLEBAR|TRUNCATE|UNASSIGN|WHENEVER|ANALYZER|COALESCE|COMMENTS|CONDENSE|DECIMALS|DEFERRED|ENDWHILE|EXPLICIT|KEYWORDS|MESSAGES|POSITION|PRIORITY|RECEIVER|RENAMING|TIMEZONE|TRAILING|ALLOCATE|CENTERED|CIRCULAR|CONTROLS|CURRENCY|DELETING|DESCRIBE|DISTANCE|ENDCATCH|EXPONENT|EXTENDED|GENERATE|IGNORING|INCLUDES|INTERNAL|MAJOR-ID|MODIFIER|NEW-LINE|OPTIONAL|PROPERTY|ROLLBACK|STARTING|SUPPLIED|ABSTRACT|CHANGING|CONTEXTS|CREATING|CUSTOMER|DATABASE|DAYLIGHT|DEFINING|DISTINCT|DIVISION|ENABLING|ENDCHAIN|ESCAPING|HARMLESS|IMPLICIT|INACTIVE|LANGUAGE|MINOR-ID|MULTIPLY|NEW-PAGE|NO-TITLE|POS_HIGH|SEPARATE|TEXTPOOL|TRANSFER|SELECTOR|DBMAXLEN|ITERATOR|ARCHIVE|BIT-XOR|BYTE-CO|COLLECT|COMMENT|CURRENT|DEFAULT|DISPLAY|ENDFORM|EXTRACT|LEADING|LISTBOX|LOCATOR|MEMBERS|METHODS|NESTING|POS_LOW|PROCESS|PROVIDE|RAISING|RESERVE|SECONDS|SUMMARY|VISIBLE|BETWEEN|BIT-AND|BYTE-CS|CLEANUP|COMPUTE|CONTROL|CONVERT|DATASET|ENDCASE|FORWARD|HEADERS|HOTSPOT|INCLUDE|INVERSE|KEEPING|NO-ZERO|OBJECTS|OVERLAY|PADDING|PATTERN|PROGRAM|REFRESH|SECTION|SUMMING|TESTING|VERSION|WINDOWS|WITHOUT|BIT-NOT|BYTE-CA|BYTE-NA|CASTING|CONTEXT|COUNTRY|DYNAMIC|ENABLED|ENDLOOP|EXECUTE|FRIENDS|HANDLER|HEADING|INITIAL|\*-INPUT|LOGFILE|MAXIMUM|MINIMUM|NO-GAPS|NO-SIGN|PRAGMAS|PRIMARY|PRIVATE|REDUCED|REPLACE|REQUEST|RESULTS|UNICODE|WARNING|ALIASES|BYTE-CN|BYTE-NS|CALLING|COL_KEY|COLUMNS|CONNECT|ENDEXEC|ENTRIES|EXCLUDE|FILTERS|FURTHER|HELP-ID|LOGICAL|MAPPING|MESSAGE|NAMETAB|OPTIONS|PACKAGE|PERFORM|RECEIVE|STATICS|VARYING|BINDING|CHARLEN|GREATER|XSTRLEN|ACCEPT|APPEND|DETAIL|ELSEIF|ENDING|ENDTRY|FORMAT|FRAMES|GIVING|HASHED|HEADER|IMPORT|INSERT|MARGIN|MODULE|NATIVE|OBJECT|OFFSET|REMOTE|RESUME|SAVING|SIMPLE|SUBMIT|TABBED|TOKENS|UNIQUE|UNPACK|UPDATE|WINDOW|YELLOW|ACTUAL|ASPECT|CENTER|CURSOR|DELETE|DIALOG|DIVIDE|DURING|ERRORS|EVENTS|EXTEND|FILTER|HANDLE|HAVING|IGNORE|LITTLE|MEMORY|NO-GAP|OCCURS|OPTION|PERSON|PLACES|PUBLIC|REDUCE|REPORT|RESULT|SINGLE|SORTED|SWITCH|SYNTAX|TARGET|VALUES|WRITER|ASSERT|BLOCKS|BOUNDS|BUFFER|CHANGE|COLUMN|COMMIT|CONCAT|COPIES|CREATE|DDMMYY|DEFINE|ENDIAN|ESCAPE|EXPAND|KERNEL|LAYOUT|LEGACY|LEVELS|MMDDYY|NUMBER|OUTPUT|RANGES|READER|RETURN|SCREEN|SEARCH|SELECT|SHARED|SOURCE|STABLE|STATIC|SUBKEY|SUFFIX|TABLES|UNWIND|YYMMDD|ASSIGN|BACKUP|BEFORE|BINARY|BIT-OR|BLANKS|CLIENT|CODING|COMMON|DEMAND|DYNPRO|EXCEPT|EXISTS|EXPORT|FIELDS|GLOBAL|GROUPS|LENGTH|LOCALE|MEDIUM|METHOD|MODIFY|NESTED|OTHERS|REJECT|SCROLL|SUPPLY|SYMBOL|ENDFOR|STRLEN|ALIGN|BEGIN|BOUND|ENDAT|ENTRY|EVENT|FINAL|FLUSH|GRANT|INNER|SHORT|USING|WRITE|AFTER|BLACK|BLOCK|CLOCK|COLOR|COUNT|DUMMY|EMPTY|ENDDO|ENDON|GREEN|INDEX|INOUT|LEAVE|LEVEL|LINES|MODIF|ORDER|OUTER|RANGE|RESET|RETRY|RIGHT|SMART|SPLIT|STYLE|TABLE|THROW|UNDER|UNTIL|UPPER|UTF-8|WHERE|ALIAS|BLANK|CLEAR|CLOSE|EXACT|FETCH|FIRST|FOUND|GROUP|LLANG|LOCAL|OTHER|REGEX|SPOOL|TITLE|TYPES|VALID|WHILE|ALPHA|BOXED|CATCH|CHAIN|CHECK|CLASS|COVER|ENDIF|EQUIV|FIELD|FLOOR|FRAME|INPUT|LOWER|MATCH|NODES|PAGES|PRINT|RAISE|ROUND|SHIFT|SPACE|SPOTS|STAMP|STATE|TASKS|TIMES|TRMAC|ULINE|UNION|VALUE|WIDTH|EQUAL|LOG10|TRUNC|BLOB|CASE|CEIL|CLOB|COND|EXIT|FILE|GAPS|HOLD|INCL|INTO|KEEP|KEYS|LAST|LINE|LONG|LPAD|MAIL|MODE|OPEN|PINK|READ|ROWS|TEST|THEN|ZERO|AREA|BACK|BADI|BYTE|CAST|EDIT|EXEC|FAIL|FIND|FKEQ|FONT|FREE|GKEQ|HIDE|INIT|ITNO|LATE|LOOP|MAIN|MARK|MOVE|NEXT|NULL|RISK|ROLE|UNIT|WAIT|ZONE|BASE|CALL|CODE|DATA|DATE|FKGE|GKGE|HIGH|KIND|LEFT|LIST|MASK|MESH|NAME|NODE|PACK|PAGE|POOL|SEND|SIGN|SIZE|SOME|STOP|TASK|TEXT|TIME|USER|VARY|WITH|WORD|BLUE|CONV|COPY|DEEP|ELSE|FORM|FROM|HINT|ICON|JOIN|LIKE|LOAD|ONLY|PART|SCAN|SKIP|SORT|TYPE|UNIX|VIEW|WHEN|WORK|ACOS|ASIN|ATAN|COSH|EACH|FRAC|LESS|RTTI|SINH|SQRT|TANH|AVG|BIT|DIV|ISO|LET|OUT|PAD|SQL|ALL|CI_|CPI|END|LOB|LPI|MAX|MIN|NEW|OLE|RUN|SET|\?TO|YES|ABS|ADD|AND|BIG|FOR|HDB|JOB|LOW|NOT|SAP|TRY|VIA|XML|ANY|GET|IDS|KEY|MOD|OFF|PUT|RAW|RED|REF|SUM|TAB|XSD|CNT|COS|EXP|LOG|SIN|TAN|XOR|AT|CO|CP|DO|GT|ID|IF|NS|OR|BT|CA|CS|GE|NA|NB|EQ|IN|LT|NE|NO|OF|ON|PF|TO|AS|BY|CN|IS|LE|NP|UP|E|I|M|O|Z|C|X)\b/i,
					lookbehind: true
				},
				number: /\b\d+\b/,
				operator: {
					pattern: /(\s)(?:\*\*?|<[=>]?|>=?|\?=|[-+\/=])(?=\s)/,
					lookbehind: true
				},
				'string-operator': {
					pattern: /(\s)&&?(?=\s)/,
					lookbehind: true,
					alias: 'keyword'
				},
				'token-operator': [
					{
						pattern: /(\w)(?:->?|=>|[~|{}])(?=\w)/,
						lookbehind: true,
						alias: 'punctuation'
					},
					{
						pattern: /[|{}]/,
						alias: 'punctuation'
					}
				],
				punctuation: /[,.:()]/
			};
		}
	}
});

// node_modules/refractor/lang/abnf.js
var require_abnf = __commonJS({
	'node_modules/refractor/lang/abnf.js'(exports, module2) {
		'use strict';
		module2.exports = abnf;
		abnf.displayName = 'abnf';
		abnf.aliases = [];
		function abnf(Prism) {
			(function (Prism2) {
				var coreRules =
					'(?:ALPHA|BIT|CHAR|CR|CRLF|CTL|DIGIT|DQUOTE|HEXDIG|HTAB|LF|LWSP|OCTET|SP|VCHAR|WSP)';
				Prism2.languages.abnf = {
					comment: /;.*/,
					string: {
						pattern: /(?:%[is])?"[^"\n\r]*"/,
						greedy: true,
						inside: {
							punctuation: /^%[is]/
						}
					},
					range: {
						pattern: /%(?:b[01]+-[01]+|d\d+-\d+|x[A-F\d]+-[A-F\d]+)/i,
						alias: 'number'
					},
					terminal: {
						pattern: /%(?:b[01]+(?:\.[01]+)*|d\d+(?:\.\d+)*|x[A-F\d]+(?:\.[A-F\d]+)*)/i,
						alias: 'number'
					},
					repetition: {
						pattern: /(^|[^\w-])(?:\d*\*\d*|\d+)/,
						lookbehind: true,
						alias: 'operator'
					},
					definition: {
						pattern: /(^[ \t]*)(?:[a-z][\w-]*|<[^<>\r\n]*>)(?=\s*=)/m,
						lookbehind: true,
						alias: 'keyword',
						inside: {
							punctuation: /<|>/
						}
					},
					'core-rule': {
						pattern: RegExp('(?:(^|[^<\\w-])' + coreRules + '|<' + coreRules + '>)(?![\\w-])', 'i'),
						lookbehind: true,
						alias: ['rule', 'constant'],
						inside: {
							punctuation: /<|>/
						}
					},
					rule: {
						pattern: /(^|[^<\w-])[a-z][\w-]*|<[^<>\r\n]*>/i,
						lookbehind: true,
						inside: {
							punctuation: /<|>/
						}
					},
					operator: /=\/?|\//,
					punctuation: /[()\[\]]/
				};
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/actionscript.js
var require_actionscript = __commonJS({
	'node_modules/refractor/lang/actionscript.js'(exports, module2) {
		'use strict';
		module2.exports = actionscript;
		actionscript.displayName = 'actionscript';
		actionscript.aliases = [];
		function actionscript(Prism) {
			Prism.languages.actionscript = Prism.languages.extend('javascript', {
				keyword:
					/\b(?:as|break|case|catch|class|const|default|delete|do|dynamic|each|else|extends|final|finally|for|function|get|if|implements|import|in|include|instanceof|interface|internal|is|namespace|native|new|null|override|package|private|protected|public|return|set|static|super|switch|this|throw|try|typeof|use|var|void|while|with)\b/,
				operator: /\+\+|--|(?:[+\-*\/%^]|&&?|\|\|?|<<?|>>?>?|[!=]=?)=?|[~?@]/
			});
			Prism.languages.actionscript['class-name'].alias = 'function';
			delete Prism.languages.actionscript['parameter'];
			delete Prism.languages.actionscript['literal-property'];
			if (Prism.languages.markup) {
				Prism.languages.insertBefore('actionscript', 'string', {
					xml: {
						pattern: /(^|[^.])<\/?\w+(?:\s+[^\s>\/=]+=("|')(?:\\[\s\S]|(?!\2)[^\\])*\2)*\s*\/?>/,
						lookbehind: true,
						inside: Prism.languages.markup
					}
				});
			}
		}
	}
});

// node_modules/refractor/lang/ada.js
var require_ada = __commonJS({
	'node_modules/refractor/lang/ada.js'(exports, module2) {
		'use strict';
		module2.exports = ada;
		ada.displayName = 'ada';
		ada.aliases = [];
		function ada(Prism) {
			Prism.languages.ada = {
				comment: /--.*/,
				string: /"(?:""|[^"\r\f\n])*"/,
				number: [
					{
						pattern:
							/\b\d(?:_?\d)*#[\dA-F](?:_?[\dA-F])*(?:\.[\dA-F](?:_?[\dA-F])*)?#(?:E[+-]?\d(?:_?\d)*)?/i
					},
					{
						pattern: /\b\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:E[+-]?\d(?:_?\d)*)?\b/i
					}
				],
				'attr-name': /\b'\w+/,
				keyword:
					/\b(?:abort|abs|abstract|accept|access|aliased|all|and|array|at|begin|body|case|constant|declare|delay|delta|digits|do|else|elsif|end|entry|exception|exit|for|function|generic|goto|if|in|interface|is|limited|loop|mod|new|not|null|of|others|out|overriding|package|pragma|private|procedure|protected|raise|range|record|rem|renames|requeue|return|reverse|select|separate|some|subtype|synchronized|tagged|task|terminate|then|type|until|use|when|while|with|xor)\b/i,
				boolean: /\b(?:false|true)\b/i,
				operator: /<[=>]?|>=?|=>?|:=|\/=?|\*\*?|[&+-]/,
				punctuation: /\.\.?|[,;():]/,
				char: /'.'/,
				variable: /\b[a-z](?:\w)*\b/i
			};
		}
	}
});

// node_modules/refractor/lang/agda.js
var require_agda = __commonJS({
	'node_modules/refractor/lang/agda.js'(exports, module2) {
		'use strict';
		module2.exports = agda;
		agda.displayName = 'agda';
		agda.aliases = [];
		function agda(Prism) {
			(function (Prism2) {
				Prism2.languages.agda = {
					comment: /\{-[\s\S]*?(?:-\}|$)|--.*/,
					string: {
						pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/,
						greedy: true
					},
					punctuation: /[(){}.;@]/,
					'class-name': {
						pattern: /((?:data|record) +)\S+/,
						lookbehind: true
					},
					function: {
						pattern: /(^[ \t]*)(?!\s)[^:\r\n]+(?=:)/m,
						lookbehind: true
					},
					operator: {
						pattern: /(^\s*|\s)(?:[=|:\\?_]|->)(?=\s)/,
						lookbehind: true
					},
					keyword:
						/\b(?:Set|abstract|constructor|data|eta-equality|field|forall|hiding|import|in|inductive|infix|infixl|infixr|instance|let|macro|module|mutual|no-eta-equality|open|overlap|pattern|postulate|primitive|private|public|quote|quoteContext|quoteGoal|quoteTerm|record|renaming|rewrite|syntax|tactic|unquote|unquoteDecl|unquoteDef|using|variable|where|with)\b/
				};
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/al.js
var require_al = __commonJS({
	'node_modules/refractor/lang/al.js'(exports, module2) {
		'use strict';
		module2.exports = al;
		al.displayName = 'al';
		al.aliases = [];
		function al(Prism) {
			Prism.languages.al = {
				comment: /\/\/.*|\/\*[\s\S]*?\*\//,
				string: {
					pattern: /'(?:''|[^'\r\n])*'(?!')|"(?:""|[^"\r\n])*"(?!")/,
					greedy: true
				},
				function: {
					pattern: /(\b(?:event|procedure|trigger)\s+|(?:^|[^.])\.\s*)[a-z_]\w*(?=\s*\()/i,
					lookbehind: true
				},
				keyword: [
					/\b(?:array|asserterror|begin|break|case|do|downto|else|end|event|exit|for|foreach|function|if|implements|in|indataset|interface|internal|local|of|procedure|program|protected|repeat|runonclient|securityfiltering|suppressdispose|temporary|then|to|trigger|until|var|while|with|withevents)\b/i,
					/\b(?:action|actions|addafter|addbefore|addfirst|addlast|area|assembly|chartpart|codeunit|column|controladdin|cuegroup|customizes|dataitem|dataset|dotnet|elements|enum|enumextension|extends|field|fieldattribute|fieldelement|fieldgroup|fieldgroups|fields|filter|fixed|grid|group|key|keys|label|labels|layout|modify|moveafter|movebefore|movefirst|movelast|page|pagecustomization|pageextension|part|profile|query|repeater|report|requestpage|schema|separator|systempart|table|tableelement|tableextension|textattribute|textelement|type|usercontrol|value|xmlport)\b/i
				],
				number: /\b(?:0x[\da-f]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?)(?:F|LL?|U(?:LL?)?)?\b/i,
				boolean: /\b(?:false|true)\b/i,
				variable: /\b(?:Curr(?:FieldNo|Page|Report)|x?Rec|RequestOptionsPage)\b/,
				'class-name':
					/\b(?:automation|biginteger|bigtext|blob|boolean|byte|char|clienttype|code|completiontriggererrorlevel|connectiontype|database|dataclassification|datascope|date|dateformula|datetime|decimal|defaultlayout|dialog|dictionary|dotnetassembly|dotnettypedeclaration|duration|errorinfo|errortype|executioncontext|executionmode|fieldclass|fieldref|fieldtype|file|filterpagebuilder|guid|httpclient|httpcontent|httpheaders|httprequestmessage|httpresponsemessage|instream|integer|joker|jsonarray|jsonobject|jsontoken|jsonvalue|keyref|list|moduledependencyinfo|moduleinfo|none|notification|notificationscope|objecttype|option|outstream|pageresult|record|recordid|recordref|reportformat|securityfilter|sessionsettings|tableconnectiontype|tablefilter|testaction|testfield|testfilterfield|testpage|testpermissions|testrequestpage|text|textbuilder|textconst|textencoding|time|transactionmodel|transactiontype|variant|verbosity|version|view|views|webserviceactioncontext|webserviceactionresultcode|xmlattribute|xmlattributecollection|xmlcdata|xmlcomment|xmldeclaration|xmldocument|xmldocumenttype|xmlelement|xmlnamespacemanager|xmlnametable|xmlnode|xmlnodelist|xmlprocessinginstruction|xmlreadoptions|xmltext|xmlwriteoptions)\b/i,
				operator: /\.\.|:[=:]|[-+*/]=?|<>|[<>]=?|=|\b(?:and|div|mod|not|or|xor)\b/i,
				punctuation: /[()\[\]{}:.;,]/
			};
		}
	}
});

// node_modules/refractor/lang/antlr4.js
var require_antlr4 = __commonJS({
	'node_modules/refractor/lang/antlr4.js'(exports, module2) {
		'use strict';
		module2.exports = antlr4;
		antlr4.displayName = 'antlr4';
		antlr4.aliases = ['g4'];
		function antlr4(Prism) {
			Prism.languages.antlr4 = {
				comment: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
				string: {
					pattern: /'(?:\\.|[^\\'\r\n])*'/,
					greedy: true
				},
				'character-class': {
					pattern: /\[(?:\\.|[^\\\]\r\n])*\]/,
					greedy: true,
					alias: 'regex',
					inside: {
						range: {
							pattern: /([^[]|(?:^|[^\\])(?:\\\\)*\\\[)-(?!\])/,
							lookbehind: true,
							alias: 'punctuation'
						},
						escape: /\\(?:u(?:[a-fA-F\d]{4}|\{[a-fA-F\d]+\})|[pP]\{[=\w-]+\}|[^\r\nupP])/,
						punctuation: /[\[\]]/
					}
				},
				action: {
					pattern: /\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*\}/,
					greedy: true,
					inside: {
						content: {
							pattern: /(\{)[\s\S]+(?=\})/,
							lookbehind: true
						},
						punctuation: /[{}]/
					}
				},
				command: {
					pattern: /(->\s*(?!\s))(?:\s*(?:,\s*)?\b[a-z]\w*(?:\s*\([^()\r\n]*\))?)+(?=\s*;)/i,
					lookbehind: true,
					inside: {
						function: /\b\w+(?=\s*(?:[,(]|$))/,
						punctuation: /[,()]/
					}
				},
				annotation: {
					pattern: /@\w+(?:::\w+)*/,
					alias: 'keyword'
				},
				label: {
					pattern: /#[ \t]*\w+/,
					alias: 'punctuation'
				},
				keyword:
					/\b(?:catch|channels|finally|fragment|grammar|import|lexer|locals|mode|options|parser|returns|throws|tokens)\b/,
				definition: [
					{
						pattern: /\b[a-z]\w*(?=\s*:)/,
						alias: ['rule', 'class-name']
					},
					{
						pattern: /\b[A-Z]\w*(?=\s*:)/,
						alias: ['token', 'constant']
					}
				],
				constant: /\b[A-Z][A-Z_]*\b/,
				operator: /\.\.|->|[|~]|[*+?]\??/,
				punctuation: /[;:()=]/
			};
			Prism.languages.g4 = Prism.languages.antlr4;
		}
	}
});

// node_modules/refractor/lang/apacheconf.js
var require_apacheconf = __commonJS({
	'node_modules/refractor/lang/apacheconf.js'(exports, module2) {
		'use strict';
		module2.exports = apacheconf;
		apacheconf.displayName = 'apacheconf';
		apacheconf.aliases = [];
		function apacheconf(Prism) {
			Prism.languages.apacheconf = {
				comment: /#.*/,
				'directive-inline': {
					pattern:
						/(^[\t ]*)\b(?:AcceptFilter|AcceptPathInfo|AccessFileName|Action|Add(?:Alt|AltByEncoding|AltByType|Charset|DefaultCharset|Description|Encoding|Handler|Icon|IconByEncoding|IconByType|InputFilter|Language|ModuleInfo|OutputFilter|OutputFilterByType|Type)|Alias|AliasMatch|Allow(?:CONNECT|EncodedSlashes|Methods|Override|OverrideList)?|Anonymous(?:_LogEmail|_MustGiveEmail|_NoUserID|_VerifyEmail)?|AsyncRequestWorkerFactor|Auth(?:BasicAuthoritative|BasicFake|BasicProvider|BasicUseDigestAlgorithm|DBDUserPWQuery|DBDUserRealmQuery|DBMGroupFile|DBMType|DBMUserFile|Digest(?:Algorithm|Domain|NonceLifetime|Provider|Qop|ShmemSize)|Form(?:Authoritative|Body|DisableNoStore|FakeBasicAuth|Location|LoginRequiredLocation|LoginSuccessLocation|LogoutLocation|Method|Mimetype|Password|Provider|SitePassphrase|Size|Username)|GroupFile|LDAP(?:AuthorizePrefix|BindAuthoritative|BindDN|BindPassword|CharsetConfig|CompareAsUser|CompareDNOnServer|DereferenceAliases|GroupAttribute|GroupAttributeIsDN|InitialBindAsUser|InitialBindPattern|MaxSubGroupDepth|RemoteUserAttribute|RemoteUserIsDN|SearchAsUser|SubGroupAttribute|SubGroupClass|Url)|Merging|Name|nCache(?:Context|Enable|ProvideFor|SOCache|Timeout)|nzFcgiCheckAuthnProvider|nzFcgiDefineProvider|Type|UserFile|zDBDLoginToReferer|zDBDQuery|zDBDRedirectQuery|zDBMType|zSendForbiddenOnFailure)|BalancerGrowth|BalancerInherit|BalancerMember|BalancerPersist|BrowserMatch|BrowserMatchNoCase|BufferedLogs|BufferSize|Cache(?:DefaultExpire|DetailHeader|DirLength|DirLevels|Disable|Enable|File|Header|IgnoreCacheControl|IgnoreHeaders|IgnoreNoLastMod|IgnoreQueryString|IgnoreURLSessionIdentifiers|KeyBaseURL|LastModifiedFactor|Lock|LockMaxAge|LockPath|MaxExpire|MaxFileSize|MinExpire|MinFileSize|NegotiatedDocs|QuickHandler|ReadSize|ReadTime|Root|Socache(?:MaxSize|MaxTime|MinTime|ReadSize|ReadTime)?|StaleOnError|StoreExpired|StoreNoStore|StorePrivate)|CGIDScriptTimeout|CGIMapExtension|CharsetDefault|CharsetOptions|CharsetSourceEnc|CheckCaseOnly|CheckSpelling|ChrootDir|ContentDigest|CookieDomain|CookieExpires|CookieName|CookieStyle|CookieTracking|CoreDumpDirectory|CustomLog|Dav|DavDepthInfinity|DavGenericLockDB|DavLockDB|DavMinTimeout|DBDExptime|DBDInitSQL|DBDKeep|DBDMax|DBDMin|DBDParams|DBDPersist|DBDPrepareSQL|DBDriver|DefaultIcon|DefaultLanguage|DefaultRuntimeDir|DefaultType|Define|Deflate(?:BufferSize|CompressionLevel|FilterNote|InflateLimitRequestBody|InflateRatio(?:Burst|Limit)|MemLevel|WindowSize)|Deny|DirectoryCheckHandler|DirectoryIndex|DirectoryIndexRedirect|DirectorySlash|DocumentRoot|DTracePrivileges|DumpIOInput|DumpIOOutput|EnableExceptionHook|EnableMMAP|EnableSendfile|Error|ErrorDocument|ErrorLog|ErrorLogFormat|Example|ExpiresActive|ExpiresByType|ExpiresDefault|ExtendedStatus|ExtFilterDefine|ExtFilterOptions|FallbackResource|FileETag|FilterChain|FilterDeclare|FilterProtocol|FilterProvider|FilterTrace|ForceLanguagePriority|ForceType|ForensicLog|GprofDir|GracefulShutdownTimeout|Group|Header|HeaderName|Heartbeat(?:Address|Listen|MaxServers|Storage)|HostnameLookups|IdentityCheck|IdentityCheckTimeout|ImapBase|ImapDefault|ImapMenu|Include|IncludeOptional|Index(?:HeadInsert|Ignore|IgnoreReset|Options|OrderDefault|StyleSheet)|InputSed|ISAPI(?:AppendLogToErrors|AppendLogToQuery|CacheFile|FakeAsync|LogNotSupported|ReadAheadBuffer)|KeepAlive|KeepAliveTimeout|KeptBodySize|LanguagePriority|LDAP(?:CacheEntries|CacheTTL|ConnectionPoolTTL|ConnectionTimeout|LibraryDebug|OpCacheEntries|OpCacheTTL|ReferralHopLimit|Referrals|Retries|RetryDelay|SharedCacheFile|SharedCacheSize|Timeout|TrustedClientCert|TrustedGlobalCert|TrustedMode|VerifyServerCert)|Limit(?:InternalRecursion|Request(?:Body|Fields|FieldSize|Line)|XMLRequestBody)|Listen|ListenBackLog|LoadFile|LoadModule|LogFormat|LogLevel|LogMessage|LuaAuthzProvider|LuaCodeCache|Lua(?:Hook(?:AccessChecker|AuthChecker|CheckUserID|Fixups|InsertFilter|Log|MapToStorage|TranslateName|TypeChecker)|Inherit|InputFilter|MapHandler|OutputFilter|PackageCPath|PackagePath|QuickHandler|Root|Scope)|Max(?:ConnectionsPerChild|KeepAliveRequests|MemFree|RangeOverlaps|RangeReversals|Ranges|RequestWorkers|SpareServers|SpareThreads|Threads)|MergeTrailers|MetaDir|MetaFiles|MetaSuffix|MimeMagicFile|MinSpareServers|MinSpareThreads|MMapFile|ModemStandard|ModMimeUsePathInfo|MultiviewsMatch|Mutex|NameVirtualHost|NoProxy|NWSSLTrustedCerts|NWSSLUpgradeable|Options|Order|OutputSed|PassEnv|PidFile|PrivilegesMode|Protocol|ProtocolEcho|Proxy(?:AddHeaders|BadHeader|Block|Domain|ErrorOverride|ExpressDBMFile|ExpressDBMType|ExpressEnable|FtpDirCharset|FtpEscapeWildcards|FtpListOnWildcard|HTML(?:BufSize|CharsetOut|DocType|Enable|Events|Extended|Fixups|Interp|Links|Meta|StripComments|URLMap)|IOBufferSize|MaxForwards|Pass(?:Inherit|InterpolateEnv|Match|Reverse|ReverseCookieDomain|ReverseCookiePath)?|PreserveHost|ReceiveBufferSize|Remote|RemoteMatch|Requests|SCGIInternalRedirect|SCGISendfile|Set|SourceAddress|Status|Timeout|Via)|ReadmeName|ReceiveBufferSize|Redirect|RedirectMatch|RedirectPermanent|RedirectTemp|ReflectorHeader|RemoteIP(?:Header|InternalProxy|InternalProxyList|ProxiesHeader|TrustedProxy|TrustedProxyList)|RemoveCharset|RemoveEncoding|RemoveHandler|RemoveInputFilter|RemoveLanguage|RemoveOutputFilter|RemoveType|RequestHeader|RequestReadTimeout|Require|Rewrite(?:Base|Cond|Engine|Map|Options|Rule)|RLimitCPU|RLimitMEM|RLimitNPROC|Satisfy|ScoreBoardFile|Script(?:Alias|AliasMatch|InterpreterSource|Log|LogBuffer|LogLength|Sock)?|SecureListen|SeeRequestTail|SendBufferSize|Server(?:Admin|Alias|Limit|Name|Path|Root|Signature|Tokens)|Session(?:Cookie(?:Name|Name2|Remove)|Crypto(?:Cipher|Driver|Passphrase|PassphraseFile)|DBD(?:CookieName|CookieName2|CookieRemove|DeleteLabel|InsertLabel|PerUser|SelectLabel|UpdateLabel)|Env|Exclude|Header|Include|MaxAge)?|SetEnv|SetEnvIf|SetEnvIfExpr|SetEnvIfNoCase|SetHandler|SetInputFilter|SetOutputFilter|SSIEndTag|SSIErrorMsg|SSIETag|SSILastModified|SSILegacyExprParser|SSIStartTag|SSITimeFormat|SSIUndefinedEcho|SSL(?:CACertificateFile|CACertificatePath|CADNRequestFile|CADNRequestPath|CARevocationCheck|CARevocationFile|CARevocationPath|CertificateChainFile|CertificateFile|CertificateKeyFile|CipherSuite|Compression|CryptoDevice|Engine|FIPS|HonorCipherOrder|InsecureRenegotiation|OCSP(?:DefaultResponder|Enable|OverrideResponder|ResponderTimeout|ResponseMaxAge|ResponseTimeSkew|UseRequestNonce)|OpenSSLConfCmd|Options|PassPhraseDialog|Protocol|Proxy(?:CACertificateFile|CACertificatePath|CARevocation(?:Check|File|Path)|CheckPeer(?:CN|Expire|Name)|CipherSuite|Engine|MachineCertificate(?:ChainFile|File|Path)|Protocol|Verify|VerifyDepth)|RandomSeed|RenegBufferSize|Require|RequireSSL|Session(?:Cache|CacheTimeout|TicketKeyFile|Tickets)|SRPUnknownUserSeed|SRPVerifierFile|Stapling(?:Cache|ErrorCacheTimeout|FakeTryLater|ForceURL|ResponderTimeout|ResponseMaxAge|ResponseTimeSkew|ReturnResponderErrors|StandardCacheTimeout)|StrictSNIVHostCheck|UserName|UseStapling|VerifyClient|VerifyDepth)|StartServers|StartThreads|Substitute|Suexec|SuexecUserGroup|ThreadLimit|ThreadsPerChild|ThreadStackSize|TimeOut|TraceEnable|TransferLog|TypesConfig|UnDefine|UndefMacro|UnsetEnv|Use|UseCanonicalName|UseCanonicalPhysicalPort|User|UserDir|VHostCGIMode|VHostCGIPrivs|VHostGroup|VHostPrivs|VHostSecure|VHostUser|Virtual(?:DocumentRoot|ScriptAlias)(?:IP)?|WatchdogInterval|XBitHack|xml2EncAlias|xml2EncDefault|xml2StartParse)\b/im,
					lookbehind: true,
					alias: 'property'
				},
				'directive-block': {
					pattern:
						/<\/?\b(?:Auth[nz]ProviderAlias|Directory|DirectoryMatch|Else|ElseIf|Files|FilesMatch|If|IfDefine|IfModule|IfVersion|Limit|LimitExcept|Location|LocationMatch|Macro|Proxy|Require(?:All|Any|None)|VirtualHost)\b.*>/i,
					inside: {
						'directive-block': {
							pattern: /^<\/?\w+/,
							inside: {
								punctuation: /^<\/?/
							},
							alias: 'tag'
						},
						'directive-block-parameter': {
							pattern: /.*[^>]/,
							inside: {
								punctuation: /:/,
								string: {
									pattern: /("|').*\1/,
									inside: {
										variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/
									}
								}
							},
							alias: 'attr-value'
						},
						punctuation: />/
					},
					alias: 'tag'
				},
				'directive-flags': {
					pattern: /\[(?:[\w=],?)+\]/,
					alias: 'keyword'
				},
				string: {
					pattern: /("|').*\1/,
					inside: {
						variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/
					}
				},
				variable: /[$%]\{?(?:\w\.?[-+:]?)+\}?/,
				regex: /\^?.*\$|\^.*\$?/
			};
		}
	}
});

// node_modules/refractor/lang/sql.js
var require_sql = __commonJS({
	'node_modules/refractor/lang/sql.js'(exports, module2) {
		'use strict';
		module2.exports = sql;
		sql.displayName = 'sql';
		sql.aliases = [];
		function sql(Prism) {
			Prism.languages.sql = {
				comment: {
					pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
					lookbehind: true
				},
				variable: [
					{
						pattern: /@(["'`])(?:\\[\s\S]|(?!\1)[^\\])+\1/,
						greedy: true
					},
					/@[\w.$]+/
				],
				string: {
					pattern: /(^|[^@\\])("|')(?:\\[\s\S]|(?!\2)[^\\]|\2\2)*\2/,
					greedy: true,
					lookbehind: true
				},
				identifier: {
					pattern: /(^|[^@\\])`(?:\\[\s\S]|[^`\\]|``)*`/,
					greedy: true,
					lookbehind: true,
					inside: {
						punctuation: /^`|`$/
					}
				},
				function:
					/\b(?:AVG|COUNT|FIRST|FORMAT|LAST|LCASE|LEN|MAX|MID|MIN|MOD|NOW|ROUND|SUM|UCASE)(?=\s*\()/i,
				keyword:
					/\b(?:ACTION|ADD|AFTER|ALGORITHM|ALL|ALTER|ANALYZE|ANY|APPLY|AS|ASC|AUTHORIZATION|AUTO_INCREMENT|BACKUP|BDB|BEGIN|BERKELEYDB|BIGINT|BINARY|BIT|BLOB|BOOL|BOOLEAN|BREAK|BROWSE|BTREE|BULK|BY|CALL|CASCADED?|CASE|CHAIN|CHAR(?:ACTER|SET)?|CHECK(?:POINT)?|CLOSE|CLUSTERED|COALESCE|COLLATE|COLUMNS?|COMMENT|COMMIT(?:TED)?|COMPUTE|CONNECT|CONSISTENT|CONSTRAINT|CONTAINS(?:TABLE)?|CONTINUE|CONVERT|CREATE|CROSS|CURRENT(?:_DATE|_TIME|_TIMESTAMP|_USER)?|CURSOR|CYCLE|DATA(?:BASES?)?|DATE(?:TIME)?|DAY|DBCC|DEALLOCATE|DEC|DECIMAL|DECLARE|DEFAULT|DEFINER|DELAYED|DELETE|DELIMITERS?|DENY|DESC|DESCRIBE|DETERMINISTIC|DISABLE|DISCARD|DISK|DISTINCT|DISTINCTROW|DISTRIBUTED|DO|DOUBLE|DROP|DUMMY|DUMP(?:FILE)?|DUPLICATE|ELSE(?:IF)?|ENABLE|ENCLOSED|END|ENGINE|ENUM|ERRLVL|ERRORS|ESCAPED?|EXCEPT|EXEC(?:UTE)?|EXISTS|EXIT|EXPLAIN|EXTENDED|FETCH|FIELDS|FILE|FILLFACTOR|FIRST|FIXED|FLOAT|FOLLOWING|FOR(?: EACH ROW)?|FORCE|FOREIGN|FREETEXT(?:TABLE)?|FROM|FULL|FUNCTION|GEOMETRY(?:COLLECTION)?|GLOBAL|GOTO|GRANT|GROUP|HANDLER|HASH|HAVING|HOLDLOCK|HOUR|IDENTITY(?:COL|_INSERT)?|IF|IGNORE|IMPORT|INDEX|INFILE|INNER|INNODB|INOUT|INSERT|INT|INTEGER|INTERSECT|INTERVAL|INTO|INVOKER|ISOLATION|ITERATE|JOIN|KEYS?|KILL|LANGUAGE|LAST|LEAVE|LEFT|LEVEL|LIMIT|LINENO|LINES|LINESTRING|LOAD|LOCAL|LOCK|LONG(?:BLOB|TEXT)|LOOP|MATCH(?:ED)?|MEDIUM(?:BLOB|INT|TEXT)|MERGE|MIDDLEINT|MINUTE|MODE|MODIFIES|MODIFY|MONTH|MULTI(?:LINESTRING|POINT|POLYGON)|NATIONAL|NATURAL|NCHAR|NEXT|NO|NONCLUSTERED|NULLIF|NUMERIC|OFF?|OFFSETS?|ON|OPEN(?:DATASOURCE|QUERY|ROWSET)?|OPTIMIZE|OPTION(?:ALLY)?|ORDER|OUT(?:ER|FILE)?|OVER|PARTIAL|PARTITION|PERCENT|PIVOT|PLAN|POINT|POLYGON|PRECEDING|PRECISION|PREPARE|PREV|PRIMARY|PRINT|PRIVILEGES|PROC(?:EDURE)?|PUBLIC|PURGE|QUICK|RAISERROR|READS?|REAL|RECONFIGURE|REFERENCES|RELEASE|RENAME|REPEAT(?:ABLE)?|REPLACE|REPLICATION|REQUIRE|RESIGNAL|RESTORE|RESTRICT|RETURN(?:ING|S)?|REVOKE|RIGHT|ROLLBACK|ROUTINE|ROW(?:COUNT|GUIDCOL|S)?|RTREE|RULE|SAVE(?:POINT)?|SCHEMA|SECOND|SELECT|SERIAL(?:IZABLE)?|SESSION(?:_USER)?|SET(?:USER)?|SHARE|SHOW|SHUTDOWN|SIMPLE|SMALLINT|SNAPSHOT|SOME|SONAME|SQL|START(?:ING)?|STATISTICS|STATUS|STRIPED|SYSTEM_USER|TABLES?|TABLESPACE|TEMP(?:ORARY|TABLE)?|TERMINATED|TEXT(?:SIZE)?|THEN|TIME(?:STAMP)?|TINY(?:BLOB|INT|TEXT)|TOP?|TRAN(?:SACTIONS?)?|TRIGGER|TRUNCATE|TSEQUAL|TYPES?|UNBOUNDED|UNCOMMITTED|UNDEFINED|UNION|UNIQUE|UNLOCK|UNPIVOT|UNSIGNED|UPDATE(?:TEXT)?|USAGE|USE|USER|USING|VALUES?|VAR(?:BINARY|CHAR|CHARACTER|YING)|VIEW|WAITFOR|WARNINGS|WHEN|WHERE|WHILE|WITH(?: ROLLUP|IN)?|WORK|WRITE(?:TEXT)?|YEAR)\b/i,
				boolean: /\b(?:FALSE|NULL|TRUE)\b/i,
				number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
				operator:
					/[-+*\/=%^~]|&&?|\|\|?|!=?|<(?:=>?|<|>)?|>[>=]?|\b(?:AND|BETWEEN|DIV|ILIKE|IN|IS|LIKE|NOT|OR|REGEXP|RLIKE|SOUNDS LIKE|XOR)\b/i,
				punctuation: /[;[\]()`,.]/
			};
		}
	}
});

// node_modules/refractor/lang/apex.js
var require_apex = __commonJS({
	'node_modules/refractor/lang/apex.js'(exports, module2) {
		'use strict';
		var refractorSql = require_sql();
		module2.exports = apex;
		apex.displayName = 'apex';
		apex.aliases = [];
		function apex(Prism) {
			Prism.register(refractorSql);
			(function (Prism2) {
				var keywords =
					/\b(?:(?:after|before)(?=\s+[a-z])|abstract|activate|and|any|array|as|asc|autonomous|begin|bigdecimal|blob|boolean|break|bulk|by|byte|case|cast|catch|char|class|collect|commit|const|continue|currency|date|datetime|decimal|default|delete|desc|do|double|else|end|enum|exception|exit|export|extends|final|finally|float|for|from|get(?=\s*[{};])|global|goto|group|having|hint|if|implements|import|in|inner|insert|instanceof|int|integer|interface|into|join|like|limit|list|long|loop|map|merge|new|not|null|nulls|number|object|of|on|or|outer|override|package|parallel|pragma|private|protected|public|retrieve|return|rollback|select|set|short|sObject|sort|static|string|super|switch|synchronized|system|testmethod|then|this|throw|time|transaction|transient|trigger|try|undelete|update|upsert|using|virtual|void|webservice|when|where|while|(?:inherited|with|without)\s+sharing)\b/i;
				var className =
					/\b(?:(?=[a-z_]\w*\s*[<\[])|(?!<keyword>))[A-Z_]\w*(?:\s*\.\s*[A-Z_]\w*)*\b(?:\s*(?:\[\s*\]|<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>))*/.source.replace(
						/<keyword>/g,
						function () {
							return keywords.source;
						}
					);
				function insertClassName(pattern) {
					return RegExp(
						pattern.replace(/<CLASS-NAME>/g, function () {
							return className;
						}),
						'i'
					);
				}
				var classNameInside = {
					keyword: keywords,
					punctuation: /[()\[\]{};,:.<>]/
				};
				Prism2.languages.apex = {
					comment: Prism2.languages.clike.comment,
					string: Prism2.languages.clike.string,
					sql: {
						pattern: /((?:[=,({:]|\breturn)\s*)\[[^\[\]]*\]/i,
						lookbehind: true,
						greedy: true,
						alias: 'language-sql',
						inside: Prism2.languages.sql
					},
					annotation: {
						pattern: /@\w+\b/,
						alias: 'punctuation'
					},
					'class-name': [
						{
							pattern: insertClassName(
								/(\b(?:class|enum|extends|implements|instanceof|interface|new|trigger\s+\w+\s+on)\s+)<CLASS-NAME>/
									.source
							),
							lookbehind: true,
							inside: classNameInside
						},
						{
							pattern: insertClassName(/(\(\s*)<CLASS-NAME>(?=\s*\)\s*[\w(])/.source),
							lookbehind: true,
							inside: classNameInside
						},
						{
							pattern: insertClassName(/<CLASS-NAME>(?=\s*\w+\s*[;=,(){:])/.source),
							inside: classNameInside
						}
					],
					trigger: {
						pattern: /(\btrigger\s+)\w+\b/i,
						lookbehind: true,
						alias: 'class-name'
					},
					keyword: keywords,
					function: /\b[a-z_]\w*(?=\s*\()/i,
					boolean: /\b(?:false|true)\b/i,
					number: /(?:\B\.\d+|\b\d+(?:\.\d+|L)?)\b/i,
					operator: /[!=](?:==?)?|\?\.?|&&|\|\||--|\+\+|[-+*/^&|]=?|:|<<?=?|>{1,3}=?/,
					punctuation: /[()\[\]{};,.]/
				};
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/apl.js
var require_apl = __commonJS({
	'node_modules/refractor/lang/apl.js'(exports, module2) {
		'use strict';
		module2.exports = apl;
		apl.displayName = 'apl';
		apl.aliases = [];
		function apl(Prism) {
			Prism.languages.apl = {
				comment: /(?:|#[! ]).*$/m,
				string: {
					pattern: /'(?:[^'\r\n]|'')*'/,
					greedy: true
				},
				number:
					/?(?:\d*\.?\b\d+(?:e[+]?\d+)?||)(?:j?(?:(?:\d+(?:\.\d+)?|\.\d+)(?:e[+]?\d+)?||))?/i,
				statement: /:[A-Z][a-z][A-Za-z]*\b/,
				'system-function': {
					pattern: /[A-Z]+/i,
					alias: 'function'
				},
				constant: /[#]/,
				function: /[-+|?*!<=>~,]/,
				'monadic-operator': {
					pattern: /[\\\/&]/,
					alias: 'operator'
				},
				'dyadic-operator': {
					pattern: /[.@]/,
					alias: 'operator'
				},
				assignment: {
					pattern: //,
					alias: 'keyword'
				},
				punctuation: /[\[;\]()]/,
				dfn: {
					pattern: /[{}:]/,
					alias: 'builtin'
				}
			};
		}
	}
});

// node_modules/refractor/lang/applescript.js
var require_applescript = __commonJS({
	'node_modules/refractor/lang/applescript.js'(exports, module2) {
		'use strict';
		module2.exports = applescript;
		applescript.displayName = 'applescript';
		applescript.aliases = [];
		function applescript(Prism) {
			Prism.languages.applescript = {
				comment: [/\(\*(?:\(\*(?:[^*]|\*(?!\)))*\*\)|(?!\(\*)[\s\S])*?\*\)/, /--.+/, /#.+/],
				string: /"(?:\\.|[^"\\\r\n])*"/,
				number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e-?\d+)?\b/i,
				operator: [
					/[&=*+\-\/^]|[<>]=?/,
					/\b(?:(?:begin|end|start)s? with|(?:contains?|(?:does not|doesn't) contain)|(?:is|isn't|is not) (?:contained by|in)|(?:(?:is|isn't|is not) )?(?:greater|less) than(?: or equal)?(?: to)?|(?:comes|(?:does not|doesn't) come) (?:after|before)|(?:is|isn't|is not) equal(?: to)?|(?:(?:does not|doesn't) equal|equal to|equals|is not|isn't)|(?:a )?(?:ref(?: to)?|reference to)|(?:and|as|div|mod|not|or))\b/
				],
				keyword:
					/\b(?:about|above|after|against|apart from|around|aside from|at|back|before|beginning|behind|below|beneath|beside|between|but|by|considering|continue|copy|does|eighth|else|end|equal|error|every|exit|false|fifth|first|for|fourth|from|front|get|given|global|if|ignoring|in|instead of|into|is|it|its|last|local|me|middle|my|ninth|of|on|onto|out of|over|prop|property|put|repeat|return|returning|second|set|seventh|since|sixth|some|tell|tenth|that|the|then|third|through|thru|timeout|times|to|transaction|true|try|until|where|while|whose|with|without)\b/,
				'class-name':
					/\b(?:POSIX file|RGB color|alias|application|boolean|centimeters|centimetres|class|constant|cubic centimeters|cubic centimetres|cubic feet|cubic inches|cubic meters|cubic metres|cubic yards|date|degrees Celsius|degrees Fahrenheit|degrees Kelvin|feet|file|gallons|grams|inches|integer|kilograms|kilometers|kilometres|list|liters|litres|meters|metres|miles|number|ounces|pounds|quarts|real|record|reference|script|square feet|square kilometers|square kilometres|square meters|square metres|square miles|square yards|text|yards)\b/,
				punctuation: /[{}():,]/
			};
		}
	}
});

// node_modules/refractor/lang/aql.js
var require_aql = __commonJS({
	'node_modules/refractor/lang/aql.js'(exports, module2) {
		'use strict';
		module2.exports = aql;
		aql.displayName = 'aql';
		aql.aliases = [];
		function aql(Prism) {
			Prism.languages.aql = {
				comment: /\/\/.*|\/\*[\s\S]*?\*\//,
				property: {
					pattern: /([{,]\s*)(?:(?!\d)\w+|(["'`])(?:(?!\2)[^\\\r\n]|\\.)*\2)(?=\s*:)/,
					lookbehind: true,
					greedy: true
				},
				string: {
					pattern: /(["'])(?:(?!\1)[^\\\r\n]|\\.)*\1/,
					greedy: true
				},
				identifier: {
					pattern: /([`])(?:(?!\1)[^\\\r\n]|\\.)*\1/,
					greedy: true
				},
				variable: /@@?\w+/,
				keyword: [
					{
						pattern: /(\bWITH\s+)COUNT(?=\s+INTO\b)/i,
						lookbehind: true
					},
					/\b(?:AGGREGATE|ALL|AND|ANY|ASC|COLLECT|DESC|DISTINCT|FILTER|FOR|GRAPH|IN|INBOUND|INSERT|INTO|K_PATHS|K_SHORTEST_PATHS|LET|LIKE|LIMIT|NONE|NOT|NULL|OR|OUTBOUND|REMOVE|REPLACE|RETURN|SHORTEST_PATH|SORT|UPDATE|UPSERT|WINDOW|WITH)\b/i,
					{
						pattern: /(^|[^\w.[])(?:KEEP|PRUNE|SEARCH|TO)\b/i,
						lookbehind: true
					},
					{
						pattern: /(^|[^\w.[])(?:CURRENT|NEW|OLD)\b/,
						lookbehind: true
					},
					{
						pattern: /\bOPTIONS(?=\s*\{)/i
					}
				],
				function: /\b(?!\d)\w+(?=\s*\()/,
				boolean: /\b(?:false|true)\b/i,
				range: {
					pattern: /\.\./,
					alias: 'operator'
				},
				number: [
					/\b0b[01]+/i,
					/\b0x[0-9a-f]+/i,
					/(?:\B\.\d+|\b(?:0|[1-9]\d*)(?:\.\d+)?)(?:e[+-]?\d+)?/i
				],
				operator: /\*{2,}|[=!]~|[!=<>]=?|&&|\|\||[-+*/%]/,
				punctuation: /::|[?.:,;()[\]{}]/
			};
		}
	}
});

// node_modules/refractor/lang/c.js
var require_c = __commonJS({
	'node_modules/refractor/lang/c.js'(exports, module2) {
		'use strict';
		module2.exports = c;
		c.displayName = 'c';
		c.aliases = [];
		function c(Prism) {
			Prism.languages.c = Prism.languages.extend('clike', {
				comment: {
					pattern: /\/\/(?:[^\r\n\\]|\\(?:\r\n?|\n|(?![\r\n])))*|\/\*[\s\S]*?(?:\*\/|$)/,
					greedy: true
				},
				string: {
					pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
					greedy: true
				},
				'class-name': {
					pattern:
						/(\b(?:enum|struct)\s+(?:__attribute__\s*\(\([\s\S]*?\)\)\s*)?)\w+|\b[a-z]\w*_t\b/,
					lookbehind: true
				},
				keyword:
					/\b(?:_Alignas|_Alignof|_Atomic|_Bool|_Complex|_Generic|_Imaginary|_Noreturn|_Static_assert|_Thread_local|__attribute__|asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|inline|int|long|register|return|short|signed|sizeof|static|struct|switch|typedef|typeof|union|unsigned|void|volatile|while)\b/,
				function: /\b[a-z_]\w*(?=\s*\()/i,
				number:
					/(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ful]{0,4}/i,
				operator: />>=?|<<=?|->|([-+&|:])\1|[?:~]|[-+*/%&|^!=<>]=?/
			});
			Prism.languages.insertBefore('c', 'string', {
				char: {
					pattern: /'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n]){0,32}'/,
					greedy: true
				}
			});
			Prism.languages.insertBefore('c', 'string', {
				macro: {
					pattern:
						/(^[\t ]*)#\s*[a-z](?:[^\r\n\\/]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|\\(?:\r\n|[\s\S]))*/im,
					lookbehind: true,
					greedy: true,
					alias: 'property',
					inside: {
						string: [
							{
								pattern: /^(#\s*include\s*)<[^>]+>/,
								lookbehind: true
							},
							Prism.languages.c['string']
						],
						char: Prism.languages.c['char'],
						comment: Prism.languages.c['comment'],
						'macro-name': [
							{
								pattern: /(^#\s*define\s+)\w+\b(?!\()/i,
								lookbehind: true
							},
							{
								pattern: /(^#\s*define\s+)\w+\b(?=\()/i,
								lookbehind: true,
								alias: 'function'
							}
						],
						directive: {
							pattern: /^(#\s*)[a-z]+/,
							lookbehind: true,
							alias: 'keyword'
						},
						'directive-hash': /^#/,
						punctuation: /##|\\(?=[\r\n])/,
						expression: {
							pattern: /\S[\s\S]*/,
							inside: Prism.languages.c
						}
					}
				}
			});
			Prism.languages.insertBefore('c', 'function', {
				constant:
					/\b(?:EOF|NULL|SEEK_CUR|SEEK_END|SEEK_SET|__DATE__|__FILE__|__LINE__|__TIMESTAMP__|__TIME__|__func__|stderr|stdin|stdout)\b/
			});
			delete Prism.languages.c['boolean'];
		}
	}
});

// node_modules/refractor/lang/cpp.js
var require_cpp = __commonJS({
	'node_modules/refractor/lang/cpp.js'(exports, module2) {
		'use strict';
		var refractorC = require_c();
		module2.exports = cpp;
		cpp.displayName = 'cpp';
		cpp.aliases = [];
		function cpp(Prism) {
			Prism.register(refractorC);
			(function (Prism2) {
				var keyword =
					/\b(?:alignas|alignof|asm|auto|bool|break|case|catch|char|char16_t|char32_t|char8_t|class|co_await|co_return|co_yield|compl|concept|const|const_cast|consteval|constexpr|constinit|continue|decltype|default|delete|do|double|dynamic_cast|else|enum|explicit|export|extern|final|float|for|friend|goto|if|import|inline|int|int16_t|int32_t|int64_t|int8_t|long|module|mutable|namespace|new|noexcept|nullptr|operator|override|private|protected|public|register|reinterpret_cast|requires|return|short|signed|sizeof|static|static_assert|static_cast|struct|switch|template|this|thread_local|throw|try|typedef|typeid|typename|uint16_t|uint32_t|uint64_t|uint8_t|union|unsigned|using|virtual|void|volatile|wchar_t|while)\b/;
				var modName = /\b(?!<keyword>)\w+(?:\s*\.\s*\w+)*\b/.source.replace(
					/<keyword>/g,
					function () {
						return keyword.source;
					}
				);
				Prism2.languages.cpp = Prism2.languages.extend('c', {
					'class-name': [
						{
							pattern: RegExp(
								/(\b(?:class|concept|enum|struct|typename)\s+)(?!<keyword>)\w+/.source.replace(
									/<keyword>/g,
									function () {
										return keyword.source;
									}
								)
							),
							lookbehind: true
						},
						/\b[A-Z]\w*(?=\s*::\s*\w+\s*\()/,
						/\b[A-Z_]\w*(?=\s*::\s*~\w+\s*\()/i,
						/\b\w+(?=\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>\s*::\s*\w+\s*\()/
					],
					keyword,
					number: {
						pattern:
							/(?:\b0b[01']+|\b0x(?:[\da-f']+(?:\.[\da-f']*)?|\.[\da-f']+)(?:p[+-]?[\d']+)?|(?:\b[\d']+(?:\.[\d']*)?|\B\.[\d']+)(?:e[+-]?[\d']+)?)[ful]{0,4}/i,
						greedy: true
					},
					operator:
						/>>=?|<<=?|->|--|\+\+|&&|\|\||[?:~]|<=>|[-+*/%&|^!=<>]=?|\b(?:and|and_eq|bitand|bitor|not|not_eq|or|or_eq|xor|xor_eq)\b/,
					boolean: /\b(?:false|true)\b/
				});
				Prism2.languages.insertBefore('cpp', 'string', {
					module: {
						pattern: RegExp(
							/(\b(?:import|module)\s+)/.source +
								'(?:' +
								/"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|<[^<>\r\n]*>/.source +
								'|' +
								/<mod-name>(?:\s*:\s*<mod-name>)?|:\s*<mod-name>/.source.replace(
									/<mod-name>/g,
									function () {
										return modName;
									}
								) +
								')'
						),
						lookbehind: true,
						greedy: true,
						inside: {
							string: /^[<"][\s\S]+/,
							operator: /:/,
							punctuation: /\./
						}
					},
					'raw-string': {
						pattern: /R"([^()\\ ]{0,16})\([\s\S]*?\)\1"/,
						alias: 'string',
						greedy: true
					}
				});
				Prism2.languages.insertBefore('cpp', 'keyword', {
					'generic-function': {
						pattern: /\b(?!operator\b)[a-z_]\w*\s*<(?:[^<>]|<[^<>]*>)*>(?=\s*\()/i,
						inside: {
							function: /^\w+/,
							generic: {
								pattern: /<[\s\S]+/,
								alias: 'class-name',
								inside: Prism2.languages.cpp
							}
						}
					}
				});
				Prism2.languages.insertBefore('cpp', 'operator', {
					'double-colon': {
						pattern: /::/,
						alias: 'punctuation'
					}
				});
				Prism2.languages.insertBefore('cpp', 'class-name', {
					'base-clause': {
						pattern: /(\b(?:class|struct)\s+\w+\s*:\s*)[^;{}"'\s]+(?:\s+[^;{}"'\s]+)*(?=\s*[;{])/,
						lookbehind: true,
						greedy: true,
						inside: Prism2.languages.extend('cpp', {})
					}
				});
				Prism2.languages.insertBefore(
					'inside',
					'double-colon',
					{
						'class-name': /\b[a-z_]\w*\b(?!\s*::)/i
					},
					Prism2.languages.cpp['base-clause']
				);
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/arduino.js
var require_arduino = __commonJS({
	'node_modules/refractor/lang/arduino.js'(exports, module2) {
		'use strict';
		var refractorCpp = require_cpp();
		module2.exports = arduino;
		arduino.displayName = 'arduino';
		arduino.aliases = ['ino'];
		function arduino(Prism) {
			Prism.register(refractorCpp);
			Prism.languages.arduino = Prism.languages.extend('cpp', {
				keyword:
					/\b(?:String|array|bool|boolean|break|byte|case|catch|continue|default|do|double|else|finally|for|function|goto|if|in|instanceof|int|integer|long|loop|new|null|return|setup|string|switch|throw|try|void|while|word)\b/,
				constant:
					/\b(?:ANALOG_MESSAGE|DEFAULT|DIGITAL_MESSAGE|EXTERNAL|FIRMATA_STRING|HIGH|INPUT|INPUT_PULLUP|INTERNAL|INTERNAL1V1|INTERNAL2V56|LED_BUILTIN|LOW|OUTPUT|REPORT_ANALOG|REPORT_DIGITAL|SET_PIN_MODE|SYSEX_START|SYSTEM_RESET)\b/,
				builtin:
					/\b(?:Audio|BSSID|Bridge|Client|Console|EEPROM|Esplora|EsploraTFT|Ethernet|EthernetClient|EthernetServer|EthernetUDP|File|FileIO|FileSystem|Firmata|GPRS|GSM|GSMBand|GSMClient|GSMModem|GSMPIN|GSMScanner|GSMServer|GSMVoiceCall|GSM_SMS|HttpClient|IPAddress|IRread|Keyboard|KeyboardController|LiquidCrystal|LiquidCrystal_I2C|Mailbox|Mouse|MouseController|PImage|Process|RSSI|RobotControl|RobotMotor|SD|SPI|SSID|Scheduler|Serial|Server|Servo|SoftwareSerial|Stepper|Stream|TFT|Task|USBHost|WiFi|WiFiClient|WiFiServer|WiFiUDP|Wire|YunClient|YunServer|abs|addParameter|analogRead|analogReadResolution|analogReference|analogWrite|analogWriteResolution|answerCall|attach|attachGPRS|attachInterrupt|attached|autoscroll|available|background|beep|begin|beginPacket|beginSD|beginSMS|beginSpeaker|beginTFT|beginTransmission|beginWrite|bit|bitClear|bitRead|bitSet|bitWrite|blink|blinkVersion|buffer|changePIN|checkPIN|checkPUK|checkReg|circle|cityNameRead|cityNameWrite|clear|clearScreen|click|close|compassRead|config|connect|connected|constrain|cos|countryNameRead|countryNameWrite|createChar|cursor|debugPrint|delay|delayMicroseconds|detach|detachInterrupt|digitalRead|digitalWrite|disconnect|display|displayLogos|drawBMP|drawCompass|encryptionType|end|endPacket|endSMS|endTransmission|endWrite|exists|exitValue|fill|find|findUntil|flush|gatewayIP|get|getAsynchronously|getBand|getButton|getCurrentCarrier|getIMEI|getKey|getModifiers|getOemKey|getPINUsed|getResult|getSignalStrength|getSocket|getVoiceCallStatus|getXChange|getYChange|hangCall|height|highByte|home|image|interrupts|isActionDone|isDirectory|isListening|isPIN|isPressed|isValid|keyPressed|keyReleased|keyboardRead|knobRead|leftToRight|line|lineFollowConfig|listen|listenOnLocalhost|loadImage|localIP|lowByte|macAddress|maintain|map|max|messageAvailable|micros|millis|min|mkdir|motorsStop|motorsWrite|mouseDragged|mouseMoved|mousePressed|mouseReleased|move|noAutoscroll|noBlink|noBuffer|noCursor|noDisplay|noFill|noInterrupts|noListenOnLocalhost|noStroke|noTone|onReceive|onRequest|open|openNextFile|overflow|parseCommand|parseFloat|parseInt|parsePacket|pauseMode|peek|pinMode|playFile|playMelody|point|pointTo|position|pow|prepare|press|print|printFirmwareVersion|printVersion|println|process|processInput|pulseIn|put|random|randomSeed|read|readAccelerometer|readBlue|readButton|readBytes|readBytesUntil|readGreen|readJoystickButton|readJoystickSwitch|readJoystickX|readJoystickY|readLightSensor|readMessage|readMicrophone|readNetworks|readRed|readSlider|readString|readStringUntil|readTemperature|ready|rect|release|releaseAll|remoteIP|remoteNumber|remotePort|remove|requestFrom|retrieveCallingNumber|rewindDirectory|rightToLeft|rmdir|robotNameRead|robotNameWrite|run|runAsynchronously|runShellCommand|runShellCommandAsynchronously|running|scanNetworks|scrollDisplayLeft|scrollDisplayRight|seek|sendAnalog|sendDigitalPortPair|sendDigitalPorts|sendString|sendSysex|serialEvent|setBand|setBitOrder|setClockDivider|setCursor|setDNS|setDataMode|setFirmwareVersion|setMode|setPINUsed|setSpeed|setTextSize|setTimeout|shiftIn|shiftOut|shutdown|sin|size|sqrt|startLoop|step|stop|stroke|subnetMask|switchPIN|tan|tempoWrite|text|tone|transfer|tuneWrite|turn|updateIR|userNameRead|userNameWrite|voiceCall|waitContinue|width|write|writeBlue|writeGreen|writeJSON|writeMessage|writeMicroseconds|writeRGB|writeRed|yield)\b/
			});
			Prism.languages.ino = Prism.languages.arduino;
		}
	}
});

// node_modules/refractor/lang/arff.js
var require_arff = __commonJS({
	'node_modules/refractor/lang/arff.js'(exports, module2) {
		'use strict';
		module2.exports = arff;
		arff.displayName = 'arff';
		arff.aliases = [];
		function arff(Prism) {
			Prism.languages.arff = {
				comment: /%.*/,
				string: {
					pattern: /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/,
					greedy: true
				},
				keyword: /@(?:attribute|data|end|relation)\b/i,
				number: /\b\d+(?:\.\d+)?\b/,
				punctuation: /[{},]/
			};
		}
	}
});

// node_modules/refractor/lang/asciidoc.js
var require_asciidoc = __commonJS({
	'node_modules/refractor/lang/asciidoc.js'(exports, module2) {
		'use strict';
		module2.exports = asciidoc;
		asciidoc.displayName = 'asciidoc';
		asciidoc.aliases = ['adoc'];
		function asciidoc(Prism) {
			(function (Prism2) {
				var attributes = {
					pattern:
						/(^[ \t]*)\[(?!\[)(?:(["'$`])(?:(?!\2)[^\\]|\\.)*\2|\[(?:[^\[\]\\]|\\.)*\]|[^\[\]\\"'$`]|\\.)*\]/m,
					lookbehind: true,
					inside: {
						quoted: {
							pattern: /([$`])(?:(?!\1)[^\\]|\\.)*\1/,
							inside: {
								punctuation: /^[$`]|[$`]$/
							}
						},
						interpreted: {
							pattern: /'(?:[^'\\]|\\.)*'/,
							inside: {
								punctuation: /^'|'$/
							}
						},
						string: /"(?:[^"\\]|\\.)*"/,
						variable: /\w+(?==)/,
						punctuation: /^\[|\]$|,/,
						operator: /=/,
						'attr-value': /(?!^\s+$).+/
					}
				};
				var asciidoc2 = (Prism2.languages.asciidoc = {
					'comment-block': {
						pattern: /^(\/{4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1/m,
						alias: 'comment'
					},
					table: {
						pattern: /^\|={3,}(?:(?:\r?\n|\r(?!\n)).*)*?(?:\r?\n|\r)\|={3,}$/m,
						inside: {
							specifiers: {
								pattern:
									/(?:(?:(?:\d+(?:\.\d+)?|\.\d+)[+*](?:[<^>](?:\.[<^>])?|\.[<^>])?|[<^>](?:\.[<^>])?|\.[<^>])[a-z]*|[a-z]+)(?=\|)/,
								alias: 'attr-value'
							},
							punctuation: {
								pattern: /(^|[^\\])[|!]=*/,
								lookbehind: true
							}
						}
					},
					'passthrough-block': {
						pattern: /^(\+{4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1$/m,
						inside: {
							punctuation: /^\++|\++$/
						}
					},
					'literal-block': {
						pattern: /^(-{4,}|\.{4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1$/m,
						inside: {
							punctuation: /^(?:-+|\.+)|(?:-+|\.+)$/
						}
					},
					'other-block': {
						pattern: /^(--|\*{4,}|_{4,}|={4,})(?:\r?\n|\r)(?:[\s\S]*(?:\r?\n|\r))??\1$/m,
						inside: {
							punctuation: /^(?:-+|\*+|_+|=+)|(?:-+|\*+|_+|=+)$/
						}
					},
					'list-punctuation': {
						pattern: /(^[ \t]*)(?:-|\*{1,5}|\.{1,5}|(?:[a-z]|\d+)\.|[xvi]+\))(?= )/im,
						lookbehind: true,
						alias: 'punctuation'
					},
					'list-label': {
						pattern: /(^[ \t]*)[a-z\d].+(?::{2,4}|;;)(?=\s)/im,
						lookbehind: true,
						alias: 'symbol'
					},
					'indented-block': {
						pattern: /((\r?\n|\r)\2)([ \t]+)\S.*(?:(?:\r?\n|\r)\3.+)*(?=\2{2}|$)/,
						lookbehind: true
					},
					comment: /^\/\/.*/m,
					title: {
						pattern:
							/^.+(?:\r?\n|\r)(?:={3,}|-{3,}|~{3,}|\^{3,}|\+{3,})$|^={1,5} .+|^\.(?![\s.]).*/m,
						alias: 'important',
						inside: {
							punctuation: /^(?:\.|=+)|(?:=+|-+|~+|\^+|\++)$/
						}
					},
					'attribute-entry': {
						pattern: /^:[^:\r\n]+:(?: .*?(?: \+(?:\r?\n|\r).*?)*)?$/m,
						alias: 'tag'
					},
					attributes,
					hr: {
						pattern: /^'{3,}$/m,
						alias: 'punctuation'
					},
					'page-break': {
						pattern: /^<{3,}$/m,
						alias: 'punctuation'
					},
					admonition: {
						pattern: /^(?:CAUTION|IMPORTANT|NOTE|TIP|WARNING):/m,
						alias: 'keyword'
					},
					callout: [
						{
							pattern: /(^[ \t]*)<?\d*>/m,
							lookbehind: true,
							alias: 'symbol'
						},
						{
							pattern: /<\d+>/,
							alias: 'symbol'
						}
					],
					macro: {
						pattern:
							/\b[a-z\d][a-z\d-]*::?(?:[^\s\[\]]*\[(?:[^\]\\"']|(["'])(?:(?!\1)[^\\]|\\.)*\1|\\.)*\])/,
						inside: {
							function: /^[a-z\d-]+(?=:)/,
							punctuation: /^::?/,
							attributes: {
								pattern: /(?:\[(?:[^\]\\"']|(["'])(?:(?!\1)[^\\]|\\.)*\1|\\.)*\])/,
								inside: attributes.inside
							}
						}
					},
					inline: {
						pattern:
							/(^|[^\\])(?:(?:\B\[(?:[^\]\\"']|(["'])(?:(?!\2)[^\\]|\\.)*\2|\\.)*\])?(?:\b_(?!\s)(?: _|[^_\\\r\n]|\\.)+(?:(?:\r?\n|\r)(?: _|[^_\\\r\n]|\\.)+)*_\b|\B``(?!\s).+?(?:(?:\r?\n|\r).+?)*''\B|\B`(?!\s)(?:[^`'\s]|\s+\S)+['`]\B|\B(['*+#])(?!\s)(?: \3|(?!\3)[^\\\r\n]|\\.)+(?:(?:\r?\n|\r)(?: \3|(?!\3)[^\\\r\n]|\\.)+)*\3\B)|(?:\[(?:[^\]\\"']|(["'])(?:(?!\4)[^\\]|\\.)*\4|\\.)*\])?(?:(__|\*\*|\+\+\+?|##|\$\$|[~^]).+?(?:(?:\r?\n|\r).+?)*\5|\{[^}\r\n]+\}|\[\[\[?.+?(?:(?:\r?\n|\r).+?)*\]?\]\]|<<.+?(?:(?:\r?\n|\r).+?)*>>|\(\(\(?.+?(?:(?:\r?\n|\r).+?)*\)?\)\)))/m,
						lookbehind: true,
						inside: {
							attributes,
							url: {
								pattern: /^(?:\[\[\[?.+?\]?\]\]|<<.+?>>)$/,
								inside: {
									punctuation: /^(?:\[\[\[?|<<)|(?:\]\]\]?|>>)$/
								}
							},
							'attribute-ref': {
								pattern: /^\{.+\}$/,
								inside: {
									variable: {
										pattern: /(^\{)[a-z\d,+_-]+/,
										lookbehind: true
									},
									operator: /^[=?!#%@$]|!(?=[:}])/,
									punctuation: /^\{|\}$|::?/
								}
							},
							italic: {
								pattern: /^(['_])[\s\S]+\1$/,
								inside: {
									punctuation: /^(?:''?|__?)|(?:''?|__?)$/
								}
							},
							bold: {
								pattern: /^\*[\s\S]+\*$/,
								inside: {
									punctuation: /^\*\*?|\*\*?$/
								}
							},
							punctuation:
								/^(?:``?|\+{1,3}|##?|\$\$|[~^]|\(\(\(?)|(?:''?|\+{1,3}|##?|\$\$|[~^`]|\)?\)\))$/
						}
					},
					replacement: {
						pattern: /\((?:C|R|TM)\)/,
						alias: 'builtin'
					},
					entity: /&#?[\da-z]{1,8};/i,
					'line-continuation': {
						pattern: /(^| )\+$/m,
						lookbehind: true,
						alias: 'punctuation'
					}
				});
				function copyFromAsciiDoc(keys2) {
					keys2 = keys2.split(' ');
					var o = {};
					for (var i2 = 0, l = keys2.length; i2 < l; i2++) {
						o[keys2[i2]] = asciidoc2[keys2[i2]];
					}
					return o;
				}
				attributes.inside['interpreted'].inside.rest = copyFromAsciiDoc(
					'macro inline replacement entity'
				);
				asciidoc2['passthrough-block'].inside.rest = copyFromAsciiDoc('macro');
				asciidoc2['literal-block'].inside.rest = copyFromAsciiDoc('callout');
				asciidoc2['table'].inside.rest = copyFromAsciiDoc(
					'comment-block passthrough-block literal-block other-block list-punctuation indented-block comment title attribute-entry attributes hr page-break admonition list-label callout macro inline replacement entity line-continuation'
				);
				asciidoc2['other-block'].inside.rest = copyFromAsciiDoc(
					'table list-punctuation indented-block comment attribute-entry attributes hr page-break admonition list-label macro inline replacement entity line-continuation'
				);
				asciidoc2['title'].inside.rest = copyFromAsciiDoc('macro inline replacement entity');
				Prism2.hooks.add('wrap', function (env) {
					if (env.type === 'entity') {
						env.attributes['title'] = env.content.value.replace(/&amp;/, '&');
					}
				});
				Prism2.languages.adoc = Prism2.languages.asciidoc;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/asm6502.js
var require_asm6502 = __commonJS({
	'node_modules/refractor/lang/asm6502.js'(exports, module2) {
		'use strict';
		module2.exports = asm6502;
		asm6502.displayName = 'asm6502';
		asm6502.aliases = [];
		function asm6502(Prism) {
			Prism.languages.asm6502 = {
				comment: /;.*/,
				directive: {
					pattern: /\.\w+(?= )/,
					alias: 'property'
				},
				string: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
				'op-code': {
					pattern:
						/\b(?:ADC|AND|ASL|BCC|BCS|BEQ|BIT|BMI|BNE|BPL|BRK|BVC|BVS|CLC|CLD|CLI|CLV|CMP|CPX|CPY|DEC|DEX|DEY|EOR|INC|INX|INY|JMP|JSR|LDA|LDX|LDY|LSR|NOP|ORA|PHA|PHP|PLA|PLP|ROL|ROR|RTI|RTS|SBC|SEC|SED|SEI|STA|STX|STY|TAX|TAY|TSX|TXA|TXS|TYA|adc|and|asl|bcc|bcs|beq|bit|bmi|bne|bpl|brk|bvc|bvs|clc|cld|cli|clv|cmp|cpx|cpy|dec|dex|dey|eor|inc|inx|iny|jmp|jsr|lda|ldx|ldy|lsr|nop|ora|pha|php|pla|plp|rol|ror|rti|rts|sbc|sec|sed|sei|sta|stx|sty|tax|tay|tsx|txa|txs|tya)\b/,
					alias: 'keyword'
				},
				'hex-number': {
					pattern: /#?\$[\da-f]{1,4}\b/i,
					alias: 'number'
				},
				'binary-number': {
					pattern: /#?%[01]+\b/,
					alias: 'number'
				},
				'decimal-number': {
					pattern: /#?\b\d+\b/,
					alias: 'number'
				},
				register: {
					pattern: /\b[xya]\b/i,
					alias: 'variable'
				},
				punctuation: /[(),:]/
			};
		}
	}
});

// node_modules/refractor/lang/asmatmel.js
var require_asmatmel = __commonJS({
	'node_modules/refractor/lang/asmatmel.js'(exports, module2) {
		'use strict';
		module2.exports = asmatmel;
		asmatmel.displayName = 'asmatmel';
		asmatmel.aliases = [];
		function asmatmel(Prism) {
			Prism.languages.asmatmel = {
				comment: {
					pattern: /;.*/,
					greedy: true
				},
				string: {
					pattern: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
					greedy: true
				},
				constant: /\b(?:PORT[A-Z]|DDR[A-Z]|(?:DD|P)[A-Z](?:\d|[0-2]\d|3[01]))\b/,
				directive: {
					pattern: /\.\w+(?= )/,
					alias: 'property'
				},
				'r-register': {
					pattern: /\br(?:\d|[12]\d|3[01])\b/,
					alias: 'variable'
				},
				'op-code': {
					pattern:
						/\b(?:ADC|ADD|ADIW|AND|ANDI|ASR|BCLR|BLD|BRBC|BRBS|BRCC|BRCS|BREAK|BREQ|BRGE|BRHC|BRHS|BRID|BRIE|BRLO|BRLT|BRMI|BRNE|BRPL|BRSH|BRTC|BRTS|BRVC|BRVS|BSET|BST|CALL|CBI|CBR|CLC|CLH|CLI|CLN|CLR|CLS|CLT|CLV|CLZ|COM|CP|CPC|CPI|CPSE|DEC|DES|EICALL|EIJMP|ELPM|EOR|FMUL|FMULS|FMULSU|ICALL|IJMP|IN|INC|JMP|LAC|LAS|LAT|LD|LD[A-Za-z0-9]|LPM|LSL|LSR|MOV|MOVW|MUL|MULS|MULSU|NEG|NOP|OR|ORI|OUT|POP|PUSH|RCALL|RET|RETI|RJMP|ROL|ROR|SBC|SBCI|SBI|SBIC|SBIS|SBIW|SBR|SBRC|SBRS|SEC|SEH|SEI|SEN|SER|SES|SET|SEV|SEZ|SLEEP|SPM|ST|ST[A-Z0-9]|SUB|SUBI|SWAP|TST|WDR|XCH|adc|add|adiw|and|andi|asr|bclr|bld|brbc|brbs|brcc|brcs|break|breq|brge|brhc|brhs|brid|brie|brlo|brlt|brmi|brne|brpl|brsh|brtc|brts|brvc|brvs|bset|bst|call|cbi|cbr|clc|clh|cli|cln|clr|cls|clt|clv|clz|com|cp|cpc|cpi|cpse|dec|des|eicall|eijmp|elpm|eor|fmul|fmuls|fmulsu|icall|ijmp|in|inc|jmp|lac|las|lat|ld|ld[a-z0-9]|lpm|lsl|lsr|mov|movw|mul|muls|mulsu|neg|nop|or|ori|out|pop|push|rcall|ret|reti|rjmp|rol|ror|sbc|sbci|sbi|sbic|sbis|sbiw|sbr|sbrc|sbrs|sec|seh|sei|sen|ser|ses|set|sev|sez|sleep|spm|st|st[a-zA-Z0-9]|sub|subi|swap|tst|wdr|xch)\b/,
					alias: 'keyword'
				},
				'hex-number': {
					pattern: /#?\$[\da-f]{2,4}\b/i,
					alias: 'number'
				},
				'binary-number': {
					pattern: /#?%[01]+\b/,
					alias: 'number'
				},
				'decimal-number': {
					pattern: /#?\b\d+\b/,
					alias: 'number'
				},
				register: {
					pattern: /\b[acznvshtixy]\b/i,
					alias: 'variable'
				},
				operator: />>=?|<<=?|&&?|\|\|?|[-+*/%&|^!=<>?]=?/,
				punctuation: /[(),:]/
			};
		}
	}
});

// node_modules/refractor/lang/csharp.js
var require_csharp = __commonJS({
	'node_modules/refractor/lang/csharp.js'(exports, module2) {
		'use strict';
		module2.exports = csharp;
		csharp.displayName = 'csharp';
		csharp.aliases = ['dotnet', 'cs'];
		function csharp(Prism) {
			(function (Prism2) {
				function replace(pattern, replacements) {
					return pattern.replace(/<<(\d+)>>/g, function (m2, index6) {
						return '(?:' + replacements[+index6] + ')';
					});
				}
				function re(pattern, replacements, flags) {
					return RegExp(replace(pattern, replacements), flags || '');
				}
				function nested(pattern, depthLog2) {
					for (var i2 = 0; i2 < depthLog2; i2++) {
						pattern = pattern.replace(/<<self>>/g, function () {
							return '(?:' + pattern + ')';
						});
					}
					return pattern.replace(/<<self>>/g, '[^\\s\\S]');
				}
				var keywordKinds = {
					type: 'bool byte char decimal double dynamic float int long object sbyte short string uint ulong ushort var void',
					typeDeclaration: 'class enum interface record struct',
					contextual:
						'add alias and ascending async await by descending from(?=\\s*(?:\\w|$)) get global group into init(?=\\s*;) join let nameof not notnull on or orderby partial remove select set unmanaged value when where with(?=\\s*{)',
					other:
						'abstract as base break case catch checked const continue default delegate do else event explicit extern finally fixed for foreach goto if implicit in internal is lock namespace new null operator out override params private protected public readonly ref return sealed sizeof stackalloc static switch this throw try typeof unchecked unsafe using virtual volatile while yield'
				};
				function keywordsToPattern(words) {
					return '\\b(?:' + words.trim().replace(/ /g, '|') + ')\\b';
				}
				var typeDeclarationKeywords = keywordsToPattern(keywordKinds.typeDeclaration);
				var keywords = RegExp(
					keywordsToPattern(
						keywordKinds.type +
							' ' +
							keywordKinds.typeDeclaration +
							' ' +
							keywordKinds.contextual +
							' ' +
							keywordKinds.other
					)
				);
				var nonTypeKeywords = keywordsToPattern(
					keywordKinds.typeDeclaration + ' ' + keywordKinds.contextual + ' ' + keywordKinds.other
				);
				var nonContextualKeywords = keywordsToPattern(
					keywordKinds.type + ' ' + keywordKinds.typeDeclaration + ' ' + keywordKinds.other
				);
				var generic = nested(/<(?:[^<>;=+\-*/%&|^]|<<self>>)*>/.source, 2);
				var nestedRound = nested(/\((?:[^()]|<<self>>)*\)/.source, 2);
				var name = /@?\b[A-Za-z_]\w*\b/.source;
				var genericName = replace(/<<0>>(?:\s*<<1>>)?/.source, [name, generic]);
				var identifier = replace(/(?!<<0>>)<<1>>(?:\s*\.\s*<<1>>)*/.source, [
					nonTypeKeywords,
					genericName
				]);
				var array2 = /\[\s*(?:,\s*)*\]/.source;
				var typeExpressionWithoutTuple = replace(/<<0>>(?:\s*(?:\?\s*)?<<1>>)*(?:\s*\?)?/.source, [
					identifier,
					array2
				]);
				var tupleElement = replace(/[^,()<>[\];=+\-*/%&|^]|<<0>>|<<1>>|<<2>>/.source, [
					generic,
					nestedRound,
					array2
				]);
				var tuple = replace(/\(<<0>>+(?:,<<0>>+)+\)/.source, [tupleElement]);
				var typeExpression = replace(/(?:<<0>>|<<1>>)(?:\s*(?:\?\s*)?<<2>>)*(?:\s*\?)?/.source, [
					tuple,
					identifier,
					array2
				]);
				var typeInside = {
					keyword: keywords,
					punctuation: /[<>()?,.:[\]]/
				};
				var character = /'(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'/.source;
				var regularString = /"(?:\\.|[^\\"\r\n])*"/.source;
				var verbatimString = /@"(?:""|\\[\s\S]|[^\\"])*"(?!")/.source;
				Prism2.languages.csharp = Prism2.languages.extend('clike', {
					string: [
						{
							pattern: re(/(^|[^$\\])<<0>>/.source, [verbatimString]),
							lookbehind: true,
							greedy: true
						},
						{
							pattern: re(/(^|[^@$\\])<<0>>/.source, [regularString]),
							lookbehind: true,
							greedy: true
						}
					],
					'class-name': [
						{
							pattern: re(/(\busing\s+static\s+)<<0>>(?=\s*;)/.source, [identifier]),
							lookbehind: true,
							inside: typeInside
						},
						{
							pattern: re(/(\busing\s+<<0>>\s*=\s*)<<1>>(?=\s*;)/.source, [name, typeExpression]),
							lookbehind: true,
							inside: typeInside
						},
						{
							pattern: re(/(\busing\s+)<<0>>(?=\s*=)/.source, [name]),
							lookbehind: true
						},
						{
							pattern: re(/(\b<<0>>\s+)<<1>>/.source, [typeDeclarationKeywords, genericName]),
							lookbehind: true,
							inside: typeInside
						},
						{
							pattern: re(/(\bcatch\s*\(\s*)<<0>>/.source, [identifier]),
							lookbehind: true,
							inside: typeInside
						},
						{
							pattern: re(/(\bwhere\s+)<<0>>/.source, [name]),
							lookbehind: true
						},
						{
							pattern: re(/(\b(?:is(?:\s+not)?|as)\s+)<<0>>/.source, [typeExpressionWithoutTuple]),
							lookbehind: true,
							inside: typeInside
						},
						{
							pattern: re(
								/\b<<0>>(?=\s+(?!<<1>>|with\s*\{)<<2>>(?:\s*[=,;:{)\]]|\s+(?:in|when)\b))/.source,
								[typeExpression, nonContextualKeywords, name]
							),
							inside: typeInside
						}
					],
					keyword: keywords,
					number:
						/(?:\b0(?:x[\da-f_]*[\da-f]|b[01_]*[01])|(?:\B\.\d+(?:_+\d+)*|\b\d+(?:_+\d+)*(?:\.\d+(?:_+\d+)*)?)(?:e[-+]?\d+(?:_+\d+)*)?)(?:[dflmu]|lu|ul)?\b/i,
					operator: />>=?|<<=?|[-=]>|([-+&|])\1|~|\?\?=?|[-+*/%&|^!=<>]=?/,
					punctuation: /\?\.?|::|[{}[\];(),.:]/
				});
				Prism2.languages.insertBefore('csharp', 'number', {
					range: {
						pattern: /\.\./,
						alias: 'operator'
					}
				});
				Prism2.languages.insertBefore('csharp', 'punctuation', {
					'named-parameter': {
						pattern: re(/([(,]\s*)<<0>>(?=\s*:)/.source, [name]),
						lookbehind: true,
						alias: 'punctuation'
					}
				});
				Prism2.languages.insertBefore('csharp', 'class-name', {
					namespace: {
						pattern: re(/(\b(?:namespace|using)\s+)<<0>>(?:\s*\.\s*<<0>>)*(?=\s*[;{])/.source, [
							name
						]),
						lookbehind: true,
						inside: {
							punctuation: /\./
						}
					},
					'type-expression': {
						pattern: re(
							/(\b(?:default|sizeof|typeof)\s*\(\s*(?!\s))(?:[^()\s]|\s(?!\s)|<<0>>)*(?=\s*\))/
								.source,
							[nestedRound]
						),
						lookbehind: true,
						alias: 'class-name',
						inside: typeInside
					},
					'return-type': {
						pattern: re(/<<0>>(?=\s+(?:<<1>>\s*(?:=>|[({]|\.\s*this\s*\[)|this\s*\[))/.source, [
							typeExpression,
							identifier
						]),
						inside: typeInside,
						alias: 'class-name'
					},
					'constructor-invocation': {
						pattern: re(/(\bnew\s+)<<0>>(?=\s*[[({])/.source, [typeExpression]),
						lookbehind: true,
						inside: typeInside,
						alias: 'class-name'
					},
					'generic-method': {
						pattern: re(/<<0>>\s*<<1>>(?=\s*\()/.source, [name, generic]),
						inside: {
							function: re(/^<<0>>/.source, [name]),
							generic: {
								pattern: RegExp(generic),
								alias: 'class-name',
								inside: typeInside
							}
						}
					},
					'type-list': {
						pattern: re(
							/\b((?:<<0>>\s+<<1>>|record\s+<<1>>\s*<<5>>|where\s+<<2>>)\s*:\s*)(?:<<3>>|<<4>>|<<1>>\s*<<5>>|<<6>>)(?:\s*,\s*(?:<<3>>|<<4>>|<<6>>))*(?=\s*(?:where|[{;]|=>|$))/
								.source,
							[
								typeDeclarationKeywords,
								genericName,
								name,
								typeExpression,
								keywords.source,
								nestedRound,
								/\bnew\s*\(\s*\)/.source
							]
						),
						lookbehind: true,
						inside: {
							'record-arguments': {
								pattern: re(/(^(?!new\s*\()<<0>>\s*)<<1>>/.source, [genericName, nestedRound]),
								lookbehind: true,
								greedy: true,
								inside: Prism2.languages.csharp
							},
							keyword: keywords,
							'class-name': {
								pattern: RegExp(typeExpression),
								greedy: true,
								inside: typeInside
							},
							punctuation: /[,()]/
						}
					},
					preprocessor: {
						pattern: /(^[\t ]*)#.*/m,
						lookbehind: true,
						alias: 'property',
						inside: {
							directive: {
								pattern:
									/(#)\b(?:define|elif|else|endif|endregion|error|if|line|nullable|pragma|region|undef|warning)\b/,
								lookbehind: true,
								alias: 'keyword'
							}
						}
					}
				});
				var regularStringOrCharacter = regularString + '|' + character;
				var regularStringCharacterOrComment = replace(
					/\/(?![*/])|\/\/[^\r\n]*[\r\n]|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>/.source,
					[regularStringOrCharacter]
				);
				var roundExpression = nested(
					replace(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]),
					2
				);
				var attrTarget = /\b(?:assembly|event|field|method|module|param|property|return|type)\b/
					.source;
				var attr = replace(/<<0>>(?:\s*\(<<1>>*\))?/.source, [identifier, roundExpression]);
				Prism2.languages.insertBefore('csharp', 'class-name', {
					attribute: {
						pattern: re(
							/((?:^|[^\s\w>)?])\s*\[\s*)(?:<<0>>\s*:\s*)?<<1>>(?:\s*,\s*<<1>>)*(?=\s*\])/.source,
							[attrTarget, attr]
						),
						lookbehind: true,
						greedy: true,
						inside: {
							target: {
								pattern: re(/^<<0>>(?=\s*:)/.source, [attrTarget]),
								alias: 'keyword'
							},
							'attribute-arguments': {
								pattern: re(/\(<<0>>*\)/.source, [roundExpression]),
								inside: Prism2.languages.csharp
							},
							'class-name': {
								pattern: RegExp(identifier),
								inside: {
									punctuation: /\./
								}
							},
							punctuation: /[:,]/
						}
					}
				});
				var formatString = /:[^}\r\n]+/.source;
				var mInterpolationRound = nested(
					replace(/[^"'/()]|<<0>>|\(<<self>>*\)/.source, [regularStringCharacterOrComment]),
					2
				);
				var mInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [
					mInterpolationRound,
					formatString
				]);
				var sInterpolationRound = nested(
					replace(/[^"'/()]|\/(?!\*)|\/\*(?:[^*]|\*(?!\/))*\*\/|<<0>>|\(<<self>>*\)/.source, [
						regularStringOrCharacter
					]),
					2
				);
				var sInterpolation = replace(/\{(?!\{)(?:(?![}:])<<0>>)*<<1>>?\}/.source, [
					sInterpolationRound,
					formatString
				]);
				function createInterpolationInside(interpolation, interpolationRound) {
					return {
						interpolation: {
							pattern: re(/((?:^|[^{])(?:\{\{)*)<<0>>/.source, [interpolation]),
							lookbehind: true,
							inside: {
								'format-string': {
									pattern: re(/(^\{(?:(?![}:])<<0>>)*)<<1>>(?=\}$)/.source, [
										interpolationRound,
										formatString
									]),
									lookbehind: true,
									inside: {
										punctuation: /^:/
									}
								},
								punctuation: /^\{|\}$/,
								expression: {
									pattern: /[\s\S]+/,
									alias: 'language-csharp',
									inside: Prism2.languages.csharp
								}
							}
						},
						string: /[\s\S]+/
					};
				}
				Prism2.languages.insertBefore('csharp', 'string', {
					'interpolation-string': [
						{
							pattern: re(/(^|[^\\])(?:\$@|@\$)"(?:""|\\[\s\S]|\{\{|<<0>>|[^\\{"])*"/.source, [
								mInterpolation
							]),
							lookbehind: true,
							greedy: true,
							inside: createInterpolationInside(mInterpolation, mInterpolationRound)
						},
						{
							pattern: re(/(^|[^@\\])\$"(?:\\.|\{\{|<<0>>|[^\\"{])*"/.source, [sInterpolation]),
							lookbehind: true,
							greedy: true,
							inside: createInterpolationInside(sInterpolation, sInterpolationRound)
						}
					],
					char: {
						pattern: RegExp(character),
						greedy: true
					}
				});
				Prism2.languages.dotnet = Prism2.languages.cs = Prism2.languages.csharp;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/aspnet.js
var require_aspnet = __commonJS({
	'node_modules/refractor/lang/aspnet.js'(exports, module2) {
		'use strict';
		var refractorCsharp = require_csharp();
		module2.exports = aspnet;
		aspnet.displayName = 'aspnet';
		aspnet.aliases = [];
		function aspnet(Prism) {
			Prism.register(refractorCsharp);
			Prism.languages.aspnet = Prism.languages.extend('markup', {
				'page-directive': {
					pattern: /<%\s*@.*%>/,
					alias: 'tag',
					inside: {
						'page-directive': {
							pattern:
								/<%\s*@\s*(?:Assembly|Control|Implements|Import|Master(?:Type)?|OutputCache|Page|PreviousPageType|Reference|Register)?|%>/i,
							alias: 'tag'
						},
						rest: Prism.languages.markup.tag.inside
					}
				},
				directive: {
					pattern: /<%.*%>/,
					alias: 'tag',
					inside: {
						directive: {
							pattern: /<%\s*?[$=%#:]{0,2}|%>/,
							alias: 'tag'
						},
						rest: Prism.languages.csharp
					}
				}
			});
			Prism.languages.aspnet.tag.pattern =
				/<(?!%)\/?[^\s>\/]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/;
			Prism.languages.insertBefore(
				'inside',
				'punctuation',
				{
					directive: Prism.languages.aspnet['directive']
				},
				Prism.languages.aspnet.tag.inside['attr-value']
			);
			Prism.languages.insertBefore('aspnet', 'comment', {
				'asp-comment': {
					pattern: /<%--[\s\S]*?--%>/,
					alias: ['asp', 'comment']
				}
			});
			Prism.languages.insertBefore('aspnet', Prism.languages.javascript ? 'script' : 'tag', {
				'asp-script': {
					pattern: /(<script(?=.*runat=['"]?server\b)[^>]*>)[\s\S]*?(?=<\/script>)/i,
					lookbehind: true,
					alias: ['asp', 'script'],
					inside: Prism.languages.csharp || {}
				}
			});
		}
	}
});

// node_modules/refractor/lang/autohotkey.js
var require_autohotkey = __commonJS({
	'node_modules/refractor/lang/autohotkey.js'(exports, module2) {
		'use strict';
		module2.exports = autohotkey;
		autohotkey.displayName = 'autohotkey';
		autohotkey.aliases = [];
		function autohotkey(Prism) {
			Prism.languages.autohotkey = {
				comment: [
					{
						pattern: /(^|\s);.*/,
						lookbehind: true
					},
					{
						pattern: /(^[\t ]*)\/\*(?:[\r\n](?![ \t]*\*\/)|[^\r\n])*(?:[\r\n][ \t]*\*\/)?/m,
						lookbehind: true,
						greedy: true
					}
				],
				tag: {
					pattern: /^([ \t]*)[^\s,`":]+(?=:[ \t]*$)/m,
					lookbehind: true
				},
				string: /"(?:[^"\n\r]|"")*"/,
				variable: /%\w+%/,
				number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
				operator:
					/\?|\/\/?=?|:=|\|[=|]?|&[=&]?|\+[=+]?|-[=-]?|\*[=*]?|<(?:<=?|>|=)?|>>?=?|[.^!=~]=?|\b(?:AND|NOT|OR)\b/,
				boolean: /\b(?:false|true)\b/,
				selector:
					/\b(?:AutoTrim|BlockInput|Break|Click|ClipWait|Continue|Control|ControlClick|ControlFocus|ControlGet|ControlGetFocus|ControlGetPos|ControlGetText|ControlMove|ControlSend|ControlSendRaw|ControlSetText|CoordMode|Critical|DetectHiddenText|DetectHiddenWindows|Drive|DriveGet|DriveSpaceFree|EnvAdd|EnvDiv|EnvGet|EnvMult|EnvSet|EnvSub|EnvUpdate|Exit|ExitApp|FileAppend|FileCopy|FileCopyDir|FileCreateDir|FileCreateShortcut|FileDelete|FileEncoding|FileGetAttrib|FileGetShortcut|FileGetSize|FileGetTime|FileGetVersion|FileInstall|FileMove|FileMoveDir|FileRead|FileReadLine|FileRecycle|FileRecycleEmpty|FileRemoveDir|FileSelectFile|FileSelectFolder|FileSetAttrib|FileSetTime|FormatTime|GetKeyState|Gosub|Goto|GroupActivate|GroupAdd|GroupClose|GroupDeactivate|Gui|GuiControl|GuiControlGet|Hotkey|ImageSearch|IniDelete|IniRead|IniWrite|Input|InputBox|KeyWait|ListHotkeys|ListLines|ListVars|Loop|Menu|MouseClick|MouseClickDrag|MouseGetPos|MouseMove|MsgBox|OnExit|OutputDebug|Pause|PixelGetColor|PixelSearch|PostMessage|Process|Progress|Random|RegDelete|RegRead|RegWrite|Reload|Repeat|Return|Run|RunAs|RunWait|Send|SendEvent|SendInput|SendMessage|SendMode|SendPlay|SendRaw|SetBatchLines|SetCapslockState|SetControlDelay|SetDefaultMouseSpeed|SetEnv|SetFormat|SetKeyDelay|SetMouseDelay|SetNumlockState|SetRegView|SetScrollLockState|SetStoreCapslockMode|SetTimer|SetTitleMatchMode|SetWinDelay|SetWorkingDir|Shutdown|Sleep|Sort|SoundBeep|SoundGet|SoundGetWaveVolume|SoundPlay|SoundSet|SoundSetWaveVolume|SplashImage|SplashTextOff|SplashTextOn|SplitPath|StatusBarGetText|StatusBarWait|StringCaseSense|StringGetPos|StringLeft|StringLen|StringLower|StringMid|StringReplace|StringRight|StringSplit|StringTrimLeft|StringTrimRight|StringUpper|Suspend|SysGet|Thread|ToolTip|Transform|TrayTip|URLDownloadToFile|WinActivate|WinActivateBottom|WinClose|WinGet|WinGetActiveStats|WinGetActiveTitle|WinGetClass|WinGetPos|WinGetText|WinGetTitle|WinHide|WinKill|WinMaximize|WinMenuSelectItem|WinMinimize|WinMinimizeAll|WinMinimizeAllUndo|WinMove|WinRestore|WinSet|WinSetTitle|WinShow|WinWait|WinWaitActive|WinWaitClose|WinWaitNotActive)\b/i,
				constant:
					/\b(?:a_ahkpath|a_ahkversion|a_appdata|a_appdatacommon|a_autotrim|a_batchlines|a_caretx|a_carety|a_computername|a_controldelay|a_cursor|a_dd|a_ddd|a_dddd|a_defaultmousespeed|a_desktop|a_desktopcommon|a_detecthiddentext|a_detecthiddenwindows|a_endchar|a_eventinfo|a_exitreason|a_fileencoding|a_formatfloat|a_formatinteger|a_gui|a_guicontrol|a_guicontrolevent|a_guievent|a_guiheight|a_guiwidth|a_guix|a_guiy|a_hour|a_iconfile|a_iconhidden|a_iconnumber|a_icontip|a_index|a_ipaddress1|a_ipaddress2|a_ipaddress3|a_ipaddress4|a_is64bitos|a_isadmin|a_iscompiled|a_iscritical|a_ispaused|a_issuspended|a_isunicode|a_keydelay|a_language|a_lasterror|a_linefile|a_linenumber|a_loopfield|a_loopfileattrib|a_loopfiledir|a_loopfileext|a_loopfilefullpath|a_loopfilelongpath|a_loopfilename|a_loopfileshortname|a_loopfileshortpath|a_loopfilesize|a_loopfilesizekb|a_loopfilesizemb|a_loopfiletimeaccessed|a_loopfiletimecreated|a_loopfiletimemodified|a_loopreadline|a_loopregkey|a_loopregname|a_loopregsubkey|a_loopregtimemodified|a_loopregtype|a_mday|a_min|a_mm|a_mmm|a_mmmm|a_mon|a_mousedelay|a_msec|a_mydocuments|a_now|a_nowutc|a_numbatchlines|a_ostype|a_osversion|a_priorhotkey|a_priorkey|a_programfiles|a_programs|a_programscommon|a_ptrsize|a_regview|a_screendpi|a_screenheight|a_screenwidth|a_scriptdir|a_scriptfullpath|a_scripthwnd|a_scriptname|a_sec|a_space|a_startmenu|a_startmenucommon|a_startup|a_startupcommon|a_stringcasesense|a_tab|a_temp|a_thisfunc|a_thishotkey|a_thislabel|a_thismenu|a_thismenuitem|a_thismenuitempos|a_tickcount|a_timeidle|a_timeidlephysical|a_timesincepriorhotkey|a_timesincethishotkey|a_titlematchmode|a_titlematchmodespeed|a_username|a_wday|a_windelay|a_windir|a_workingdir|a_yday|a_year|a_yweek|a_yyyy|clipboard|clipboardall|comspec|errorlevel|programfiles)\b/i,
				builtin:
					/\b(?:abs|acos|asc|asin|atan|ceil|chr|class|comobjactive|comobjarray|comobjconnect|comobjcreate|comobjerror|comobjflags|comobjget|comobjquery|comobjtype|comobjvalue|cos|dllcall|exp|fileexist|Fileopen|floor|format|il_add|il_create|il_destroy|instr|isfunc|islabel|IsObject|ln|log|ltrim|lv_add|lv_delete|lv_deletecol|lv_getcount|lv_getnext|lv_gettext|lv_insert|lv_insertcol|lv_modify|lv_modifycol|lv_setimagelist|mod|numget|numput|onmessage|regexmatch|regexreplace|registercallback|round|rtrim|sb_seticon|sb_setparts|sb_settext|sin|sqrt|strlen|strreplace|strsplit|substr|tan|tv_add|tv_delete|tv_get|tv_getchild|tv_getcount|tv_getnext|tv_getparent|tv_getprev|tv_getselection|tv_gettext|tv_modify|varsetcapacity|winactive|winexist|__Call|__Get|__New|__Set)\b/i,
				symbol:
					/\b(?:alt|altdown|altup|appskey|backspace|browser_back|browser_favorites|browser_forward|browser_home|browser_refresh|browser_search|browser_stop|bs|capslock|ctrl|ctrlbreak|ctrldown|ctrlup|del|delete|down|end|enter|esc|escape|f1|f10|f11|f12|f13|f14|f15|f16|f17|f18|f19|f2|f20|f21|f22|f23|f24|f3|f4|f5|f6|f7|f8|f9|home|ins|insert|joy1|joy10|joy11|joy12|joy13|joy14|joy15|joy16|joy17|joy18|joy19|joy2|joy20|joy21|joy22|joy23|joy24|joy25|joy26|joy27|joy28|joy29|joy3|joy30|joy31|joy32|joy4|joy5|joy6|joy7|joy8|joy9|joyaxes|joybuttons|joyinfo|joyname|joypov|joyr|joyu|joyv|joyx|joyy|joyz|lalt|launch_app1|launch_app2|launch_mail|launch_media|lbutton|lcontrol|lctrl|left|lshift|lwin|lwindown|lwinup|mbutton|media_next|media_play_pause|media_prev|media_stop|numlock|numpad0|numpad1|numpad2|numpad3|numpad4|numpad5|numpad6|numpad7|numpad8|numpad9|numpadadd|numpadclear|numpaddel|numpaddiv|numpaddot|numpaddown|numpadend|numpadenter|numpadhome|numpadins|numpadleft|numpadmult|numpadpgdn|numpadpgup|numpadright|numpadsub|numpadup|pgdn|pgup|printscreen|ralt|rbutton|rcontrol|rctrl|right|rshift|rwin|rwindown|rwinup|scrolllock|shift|shiftdown|shiftup|space|tab|up|volume_down|volume_mute|volume_up|wheeldown|wheelleft|wheelright|wheelup|xbutton1|xbutton2)\b/i,
				important:
					/#\b(?:AllowSameLineComments|ClipboardTimeout|CommentFlag|DerefChar|ErrorStdOut|EscapeChar|HotkeyInterval|HotkeyModifierTimeout|Hotstring|If|IfTimeout|IfWinActive|IfWinExist|IfWinNotActive|IfWinNotExist|Include|IncludeAgain|InputLevel|InstallKeybdHook|InstallMouseHook|KeyHistory|MaxHotkeysPerInterval|MaxMem|MaxThreads|MaxThreadsBuffer|MaxThreadsPerHotkey|MenuMaskKey|NoEnv|NoTrayIcon|Persistent|SingleInstance|UseHook|Warn|WinActivateForce)\b/i,
				keyword:
					/\b(?:Abort|AboveNormal|Add|ahk_class|ahk_exe|ahk_group|ahk_id|ahk_pid|All|Alnum|Alpha|AltSubmit|AltTab|AltTabAndMenu|AltTabMenu|AltTabMenuDismiss|AlwaysOnTop|AutoSize|Background|BackgroundTrans|BelowNormal|between|BitAnd|BitNot|BitOr|BitShiftLeft|BitShiftRight|BitXOr|Bold|Border|Button|ByRef|Catch|Checkbox|Checked|CheckedGray|Choose|ChooseString|Close|Color|ComboBox|Contains|ControlList|Count|Date|DateTime|Days|DDL|Default|DeleteAll|Delimiter|Deref|Destroy|Digit|Disable|Disabled|DropDownList|Edit|Eject|Else|Enable|Enabled|Error|Exist|Expand|ExStyle|FileSystem|Finally|First|Flash|Float|FloatFast|Focus|Font|for|global|Grid|Group|GroupBox|GuiClose|GuiContextMenu|GuiDropFiles|GuiEscape|GuiSize|Hdr|Hidden|Hide|High|HKCC|HKCR|HKCU|HKEY_CLASSES_ROOT|HKEY_CURRENT_CONFIG|HKEY_CURRENT_USER|HKEY_LOCAL_MACHINE|HKEY_USERS|HKLM|HKU|Hours|HScroll|Icon|IconSmall|ID|IDLast|If|IfEqual|IfExist|IfGreater|IfGreaterOrEqual|IfInString|IfLess|IfLessOrEqual|IfMsgBox|IfNotEqual|IfNotExist|IfNotInString|IfWinActive|IfWinExist|IfWinNotActive|IfWinNotExist|Ignore|ImageList|in|Integer|IntegerFast|Interrupt|is|italic|Join|Label|LastFound|LastFoundExist|Limit|Lines|List|ListBox|ListView|local|Lock|Logoff|Low|Lower|Lowercase|MainWindow|Margin|Maximize|MaximizeBox|MaxSize|Minimize|MinimizeBox|MinMax|MinSize|Minutes|MonthCal|Mouse|Move|Multi|NA|No|NoActivate|NoDefault|NoHide|NoIcon|NoMainWindow|norm|Normal|NoSort|NoSortHdr|NoStandard|Not|NoTab|NoTimers|Number|Off|Ok|On|OwnDialogs|Owner|Parse|Password|Picture|Pixel|Pos|Pow|Priority|ProcessName|Radio|Range|Read|ReadOnly|Realtime|Redraw|Region|REG_BINARY|REG_DWORD|REG_EXPAND_SZ|REG_MULTI_SZ|REG_SZ|Relative|Rename|Report|Resize|Restore|Retry|RGB|Screen|Seconds|Section|Serial|SetLabel|ShiftAltTab|Show|Single|Slider|SortDesc|Standard|static|Status|StatusBar|StatusCD|strike|Style|Submit|SysMenu|Tab2|TabStop|Text|Theme|Throw|Tile|ToggleCheck|ToggleEnable|ToolWindow|Top|Topmost|TransColor|Transparent|Tray|TreeView|Try|TryAgain|Type|UnCheck|underline|Unicode|Unlock|Until|UpDown|Upper|Uppercase|UseErrorLevel|Vis|VisFirst|Visible|VScroll|Wait|WaitClose|WantCtrlA|WantF2|WantReturn|While|Wrap|Xdigit|xm|xp|xs|Yes|ym|yp|ys)\b/i,
				function: /[^(); \t,\n+*\-=?>:\\\/<&%\[\]]+(?=\()/,
				punctuation: /[{}[\]():,]/
			};
		}
	}
});

// node_modules/refractor/lang/autoit.js
var require_autoit = __commonJS({
	'node_modules/refractor/lang/autoit.js'(exports, module2) {
		'use strict';
		module2.exports = autoit;
		autoit.displayName = 'autoit';
		autoit.aliases = [];
		function autoit(Prism) {
			Prism.languages.autoit = {
				comment: [
					/;.*/,
					{
						pattern: /(^[\t ]*)#(?:comments-start|cs)[\s\S]*?^[ \t]*#(?:ce|comments-end)/m,
						lookbehind: true
					}
				],
				url: {
					pattern: /(^[\t ]*#include\s+)(?:<[^\r\n>]+>|"[^\r\n"]+")/m,
					lookbehind: true
				},
				string: {
					pattern: /(["'])(?:\1\1|(?!\1)[^\r\n])*\1/,
					greedy: true,
					inside: {
						variable: /([%$@])\w+\1/
					}
				},
				directive: {
					pattern: /(^[\t ]*)#[\w-]+/m,
					lookbehind: true,
					alias: 'keyword'
				},
				function: /\b\w+(?=\()/,
				variable: /[$@]\w+/,
				keyword:
					/\b(?:Case|Const|Continue(?:Case|Loop)|Default|Dim|Do|Else(?:If)?|End(?:Func|If|Select|Switch|With)|Enum|Exit(?:Loop)?|For|Func|Global|If|In|Local|Next|Null|ReDim|Select|Static|Step|Switch|Then|To|Until|Volatile|WEnd|While|With)\b/i,
				number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i,
				boolean: /\b(?:False|True)\b/i,
				operator: /<[=>]?|[-+*\/=&>]=?|[?^]|\b(?:And|Not|Or)\b/i,
				punctuation: /[\[\]().,:]/
			};
		}
	}
});

// node_modules/refractor/lang/avisynth.js
var require_avisynth = __commonJS({
	'node_modules/refractor/lang/avisynth.js'(exports, module2) {
		'use strict';
		module2.exports = avisynth;
		avisynth.displayName = 'avisynth';
		avisynth.aliases = ['avs'];
		function avisynth(Prism) {
			(function (Prism2) {
				function replace(pattern, replacements) {
					return pattern.replace(/<<(\d+)>>/g, function (m2, index6) {
						return replacements[+index6];
					});
				}
				function re(pattern, replacements, flags) {
					return RegExp(replace(pattern, replacements), flags || '');
				}
				var types2 = /bool|clip|float|int|string|val/.source;
				var internals = [
					/is(?:bool|clip|float|int|string)|defined|(?:(?:internal)?function|var)?exists?/.source,
					/apply|assert|default|eval|import|nop|select|undefined/.source,
					/opt_(?:allowfloataudio|avipadscanlines|dwchannelmask|enable_(?:b64a|planartopackedrgb|v210|y3_10_10|y3_10_16)|usewaveextensible|vdubplanarhack)|set(?:cachemode|maxcpu|memorymax|planarlegacyalignment|workingdir)/
						.source,
					/hex(?:value)?|value/.source,
					/abs|ceil|continued(?:denominator|numerator)?|exp|floor|fmod|frac|log(?:10)?|max|min|muldiv|pi|pow|rand|round|sign|spline|sqrt/
						.source,
					/a?sinh?|a?cosh?|a?tan[2h]?/.source,
					/(?:bit(?:and|not|x?or|[lr]?shift[aslu]?|sh[lr]|sa[lr]|[lr]rotatel?|ro[rl]|te?st|set(?:count)?|cl(?:ea)?r|ch(?:an)?ge?))/
						.source,
					/average(?:[bgr]|chroma[uv]|luma)|(?:[rgb]|chroma[uv]|luma|rgb|[yuv](?=difference(?:fromprevious|tonext)))difference(?:fromprevious|tonext)?|[yuvrgb]plane(?:median|min|max|minmaxdifference)/
						.source,
					/getprocessinfo|logmsg|script(?:dir(?:utf8)?|file(?:utf8)?|name(?:utf8)?)|setlogparams/
						.source,
					/chr|(?:fill|find|left|mid|replace|rev|right)str|format|[lu]case|ord|str(?:cmpi?|fromutf8|len|toutf8)|time|trim(?:all|left|right)/
						.source,
					/isversionorgreater|version(?:number|string)/.source,
					/buildpixeltype|colorspacenametopixeltype/.source,
					/addautoloaddir|on(?:cpu|cuda)|prefetch|setfiltermtmode/.source
				].join('|');
				var properties2 = [
					/has(?:audio|video)/.source,
					/height|width/.source,
					/frame(?:count|rate)|framerate(?:denominator|numerator)/.source,
					/getparity|is(?:field|frame)based/.source,
					/bitspercomponent|componentsize|hasalpha|is(?:planar(?:rgba?)?|interleaved|rgb(?:24|32|48|64)?|y(?:8|u(?:va?|y2))?|yv(?:12|16|24|411)|420|422|444|packedrgb)|numcomponents|pixeltype/
						.source,
					/audio(?:bits|channels|duration|length(?:[fs]|hi|lo)?|rate)|isaudio(?:float|int)/.source
				].join('|');
				var filters = [
					/avi(?:file)?source|directshowsource|image(?:reader|source|sourceanim)|opendmlsource|segmented(?:avisource|directshowsource)|wavsource/
						.source,
					/coloryuv|convertbacktoyuy2|convertto(?:RGB(?:24|32|48|64)|(?:planar)?RGBA?|Y8?|YV(?:12|16|24|411)|YUVA?(?:411|420|422|444)|YUY2)|fixluminance|gr[ae]yscale|invert|levels|limiter|mergea?rgb|merge(?:chroma|luma)|rgbadjust|show(?:alpha|blue|green|red)|swapuv|tweak|[uv]toy8?|ytouv/
						.source,
					/(?:colorkey|reset)mask|layer|mask(?:hs)?|merge|overlay|subtract/.source,
					/addborders|(?:bicubic|bilinear|blackman|gauss|lanczos4|lanczos|point|sinc|spline(?:16|36|64))resize|crop(?:bottom)?|flip(?:horizontal|vertical)|(?:horizontal|vertical)?reduceby2|letterbox|skewrows|turn(?:180|left|right)/
						.source,
					/blur|fixbrokenchromaupsampling|generalconvolution|(?:spatial|temporal)soften|sharpen/
						.source,
					/trim|(?:un)?alignedsplice|(?:assume|assumescaled|change|convert)FPS|(?:delete|duplicate)frame|dissolve|fade(?:in|io|out)[02]?|freezeframe|interleave|loop|reverse|select(?:even|odd|(?:range)?every)/
						.source,
					/assume[bt]ff|assume(?:field|frame)based|bob|complementparity|doubleweave|peculiarblend|pulldown|separate(?:columns|fields|rows)|swapfields|weave(?:columns|rows)?/
						.source,
					/amplify(?:db)?|assumesamplerate|audiodub(?:ex)?|audiotrim|convertaudioto(?:(?:8|16|24|32)bit|float)|converttomono|delayaudio|ensurevbrmp3sync|get(?:left|right)?channel|kill(?:audio|video)|mergechannels|mixaudio|monotostereo|normalize|resampleaudio|ssrc|supereq|timestretch/
						.source,
					/animate|applyrange|conditional(?:filter|reader|select)|frameevaluate|scriptclip|tcp(?:server|source)|writefile(?:end|if|start)?/
						.source,
					/imagewriter/.source,
					/blackness|blankclip|colorbars(?:hd)?|compare|dumpfiltergraph|echo|histogram|info|messageclip|preroll|setgraphanalysis|show(?:framenumber|smpte|time)|showfiveversions|stack(?:horizontal|vertical)|subtitle|tone|version/
						.source
				].join('|');
				var allinternals = [internals, properties2, filters].join('|');
				Prism2.languages.avisynth = {
					comment: [
						{
							pattern:
								/(^|[^\\])\[\*(?:[^\[*]|\[(?!\*)|\*(?!\])|\[\*(?:[^\[*]|\[(?!\*)|\*(?!\]))*\*\])*\*\]/,
							lookbehind: true,
							greedy: true
						},
						{
							pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
							lookbehind: true,
							greedy: true
						},
						{
							pattern: /(^|[^\\$])#.*/,
							lookbehind: true,
							greedy: true
						}
					],
					argument: {
						pattern: re(/\b(?:<<0>>)\s+("?)\w+\1/.source, [types2], 'i'),
						inside: {
							keyword: /^\w+/
						}
					},
					'argument-label': {
						pattern: /([,(][\s\\]*)\w+\s*=(?!=)/,
						lookbehind: true,
						inside: {
							'argument-name': {
								pattern: /^\w+/,
								alias: 'punctuation'
							},
							punctuation: /=$/
						}
					},
					string: [
						{
							pattern: /"""[\s\S]*?"""/,
							greedy: true
						},
						{
							pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
							greedy: true,
							inside: {
								constant: {
									pattern:
										/\b(?:DEFAULT_MT_MODE|(?:MAINSCRIPT|PROGRAM|SCRIPT)DIR|(?:MACHINE|USER)_(?:CLASSIC|PLUS)_PLUGINS)\b/
								}
							}
						}
					],
					variable: /\b(?:last)\b/i,
					boolean: /\b(?:false|no|true|yes)\b/i,
					keyword: /\b(?:catch|else|for|function|global|if|return|try|while|__END__)\b/i,
					constant: /\bMT_(?:MULTI_INSTANCE|NICE_FILTER|SERIALIZED|SPECIAL_MT)\b/,
					'builtin-function': {
						pattern: re(/\b(?:<<0>>)\b/.source, [allinternals], 'i'),
						alias: 'function'
					},
					'type-cast': {
						pattern: re(/\b(?:<<0>>)(?=\s*\()/.source, [types2], 'i'),
						alias: 'keyword'
					},
					function: {
						pattern: /\b[a-z_]\w*(?=\s*\()|(\.)[a-z_]\w*\b/i,
						lookbehind: true
					},
					'line-continuation': {
						pattern: /(^[ \t]*)\\|\\(?=[ \t]*$)/m,
						lookbehind: true,
						alias: 'punctuation'
					},
					number: /\B\$(?:[\da-f]{6}|[\da-f]{8})\b|(?:(?:\b|\B-)\d+(?:\.\d*)?\b|\B\.\d+\b)/i,
					operator: /\+\+?|[!=<>]=?|&&|\|\||[?:*/%-]/,
					punctuation: /[{}\[\]();,.]/
				};
				Prism2.languages.avs = Prism2.languages.avisynth;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/avro-idl.js
var require_avro_idl = __commonJS({
	'node_modules/refractor/lang/avro-idl.js'(exports, module2) {
		'use strict';
		module2.exports = avroIdl;
		avroIdl.displayName = 'avroIdl';
		avroIdl.aliases = [];
		function avroIdl(Prism) {
			Prism.languages['avro-idl'] = {
				comment: {
					pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
					greedy: true
				},
				string: {
					pattern: /(^|[^\\])"(?:[^\r\n"\\]|\\.)*"/,
					lookbehind: true,
					greedy: true
				},
				annotation: {
					pattern: /@(?:[$\w.-]|`[^\r\n`]+`)+/,
					greedy: true,
					alias: 'function'
				},
				'function-identifier': {
					pattern: /`[^\r\n`]+`(?=\s*\()/,
					greedy: true,
					alias: 'function'
				},
				identifier: {
					pattern: /`[^\r\n`]+`/,
					greedy: true
				},
				'class-name': {
					pattern: /(\b(?:enum|error|protocol|record|throws)\b\s+)[$\w]+/,
					lookbehind: true,
					greedy: true
				},
				keyword:
					/\b(?:array|boolean|bytes|date|decimal|double|enum|error|false|fixed|float|idl|import|int|local_timestamp_ms|long|map|null|oneway|protocol|record|schema|string|throws|time_ms|timestamp_ms|true|union|uuid|void)\b/,
				function: /\b[a-z_]\w*(?=\s*\()/i,
				number: [
					{
						pattern:
							/(^|[^\w.])-?(?:(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|0x(?:[a-f0-9]+(?:\.[a-f0-9]*)?|\.[a-f0-9]+)(?:p[+-]?\d+)?)[dfl]?(?![\w.])/i,
						lookbehind: true
					},
					/-?\b(?:Infinity|NaN)\b/
				],
				operator: /=/,
				punctuation: /[()\[\]{}<>.:,;-]/
			};
			Prism.languages.avdl = Prism.languages['avro-idl'];
		}
	}
});

// node_modules/refractor/lang/bash.js
var require_bash = __commonJS({
	'node_modules/refractor/lang/bash.js'(exports, module2) {
		'use strict';
		module2.exports = bash;
		bash.displayName = 'bash';
		bash.aliases = ['shell'];
		function bash(Prism) {
			(function (Prism2) {
				var envVars =
					'\\b(?:BASH|BASHOPTS|BASH_ALIASES|BASH_ARGC|BASH_ARGV|BASH_CMDS|BASH_COMPLETION_COMPAT_DIR|BASH_LINENO|BASH_REMATCH|BASH_SOURCE|BASH_VERSINFO|BASH_VERSION|COLORTERM|COLUMNS|COMP_WORDBREAKS|DBUS_SESSION_BUS_ADDRESS|DEFAULTS_PATH|DESKTOP_SESSION|DIRSTACK|DISPLAY|EUID|GDMSESSION|GDM_LANG|GNOME_KEYRING_CONTROL|GNOME_KEYRING_PID|GPG_AGENT_INFO|GROUPS|HISTCONTROL|HISTFILE|HISTFILESIZE|HISTSIZE|HOME|HOSTNAME|HOSTTYPE|IFS|INSTANCE|JOB|LANG|LANGUAGE|LC_ADDRESS|LC_ALL|LC_IDENTIFICATION|LC_MEASUREMENT|LC_MONETARY|LC_NAME|LC_NUMERIC|LC_PAPER|LC_TELEPHONE|LC_TIME|LESSCLOSE|LESSOPEN|LINES|LOGNAME|LS_COLORS|MACHTYPE|MAILCHECK|MANDATORY_PATH|NO_AT_BRIDGE|OLDPWD|OPTERR|OPTIND|ORBIT_SOCKETDIR|OSTYPE|PAPERSIZE|PATH|PIPESTATUS|PPID|PS1|PS2|PS3|PS4|PWD|RANDOM|REPLY|SECONDS|SELINUX_INIT|SESSION|SESSIONTYPE|SESSION_MANAGER|SHELL|SHELLOPTS|SHLVL|SSH_AUTH_SOCK|TERM|UID|UPSTART_EVENTS|UPSTART_INSTANCE|UPSTART_JOB|UPSTART_SESSION|USER|WINDOWID|XAUTHORITY|XDG_CONFIG_DIRS|XDG_CURRENT_DESKTOP|XDG_DATA_DIRS|XDG_GREETER_DATA_DIR|XDG_MENU_PREFIX|XDG_RUNTIME_DIR|XDG_SEAT|XDG_SEAT_PATH|XDG_SESSION_DESKTOP|XDG_SESSION_ID|XDG_SESSION_PATH|XDG_SESSION_TYPE|XDG_VTNR|XMODIFIERS)\\b';
				var commandAfterHeredoc = {
					pattern: /(^(["']?)\w+\2)[ \t]+\S.*/,
					lookbehind: true,
					alias: 'punctuation',
					inside: null
				};
				var insideString = {
					bash: commandAfterHeredoc,
					environment: {
						pattern: RegExp('\\$' + envVars),
						alias: 'constant'
					},
					variable: [
						{
							pattern: /\$?\(\([\s\S]+?\)\)/,
							greedy: true,
							inside: {
								variable: [
									{
										pattern: /(^\$\(\([\s\S]+)\)\)/,
										lookbehind: true
									},
									/^\$\(\(/
								],
								number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
								operator: /--|\+\+|\*\*=?|<<=?|>>=?|&&|\|\||[=!+\-*/%<>^&|]=?|[?~:]/,
								punctuation: /\(\(?|\)\)?|,|;/
							}
						},
						{
							pattern: /\$\((?:\([^)]+\)|[^()])+\)|`[^`]+`/,
							greedy: true,
							inside: {
								variable: /^\$\(|^`|\)$|`$/
							}
						},
						{
							pattern: /\$\{[^}]+\}/,
							greedy: true,
							inside: {
								operator: /:[-=?+]?|[!\/]|##?|%%?|\^\^?|,,?/,
								punctuation: /[\[\]]/,
								environment: {
									pattern: RegExp('(\\{)' + envVars),
									lookbehind: true,
									alias: 'constant'
								}
							}
						},
						/\$(?:\w+|[#?*!@$])/
					],
					entity:
						/\\(?:[abceEfnrtv\\"]|O?[0-7]{1,3}|U[0-9a-fA-F]{8}|u[0-9a-fA-F]{4}|x[0-9a-fA-F]{1,2})/
				};
				Prism2.languages.bash = {
					shebang: {
						pattern: /^#!\s*\/.*/,
						alias: 'important'
					},
					comment: {
						pattern: /(^|[^"{\\$])#.*/,
						lookbehind: true
					},
					'function-name': [
						{
							pattern: /(\bfunction\s+)[\w-]+(?=(?:\s*\(?:\s*\))?\s*\{)/,
							lookbehind: true,
							alias: 'function'
						},
						{
							pattern: /\b[\w-]+(?=\s*\(\s*\)\s*\{)/,
							alias: 'function'
						}
					],
					'for-or-select': {
						pattern: /(\b(?:for|select)\s+)\w+(?=\s+in\s)/,
						alias: 'variable',
						lookbehind: true
					},
					'assign-left': {
						pattern: /(^|[\s;|&]|[<>]\()\w+(?=\+?=)/,
						inside: {
							environment: {
								pattern: RegExp('(^|[\\s;|&]|[<>]\\()' + envVars),
								lookbehind: true,
								alias: 'constant'
							}
						},
						alias: 'variable',
						lookbehind: true
					},
					string: [
						{
							pattern: /((?:^|[^<])<<-?\s*)(\w+)\s[\s\S]*?(?:\r?\n|\r)\2/,
							lookbehind: true,
							greedy: true,
							inside: insideString
						},
						{
							pattern: /((?:^|[^<])<<-?\s*)(["'])(\w+)\2\s[\s\S]*?(?:\r?\n|\r)\3/,
							lookbehind: true,
							greedy: true,
							inside: {
								bash: commandAfterHeredoc
							}
						},
						{
							pattern: /(^|[^\\](?:\\\\)*)"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/,
							lookbehind: true,
							greedy: true,
							inside: insideString
						},
						{
							pattern: /(^|[^$\\])'[^']*'/,
							lookbehind: true,
							greedy: true
						},
						{
							pattern: /\$'(?:[^'\\]|\\[\s\S])*'/,
							greedy: true,
							inside: {
								entity: insideString.entity
							}
						}
					],
					environment: {
						pattern: RegExp('\\$?' + envVars),
						alias: 'constant'
					},
					variable: insideString.variable,
					function: {
						pattern:
							/(^|[\s;|&]|[<>]\()(?:add|apropos|apt|apt-cache|apt-get|aptitude|aspell|automysqlbackup|awk|basename|bash|bc|bconsole|bg|bzip2|cal|cat|cfdisk|chgrp|chkconfig|chmod|chown|chroot|cksum|clear|cmp|column|comm|composer|cp|cron|crontab|csplit|curl|cut|date|dc|dd|ddrescue|debootstrap|df|diff|diff3|dig|dir|dircolors|dirname|dirs|dmesg|docker|docker-compose|du|egrep|eject|env|ethtool|expand|expect|expr|fdformat|fdisk|fg|fgrep|file|find|fmt|fold|format|free|fsck|ftp|fuser|gawk|git|gparted|grep|groupadd|groupdel|groupmod|groups|grub-mkconfig|gzip|halt|head|hg|history|host|hostname|htop|iconv|id|ifconfig|ifdown|ifup|import|install|ip|jobs|join|kill|killall|less|link|ln|locate|logname|logrotate|look|lpc|lpr|lprint|lprintd|lprintq|lprm|ls|lsof|lynx|make|man|mc|mdadm|mkconfig|mkdir|mke2fs|mkfifo|mkfs|mkisofs|mknod|mkswap|mmv|more|most|mount|mtools|mtr|mutt|mv|nano|nc|netstat|nice|nl|node|nohup|notify-send|npm|nslookup|op|open|parted|passwd|paste|pathchk|ping|pkill|pnpm|podman|podman-compose|popd|pr|printcap|printenv|ps|pushd|pv|quota|quotacheck|quotactl|ram|rar|rcp|reboot|remsync|rename|renice|rev|rm|rmdir|rpm|rsync|scp|screen|sdiff|sed|sendmail|seq|service|sftp|sh|shellcheck|shuf|shutdown|sleep|slocate|sort|split|ssh|stat|strace|su|sudo|sum|suspend|swapon|sync|tac|tail|tar|tee|time|timeout|top|touch|tr|traceroute|tsort|tty|umount|uname|unexpand|uniq|units|unrar|unshar|unzip|update-grub|uptime|useradd|userdel|usermod|users|uudecode|uuencode|v|vcpkg|vdir|vi|vim|virsh|vmstat|wait|watch|wc|wget|whereis|which|who|whoami|write|xargs|xdg-open|yarn|yes|zenity|zip|zsh|zypper)(?=$|[)\s;|&])/,
						lookbehind: true
					},
					keyword: {
						pattern:
							/(^|[\s;|&]|[<>]\()(?:case|do|done|elif|else|esac|fi|for|function|if|in|select|then|until|while)(?=$|[)\s;|&])/,
						lookbehind: true
					},
					builtin: {
						pattern:
							/(^|[\s;|&]|[<>]\()(?:\.|:|alias|bind|break|builtin|caller|cd|command|continue|declare|echo|enable|eval|exec|exit|export|getopts|hash|help|let|local|logout|mapfile|printf|pwd|read|readarray|readonly|return|set|shift|shopt|source|test|times|trap|type|typeset|ulimit|umask|unalias|unset)(?=$|[)\s;|&])/,
						lookbehind: true,
						alias: 'class-name'
					},
					boolean: {
						pattern: /(^|[\s;|&]|[<>]\()(?:false|true)(?=$|[)\s;|&])/,
						lookbehind: true
					},
					'file-descriptor': {
						pattern: /\B&\d\b/,
						alias: 'important'
					},
					operator: {
						pattern: /\d?<>|>\||\+=|=[=~]?|!=?|<<[<-]?|[&\d]?>>|\d[<>]&?|[<>][&=]?|&[>&]?|\|[&|]?/,
						inside: {
							'file-descriptor': {
								pattern: /^\d/,
								alias: 'important'
							}
						}
					},
					punctuation: /\$?\(\(?|\)\)?|\.\.|[{}[\];\\]/,
					number: {
						pattern: /(^|\s)(?:[1-9]\d*|0)(?:[.,]\d+)?\b/,
						lookbehind: true
					}
				};
				commandAfterHeredoc.inside = Prism2.languages.bash;
				var toBeCopied = [
					'comment',
					'function-name',
					'for-or-select',
					'assign-left',
					'string',
					'environment',
					'function',
					'keyword',
					'builtin',
					'boolean',
					'file-descriptor',
					'operator',
					'punctuation',
					'number'
				];
				var inside = insideString.variable[1].inside;
				for (var i2 = 0; i2 < toBeCopied.length; i2++) {
					inside[toBeCopied[i2]] = Prism2.languages.bash[toBeCopied[i2]];
				}
				Prism2.languages.shell = Prism2.languages.bash;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/basic.js
var require_basic = __commonJS({
	'node_modules/refractor/lang/basic.js'(exports, module2) {
		'use strict';
		module2.exports = basic;
		basic.displayName = 'basic';
		basic.aliases = [];
		function basic(Prism) {
			Prism.languages.basic = {
				comment: {
					pattern: /(?:!|REM\b).+/i,
					inside: {
						keyword: /^REM/i
					}
				},
				string: {
					pattern: /"(?:""|[!#$%&'()*,\/:;<=>?^\w +\-.])*"/,
					greedy: true
				},
				number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
				keyword:
					/\b(?:AS|BEEP|BLOAD|BSAVE|CALL(?: ABSOLUTE)?|CASE|CHAIN|CHDIR|CLEAR|CLOSE|CLS|COM|COMMON|CONST|DATA|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DIM|DO|DOUBLE|ELSE|ELSEIF|END|ENVIRON|ERASE|ERROR|EXIT|FIELD|FILES|FOR|FUNCTION|GET|GOSUB|GOTO|IF|INPUT|INTEGER|IOCTL|KEY|KILL|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|MKDIR|NAME|NEXT|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPTION BASE|OUT|POKE|PUT|READ|REDIM|REM|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SELECT CASE|SHARED|SHELL|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|SUB|SWAP|SYSTEM|THEN|TIMER|TO|TROFF|TRON|TYPE|UNLOCK|UNTIL|USING|VIEW PRINT|WAIT|WEND|WHILE|WRITE)(?:\$|\b)/i,
				function:
					/\b(?:ABS|ACCESS|ACOS|ANGLE|AREA|ARITHMETIC|ARRAY|ASIN|ASK|AT|ATN|BASE|BEGIN|BREAK|CAUSE|CEIL|CHR|CLIP|COLLATE|COLOR|CON|COS|COSH|COT|CSC|DATE|DATUM|DEBUG|DECIMAL|DEF|DEG|DEGREES|DELETE|DET|DEVICE|DISPLAY|DOT|ELAPSED|EPS|ERASABLE|EXLINE|EXP|EXTERNAL|EXTYPE|FILETYPE|FIXED|FP|GO|GRAPH|HANDLER|IDN|IMAGE|IN|INT|INTERNAL|IP|IS|KEYED|LBOUND|LCASE|LEFT|LEN|LENGTH|LET|LINE|LINES|LOG|LOG10|LOG2|LTRIM|MARGIN|MAT|MAX|MAXNUM|MID|MIN|MISSING|MOD|NATIVE|NUL|NUMERIC|OF|OPTION|ORD|ORGANIZATION|OUTIN|OUTPUT|PI|POINT|POINTER|POINTS|POS|PRINT|PROGRAM|PROMPT|RAD|RADIANS|RANDOMIZE|RECORD|RECSIZE|RECTYPE|RELATIVE|REMAINDER|REPEAT|REST|RETRY|REWRITE|RIGHT|RND|ROUND|RTRIM|SAME|SEC|SELECT|SEQUENTIAL|SET|SETTER|SGN|SIN|SINH|SIZE|SKIP|SQR|STANDARD|STATUS|STR|STREAM|STYLE|TAB|TAN|TANH|TEMPLATE|TEXT|THERE|TIME|TIMEOUT|TRACE|TRANSFORM|TRUNCATE|UBOUND|UCASE|USE|VAL|VARIABLE|VIEWPORT|WHEN|WINDOW|WITH|ZER|ZONEWIDTH)(?:\$|\b)/i,
				operator: /<[=>]?|>=?|[+\-*\/^=&]|\b(?:AND|EQV|IMP|NOT|OR|XOR)\b/i,
				punctuation: /[,;:()]/
			};
		}
	}
});

// node_modules/refractor/lang/batch.js
var require_batch = __commonJS({
	'node_modules/refractor/lang/batch.js'(exports, module2) {
		'use strict';
		module2.exports = batch;
		batch.displayName = 'batch';
		batch.aliases = [];
		function batch(Prism) {
			(function (Prism2) {
				var variable = /%%?[~:\w]+%?|!\S+!/;
				var parameter = {
					pattern: /\/[a-z?]+(?=[ :]|$):?|-[a-z]\b|--[a-z-]+\b/im,
					alias: 'attr-name',
					inside: {
						punctuation: /:/
					}
				};
				var string3 = /"(?:[\\"]"|[^"])*"(?!")/;
				var number3 = /(?:\b|-)\d+\b/;
				Prism2.languages.batch = {
					comment: [
						/^::.*/m,
						{
							pattern: /((?:^|[&(])[ \t]*)rem\b(?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im,
							lookbehind: true
						}
					],
					label: {
						pattern: /^:.*/m,
						alias: 'property'
					},
					command: [
						{
							pattern:
								/((?:^|[&(])[ \t]*)for(?: \/[a-z?](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* \S+ in \([^)]+\) do/im,
							lookbehind: true,
							inside: {
								keyword: /\b(?:do|in)\b|^for\b/i,
								string: string3,
								parameter,
								variable,
								number: number3,
								punctuation: /[()',]/
							}
						},
						{
							pattern:
								/((?:^|[&(])[ \t]*)if(?: \/[a-z?](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* (?:not )?(?:cmdextversion \d+|defined \w+|errorlevel \d+|exist \S+|(?:"[^"]*"|(?!")(?:(?!==)\S)+)?(?:==| (?:equ|geq|gtr|leq|lss|neq) )(?:"[^"]*"|[^\s"]\S*))/im,
							lookbehind: true,
							inside: {
								keyword: /\b(?:cmdextversion|defined|errorlevel|exist|not)\b|^if\b/i,
								string: string3,
								parameter,
								variable,
								number: number3,
								operator: /\^|==|\b(?:equ|geq|gtr|leq|lss|neq)\b/i
							}
						},
						{
							pattern: /((?:^|[&()])[ \t]*)else\b/im,
							lookbehind: true,
							inside: {
								keyword: /^else\b/i
							}
						},
						{
							pattern:
								/((?:^|[&(])[ \t]*)set(?: \/[a-z](?:[ :](?:"[^"]*"|[^\s"/]\S*))?)* (?:[^^&)\r\n]|\^(?:\r\n|[\s\S]))*/im,
							lookbehind: true,
							inside: {
								keyword: /^set\b/i,
								string: string3,
								parameter,
								variable: [variable, /\w+(?=(?:[*\/%+\-&^|]|<<|>>)?=)/],
								number: number3,
								operator: /[*\/%+\-&^|]=?|<<=?|>>=?|[!~_=]/,
								punctuation: /[()',]/
							}
						},
						{
							pattern:
								/((?:^|[&(])[ \t]*@?)\w+\b(?:"(?:[\\"]"|[^"])*"(?!")|[^"^&)\r\n]|\^(?:\r\n|[\s\S]))*/m,
							lookbehind: true,
							inside: {
								keyword: /^\w+\b/,
								string: string3,
								parameter,
								label: {
									pattern: /(^\s*):\S+/m,
									lookbehind: true,
									alias: 'property'
								},
								variable,
								number: number3,
								operator: /\^/
							}
						}
					],
					operator: /[&@]/,
					punctuation: /[()']/
				};
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/bbcode.js
var require_bbcode = __commonJS({
	'node_modules/refractor/lang/bbcode.js'(exports, module2) {
		'use strict';
		module2.exports = bbcode;
		bbcode.displayName = 'bbcode';
		bbcode.aliases = ['shortcode'];
		function bbcode(Prism) {
			Prism.languages.bbcode = {
				tag: {
					pattern:
						/\[\/?[^\s=\]]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+))?(?:\s+[^\s=\]]+\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+))*\s*\]/,
					inside: {
						tag: {
							pattern: /^\[\/?[^\s=\]]+/,
							inside: {
								punctuation: /^\[\/?/
							}
						},
						'attr-value': {
							pattern: /=\s*(?:"[^"]*"|'[^']*'|[^\s'"\]=]+)/,
							inside: {
								punctuation: [
									/^=/,
									{
										pattern: /^(\s*)["']|["']$/,
										lookbehind: true
									}
								]
							}
						},
						punctuation: /\]/,
						'attr-name': /[^\s=\]]+/
					}
				}
			};
			Prism.languages.shortcode = Prism.languages.bbcode;
		}
	}
});

// node_modules/refractor/lang/bicep.js
var require_bicep = __commonJS({
	'node_modules/refractor/lang/bicep.js'(exports, module2) {
		'use strict';
		module2.exports = bicep;
		bicep.displayName = 'bicep';
		bicep.aliases = [];
		function bicep(Prism) {
			Prism.languages.bicep = {
				comment: [
					{
						pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
						lookbehind: true,
						greedy: true
					},
					{
						pattern: /(^|[^\\:])\/\/.*/,
						lookbehind: true,
						greedy: true
					}
				],
				property: [
					{
						pattern: /([\r\n][ \t]*)[a-z_]\w*(?=[ \t]*:)/i,
						lookbehind: true
					},
					{
						pattern: /([\r\n][ \t]*)'(?:\\.|\$(?!\{)|[^'\\\r\n$])*'(?=[ \t]*:)/,
						lookbehind: true,
						greedy: true
					}
				],
				string: [
					{
						pattern: /'''[^'][\s\S]*?'''/,
						greedy: true
					},
					{
						pattern: /(^|[^\\'])'(?:\\.|\$(?!\{)|[^'\\\r\n$])*'/,
						lookbehind: true,
						greedy: true
					}
				],
				'interpolated-string': {
					pattern: /(^|[^\\'])'(?:\\.|\$(?:(?!\{)|\{[^{}\r\n]*\})|[^'\\\r\n$])*'/,
					lookbehind: true,
					greedy: true,
					inside: {
						interpolation: {
							pattern: /\$\{[^{}\r\n]*\}/,
							inside: {
								expression: {
									pattern: /(^\$\{)[\s\S]+(?=\}$)/,
									lookbehind: true
								},
								punctuation: /^\$\{|\}$/
							}
						},
						string: /[\s\S]+/
					}
				},
				datatype: {
					pattern: /(\b(?:output|param)\b[ \t]+\w+[ \t]+)\w+\b/,
					lookbehind: true,
					alias: 'class-name'
				},
				boolean: /\b(?:false|true)\b/,
				keyword: /\b(?:existing|for|if|in|module|null|output|param|resource|targetScope|var)\b/,
				decorator: /@\w+\b/,
				function: /\b[a-z_]\w*(?=[ \t]*\()/i,
				number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
				operator:
					/--|\+\+|\*\*=?|=>|&&=?|\|\|=?|[!=]==|<<=?|>>>?=?|[-+*/%&|^!=<>]=?|\.{3}|\?\?=?|\?\.?|[~:]/,
				punctuation: /[{}[\];(),.:]/
			};
			Prism.languages.bicep['interpolated-string'].inside['interpolation'].inside[
				'expression'
			].inside = Prism.languages.bicep;
		}
	}
});

// node_modules/refractor/lang/birb.js
var require_birb = __commonJS({
	'node_modules/refractor/lang/birb.js'(exports, module2) {
		'use strict';
		module2.exports = birb;
		birb.displayName = 'birb';
		birb.aliases = [];
		function birb(Prism) {
			Prism.languages.birb = Prism.languages.extend('clike', {
				string: {
					pattern: /r?("|')(?:\\.|(?!\1)[^\\])*\1/,
					greedy: true
				},
				'class-name': [
					/\b[A-Z](?:[\d_]*[a-zA-Z]\w*)?\b/,
					/\b(?:[A-Z]\w*|(?!(?:var|void)\b)[a-z]\w*)(?=\s+\w+\s*[;,=()])/
				],
				keyword:
					/\b(?:assert|break|case|class|const|default|else|enum|final|follows|for|grab|if|nest|new|next|noSeeb|return|static|switch|throw|var|void|while)\b/,
				operator: /\+\+|--|&&|\|\||<<=?|>>=?|~(?:\/=?)?|[+\-*\/%&^|=!<>]=?|\?|:/,
				variable: /\b[a-z_]\w*\b/
			});
			Prism.languages.insertBefore('birb', 'function', {
				metadata: {
					pattern: /<\w+>/,
					greedy: true,
					alias: 'symbol'
				}
			});
		}
	}
});

// node_modules/refractor/lang/bison.js
var require_bison = __commonJS({
	'node_modules/refractor/lang/bison.js'(exports, module2) {
		'use strict';
		var refractorC = require_c();
		module2.exports = bison;
		bison.displayName = 'bison';
		bison.aliases = [];
		function bison(Prism) {
			Prism.register(refractorC);
			Prism.languages.bison = Prism.languages.extend('c', {});
			Prism.languages.insertBefore('bison', 'comment', {
				bison: {
					pattern: /^(?:[^%]|%(?!%))*%%[\s\S]*?%%/,
					inside: {
						c: {
							pattern: /%\{[\s\S]*?%\}|\{(?:\{[^}]*\}|[^{}])*\}/,
							inside: {
								delimiter: {
									pattern: /^%?\{|%?\}$/,
									alias: 'punctuation'
								},
								'bison-variable': {
									pattern: /[$@](?:<[^\s>]+>)?[\w$]+/,
									alias: 'variable',
									inside: {
										punctuation: /<|>/
									}
								},
								rest: Prism.languages.c
							}
						},
						comment: Prism.languages.c.comment,
						string: Prism.languages.c.string,
						property: /\S+(?=:)/,
						keyword: /%\w+/,
						number: {
							pattern: /(^|[^@])\b(?:0x[\da-f]+|\d+)/i,
							lookbehind: true
						},
						punctuation: /%[%?]|[|:;\[\]<>]/
					}
				}
			});
		}
	}
});

// node_modules/refractor/lang/bnf.js
var require_bnf = __commonJS({
	'node_modules/refractor/lang/bnf.js'(exports, module2) {
		'use strict';
		module2.exports = bnf;
		bnf.displayName = 'bnf';
		bnf.aliases = ['rbnf'];
		function bnf(Prism) {
			Prism.languages.bnf = {
				string: {
					pattern: /"[^\r\n"]*"|'[^\r\n']*'/
				},
				definition: {
					pattern: /<[^<>\r\n\t]+>(?=\s*::=)/,
					alias: ['rule', 'keyword'],
					inside: {
						punctuation: /^<|>$/
					}
				},
				rule: {
					pattern: /<[^<>\r\n\t]+>/,
					inside: {
						punctuation: /^<|>$/
					}
				},
				operator: /::=|[|()[\]{}*+?]|\.{3}/
			};
			Prism.languages.rbnf = Prism.languages.bnf;
		}
	}
});

// node_modules/refractor/lang/brainfuck.js
var require_brainfuck = __commonJS({
	'node_modules/refractor/lang/brainfuck.js'(exports, module2) {
		'use strict';
		module2.exports = brainfuck;
		brainfuck.displayName = 'brainfuck';
		brainfuck.aliases = [];
		function brainfuck(Prism) {
			Prism.languages.brainfuck = {
				pointer: {
					pattern: /<|>/,
					alias: 'keyword'
				},
				increment: {
					pattern: /\+/,
					alias: 'inserted'
				},
				decrement: {
					pattern: /-/,
					alias: 'deleted'
				},
				branching: {
					pattern: /\[|\]/,
					alias: 'important'
				},
				operator: /[.,]/,
				comment: /\S+/
			};
		}
	}
});

// node_modules/refractor/lang/brightscript.js
var require_brightscript = __commonJS({
	'node_modules/refractor/lang/brightscript.js'(exports, module2) {
		'use strict';
		module2.exports = brightscript;
		brightscript.displayName = 'brightscript';
		brightscript.aliases = [];
		function brightscript(Prism) {
			Prism.languages.brightscript = {
				comment: /(?:\brem|').*/i,
				'directive-statement': {
					pattern: /(^[\t ]*)#(?:const|else(?:[\t ]+if)?|end[\t ]+if|error|if).*/im,
					lookbehind: true,
					alias: 'property',
					inside: {
						'error-message': {
							pattern: /(^#error).+/,
							lookbehind: true
						},
						directive: {
							pattern: /^#(?:const|else(?:[\t ]+if)?|end[\t ]+if|error|if)/,
							alias: 'keyword'
						},
						expression: {
							pattern: /[\s\S]+/,
							inside: null
						}
					}
				},
				property: {
					pattern: /([\r\n{,][\t ]*)(?:(?!\d)\w+|"(?:[^"\r\n]|"")*"(?!"))(?=[ \t]*:)/,
					lookbehind: true,
					greedy: true
				},
				string: {
					pattern: /"(?:[^"\r\n]|"")*"(?!")/,
					greedy: true
				},
				'class-name': {
					pattern: /(\bAs[\t ]+)\w+/i,
					lookbehind: true
				},
				keyword:
					/\b(?:As|Dim|Each|Else|Elseif|End|Exit|For|Function|Goto|If|In|Print|Return|Step|Stop|Sub|Then|To|While)\b/i,
				boolean: /\b(?:false|true)\b/i,
				function: /\b(?!\d)\w+(?=[\t ]*\()/,
				number: /(?:\b\d+(?:\.\d+)?(?:[ed][+-]\d+)?|&h[a-f\d]+)\b[%&!#]?/i,
				operator: /--|\+\+|>>=?|<<=?|<>|[-+*/\\<>]=?|[:^=?]|\b(?:and|mod|not|or)\b/i,
				punctuation: /[.,;()[\]{}]/,
				constant: /\b(?:LINE_NUM)\b/i
			};
			Prism.languages.brightscript['directive-statement'].inside.expression.inside =
				Prism.languages.brightscript;
		}
	}
});

// node_modules/refractor/lang/bro.js
var require_bro = __commonJS({
	'node_modules/refractor/lang/bro.js'(exports, module2) {
		'use strict';
		module2.exports = bro;
		bro.displayName = 'bro';
		bro.aliases = [];
		function bro(Prism) {
			Prism.languages.bro = {
				comment: {
					pattern: /(^|[^\\$])#.*/,
					lookbehind: true,
					inside: {
						italic: /\b(?:FIXME|TODO|XXX)\b/
					}
				},
				string: {
					pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
					greedy: true
				},
				boolean: /\b[TF]\b/,
				function: {
					pattern: /(\b(?:event|function|hook)[ \t]+)\w+(?:::\w+)?/,
					lookbehind: true
				},
				builtin:
					/(?:@(?:load(?:-(?:plugin|sigs))?|unload|prefixes|ifn?def|else|(?:end)?if|DIR|FILENAME))|(?:&?(?:add_func|create_expire|default|delete_func|encrypt|error_handler|expire_func|group|log|mergeable|optional|persistent|priority|raw_output|read_expire|redef|rotate_interval|rotate_size|synchronized|type_column|write_expire))/,
				constant: {
					pattern: /(\bconst[ \t]+)\w+/i,
					lookbehind: true
				},
				keyword:
					/\b(?:add|addr|alarm|any|bool|break|const|continue|count|delete|double|else|enum|event|export|file|for|function|global|hook|if|in|int|interval|local|module|next|of|opaque|pattern|port|print|record|return|schedule|set|string|subnet|table|time|timeout|using|vector|when)\b/,
				operator: /--?|\+\+?|!=?=?|<=?|>=?|==?=?|&&|\|\|?|\?|\*|\/|~|\^|%/,
				number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
				punctuation: /[{}[\];(),.:]/
			};
		}
	}
});

// node_modules/refractor/lang/bsl.js
var require_bsl = __commonJS({
	'node_modules/refractor/lang/bsl.js'(exports, module2) {
		'use strict';
		module2.exports = bsl;
		bsl.displayName = 'bsl';
		bsl.aliases = [];
		function bsl(Prism) {
			Prism.languages.bsl = {
				comment: /\/\/.*/,
				string: [
					{
						pattern: /"(?:[^"]|"")*"(?!")/,
						greedy: true
					},
					{
						pattern: /'(?:[^'\r\n\\]|\\.)*'/
					}
				],
				keyword: [
					{
						pattern:
							/(^|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:|||||||||||||||||||||||||||||)(?![\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])/i,
						lookbehind: true
					},
					{
						pattern:
							/\b(?:break|do|each|else|elseif|enddo|endfunction|endif|endprocedure|endtry|except|execute|export|false|for|function|if|in|new|null|procedure|raise|return|then|to|true|try|undefined|val|var|while)\b/i
					}
				],
				number: {
					pattern:
						/(^(?=\d)|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:\d+(?:\.\d*)?|\.\d+)(?:E[+-]?\d+)?/i,
					lookbehind: true
				},
				operator: [
					/[<>+\-*/]=?|[%=]/,
					{
						pattern:
							/(^|[^\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])(?:||)(?![\w\u0400-\u0484\u0487-\u052f\u1d2b\u1d78\u2de0-\u2dff\ua640-\ua69f\ufe2e\ufe2f])/i,
						lookbehind: true
					},
					{
						pattern: /\b(?:and|not|or)\b/i
					}
				],
				punctuation: /\(\.|\.\)|[()\[\]:;,.]/,
				directive: [
					{
						pattern: /^([ \t]*)&.*/m,
						lookbehind: true,
						greedy: true,
						alias: 'important'
					},
					{
						pattern: /^([ \t]*)#.*/gm,
						lookbehind: true,
						greedy: true,
						alias: 'important'
					}
				]
			};
			Prism.languages.oscript = Prism.languages['bsl'];
		}
	}
});

// node_modules/refractor/lang/cfscript.js
var require_cfscript = __commonJS({
	'node_modules/refractor/lang/cfscript.js'(exports, module2) {
		'use strict';
		module2.exports = cfscript;
		cfscript.displayName = 'cfscript';
		cfscript.aliases = [];
		function cfscript(Prism) {
			Prism.languages.cfscript = Prism.languages.extend('clike', {
				comment: [
					{
						pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
						lookbehind: true,
						inside: {
							annotation: {
								pattern: /(?:^|[^.])@[\w\.]+/,
								alias: 'punctuation'
							}
						}
					},
					{
						pattern: /(^|[^\\:])\/\/.*/,
						lookbehind: true,
						greedy: true
					}
				],
				keyword:
					/\b(?:abstract|break|catch|component|continue|default|do|else|extends|final|finally|for|function|if|in|include|package|private|property|public|remote|required|rethrow|return|static|switch|throw|try|var|while|xml)\b(?!\s*=)/,
				operator: [
					/\+\+|--|&&|\|\||::|=>|[!=]==|<=?|>=?|[-+*/%&|^!=<>]=?|\?(?:\.|:)?|[?:]/,
					/\b(?:and|contains|eq|equal|eqv|gt|gte|imp|is|lt|lte|mod|not|or|xor)\b/
				],
				scope: {
					pattern:
						/\b(?:application|arguments|cgi|client|cookie|local|session|super|this|variables)\b/,
					alias: 'global'
				},
				type: {
					pattern:
						/\b(?:any|array|binary|boolean|date|guid|numeric|query|string|struct|uuid|void|xml)\b/,
					alias: 'builtin'
				}
			});
			Prism.languages.insertBefore('cfscript', 'keyword', {
				'function-variable': {
					pattern:
						/[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*[=:]\s*(?:\bfunction\b|(?:\((?:[^()]|\([^()]*\))*\)|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/,
					alias: 'function'
				}
			});
			delete Prism.languages.cfscript['class-name'];
			Prism.languages.cfc = Prism.languages['cfscript'];
		}
	}
});

// node_modules/refractor/lang/chaiscript.js
var require_chaiscript = __commonJS({
	'node_modules/refractor/lang/chaiscript.js'(exports, module2) {
		'use strict';
		var refractorCpp = require_cpp();
		module2.exports = chaiscript;
		chaiscript.displayName = 'chaiscript';
		chaiscript.aliases = [];
		function chaiscript(Prism) {
			Prism.register(refractorCpp);
			Prism.languages.chaiscript = Prism.languages.extend('clike', {
				string: {
					pattern: /(^|[^\\])'(?:[^'\\]|\\[\s\S])*'/,
					lookbehind: true,
					greedy: true
				},
				'class-name': [
					{
						pattern: /(\bclass\s+)\w+/,
						lookbehind: true
					},
					{
						pattern: /(\b(?:attr|def)\s+)\w+(?=\s*::)/,
						lookbehind: true
					}
				],
				keyword:
					/\b(?:attr|auto|break|case|catch|class|continue|def|default|else|finally|for|fun|global|if|return|switch|this|try|var|while)\b/,
				number: [Prism.languages.cpp.number, /\b(?:Infinity|NaN)\b/],
				operator: />>=?|<<=?|\|\||&&|:[:=]?|--|\+\+|[=!<>+\-*/%|&^]=?|[?~]|`[^`\r\n]{1,4}`/
			});
			Prism.languages.insertBefore('chaiscript', 'operator', {
				'parameter-type': {
					pattern: /([,(]\s*)\w+(?=\s+\w)/,
					lookbehind: true,
					alias: 'class-name'
				}
			});
			Prism.languages.insertBefore('chaiscript', 'string', {
				'string-interpolation': {
					pattern:
						/(^|[^\\])"(?:[^"$\\]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*"/,
					lookbehind: true,
					greedy: true,
					inside: {
						interpolation: {
							pattern: /((?:^|[^\\])(?:\\{2})*)\$\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\}/,
							lookbehind: true,
							inside: {
								'interpolation-expression': {
									pattern: /(^\$\{)[\s\S]+(?=\}$)/,
									lookbehind: true,
									inside: Prism.languages.chaiscript
								},
								'interpolation-punctuation': {
									pattern: /^\$\{|\}$/,
									alias: 'punctuation'
								}
							}
						},
						string: /[\s\S]+/
					}
				}
			});
		}
	}
});

// node_modules/refractor/lang/cil.js
var require_cil = __commonJS({
	'node_modules/refractor/lang/cil.js'(exports, module2) {
		'use strict';
		module2.exports = cil;
		cil.displayName = 'cil';
		cil.aliases = [];
		function cil(Prism) {
			Prism.languages.cil = {
				comment: /\/\/.*/,
				string: {
					pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
					greedy: true
				},
				directive: {
					pattern: /(^|\W)\.[a-z]+(?=\s)/,
					lookbehind: true,
					alias: 'class-name'
				},
				variable: /\[[\w\.]+\]/,
				keyword:
					/\b(?:abstract|ansi|assembly|auto|autochar|beforefieldinit|bool|bstr|byvalstr|catch|char|cil|class|currency|date|decimal|default|enum|error|explicit|extends|extern|famandassem|family|famorassem|final(?:ly)?|float32|float64|hidebysig|u?int(?:8|16|32|64)?|iant|idispatch|implements|import|initonly|instance|interface|iunknown|literal|lpstr|lpstruct|lptstr|lpwstr|managed|method|native(?:Type)?|nested|newslot|object(?:ref)?|pinvokeimpl|private|privatescope|public|reqsecobj|rtspecialname|runtime|sealed|sequential|serializable|specialname|static|string|struct|syschar|tbstr|unicode|unmanagedexp|unsigned|value(?:type)?|variant|virtual|void)\b/,
				function:
					/\b(?:(?:constrained|no|readonly|tail|unaligned|volatile)\.)?(?:conv\.(?:[iu][1248]?|ovf\.[iu][1248]?(?:\.un)?|r\.un|r4|r8)|ldc\.(?:i4(?:\.\d+|\.[mM]1|\.s)?|i8|r4|r8)|ldelem(?:\.[iu][1248]?|\.r[48]|\.ref|a)?|ldind\.(?:[iu][1248]?|r[48]|ref)|stelem\.?(?:i[1248]?|r[48]|ref)?|stind\.(?:i[1248]?|r[48]|ref)?|end(?:fault|filter|finally)|ldarg(?:\.[0-3s]|a(?:\.s)?)?|ldloc(?:\.\d+|\.s)?|sub(?:\.ovf(?:\.un)?)?|mul(?:\.ovf(?:\.un)?)?|add(?:\.ovf(?:\.un)?)?|stloc(?:\.[0-3s])?|refany(?:type|val)|blt(?:\.un)?(?:\.s)?|ble(?:\.un)?(?:\.s)?|bgt(?:\.un)?(?:\.s)?|bge(?:\.un)?(?:\.s)?|unbox(?:\.any)?|init(?:blk|obj)|call(?:i|virt)?|brfalse(?:\.s)?|bne\.un(?:\.s)?|ldloca(?:\.s)?|brzero(?:\.s)?|brtrue(?:\.s)?|brnull(?:\.s)?|brinst(?:\.s)?|starg(?:\.s)?|leave(?:\.s)?|shr(?:\.un)?|rem(?:\.un)?|div(?:\.un)?|clt(?:\.un)?|alignment|castclass|ldvirtftn|beq(?:\.s)?|ckfinite|ldsflda|ldtoken|localloc|mkrefany|rethrow|cgt\.un|arglist|switch|stsfld|sizeof|newobj|newarr|ldsfld|ldnull|ldflda|isinst|throw|stobj|stfld|ldstr|ldobj|ldlen|ldftn|ldfld|cpobj|cpblk|break|br\.s|xor|shl|ret|pop|not|nop|neg|jmp|dup|cgt|ceq|box|and|or|br)\b/,
				boolean: /\b(?:false|true)\b/,
				number: /\b-?(?:0x[0-9a-f]+|\d+)(?:\.[0-9a-f]+)?\b/i,
				punctuation: /[{}[\];(),:=]|IL_[0-9A-Za-z]+/
			};
		}
	}
});

// node_modules/refractor/lang/clojure.js
var require_clojure = __commonJS({
	'node_modules/refractor/lang/clojure.js'(exports, module2) {
		'use strict';
		module2.exports = clojure;
		clojure.displayName = 'clojure';
		clojure.aliases = [];
		function clojure(Prism) {
			Prism.languages.clojure = {
				comment: {
					pattern: /;.*/,
					greedy: true
				},
				string: {
					pattern: /"(?:[^"\\]|\\.)*"/,
					greedy: true
				},
				char: /\\\w+/,
				symbol: {
					pattern: /(^|[\s()\[\]{},])::?[\w*+!?'<>=/.-]+/,
					lookbehind: true
				},
				keyword: {
					pattern:
						/(\()(?:-|->|->>|\.|\.\.|\*|\/|\+|<|<=|=|==|>|>=|accessor|agent|agent-errors|aget|alength|all-ns|alter|and|append-child|apply|array-map|aset|aset-boolean|aset-byte|aset-char|aset-double|aset-float|aset-int|aset-long|aset-short|assert|assoc|await|await-for|bean|binding|bit-and|bit-not|bit-or|bit-shift-left|bit-shift-right|bit-xor|boolean|branch\?|butlast|byte|cast|char|children|class|clear-agent-errors|comment|commute|comp|comparator|complement|concat|cond|conj|cons|constantly|construct-proxy|contains\?|count|create-ns|create-struct|cycle|dec|declare|def|def-|definline|definterface|defmacro|defmethod|defmulti|defn|defn-|defonce|defproject|defprotocol|defrecord|defstruct|deftype|deref|difference|disj|dissoc|distinct|do|doall|doc|dorun|doseq|dosync|dotimes|doto|double|down|drop|drop-while|edit|end\?|ensure|eval|every\?|false\?|ffirst|file-seq|filter|find|find-doc|find-ns|find-var|first|float|flush|fn|fnseq|for|frest|gensym|get|get-proxy-class|hash-map|hash-set|identical\?|identity|if|if-let|if-not|import|in-ns|inc|index|insert-child|insert-left|insert-right|inspect-table|inspect-tree|instance\?|int|interleave|intersection|into|into-array|iterate|join|key|keys|keyword|keyword\?|last|lazy-cat|lazy-cons|left|lefts|let|line-seq|list|list\*|load|load-file|locking|long|loop|macroexpand|macroexpand-1|make-array|make-node|map|map-invert|map\?|mapcat|max|max-key|memfn|merge|merge-with|meta|min|min-key|monitor-enter|name|namespace|neg\?|new|newline|next|nil\?|node|not|not-any\?|not-every\?|not=|ns|ns-imports|ns-interns|ns-map|ns-name|ns-publics|ns-refers|ns-resolve|ns-unmap|nth|nthrest|or|parse|partial|path|peek|pop|pos\?|pr|pr-str|print|print-str|println|println-str|prn|prn-str|project|proxy|proxy-mappings|quot|quote|rand|rand-int|range|re-find|re-groups|re-matcher|re-matches|re-pattern|re-seq|read|read-line|recur|reduce|ref|ref-set|refer|rem|remove|remove-method|remove-ns|rename|rename-keys|repeat|replace|replicate|resolve|rest|resultset-seq|reverse|rfirst|right|rights|root|rrest|rseq|second|select|select-keys|send|send-off|seq|seq-zip|seq\?|set|set!|short|slurp|some|sort|sort-by|sorted-map|sorted-map-by|sorted-set|special-symbol\?|split-at|split-with|str|string\?|struct|struct-map|subs|subvec|symbol|symbol\?|sync|take|take-nth|take-while|test|throw|time|to-array|to-array-2d|tree-seq|true\?|try|union|up|update-proxy|val|vals|var|var-get|var-set|var\?|vector|vector-zip|vector\?|when|when-first|when-let|when-not|with-local-vars|with-meta|with-open|with-out-str|xml-seq|xml-zip|zero\?|zipmap|zipper)(?=[\s)]|$)/,
					lookbehind: true
				},
				boolean: /\b(?:false|nil|true)\b/,
				number: {
					pattern:
						/(^|[^\w$@])(?:\d+(?:[/.]\d+)?(?:e[+-]?\d+)?|0x[a-f0-9]+|[1-9]\d?r[a-z0-9]+)[lmn]?(?![\w$@])/i,
					lookbehind: true
				},
				function: {
					pattern: /((?:^|[^'])\()[\w*+!?'<>=/.-]+(?=[\s)]|$)/,
					lookbehind: true
				},
				operator: /[#@^`~]/,
				punctuation: /[{}\[\](),]/
			};
		}
	}
});

// node_modules/refractor/lang/cmake.js
var require_cmake = __commonJS({
	'node_modules/refractor/lang/cmake.js'(exports, module2) {
		'use strict';
		module2.exports = cmake;
		cmake.displayName = 'cmake';
		cmake.aliases = [];
		function cmake(Prism) {
			Prism.languages.cmake = {
				comment: /#.*/,
				string: {
					pattern: /"(?:[^\\"]|\\.)*"/,
					greedy: true,
					inside: {
						interpolation: {
							pattern: /\$\{(?:[^{}$]|\$\{[^{}$]*\})*\}/,
							inside: {
								punctuation: /\$\{|\}/,
								variable: /\w+/
							}
						}
					}
				},
				variable:
					/\b(?:CMAKE_\w+|\w+_(?:(?:BINARY|SOURCE)_DIR|DESCRIPTION|HOMEPAGE_URL|ROOT|VERSION(?:_MAJOR|_MINOR|_PATCH|_TWEAK)?)|(?:ANDROID|APPLE|BORLAND|BUILD_SHARED_LIBS|CACHE|CPACK_(?:ABSOLUTE_DESTINATION_FILES|COMPONENT_INCLUDE_TOPLEVEL_DIRECTORY|ERROR_ON_ABSOLUTE_INSTALL_DESTINATION|INCLUDE_TOPLEVEL_DIRECTORY|INSTALL_DEFAULT_DIRECTORY_PERMISSIONS|INSTALL_SCRIPT|PACKAGING_INSTALL_PREFIX|SET_DESTDIR|WARN_ON_ABSOLUTE_INSTALL_DESTINATION)|CTEST_(?:BINARY_DIRECTORY|BUILD_COMMAND|BUILD_NAME|BZR_COMMAND|BZR_UPDATE_OPTIONS|CHANGE_ID|CHECKOUT_COMMAND|CONFIGURATION_TYPE|CONFIGURE_COMMAND|COVERAGE_COMMAND|COVERAGE_EXTRA_FLAGS|CURL_OPTIONS|CUSTOM_(?:COVERAGE_EXCLUDE|ERROR_EXCEPTION|ERROR_MATCH|ERROR_POST_CONTEXT|ERROR_PRE_CONTEXT|MAXIMUM_FAILED_TEST_OUTPUT_SIZE|MAXIMUM_NUMBER_OF_(?:ERRORS|WARNINGS)|MAXIMUM_PASSED_TEST_OUTPUT_SIZE|MEMCHECK_IGNORE|POST_MEMCHECK|POST_TEST|PRE_MEMCHECK|PRE_TEST|TESTS_IGNORE|WARNING_EXCEPTION|WARNING_MATCH)|CVS_CHECKOUT|CVS_COMMAND|CVS_UPDATE_OPTIONS|DROP_LOCATION|DROP_METHOD|DROP_SITE|DROP_SITE_CDASH|DROP_SITE_PASSWORD|DROP_SITE_USER|EXTRA_COVERAGE_GLOB|GIT_COMMAND|GIT_INIT_SUBMODULES|GIT_UPDATE_CUSTOM|GIT_UPDATE_OPTIONS|HG_COMMAND|HG_UPDATE_OPTIONS|LABELS_FOR_SUBPROJECTS|MEMORYCHECK_(?:COMMAND|COMMAND_OPTIONS|SANITIZER_OPTIONS|SUPPRESSIONS_FILE|TYPE)|NIGHTLY_START_TIME|P4_CLIENT|P4_COMMAND|P4_OPTIONS|P4_UPDATE_OPTIONS|RUN_CURRENT_SCRIPT|SCP_COMMAND|SITE|SOURCE_DIRECTORY|SUBMIT_URL|SVN_COMMAND|SVN_OPTIONS|SVN_UPDATE_OPTIONS|TEST_LOAD|TEST_TIMEOUT|TRIGGER_SITE|UPDATE_COMMAND|UPDATE_OPTIONS|UPDATE_VERSION_ONLY|USE_LAUNCHERS)|CYGWIN|ENV|EXECUTABLE_OUTPUT_PATH|GHS-MULTI|IOS|LIBRARY_OUTPUT_PATH|MINGW|MSVC(?:10|11|12|14|60|70|71|80|90|_IDE|_TOOLSET_VERSION|_VERSION)?|MSYS|PROJECT_(?:BINARY_DIR|DESCRIPTION|HOMEPAGE_URL|NAME|SOURCE_DIR|VERSION|VERSION_(?:MAJOR|MINOR|PATCH|TWEAK))|UNIX|WIN32|WINCE|WINDOWS_PHONE|WINDOWS_STORE|XCODE|XCODE_VERSION))\b/,
				property:
					/\b(?:cxx_\w+|(?:ARCHIVE_OUTPUT_(?:DIRECTORY|NAME)|COMPILE_DEFINITIONS|COMPILE_PDB_NAME|COMPILE_PDB_OUTPUT_DIRECTORY|EXCLUDE_FROM_DEFAULT_BUILD|IMPORTED_(?:IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_LANGUAGES|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|NO_SONAME|OBJECTS|SONAME)|INTERPROCEDURAL_OPTIMIZATION|LIBRARY_OUTPUT_DIRECTORY|LIBRARY_OUTPUT_NAME|LINK_FLAGS|LINK_INTERFACE_LIBRARIES|LINK_INTERFACE_MULTIPLICITY|LOCATION|MAP_IMPORTED_CONFIG|OSX_ARCHITECTURES|OUTPUT_NAME|PDB_NAME|PDB_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_DIRECTORY|RUNTIME_OUTPUT_NAME|STATIC_LIBRARY_FLAGS|VS_CSHARP|VS_DOTNET_REFERENCEPROP|VS_DOTNET_REFERENCE|VS_GLOBAL_SECTION_POST|VS_GLOBAL_SECTION_PRE|VS_GLOBAL|XCODE_ATTRIBUTE)_\w+|\w+_(?:CLANG_TIDY|COMPILER_LAUNCHER|CPPCHECK|CPPLINT|INCLUDE_WHAT_YOU_USE|OUTPUT_NAME|POSTFIX|VISIBILITY_PRESET)|ABSTRACT|ADDITIONAL_MAKE_CLEAN_FILES|ADVANCED|ALIASED_TARGET|ALLOW_DUPLICATE_CUSTOM_TARGETS|ANDROID_(?:ANT_ADDITIONAL_OPTIONS|API|API_MIN|ARCH|ASSETS_DIRECTORIES|GUI|JAR_DEPENDENCIES|NATIVE_LIB_DEPENDENCIES|NATIVE_LIB_DIRECTORIES|PROCESS_MAX|PROGUARD|PROGUARD_CONFIG_PATH|SECURE_PROPS_PATH|SKIP_ANT_STEP|STL_TYPE)|ARCHIVE_OUTPUT_DIRECTORY|ATTACHED_FILES|ATTACHED_FILES_ON_FAIL|AUTOGEN_(?:BUILD_DIR|ORIGIN_DEPENDS|PARALLEL|SOURCE_GROUP|TARGETS_FOLDER|TARGET_DEPENDS)|AUTOMOC|AUTOMOC_(?:COMPILER_PREDEFINES|DEPEND_FILTERS|EXECUTABLE|MACRO_NAMES|MOC_OPTIONS|SOURCE_GROUP|TARGETS_FOLDER)|AUTORCC|AUTORCC_EXECUTABLE|AUTORCC_OPTIONS|AUTORCC_SOURCE_GROUP|AUTOUIC|AUTOUIC_EXECUTABLE|AUTOUIC_OPTIONS|AUTOUIC_SEARCH_PATHS|BINARY_DIR|BUILDSYSTEM_TARGETS|BUILD_RPATH|BUILD_RPATH_USE_ORIGIN|BUILD_WITH_INSTALL_NAME_DIR|BUILD_WITH_INSTALL_RPATH|BUNDLE|BUNDLE_EXTENSION|CACHE_VARIABLES|CLEAN_NO_CUSTOM|COMMON_LANGUAGE_RUNTIME|COMPATIBLE_INTERFACE_(?:BOOL|NUMBER_MAX|NUMBER_MIN|STRING)|COMPILE_(?:DEFINITIONS|FEATURES|FLAGS|OPTIONS|PDB_NAME|PDB_OUTPUT_DIRECTORY)|COST|CPACK_DESKTOP_SHORTCUTS|CPACK_NEVER_OVERWRITE|CPACK_PERMANENT|CPACK_STARTUP_SHORTCUTS|CPACK_START_MENU_SHORTCUTS|CPACK_WIX_ACL|CROSSCOMPILING_EMULATOR|CUDA_EXTENSIONS|CUDA_PTX_COMPILATION|CUDA_RESOLVE_DEVICE_SYMBOLS|CUDA_SEPARABLE_COMPILATION|CUDA_STANDARD|CUDA_STANDARD_REQUIRED|CXX_EXTENSIONS|CXX_STANDARD|CXX_STANDARD_REQUIRED|C_EXTENSIONS|C_STANDARD|C_STANDARD_REQUIRED|DEBUG_CONFIGURATIONS|DEFINE_SYMBOL|DEFINITIONS|DEPENDS|DEPLOYMENT_ADDITIONAL_FILES|DEPLOYMENT_REMOTE_DIRECTORY|DISABLED|DISABLED_FEATURES|ECLIPSE_EXTRA_CPROJECT_CONTENTS|ECLIPSE_EXTRA_NATURES|ENABLED_FEATURES|ENABLED_LANGUAGES|ENABLE_EXPORTS|ENVIRONMENT|EXCLUDE_FROM_ALL|EXCLUDE_FROM_DEFAULT_BUILD|EXPORT_NAME|EXPORT_PROPERTIES|EXTERNAL_OBJECT|EchoString|FAIL_REGULAR_EXPRESSION|FIND_LIBRARY_USE_LIB32_PATHS|FIND_LIBRARY_USE_LIB64_PATHS|FIND_LIBRARY_USE_LIBX32_PATHS|FIND_LIBRARY_USE_OPENBSD_VERSIONING|FIXTURES_CLEANUP|FIXTURES_REQUIRED|FIXTURES_SETUP|FOLDER|FRAMEWORK|Fortran_FORMAT|Fortran_MODULE_DIRECTORY|GENERATED|GENERATOR_FILE_NAME|GENERATOR_IS_MULTI_CONFIG|GHS_INTEGRITY_APP|GHS_NO_SOURCE_GROUP_FILE|GLOBAL_DEPENDS_DEBUG_MODE|GLOBAL_DEPENDS_NO_CYCLES|GNUtoMS|HAS_CXX|HEADER_FILE_ONLY|HELPSTRING|IMPLICIT_DEPENDS_INCLUDE_TRANSFORM|IMPORTED|IMPORTED_(?:COMMON_LANGUAGE_RUNTIME|CONFIGURATIONS|GLOBAL|IMPLIB|LIBNAME|LINK_DEPENDENT_LIBRARIES|LINK_INTERFACE_(?:LANGUAGES|LIBRARIES|MULTIPLICITY)|LOCATION|NO_SONAME|OBJECTS|SONAME)|IMPORT_PREFIX|IMPORT_SUFFIX|INCLUDE_DIRECTORIES|INCLUDE_REGULAR_EXPRESSION|INSTALL_NAME_DIR|INSTALL_RPATH|INSTALL_RPATH_USE_LINK_PATH|INTERFACE_(?:AUTOUIC_OPTIONS|COMPILE_DEFINITIONS|COMPILE_FEATURES|COMPILE_OPTIONS|INCLUDE_DIRECTORIES|LINK_DEPENDS|LINK_DIRECTORIES|LINK_LIBRARIES|LINK_OPTIONS|POSITION_INDEPENDENT_CODE|SOURCES|SYSTEM_INCLUDE_DIRECTORIES)|INTERPROCEDURAL_OPTIMIZATION|IN_TRY_COMPILE|IOS_INSTALL_COMBINED|JOB_POOLS|JOB_POOL_COMPILE|JOB_POOL_LINK|KEEP_EXTENSION|LABELS|LANGUAGE|LIBRARY_OUTPUT_DIRECTORY|LINKER_LANGUAGE|LINK_(?:DEPENDS|DEPENDS_NO_SHARED|DIRECTORIES|FLAGS|INTERFACE_LIBRARIES|INTERFACE_MULTIPLICITY|LIBRARIES|OPTIONS|SEARCH_END_STATIC|SEARCH_START_STATIC|WHAT_YOU_USE)|LISTFILE_STACK|LOCATION|MACOSX_BUNDLE|MACOSX_BUNDLE_INFO_PLIST|MACOSX_FRAMEWORK_INFO_PLIST|MACOSX_PACKAGE_LOCATION|MACOSX_RPATH|MACROS|MANUALLY_ADDED_DEPENDENCIES|MEASUREMENT|MODIFIED|NAME|NO_SONAME|NO_SYSTEM_FROM_IMPORTED|OBJECT_DEPENDS|OBJECT_OUTPUTS|OSX_ARCHITECTURES|OUTPUT_NAME|PACKAGES_FOUND|PACKAGES_NOT_FOUND|PARENT_DIRECTORY|PASS_REGULAR_EXPRESSION|PDB_NAME|PDB_OUTPUT_DIRECTORY|POSITION_INDEPENDENT_CODE|POST_INSTALL_SCRIPT|PREDEFINED_TARGETS_FOLDER|PREFIX|PRE_INSTALL_SCRIPT|PRIVATE_HEADER|PROCESSORS|PROCESSOR_AFFINITY|PROJECT_LABEL|PUBLIC_HEADER|REPORT_UNDEFINED_PROPERTIES|REQUIRED_FILES|RESOURCE|RESOURCE_LOCK|RULE_LAUNCH_COMPILE|RULE_LAUNCH_CUSTOM|RULE_LAUNCH_LINK|RULE_MESSAGES|RUNTIME_OUTPUT_DIRECTORY|RUN_SERIAL|SKIP_AUTOGEN|SKIP_AUTOMOC|SKIP_AUTORCC|SKIP_AUTOUIC|SKIP_BUILD_RPATH|SKIP_RETURN_CODE|SOURCES|SOURCE_DIR|SOVERSION|STATIC_LIBRARY_FLAGS|STATIC_LIBRARY_OPTIONS|STRINGS|SUBDIRECTORIES|SUFFIX|SYMBOLIC|TARGET_ARCHIVES_MAY_BE_SHARED_LIBS|TARGET_MESSAGES|TARGET_SUPPORTS_SHARED_LIBS|TESTS|TEST_INCLUDE_FILE|TEST_INCLUDE_FILES|TIMEOUT|TIMEOUT_AFTER_MATCH|TYPE|USE_FOLDERS|VALUE|VARIABLES|VERSION|VISIBILITY_INLINES_HIDDEN|VS_(?:CONFIGURATION_TYPE|COPY_TO_OUT_DIR|DEBUGGER_(?:COMMAND|COMMAND_ARGUMENTS|ENVIRONMENT|WORKING_DIRECTORY)|DEPLOYMENT_CONTENT|DEPLOYMENT_LOCATION|DOTNET_REFERENCES|DOTNET_REFERENCES_COPY_LOCAL|GLOBAL_KEYWORD|GLOBAL_PROJECT_TYPES|GLOBAL_ROOTNAMESPACE|INCLUDE_IN_VSIX|IOT_STARTUP_TASK|KEYWORD|RESOURCE_GENERATOR|SCC_AUXPATH|SCC_LOCALPATH|SCC_PROJECTNAME|SCC_PROVIDER|SDK_REFERENCES|SHADER_(?:DISABLE_OPTIMIZATIONS|ENABLE_DEBUG|ENTRYPOINT|FLAGS|MODEL|OBJECT_FILE_NAME|OUTPUT_HEADER_FILE|TYPE|VARIABLE_NAME)|STARTUP_PROJECT|TOOL_OVERRIDE|USER_PROPS|WINRT_COMPONENT|WINRT_EXTENSIONS|WINRT_REFERENCES|XAML_TYPE)|WILL_FAIL|WIN32_EXECUTABLE|WINDOWS_EXPORT_ALL_SYMBOLS|WORKING_DIRECTORY|WRAP_EXCLUDE|XCODE_(?:EMIT_EFFECTIVE_PLATFORM_NAME|EXPLICIT_FILE_TYPE|FILE_ATTRIBUTES|LAST_KNOWN_FILE_TYPE|PRODUCT_TYPE|SCHEME_(?:ADDRESS_SANITIZER|ADDRESS_SANITIZER_USE_AFTER_RETURN|ARGUMENTS|DISABLE_MAIN_THREAD_CHECKER|DYNAMIC_LIBRARY_LOADS|DYNAMIC_LINKER_API_USAGE|ENVIRONMENT|EXECUTABLE|GUARD_MALLOC|MAIN_THREAD_CHECKER_STOP|MALLOC_GUARD_EDGES|MALLOC_SCRIBBLE|MALLOC_STACK|THREAD_SANITIZER(?:_STOP)?|UNDEFINED_BEHAVIOUR_SANITIZER(?:_STOP)?|ZOMBIE_OBJECTS))|XCTEST)\b/,
				keyword:
					/\b(?:add_compile_definitions|add_compile_options|add_custom_command|add_custom_target|add_definitions|add_dependencies|add_executable|add_library|add_link_options|add_subdirectory|add_test|aux_source_directory|break|build_command|build_name|cmake_host_system_information|cmake_minimum_required|cmake_parse_arguments|cmake_policy|configure_file|continue|create_test_sourcelist|ctest_build|ctest_configure|ctest_coverage|ctest_empty_binary_directory|ctest_memcheck|ctest_read_custom_files|ctest_run_script|ctest_sleep|ctest_start|ctest_submit|ctest_test|ctest_update|ctest_upload|define_property|else|elseif|enable_language|enable_testing|endforeach|endfunction|endif|endmacro|endwhile|exec_program|execute_process|export|export_library_dependencies|file|find_file|find_library|find_package|find_path|find_program|fltk_wrap_ui|foreach|function|get_cmake_property|get_directory_property|get_filename_component|get_property|get_source_file_property|get_target_property|get_test_property|if|include|include_directories|include_external_msproject|include_guard|include_regular_expression|install|install_files|install_programs|install_targets|link_directories|link_libraries|list|load_cache|load_command|macro|make_directory|mark_as_advanced|math|message|option|output_required_files|project|qt_wrap_cpp|qt_wrap_ui|remove|remove_definitions|return|separate_arguments|set|set_directory_properties|set_property|set_source_files_properties|set_target_properties|set_tests_properties|site_name|source_group|string|subdir_depends|subdirs|target_compile_definitions|target_compile_features|target_compile_options|target_include_directories|target_link_directories|target_link_libraries|target_link_options|target_sources|try_compile|try_run|unset|use_mangled_mesa|utility_source|variable_requires|variable_watch|while|write_file)(?=\s*\()\b/,
				boolean: /\b(?:FALSE|OFF|ON|TRUE)\b/,
				namespace: /\b(?:INTERFACE|PRIVATE|PROPERTIES|PUBLIC|SHARED|STATIC|TARGET_OBJECTS)\b/,
				operator:
					/\b(?:AND|DEFINED|EQUAL|GREATER|LESS|MATCHES|NOT|OR|STREQUAL|STRGREATER|STRLESS|VERSION_EQUAL|VERSION_GREATER|VERSION_LESS)\b/,
				inserted: {
					pattern: /\b\w+::\w+\b/,
					alias: 'class-name'
				},
				number: /\b\d+(?:\.\d+)*\b/,
				function: /\b[a-z_]\w*(?=\s*\()\b/i,
				punctuation: /[()>}]|\$[<{]/
			};
		}
	}
});

// node_modules/refractor/lang/cobol.js
var require_cobol = __commonJS({
	'node_modules/refractor/lang/cobol.js'(exports, module2) {
		'use strict';
		module2.exports = cobol;
		cobol.displayName = 'cobol';
		cobol.aliases = [];
		function cobol(Prism) {
			Prism.languages.cobol = {
				comment: {
					pattern: /\*>.*|(^[ \t]*)\*.*/m,
					lookbehind: true,
					greedy: true
				},
				string: {
					pattern: /[xzgn]?(?:"(?:[^\r\n"]|"")*"(?!")|'(?:[^\r\n']|'')*'(?!'))/i,
					greedy: true
				},
				level: {
					pattern: /(^[ \t]*)\d+\b/m,
					lookbehind: true,
					greedy: true,
					alias: 'number'
				},
				'class-name': {
					pattern: /(\bpic(?:ture)?\s+)(?:(?:[-\w$/,:*+<>]|\.(?!\s|$))(?:\(\d+\))?)+/i,
					lookbehind: true,
					inside: {
						number: {
							pattern: /(\()\d+/,
							lookbehind: true
						},
						punctuation: /[()]/
					}
				},
				keyword: {
					pattern:
						/(^|[^\w-])(?:ABORT|ACCEPT|ACCESS|ADD|ADDRESS|ADVANCING|AFTER|ALIGNED|ALL|ALPHABET|ALPHABETIC|ALPHABETIC-LOWER|ALPHABETIC-UPPER|ALPHANUMERIC|ALPHANUMERIC-EDITED|ALSO|ALTER|ALTERNATE|ANY|ARE|AREA|AREAS|AS|ASCENDING|ASCII|ASSIGN|ASSOCIATED-DATA|ASSOCIATED-DATA-LENGTH|AT|ATTRIBUTE|AUTHOR|AUTO|AUTO-SKIP|BACKGROUND-COLOR|BACKGROUND-COLOUR|BASIS|BEEP|BEFORE|BEGINNING|BELL|BINARY|BIT|BLANK|BLINK|BLOCK|BOTTOM|BOUNDS|BY|BYFUNCTION|BYTITLE|CALL|CANCEL|CAPABLE|CCSVERSION|CD|CF|CH|CHAINING|CHANGED|CHANNEL|CHARACTER|CHARACTERS|CLASS|CLASS-ID|CLOCK-UNITS|CLOSE|CLOSE-DISPOSITION|COBOL|CODE|CODE-SET|COL|COLLATING|COLUMN|COM-REG|COMMA|COMMITMENT|COMMON|COMMUNICATION|COMP|COMP-1|COMP-2|COMP-3|COMP-4|COMP-5|COMPUTATIONAL|COMPUTATIONAL-1|COMPUTATIONAL-2|COMPUTATIONAL-3|COMPUTATIONAL-4|COMPUTATIONAL-5|COMPUTE|CONFIGURATION|CONTAINS|CONTENT|CONTINUE|CONTROL|CONTROL-POINT|CONTROLS|CONVENTION|CONVERTING|COPY|CORR|CORRESPONDING|COUNT|CRUNCH|CURRENCY|CURSOR|DATA|DATA-BASE|DATE|DATE-COMPILED|DATE-WRITTEN|DAY|DAY-OF-WEEK|DBCS|DE|DEBUG-CONTENTS|DEBUG-ITEM|DEBUG-LINE|DEBUG-NAME|DEBUG-SUB-1|DEBUG-SUB-2|DEBUG-SUB-3|DEBUGGING|DECIMAL-POINT|DECLARATIVES|DEFAULT|DEFAULT-DISPLAY|DEFINITION|DELETE|DELIMITED|DELIMITER|DEPENDING|DESCENDING|DESTINATION|DETAIL|DFHRESP|DFHVALUE|DISABLE|DISK|DISPLAY|DISPLAY-1|DIVIDE|DIVISION|DONTCARE|DOUBLE|DOWN|DUPLICATES|DYNAMIC|EBCDIC|EGCS|EGI|ELSE|EMI|EMPTY-CHECK|ENABLE|END|END-ACCEPT|END-ADD|END-CALL|END-COMPUTE|END-DELETE|END-DIVIDE|END-EVALUATE|END-IF|END-MULTIPLY|END-OF-PAGE|END-PERFORM|END-READ|END-RECEIVE|END-RETURN|END-REWRITE|END-SEARCH|END-START|END-STRING|END-SUBTRACT|END-UNSTRING|END-WRITE|ENDING|ENTER|ENTRY|ENTRY-PROCEDURE|ENVIRONMENT|EOL|EOP|EOS|ERASE|ERROR|ESCAPE|ESI|EVALUATE|EVENT|EVERY|EXCEPTION|EXCLUSIVE|EXHIBIT|EXIT|EXPORT|EXTEND|EXTENDED|EXTERNAL|FD|FILE|FILE-CONTROL|FILLER|FINAL|FIRST|FOOTING|FOR|FOREGROUND-COLOR|FOREGROUND-COLOUR|FROM|FULL|FUNCTION|FUNCTION-POINTER|FUNCTIONNAME|GENERATE|GIVING|GLOBAL|GO|GOBACK|GRID|GROUP|HEADING|HIGH-VALUE|HIGH-VALUES|HIGHLIGHT|I-O|I-O-CONTROL|ID|IDENTIFICATION|IF|IMPLICIT|IMPORT|IN|INDEX|INDEXED|INDICATE|INITIAL|INITIALIZE|INITIATE|INPUT|INPUT-OUTPUT|INSPECT|INSTALLATION|INTEGER|INTO|INVALID|INVOKE|IS|JUST|JUSTIFIED|KANJI|KEPT|KEY|KEYBOARD|LABEL|LANGUAGE|LAST|LB|LD|LEADING|LEFT|LEFTLINE|LENGTH|LENGTH-CHECK|LIBACCESS|LIBPARAMETER|LIBRARY|LIMIT|LIMITS|LINAGE|LINAGE-COUNTER|LINE|LINE-COUNTER|LINES|LINKAGE|LIST|LOCAL|LOCAL-STORAGE|LOCK|LONG-DATE|LONG-TIME|LOW-VALUE|LOW-VALUES|LOWER|LOWLIGHT|MEMORY|MERGE|MESSAGE|MMDDYYYY|MODE|MODULES|MORE-LABELS|MOVE|MULTIPLE|MULTIPLY|NAMED|NATIONAL|NATIONAL-EDITED|NATIVE|NEGATIVE|NETWORK|NEXT|NO|NO-ECHO|NULL|NULLS|NUMBER|NUMERIC|NUMERIC-DATE|NUMERIC-EDITED|NUMERIC-TIME|OBJECT-COMPUTER|OCCURS|ODT|OF|OFF|OMITTED|ON|OPEN|OPTIONAL|ORDER|ORDERLY|ORGANIZATION|OTHER|OUTPUT|OVERFLOW|OVERLINE|OWN|PACKED-DECIMAL|PADDING|PAGE|PAGE-COUNTER|PASSWORD|PERFORM|PF|PH|PIC|PICTURE|PLUS|POINTER|PORT|POSITION|POSITIVE|PRINTER|PRINTING|PRIVATE|PROCEDURE|PROCEDURE-POINTER|PROCEDURES|PROCEED|PROCESS|PROGRAM|PROGRAM-ID|PROGRAM-LIBRARY|PROMPT|PURGE|QUEUE|QUOTE|QUOTES|RANDOM|RD|READ|READER|REAL|RECEIVE|RECEIVED|RECORD|RECORDING|RECORDS|RECURSIVE|REDEFINES|REEL|REF|REFERENCE|REFERENCES|RELATIVE|RELEASE|REMAINDER|REMARKS|REMOTE|REMOVAL|REMOVE|RENAMES|REPLACE|REPLACING|REPORT|REPORTING|REPORTS|REQUIRED|RERUN|RESERVE|RESET|RETURN|RETURN-CODE|RETURNING|REVERSE-VIDEO|REVERSED|REWIND|REWRITE|RF|RH|RIGHT|ROUNDED|RUN|SAME|SAVE|SCREEN|SD|SEARCH|SECTION|SECURE|SECURITY|SEGMENT|SEGMENT-LIMIT|SELECT|SEND|SENTENCE|SEPARATE|SEQUENCE|SEQUENTIAL|SET|SHARED|SHAREDBYALL|SHAREDBYRUNUNIT|SHARING|SHIFT-IN|SHIFT-OUT|SHORT-DATE|SIGN|SIZE|SORT|SORT-CONTROL|SORT-CORE-SIZE|SORT-FILE-SIZE|SORT-MERGE|SORT-MESSAGE|SORT-MODE-SIZE|SORT-RETURN|SOURCE|SOURCE-COMPUTER|SPACE|SPACES|SPECIAL-NAMES|STANDARD|STANDARD-1|STANDARD-2|START|STATUS|STOP|STRING|SUB-QUEUE-1|SUB-QUEUE-2|SUB-QUEUE-3|SUBTRACT|SUM|SUPPRESS|SYMBOL|SYMBOLIC|SYNC|SYNCHRONIZED|TABLE|TALLY|TALLYING|TAPE|TASK|TERMINAL|TERMINATE|TEST|TEXT|THEN|THREAD|THREAD-LOCAL|THROUGH|THRU|TIME|TIMER|TIMES|TITLE|TO|TODAYS-DATE|TODAYS-NAME|TOP|TRAILING|TRUNCATED|TYPE|TYPEDEF|UNDERLINE|UNIT|UNSTRING|UNTIL|UP|UPON|USAGE|USE|USING|VALUE|VALUES|VARYING|VIRTUAL|WAIT|WHEN|WHEN-COMPILED|WITH|WORDS|WORKING-STORAGE|WRITE|YEAR|YYYYDDD|YYYYMMDD|ZERO-FILL|ZEROES|ZEROS)(?![\w-])/i,
					lookbehind: true
				},
				boolean: {
					pattern: /(^|[^\w-])(?:false|true)(?![\w-])/i,
					lookbehind: true
				},
				number: {
					pattern:
						/(^|[^\w-])(?:[+-]?(?:(?:\d+(?:[.,]\d+)?|[.,]\d+)(?:e[+-]?\d+)?|zero))(?![\w-])/i,
					lookbehind: true
				},
				operator: [
					/<>|[<>]=?|[=+*/&]/,
					{
						pattern: /(^|[^\w-])(?:-|and|equal|greater|less|not|or|than)(?![\w-])/i,
						lookbehind: true
					}
				],
				punctuation: /[.:,()]/
			};
		}
	}
});

// node_modules/refractor/lang/coffeescript.js
var require_coffeescript = __commonJS({
	'node_modules/refractor/lang/coffeescript.js'(exports, module2) {
		'use strict';
		module2.exports = coffeescript;
		coffeescript.displayName = 'coffeescript';
		coffeescript.aliases = ['coffee'];
		function coffeescript(Prism) {
			(function (Prism2) {
				var comment4 = /#(?!\{).+/;
				var interpolation = {
					pattern: /#\{[^}]+\}/,
					alias: 'variable'
				};
				Prism2.languages.coffeescript = Prism2.languages.extend('javascript', {
					comment: comment4,
					string: [
						{
							pattern: /'(?:\\[\s\S]|[^\\'])*'/,
							greedy: true
						},
						{
							pattern: /"(?:\\[\s\S]|[^\\"])*"/,
							greedy: true,
							inside: {
								interpolation
							}
						}
					],
					keyword:
						/\b(?:and|break|by|catch|class|continue|debugger|delete|do|each|else|extend|extends|false|finally|for|if|in|instanceof|is|isnt|let|loop|namespace|new|no|not|null|of|off|on|or|own|return|super|switch|then|this|throw|true|try|typeof|undefined|unless|until|when|while|window|with|yes|yield)\b/,
					'class-member': {
						pattern: /@(?!\d)\w+/,
						alias: 'variable'
					}
				});
				Prism2.languages.insertBefore('coffeescript', 'comment', {
					'multiline-comment': {
						pattern: /###[\s\S]+?###/,
						alias: 'comment'
					},
					'block-regex': {
						pattern: /\/{3}[\s\S]*?\/{3}/,
						alias: 'regex',
						inside: {
							comment: comment4,
							interpolation
						}
					}
				});
				Prism2.languages.insertBefore('coffeescript', 'string', {
					'inline-javascript': {
						pattern: /`(?:\\[\s\S]|[^\\`])*`/,
						inside: {
							delimiter: {
								pattern: /^`|`$/,
								alias: 'punctuation'
							},
							script: {
								pattern: /[\s\S]+/,
								alias: 'language-javascript',
								inside: Prism2.languages.javascript
							}
						}
					},
					'multiline-string': [
						{
							pattern: /'''[\s\S]*?'''/,
							greedy: true,
							alias: 'string'
						},
						{
							pattern: /"""[\s\S]*?"""/,
							greedy: true,
							alias: 'string',
							inside: {
								interpolation
							}
						}
					]
				});
				Prism2.languages.insertBefore('coffeescript', 'keyword', {
					property: /(?!\d)\w+(?=\s*:(?!:))/
				});
				delete Prism2.languages.coffeescript['template-string'];
				Prism2.languages.coffee = Prism2.languages.coffeescript;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/concurnas.js
var require_concurnas = __commonJS({
	'node_modules/refractor/lang/concurnas.js'(exports, module2) {
		'use strict';
		module2.exports = concurnas;
		concurnas.displayName = 'concurnas';
		concurnas.aliases = ['conc'];
		function concurnas(Prism) {
			Prism.languages.concurnas = {
				comment: {
					pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\/\/.*)/,
					lookbehind: true,
					greedy: true
				},
				langext: {
					pattern: /\b\w+\s*\|\|[\s\S]+?\|\|/,
					greedy: true,
					inside: {
						'class-name': /^\w+/,
						string: {
							pattern: /(^\s*\|\|)[\s\S]+(?=\|\|$)/,
							lookbehind: true
						},
						punctuation: /\|\|/
					}
				},
				function: {
					pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/,
					lookbehind: true
				},
				keyword:
					/\b(?:abstract|actor|also|annotation|assert|async|await|bool|boolean|break|byte|case|catch|changed|char|class|closed|constant|continue|def|default|del|double|elif|else|enum|every|extends|false|finally|float|for|from|global|gpudef|gpukernel|if|import|in|init|inject|int|lambda|local|long|loop|match|new|nodefault|null|of|onchange|open|out|override|package|parfor|parforsync|post|pre|private|protected|provide|provider|public|return|shared|short|single|size_t|sizeof|super|sync|this|throw|trait|trans|transient|true|try|typedef|unchecked|using|val|var|void|while|with)\b/,
				boolean: /\b(?:false|true)\b/,
				number:
					/\b0b[01][01_]*L?\b|\b0x(?:[\da-f_]*\.)?[\da-f_p+-]+\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfls]?/i,
				punctuation: /[{}[\];(),.:]/,
				operator:
					/<==|>==|=>|->|<-|<>|&==|&<>|\?:?|\.\?|\+\+|--|[-+*/=<>]=?|[!^~]|\b(?:and|as|band|bor|bxor|comp|is|isnot|mod|or)\b=?/,
				annotation: {
					pattern: /@(?:\w+:)?(?:\w+|\[[^\]]+\])?/,
					alias: 'builtin'
				}
			};
			Prism.languages.insertBefore('concurnas', 'langext', {
				'regex-literal': {
					pattern: /\br("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
					greedy: true,
					inside: {
						interpolation: {
							pattern: /((?:^|[^\\])(?:\\{2})*)\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
							lookbehind: true,
							inside: Prism.languages.concurnas
						},
						regex: /[\s\S]+/
					}
				},
				'string-literal': {
					pattern: /(?:\B|\bs)("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
					greedy: true,
					inside: {
						interpolation: {
							pattern: /((?:^|[^\\])(?:\\{2})*)\{(?:[^{}]|\{(?:[^{}]|\{[^}]*\})*\})+\}/,
							lookbehind: true,
							inside: Prism.languages.concurnas
						},
						string: /[\s\S]+/
					}
				}
			});
			Prism.languages.conc = Prism.languages.concurnas;
		}
	}
});

// node_modules/refractor/lang/coq.js
var require_coq = __commonJS({
	'node_modules/refractor/lang/coq.js'(exports, module2) {
		'use strict';
		module2.exports = coq;
		coq.displayName = 'coq';
		coq.aliases = [];
		function coq(Prism) {
			(function (Prism2) {
				var commentSource = /\(\*(?:[^(*]|\((?!\*)|\*(?!\))|<self>)*\*\)/.source;
				for (var i2 = 0; i2 < 2; i2++) {
					commentSource = commentSource.replace(/<self>/g, function () {
						return commentSource;
					});
				}
				commentSource = commentSource.replace(/<self>/g, '[]');
				Prism2.languages.coq = {
					comment: RegExp(commentSource),
					string: {
						pattern: /"(?:[^"]|"")*"(?!")/,
						greedy: true
					},
					attribute: [
						{
							pattern: RegExp(
								/#\[(?:[^\[\]("]|"(?:[^"]|"")*"(?!")|\((?!\*)|<comment>)*\]/.source.replace(
									/<comment>/g,
									function () {
										return commentSource;
									}
								)
							),
							greedy: true,
							alias: 'attr-name',
							inside: {
								comment: RegExp(commentSource),
								string: {
									pattern: /"(?:[^"]|"")*"(?!")/,
									greedy: true
								},
								operator: /=/,
								punctuation: /^#\[|\]$|[,()]/
							}
						},
						{
							pattern:
								/\b(?:Cumulative|Global|Local|Monomorphic|NonCumulative|Polymorphic|Private|Program)\b/,
							alias: 'attr-name'
						}
					],
					keyword:
						/\b(?:Abort|About|Add|Admit|Admitted|All|Arguments|As|Assumptions|Axiom|Axioms|Back|BackTo|Backtrace|BinOp|BinOpSpec|BinRel|Bind|Blacklist|Canonical|Case|Cd|Check|Class|Classes|Close|CoFixpoint|CoInductive|Coercion|Coercions|Collection|Combined|Compute|Conjecture|Conjectures|Constant|Constants|Constraint|Constructors|Context|Corollary|Create|CstOp|Custom|Cut|Debug|Declare|Defined|Definition|Delimit|Dependencies|Dependent|Derive|Diffs|Drop|Elimination|End|Entry|Equality|Eval|Example|Existential|Existentials|Existing|Export|Extern|Extraction|Fact|Fail|Field|File|Firstorder|Fixpoint|Flags|Focus|From|Funclass|Function|Functional|GC|Generalizable|Goal|Grab|Grammar|Graph|Guarded|Haskell|Heap|Hide|Hint|HintDb|Hints|Hypotheses|Hypothesis|IF|Identity|Immediate|Implicit|Implicits|Import|Include|Induction|Inductive|Infix|Info|Initial|InjTyp|Inline|Inspect|Instance|Instances|Intro|Intros|Inversion|Inversion_clear|JSON|Language|Left|Lemma|Let|Lia|Libraries|Library|Load|LoadPath|Locate|Ltac|Ltac2|ML|Match|Method|Minimality|Module|Modules|Morphism|Next|NoInline|Notation|Number|OCaml|Obligation|Obligations|Opaque|Open|Optimize|Parameter|Parameters|Parametric|Path|Paths|Prenex|Preterm|Primitive|Print|Profile|Projections|Proof|Prop|PropBinOp|PropOp|PropUOp|Property|Proposition|Pwd|Qed|Quit|Rec|Record|Recursive|Redirect|Reduction|Register|Relation|Remark|Remove|Require|Reserved|Reset|Resolve|Restart|Rewrite|Right|Ring|Rings|SProp|Saturate|Save|Scheme|Scope|Scopes|Search|SearchHead|SearchPattern|SearchRewrite|Section|Separate|Set|Setoid|Show|Signatures|Solve|Solver|Sort|Sortclass|Sorted|Spec|Step|Strategies|Strategy|String|Structure|SubClass|Subgraph|SuchThat|Tactic|Term|TestCompile|Theorem|Time|Timeout|To|Transparent|Type|Typeclasses|Types|Typing|UnOp|UnOpSpec|Undelimit|Undo|Unfocus|Unfocused|Unfold|Universe|Universes|Unshelve|Variable|Variables|Variant|Verbose|View|Visibility|Zify|_|apply|as|at|by|cofix|else|end|exists|exists2|fix|for|forall|fun|if|in|let|match|measure|move|removed|return|struct|then|using|wf|where|with)\b/,
					number:
						/\b(?:0x[a-f0-9][a-f0-9_]*(?:\.[a-f0-9_]+)?(?:p[+-]?\d[\d_]*)?|\d[\d_]*(?:\.[\d_]+)?(?:e[+-]?\d[\d_]*)?)\b/i,
					punct: {
						pattern: /@\{|\{\||\[=|:>/,
						alias: 'punctuation'
					},
					operator:
						/\/\\|\\\/|\.{2,3}|:{1,2}=|\*\*|[-=]>|<(?:->?|[+:=>]|<:)|>(?:=|->)|\|[-|]?|[-!%&*+/<=>?@^~']/,
					punctuation: /\.\(|`\(|@\{|`\{|\{\||\[=|:>|[:.,;(){}\[\]]/
				};
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/ruby.js
var require_ruby = __commonJS({
	'node_modules/refractor/lang/ruby.js'(exports, module2) {
		'use strict';
		module2.exports = ruby;
		ruby.displayName = 'ruby';
		ruby.aliases = ['rb'];
		function ruby(Prism) {
			(function (Prism2) {
				Prism2.languages.ruby = Prism2.languages.extend('clike', {
					comment: {
						pattern: /#.*|^=begin\s[\s\S]*?^=end/m,
						greedy: true
					},
					'class-name': {
						pattern: /(\b(?:class|module)\s+|\bcatch\s+\()[\w.\\]+|\b[A-Z_]\w*(?=\s*\.\s*new\b)/,
						lookbehind: true,
						inside: {
							punctuation: /[.\\]/
						}
					},
					keyword:
						/\b(?:BEGIN|END|alias|and|begin|break|case|class|def|define_method|defined|do|each|else|elsif|end|ensure|extend|for|if|in|include|module|new|next|nil|not|or|prepend|private|protected|public|raise|redo|require|rescue|retry|return|self|super|then|throw|undef|unless|until|when|while|yield)\b/,
					operator: /\.{2,3}|&\.|===|<?=>|[!=]?~|(?:&&|\|\||<<|>>|\*\*|[+\-*/%<>!^&|=])=?|[?:]/,
					punctuation: /[(){}[\].,;]/
				});
				Prism2.languages.insertBefore('ruby', 'operator', {
					'double-colon': {
						pattern: /::/,
						alias: 'punctuation'
					}
				});
				var interpolation = {
					pattern: /((?:^|[^\\])(?:\\{2})*)#\{(?:[^{}]|\{[^{}]*\})*\}/,
					lookbehind: true,
					inside: {
						content: {
							pattern: /^(#\{)[\s\S]+(?=\}$)/,
							lookbehind: true,
							inside: Prism2.languages.ruby
						},
						delimiter: {
							pattern: /^#\{|\}$/,
							alias: 'punctuation'
						}
					}
				};
				delete Prism2.languages.ruby.function;
				var percentExpression =
					'(?:' +
					[
						/([^a-zA-Z0-9\s{(\[<=])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
						/\((?:[^()\\]|\\[\s\S]|\((?:[^()\\]|\\[\s\S])*\))*\)/.source,
						/\{(?:[^{}\\]|\\[\s\S]|\{(?:[^{}\\]|\\[\s\S])*\})*\}/.source,
						/\[(?:[^\[\]\\]|\\[\s\S]|\[(?:[^\[\]\\]|\\[\s\S])*\])*\]/.source,
						/<(?:[^<>\\]|\\[\s\S]|<(?:[^<>\\]|\\[\s\S])*>)*>/.source
					].join('|') +
					')';
				var symbolName = /(?:"(?:\\.|[^"\\\r\n])*"|(?:\b[a-zA-Z_]\w*|[^\s\0-\x7F]+)[?!]?|\$.)/
					.source;
				Prism2.languages.insertBefore('ruby', 'keyword', {
					'regex-literal': [
						{
							pattern: RegExp(/%r/.source + percentExpression + /[egimnosux]{0,6}/.source),
							greedy: true,
							inside: {
								interpolation,
								regex: /[\s\S]+/
							}
						},
						{
							pattern:
								/(^|[^/])\/(?!\/)(?:\[[^\r\n\]]+\]|\\.|[^[/\\\r\n])+\/[egimnosux]{0,6}(?=\s*(?:$|[\r\n,.;})#]))/,
							lookbehind: true,
							greedy: true,
							inside: {
								interpolation,
								regex: /[\s\S]+/
							}
						}
					],
					variable: /[@$]+[a-zA-Z_]\w*(?:[?!]|\b)/,
					symbol: [
						{
							pattern: RegExp(/(^|[^:]):/.source + symbolName),
							lookbehind: true,
							greedy: true
						},
						{
							pattern: RegExp(/([\r\n{(,][ \t]*)/.source + symbolName + /(?=:(?!:))/.source),
							lookbehind: true,
							greedy: true
						}
					],
					'method-definition': {
						pattern: /(\bdef\s+)\w+(?:\s*\.\s*\w+)?/,
						lookbehind: true,
						inside: {
							function: /\b\w+$/,
							keyword: /^self\b/,
							'class-name': /^\w+/,
							punctuation: /\./
						}
					}
				});
				Prism2.languages.insertBefore('ruby', 'string', {
					'string-literal': [
						{
							pattern: RegExp(/%[qQiIwWs]?/.source + percentExpression),
							greedy: true,
							inside: {
								interpolation,
								string: /[\s\S]+/
							}
						},
						{
							pattern: /("|')(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|(?!\1)[^\\#\r\n])*\1/,
							greedy: true,
							inside: {
								interpolation,
								string: /[\s\S]+/
							}
						},
						{
							pattern: /<<[-~]?([a-z_]\w*)[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
							alias: 'heredoc-string',
							greedy: true,
							inside: {
								delimiter: {
									pattern: /^<<[-~]?[a-z_]\w*|\b[a-z_]\w*$/i,
									inside: {
										symbol: /\b\w+/,
										punctuation: /^<<[-~]?/
									}
								},
								interpolation,
								string: /[\s\S]+/
							}
						},
						{
							pattern: /<<[-~]?'([a-z_]\w*)'[\r\n](?:.*[\r\n])*?[\t ]*\1/i,
							alias: 'heredoc-string',
							greedy: true,
							inside: {
								delimiter: {
									pattern: /^<<[-~]?'[a-z_]\w*'|\b[a-z_]\w*$/i,
									inside: {
										symbol: /\b\w+/,
										punctuation: /^<<[-~]?'|'$/
									}
								},
								string: /[\s\S]+/
							}
						}
					],
					'command-literal': [
						{
							pattern: RegExp(/%x/.source + percentExpression),
							greedy: true,
							inside: {
								interpolation,
								command: {
									pattern: /[\s\S]+/,
									alias: 'string'
								}
							}
						},
						{
							pattern: /`(?:#\{[^}]+\}|#(?!\{)|\\(?:\r\n|[\s\S])|[^\\`#\r\n])*`/,
							greedy: true,
							inside: {
								interpolation,
								command: {
									pattern: /[\s\S]+/,
									alias: 'string'
								}
							}
						}
					]
				});
				delete Prism2.languages.ruby.string;
				Prism2.languages.insertBefore('ruby', 'number', {
					builtin:
						/\b(?:Array|Bignum|Binding|Class|Continuation|Dir|Exception|FalseClass|File|Fixnum|Float|Hash|IO|Integer|MatchData|Method|Module|NilClass|Numeric|Object|Proc|Range|Regexp|Stat|String|Struct|Symbol|TMS|Thread|ThreadGroup|Time|TrueClass)\b/,
					constant: /\b[A-Z][A-Z0-9_]*(?:[?!]|\b)/
				});
				Prism2.languages.rb = Prism2.languages.ruby;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/crystal.js
var require_crystal = __commonJS({
	'node_modules/refractor/lang/crystal.js'(exports, module2) {
		'use strict';
		var refractorRuby = require_ruby();
		module2.exports = crystal;
		crystal.displayName = 'crystal';
		crystal.aliases = [];
		function crystal(Prism) {
			Prism.register(refractorRuby);
			(function (Prism2) {
				Prism2.languages.crystal = Prism2.languages.extend('ruby', {
					keyword: [
						/\b(?:__DIR__|__END_LINE__|__FILE__|__LINE__|abstract|alias|annotation|as|asm|begin|break|case|class|def|do|else|elsif|end|ensure|enum|extend|for|fun|if|ifdef|include|instance_sizeof|lib|macro|module|next|of|out|pointerof|private|protected|ptr|require|rescue|return|select|self|sizeof|struct|super|then|type|typeof|undef|uninitialized|union|unless|until|when|while|with|yield)\b/,
						{
							pattern: /(\.\s*)(?:is_a|responds_to)\?/,
							lookbehind: true
						}
					],
					number:
						/\b(?:0b[01_]*[01]|0o[0-7_]*[0-7]|0x[\da-fA-F_]*[\da-fA-F]|(?:\d(?:[\d_]*\d)?)(?:\.[\d_]*\d)?(?:[eE][+-]?[\d_]*\d)?)(?:_(?:[uif](?:8|16|32|64))?)?\b/,
					operator: [/->/, Prism2.languages.ruby.operator],
					punctuation: /[(){}[\].,;\\]/
				});
				Prism2.languages.insertBefore('crystal', 'string-literal', {
					attribute: {
						pattern: /@\[.*?\]/,
						inside: {
							delimiter: {
								pattern: /^@\[|\]$/,
								alias: 'punctuation'
							},
							attribute: {
								pattern: /^(\s*)\w+/,
								lookbehind: true,
								alias: 'class-name'
							},
							args: {
								pattern: /\S(?:[\s\S]*\S)?/,
								inside: Prism2.languages.crystal
							}
						}
					},
					expansion: {
						pattern: /\{(?:\{.*?\}|%.*?%)\}/,
						inside: {
							content: {
								pattern: /^(\{.)[\s\S]+(?=.\}$)/,
								lookbehind: true,
								inside: Prism2.languages.crystal
							},
							delimiter: {
								pattern: /^\{[\{%]|[\}%]\}$/,
								alias: 'operator'
							}
						}
					},
					char: {
						pattern: /'(?:[^\\\r\n]{1,2}|\\(?:.|u(?:[A-Fa-f0-9]{1,4}|\{[A-Fa-f0-9]{1,6}\})))'/,
						greedy: true
					}
				});
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/cshtml.js
var require_cshtml = __commonJS({
	'node_modules/refractor/lang/cshtml.js'(exports, module2) {
		'use strict';
		var refractorCsharp = require_csharp();
		module2.exports = cshtml;
		cshtml.displayName = 'cshtml';
		cshtml.aliases = ['razor'];
		function cshtml(Prism) {
			Prism.register(refractorCsharp);
			(function (Prism2) {
				var commentLike = /\/(?![/*])|\/\/.*[\r\n]|\/\*[^*]*(?:\*(?!\/)[^*]*)*\*\//.source;
				var stringLike =
					/@(?!")|"(?:[^\r\n\\"]|\\.)*"|@"(?:[^\\"]|""|\\[\s\S])*"(?!")/.source +
					'|' +
					/'(?:(?:[^\r\n'\\]|\\.|\\[Uux][\da-fA-F]{1,8})'|(?=[^\\](?!')))/.source;
				function nested(pattern, depthLog2) {
					for (var i2 = 0; i2 < depthLog2; i2++) {
						pattern = pattern.replace(/<self>/g, function () {
							return '(?:' + pattern + ')';
						});
					}
					return pattern
						.replace(/<self>/g, '[^\\s\\S]')
						.replace(/<str>/g, '(?:' + stringLike + ')')
						.replace(/<comment>/g, '(?:' + commentLike + ')');
				}
				var round = nested(/\((?:[^()'"@/]|<str>|<comment>|<self>)*\)/.source, 2);
				var square = nested(/\[(?:[^\[\]'"@/]|<str>|<comment>|<self>)*\]/.source, 2);
				var curly = nested(/\{(?:[^{}'"@/]|<str>|<comment>|<self>)*\}/.source, 2);
				var angle = nested(/<(?:[^<>'"@/]|<str>|<comment>|<self>)*>/.source, 2);
				var tagAttrs =
					/(?:\s(?:\s*[^\s>\/=]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+(?=[\s>]))|(?=[\s/>])))+)?/
						.source;
				var tagContent = /(?!\d)[^\s>\/=$<%]+/.source + tagAttrs + /\s*\/?>/.source;
				var tagRegion =
					/\B@?/.source +
					'(?:' +
					/<([a-zA-Z][\w:]*)/.source +
					tagAttrs +
					/\s*>/.source +
					'(?:' +
					(/[^<]/.source +
						'|' +
						/<\/?(?!\1\b)/.source +
						tagContent +
						'|' +
						nested(
							/<\1/.source +
								tagAttrs +
								/\s*>/.source +
								'(?:' +
								(/[^<]/.source + '|' + /<\/?(?!\1\b)/.source + tagContent + '|<self>') +
								')*' +
								/<\/\1\s*>/.source,
							2
						)) +
					')*' +
					/<\/\1\s*>/.source +
					'|' +
					/</.source +
					tagContent +
					')';
				Prism2.languages.cshtml = Prism2.languages.extend('markup', {});
				var csharpWithHtml = Prism2.languages.insertBefore(
					'csharp',
					'string',
					{
						html: {
							pattern: RegExp(tagRegion),
							greedy: true,
							inside: Prism2.languages.cshtml
						}
					},
					{
						csharp: Prism2.languages.extend('csharp', {})
					}
				);
				var cs = {
					pattern: /\S[\s\S]*/,
					alias: 'language-csharp',
					inside: csharpWithHtml
				};
				Prism2.languages.insertBefore('cshtml', 'prolog', {
					'razor-comment': {
						pattern: /@\*[\s\S]*?\*@/,
						greedy: true,
						alias: 'comment'
					},
					block: {
						pattern: RegExp(
							/(^|[^@])@/.source +
								'(?:' +
								[
									curly,
									/(?:code|functions)\s*/.source + curly,
									/(?:for|foreach|lock|switch|using|while)\s*/.source +
										round +
										/\s*/.source +
										curly,
									/do\s*/.source + curly + /\s*while\s*/.source + round + /(?:\s*;)?/.source,
									/try\s*/.source +
										curly +
										/\s*catch\s*/.source +
										round +
										/\s*/.source +
										curly +
										/\s*finally\s*/.source +
										curly,
									/if\s*/.source +
										round +
										/\s*/.source +
										curly +
										'(?:' +
										/\s*else/.source +
										'(?:' +
										/\s+if\s*/.source +
										round +
										')?' +
										/\s*/.source +
										curly +
										')*'
								].join('|') +
								')'
						),
						lookbehind: true,
						greedy: true,
						inside: {
							keyword: /^@\w*/,
							csharp: cs
						}
					},
					directive: {
						pattern:
							/^([ \t]*)@(?:addTagHelper|attribute|implements|inherits|inject|layout|model|namespace|page|preservewhitespace|removeTagHelper|section|tagHelperPrefix|using)(?=\s).*/m,
						lookbehind: true,
						greedy: true,
						inside: {
							keyword: /^@\w+/,
							csharp: cs
						}
					},
					value: {
						pattern: RegExp(
							/(^|[^@])@/.source +
								/(?:await\b\s*)?/.source +
								'(?:' +
								/\w+\b/.source +
								'|' +
								round +
								')(?:' +
								/[?!]?\.\w+\b/.source +
								'|' +
								round +
								'|' +
								square +
								'|' +
								angle +
								round +
								')*'
						),
						lookbehind: true,
						greedy: true,
						alias: 'variable',
						inside: {
							keyword: /^@/,
							csharp: cs
						}
					},
					'delegate-operator': {
						pattern: /(^|[^@])@(?=<)/,
						lookbehind: true,
						alias: 'operator'
					}
				});
				Prism2.languages.razor = Prism2.languages.cshtml;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/csp.js
var require_csp = __commonJS({
	'node_modules/refractor/lang/csp.js'(exports, module2) {
		'use strict';
		module2.exports = csp;
		csp.displayName = 'csp';
		csp.aliases = [];
		function csp(Prism) {
			(function (Prism2) {
				function value(source) {
					return RegExp(/([ \t])/.source + '(?:' + source + ')' + /(?=[\s;]|$)/.source, 'i');
				}
				Prism2.languages.csp = {
					directive: {
						pattern:
							/(^|[\s;])(?:base-uri|block-all-mixed-content|(?:child|connect|default|font|frame|img|manifest|media|object|prefetch|script|style|worker)-src|disown-opener|form-action|frame-(?:ancestors|options)|input-protection(?:-(?:clip|selectors))?|navigate-to|plugin-types|policy-uri|referrer|reflected-xss|report-(?:to|uri)|require-sri-for|sandbox|(?:script|style)-src-(?:attr|elem)|upgrade-insecure-requests)(?=[\s;]|$)/i,
						lookbehind: true,
						alias: 'property'
					},
					scheme: {
						pattern: value(/[a-z][a-z0-9.+-]*:/.source),
						lookbehind: true
					},
					none: {
						pattern: value(/'none'/.source),
						lookbehind: true,
						alias: 'keyword'
					},
					nonce: {
						pattern: value(/'nonce-[-+/\w=]+'/.source),
						lookbehind: true,
						alias: 'number'
					},
					hash: {
						pattern: value(/'sha(?:256|384|512)-[-+/\w=]+'/.source),
						lookbehind: true,
						alias: 'number'
					},
					host: {
						pattern: value(
							/[a-z][a-z0-9.+-]*:\/\/[^\s;,']*/.source +
								'|' +
								/\*[^\s;,']*/.source +
								'|' +
								/[a-z0-9-]+(?:\.[a-z0-9-]+)+(?::[\d*]+)?(?:\/[^\s;,']*)?/.source
						),
						lookbehind: true,
						alias: 'url',
						inside: {
							important: /\*/
						}
					},
					keyword: [
						{
							pattern: value(/'unsafe-[a-z-]+'/.source),
							lookbehind: true,
							alias: 'unsafe'
						},
						{
							pattern: value(/'[a-z-]+'/.source),
							lookbehind: true,
							alias: 'safe'
						}
					],
					punctuation: /;/
				};
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/css-extras.js
var require_css_extras = __commonJS({
	'node_modules/refractor/lang/css-extras.js'(exports, module2) {
		'use strict';
		module2.exports = cssExtras;
		cssExtras.displayName = 'cssExtras';
		cssExtras.aliases = [];
		function cssExtras(Prism) {
			(function (Prism2) {
				var string3 = /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;
				var selectorInside;
				Prism2.languages.css.selector = {
					pattern: Prism2.languages.css.selector.pattern,
					lookbehind: true,
					inside: (selectorInside = {
						'pseudo-element': /:(?:after|before|first-letter|first-line|selection)|::[-\w]+/,
						'pseudo-class': /:[-\w]+/,
						class: /\.[-\w]+/,
						id: /#[-\w]+/,
						attribute: {
							pattern: RegExp(`\\[(?:[^[\\]"']|` + string3.source + ')*\\]'),
							greedy: true,
							inside: {
								punctuation: /^\[|\]$/,
								'case-sensitivity': {
									pattern: /(\s)[si]$/i,
									lookbehind: true,
									alias: 'keyword'
								},
								namespace: {
									pattern: /^(\s*)(?:(?!\s)[-*\w\xA0-\uFFFF])*\|(?!=)/,
									lookbehind: true,
									inside: {
										punctuation: /\|$/
									}
								},
								'attr-name': {
									pattern: /^(\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+/,
									lookbehind: true
								},
								'attr-value': [
									string3,
									{
										pattern: /(=\s*)(?:(?!\s)[-\w\xA0-\uFFFF])+(?=\s*$)/,
										lookbehind: true
									}
								],
								operator: /[|~*^$]?=/
							}
						},
						'n-th': [
							{
								pattern: /(\(\s*)[+-]?\d*[\dn](?:\s*[+-]\s*\d+)?(?=\s*\))/,
								lookbehind: true,
								inside: {
									number: /[\dn]+/,
									operator: /[+-]/
								}
							},
							{
								pattern: /(\(\s*)(?:even|odd)(?=\s*\))/i,
								lookbehind: true
							}
						],
						combinator: />|\+|~|\|\|/,
						punctuation: /[(),]/
					})
				};
				Prism2.languages.css['atrule'].inside['selector-function-argument'].inside = selectorInside;
				Prism2.languages.insertBefore('css', 'property', {
					variable: {
						pattern: /(^|[^-\w\xA0-\uFFFF])--(?!\s)[-_a-z\xA0-\uFFFF](?:(?!\s)[-\w\xA0-\uFFFF])*/i,
						lookbehind: true
					}
				});
				var unit = {
					pattern: /(\b\d+)(?:%|[a-z]+(?![\w-]))/,
					lookbehind: true
				};
				var number3 = {
					pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
					lookbehind: true
				};
				Prism2.languages.insertBefore('css', 'function', {
					operator: {
						pattern: /(\s)[+\-*\/](?=\s)/,
						lookbehind: true
					},
					hexcode: {
						pattern: /\B#[\da-f]{3,8}\b/i,
						alias: 'color'
					},
					color: [
						{
							pattern:
								/(^|[^\w-])(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)(?![\w-])/i,
							lookbehind: true
						},
						{
							pattern:
								/\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
							inside: {
								unit,
								number: number3,
								function: /[\w-]+(?=\()/,
								punctuation: /[(),]/
							}
						}
					],
					entity: /\\[\da-f]{1,8}/i,
					unit,
					number: number3
				});
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/csv.js
var require_csv = __commonJS({
	'node_modules/refractor/lang/csv.js'(exports, module2) {
		'use strict';
		module2.exports = csv;
		csv.displayName = 'csv';
		csv.aliases = [];
		function csv(Prism) {
			Prism.languages.csv = {
				value: /[^\r\n,"]+|"(?:[^"]|"")*"(?!")/,
				punctuation: /,/
			};
		}
	}
});

// node_modules/refractor/lang/cypher.js
var require_cypher = __commonJS({
	'node_modules/refractor/lang/cypher.js'(exports, module2) {
		'use strict';
		module2.exports = cypher;
		cypher.displayName = 'cypher';
		cypher.aliases = [];
		function cypher(Prism) {
			Prism.languages.cypher = {
				comment: /\/\/.*/,
				string: {
					pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/,
					greedy: true
				},
				'class-name': {
					pattern: /(:\s*)(?:\w+|`(?:[^`\\\r\n])*`)(?=\s*[{):])/,
					lookbehind: true,
					greedy: true
				},
				relationship: {
					pattern:
						/(-\[\s*(?:\w+\s*|`(?:[^`\\\r\n])*`\s*)?:\s*|\|\s*:\s*)(?:\w+|`(?:[^`\\\r\n])*`)/,
					lookbehind: true,
					greedy: true,
					alias: 'property'
				},
				identifier: {
					pattern: /`(?:[^`\\\r\n])*`/,
					greedy: true
				},
				variable: /\$\w+/,
				keyword:
					/\b(?:ADD|ALL|AND|AS|ASC|ASCENDING|ASSERT|BY|CALL|CASE|COMMIT|CONSTRAINT|CONTAINS|CREATE|CSV|DELETE|DESC|DESCENDING|DETACH|DISTINCT|DO|DROP|ELSE|END|ENDS|EXISTS|FOR|FOREACH|IN|INDEX|IS|JOIN|KEY|LIMIT|LOAD|MANDATORY|MATCH|MERGE|NODE|NOT|OF|ON|OPTIONAL|OR|ORDER(?=\s+BY)|PERIODIC|REMOVE|REQUIRE|RETURN|SCALAR|SCAN|SET|SKIP|START|STARTS|THEN|UNION|UNIQUE|UNWIND|USING|WHEN|WHERE|WITH|XOR|YIELD)\b/i,
				function: /\b\w+\b(?=\s*\()/,
				boolean: /\b(?:false|null|true)\b/i,
				number: /\b(?:0x[\da-fA-F]+|\d+(?:\.\d+)?(?:[eE][+-]?\d+)?)\b/,
				operator: /:|<--?|--?>?|<>|=~?|[<>]=?|[+*/%^|]|\.\.\.?/,
				punctuation: /[()[\]{},;.]/
			};
		}
	}
});

// node_modules/refractor/lang/d.js
var require_d = __commonJS({
	'node_modules/refractor/lang/d.js'(exports, module2) {
		'use strict';
		module2.exports = d;
		d.displayName = 'd';
		d.aliases = [];
		function d(Prism) {
			Prism.languages.d = Prism.languages.extend('clike', {
				comment: [
					{
						pattern: /^\s*#!.+/,
						greedy: true
					},
					{
						pattern: RegExp(
							/(^|[^\\])/.source +
								'(?:' +
								[
									/\/\+(?:\/\+(?:[^+]|\+(?!\/))*\+\/|(?!\/\+)[\s\S])*?\+\//.source,
									/\/\/.*/.source,
									/\/\*[\s\S]*?\*\//.source
								].join('|') +
								')'
						),
						lookbehind: true,
						greedy: true
					}
				],
				string: [
					{
						pattern: RegExp(
							[
								/\b[rx]"(?:\\[\s\S]|[^\\"])*"[cwd]?/.source,
								/\bq"(?:\[[\s\S]*?\]|\([\s\S]*?\)|<[\s\S]*?>|\{[\s\S]*?\})"/.source,
								/\bq"((?!\d)\w+)$[\s\S]*?^\1"/.source,
								/\bq"(.)[\s\S]*?\2"/.source,
								/(["`])(?:\\[\s\S]|(?!\3)[^\\])*\3[cwd]?/.source
							].join('|'),
							'm'
						),
						greedy: true
					},
					{
						pattern: /\bq\{(?:\{[^{}]*\}|[^{}])*\}/,
						greedy: true,
						alias: 'token-string'
					}
				],
				keyword:
					/\$|\b(?:__(?:(?:DATE|EOF|FILE|FUNCTION|LINE|MODULE|PRETTY_FUNCTION|TIMESTAMP|TIME|VENDOR|VERSION)__|gshared|parameters|traits|vector)|abstract|alias|align|asm|assert|auto|body|bool|break|byte|case|cast|catch|cdouble|cent|cfloat|char|class|const|continue|creal|dchar|debug|default|delegate|delete|deprecated|do|double|dstring|else|enum|export|extern|false|final|finally|float|for|foreach|foreach_reverse|function|goto|idouble|if|ifloat|immutable|import|inout|int|interface|invariant|ireal|lazy|long|macro|mixin|module|new|nothrow|null|out|override|package|pragma|private|protected|ptrdiff_t|public|pure|real|ref|return|scope|shared|short|size_t|static|string|struct|super|switch|synchronized|template|this|throw|true|try|typedef|typeid|typeof|ubyte|ucent|uint|ulong|union|unittest|ushort|version|void|volatile|wchar|while|with|wstring)\b/,
				number: [
					/\b0x\.?[a-f\d_]+(?:(?!\.\.)\.[a-f\d_]*)?(?:p[+-]?[a-f\d_]+)?[ulfi]{0,4}/i,
					{
						pattern:
							/((?:\.\.)?)(?:\b0b\.?|\b|\.)\d[\d_]*(?:(?!\.\.)\.[\d_]*)?(?:e[+-]?\d[\d_]*)?[ulfi]{0,4}/i,
						lookbehind: true
					}
				],
				operator:
					/\|[|=]?|&[&=]?|\+[+=]?|-[-=]?|\.?\.\.|=[>=]?|!(?:i[ns]\b|<>?=?|>=?|=)?|\bi[ns]\b|(?:<[<>]?|>>?>?|\^\^|[*\/%^~])=?/
			});
			Prism.languages.insertBefore('d', 'string', {
				char: /'(?:\\(?:\W|\w+)|[^\\])'/
			});
			Prism.languages.insertBefore('d', 'keyword', {
				property: /\B@\w*/
			});
			Prism.languages.insertBefore('d', 'function', {
				register: {
					pattern:
						/\b(?:[ABCD][LHX]|E?(?:BP|DI|SI|SP)|[BS]PL|[ECSDGF]S|CR[0234]|[DS]IL|DR[012367]|E[ABCD]X|X?MM[0-7]|R(?:1[0-5]|[89])[BWD]?|R[ABCD]X|R[BS]P|R[DS]I|TR[3-7]|XMM(?:1[0-5]|[89])|YMM(?:1[0-5]|\d))\b|\bST(?:\([0-7]\)|\b)/,
					alias: 'variable'
				}
			});
		}
	}
});

// node_modules/refractor/lang/dart.js
var require_dart = __commonJS({
	'node_modules/refractor/lang/dart.js'(exports, module2) {
		'use strict';
		module2.exports = dart;
		dart.displayName = 'dart';
		dart.aliases = [];
		function dart(Prism) {
			(function (Prism2) {
				var keywords = [
					/\b(?:async|sync|yield)\*/,
					/\b(?:abstract|assert|async|await|break|case|catch|class|const|continue|covariant|default|deferred|do|dynamic|else|enum|export|extends|extension|external|factory|final|finally|for|get|hide|if|implements|import|in|interface|library|mixin|new|null|on|operator|part|rethrow|return|set|show|static|super|switch|sync|this|throw|try|typedef|var|void|while|with|yield)\b/
				];
				var packagePrefix = /(^|[^\w.])(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
				var className = {
					pattern: RegExp(packagePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
					lookbehind: true,
					inside: {
						namespace: {
							pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
							inside: {
								punctuation: /\./
							}
						}
					}
				};
				Prism2.languages.dart = Prism2.languages.extend('clike', {
					'class-name': [
						className,
						{
							pattern: RegExp(packagePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()])/.source),
							lookbehind: true,
							inside: className.inside
						}
					],
					keyword: keywords,
					operator: /\bis!|\b(?:as|is)\b|\+\+|--|&&|\|\||<<=?|>>=?|~(?:\/=?)?|[+\-*\/%&^|=!<>]=?|\?/
				});
				Prism2.languages.insertBefore('dart', 'string', {
					'string-literal': {
						pattern: /r?(?:("""|''')[\s\S]*?\1|(["'])(?:\\.|(?!\2)[^\\\r\n])*\2(?!\2))/,
						greedy: true,
						inside: {
							interpolation: {
								pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\w+|\{(?:[^{}]|\{[^{}]*\})*\})/,
								lookbehind: true,
								inside: {
									punctuation: /^\$\{?|\}$/,
									expression: {
										pattern: /[\s\S]+/,
										inside: Prism2.languages.dart
									}
								}
							},
							string: /[\s\S]+/
						}
					},
					string: void 0
				});
				Prism2.languages.insertBefore('dart', 'class-name', {
					metadata: {
						pattern: /@\w+/,
						alias: 'function'
					}
				});
				Prism2.languages.insertBefore('dart', 'class-name', {
					generics: {
						pattern: /<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<(?:[\w\s,.&?]|<[\w\s,.&?]*>)*>)*>)*>/,
						inside: {
							'class-name': className,
							keyword: keywords,
							punctuation: /[<>(),.:]/,
							operator: /[?&|]/
						}
					}
				});
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/dataweave.js
var require_dataweave = __commonJS({
	'node_modules/refractor/lang/dataweave.js'(exports, module2) {
		'use strict';
		module2.exports = dataweave;
		dataweave.displayName = 'dataweave';
		dataweave.aliases = [];
		function dataweave(Prism) {
			(function (Prism2) {
				Prism2.languages.dataweave = {
					url: /\b[A-Za-z]+:\/\/[\w/:.?=&-]+|\burn:[\w:.?=&-]+/,
					property: {
						pattern: /(?:\b\w+#)?(?:"(?:\\.|[^\\"\r\n])*"|\b\w+)(?=\s*[:@])/,
						greedy: true
					},
					string: {
						pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
						greedy: true
					},
					'mime-type': /\b(?:application|audio|image|multipart|text|video)\/[\w+-]+/,
					date: {
						pattern: /\|[\w:+-]+\|/,
						greedy: true
					},
					comment: [
						{
							pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
							lookbehind: true,
							greedy: true
						},
						{
							pattern: /(^|[^\\:])\/\/.*/,
							lookbehind: true,
							greedy: true
						}
					],
					regex: {
						pattern: /\/(?:[^\\\/\r\n]|\\[^\r\n])+\//,
						greedy: true
					},
					keyword:
						/\b(?:and|as|at|case|do|else|fun|if|input|is|match|not|ns|null|or|output|type|unless|update|using|var)\b/,
					function: /\b[A-Z_]\w*(?=\s*\()/i,
					number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
					punctuation: /[{}[\];(),.:@]/,
					operator: /<<|>>|->|[<>~=]=?|!=|--?-?|\+\+?|!|\?/,
					boolean: /\b(?:false|true)\b/
				};
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/dax.js
var require_dax = __commonJS({
	'node_modules/refractor/lang/dax.js'(exports, module2) {
		'use strict';
		module2.exports = dax;
		dax.displayName = 'dax';
		dax.aliases = [];
		function dax(Prism) {
			Prism.languages.dax = {
				comment: {
					pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/).*)/,
					lookbehind: true
				},
				'data-field': {
					pattern: /'(?:[^']|'')*'(?!')(?:\[[ \w\xA0-\uFFFF]+\])?|\w+\[[ \w\xA0-\uFFFF]+\]/,
					alias: 'symbol'
				},
				measure: {
					pattern: /\[[ \w\xA0-\uFFFF]+\]/,
					alias: 'constant'
				},
				string: {
					pattern: /"(?:[^"]|"")*"(?!")/,
					greedy: true
				},
				function:
					/\b(?:ABS|ACOS|ACOSH|ACOT|ACOTH|ADDCOLUMNS|ADDMISSINGITEMS|ALL|ALLCROSSFILTERED|ALLEXCEPT|ALLNOBLANKROW|ALLSELECTED|AND|APPROXIMATEDISTINCTCOUNT|ASIN|ASINH|ATAN|ATANH|AVERAGE|AVERAGEA|AVERAGEX|BETA\.DIST|BETA\.INV|BLANK|CALCULATE|CALCULATETABLE|CALENDAR|CALENDARAUTO|CEILING|CHISQ\.DIST|CHISQ\.DIST\.RT|CHISQ\.INV|CHISQ\.INV\.RT|CLOSINGBALANCEMONTH|CLOSINGBALANCEQUARTER|CLOSINGBALANCEYEAR|COALESCE|COMBIN|COMBINA|COMBINEVALUES|CONCATENATE|CONCATENATEX|CONFIDENCE\.NORM|CONFIDENCE\.T|CONTAINS|CONTAINSROW|CONTAINSSTRING|CONTAINSSTRINGEXACT|CONVERT|COS|COSH|COT|COTH|COUNT|COUNTA|COUNTAX|COUNTBLANK|COUNTROWS|COUNTX|CROSSFILTER|CROSSJOIN|CURRENCY|CURRENTGROUP|CUSTOMDATA|DATATABLE|DATE|DATEADD|DATEDIFF|DATESBETWEEN|DATESINPERIOD|DATESMTD|DATESQTD|DATESYTD|DATEVALUE|DAY|DEGREES|DETAILROWS|DISTINCT|DISTINCTCOUNT|DISTINCTCOUNTNOBLANK|DIVIDE|EARLIER|EARLIEST|EDATE|ENDOFMONTH|ENDOFQUARTER|ENDOFYEAR|EOMONTH|ERROR|EVEN|EXACT|EXCEPT|EXP|EXPON\.DIST|FACT|FALSE|FILTER|FILTERS|FIND|FIRSTDATE|FIRSTNONBLANK|FIRSTNONBLANKVALUE|FIXED|FLOOR|FORMAT|GCD|GENERATE|GENERATEALL|GENERATESERIES|GEOMEAN|GEOMEANX|GROUPBY|HASONEFILTER|HASONEVALUE|HOUR|IF|IF\.EAGER|IFERROR|IGNORE|INT|INTERSECT|ISBLANK|ISCROSSFILTERED|ISEMPTY|ISERROR|ISEVEN|ISFILTERED|ISINSCOPE|ISLOGICAL|ISNONTEXT|ISNUMBER|ISO\.CEILING|ISODD|ISONORAFTER|ISSELECTEDMEASURE|ISSUBTOTAL|ISTEXT|KEEPFILTERS|KEYWORDMATCH|LASTDATE|LASTNONBLANK|LASTNONBLANKVALUE|LCM|LEFT|LEN|LN|LOG|LOG10|LOOKUPVALUE|LOWER|MAX|MAXA|MAXX|MEDIAN|MEDIANX|MID|MIN|MINA|MINUTE|MINX|MOD|MONTH|MROUND|NATURALINNERJOIN|NATURALLEFTOUTERJOIN|NEXTDAY|NEXTMONTH|NEXTQUARTER|NEXTYEAR|NONVISUAL|NORM\.DIST|NORM\.INV|NORM\.S\.DIST|NORM\.S\.INV|NOT|NOW|ODD|OPENINGBALANCEMONTH|OPENINGBALANCEQUARTER|OPENINGBALANCEYEAR|OR|PARALLELPERIOD|PATH|PATHCONTAINS|PATHITEM|PATHITEMREVERSE|PATHLENGTH|PERCENTILE\.EXC|PERCENTILE\.INC|PERCENTILEX\.EXC|PERCENTILEX\.INC|PERMUT|PI|POISSON\.DIST|POWER|PREVIOUSDAY|PREVIOUSMONTH|PREVIOUSQUARTER|PREVIOUSYEAR|PRODUCT|PRODUCTX|QUARTER|QUOTIENT|RADIANS|RAND|RANDBETWEEN|RANK\.EQ|RANKX|RELATED|RELATEDTABLE|REMOVEFILTERS|REPLACE|REPT|RIGHT|ROLLUP|ROLLUPADDISSUBTOTAL|ROLLUPGROUP|ROLLUPISSUBTOTAL|ROUND|ROUNDDOWN|ROUNDUP|ROW|SAMEPERIODLASTYEAR|SAMPLE|SEARCH|SECOND|SELECTCOLUMNS|SELECTEDMEASURE|SELECTEDMEASUREFORMATSTRING|SELECTEDMEASURENAME|SELECTEDVALUE|SIGN|SIN|SINH|SQRT|SQRTPI|STARTOFMONTH|STARTOFQUARTER|STARTOFYEAR|STDEV\.P|STDEV\.S|STDEVX\.P|STDEVX\.S|SUBSTITUTE|SUBSTITUTEWITHINDEX|SUM|SUMMARIZE|SUMMARIZECOLUMNS|SUMX|SWITCH|T\.DIST|T\.DIST\.2T|T\.DIST\.RT|T\.INV|T\.INV\.2T|TAN|TANH|TIME|TIMEVALUE|TODAY|TOPN|TOPNPERLEVEL|TOPNSKIP|TOTALMTD|TOTALQTD|TOTALYTD|TREATAS|TRIM|TRUE|TRUNC|UNICHAR|UNICODE|UNION|UPPER|USERELATIONSHIP|USERNAME|USEROBJECTID|USERPRINCIPALNAME|UTCNOW|UTCTODAY|VALUE|VALUES|VAR\.P|VAR\.S|VARX\.P|VARX\.S|WEEKDAY|WEEKNUM|XIRR|XNPV|YEAR|YEARFRAC)(?=\s*\()/i,
				keyword: /\b(?:DEFINE|EVALUATE|MEASURE|ORDER\s+BY|RETURN|VAR|START\s+AT|ASC|DESC)\b/i,
				boolean: {
					pattern: /\b(?:FALSE|NULL|TRUE)\b/i,
					alias: 'constant'
				},
				number: /\b\d+(?:\.\d*)?|\B\.\d+\b/,
				operator: /:=|[-+*\/=^]|&&?|\|\||<(?:=>?|<|>)?|>[>=]?|\b(?:IN|NOT)\b/i,
				punctuation: /[;\[\](){}`,.]/
			};
		}
	}
});

// node_modules/refractor/lang/dhall.js
var require_dhall = __commonJS({
	'node_modules/refractor/lang/dhall.js'(exports, module2) {
		'use strict';
		module2.exports = dhall;
		dhall.displayName = 'dhall';
		dhall.aliases = [];
		function dhall(Prism) {
			Prism.languages.dhall = {
				comment: /--.*|\{-(?:[^-{]|-(?!\})|\{(?!-)|\{-(?:[^-{]|-(?!\})|\{(?!-))*-\})*-\}/,
				string: {
					pattern: /"(?:[^"\\]|\\.)*"|''(?:[^']|'(?!')|'''|''\$\{)*''(?!'|\$)/,
					greedy: true,
					inside: {
						interpolation: {
							pattern: /\$\{[^{}]*\}/,
							inside: {
								expression: {
									pattern: /(^\$\{)[\s\S]+(?=\}$)/,
									lookbehind: true,
									alias: 'language-dhall',
									inside: null
								},
								punctuation: /\$\{|\}/
							}
						}
					}
				},
				label: {
					pattern: /`[^`]*`/,
					greedy: true
				},
				url: {
					pattern:
						/\bhttps?:\/\/[\w.:%!$&'*+;=@~-]+(?:\/[\w.:%!$&'*+;=@~-]*)*(?:\?[/?\w.:%!$&'*+;=@~-]*)?/,
					greedy: true
				},
				env: {
					pattern: /\benv:(?:(?!\d)\w+|"(?:[^"\\=]|\\.)*")/,
					greedy: true,
					inside: {
						function: /^env/,
						operator: /^:/,
						variable: /[\s\S]+/
					}
				},
				hash: {
					pattern: /\bsha256:[\da-fA-F]{64}\b/,
					inside: {
						function: /sha256/,
						operator: /:/,
						number: /[\da-fA-F]{64}/
					}
				},
				keyword:
					/\b(?:as|assert|else|forall|if|in|let|merge|missing|then|toMap|using|with)\b|\u2200/,
				builtin: /\b(?:None|Some)\b/,
				boolean: /\b(?:False|True)\b/,
				number: /\bNaN\b|-?\bInfinity\b|[+-]?\b(?:0x[\da-fA-F]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/,
				operator:
					/\/\\|\/\/\\\\|&&|\|\||===|[!=]=|\/\/|->|\+\+|::|[+*#@=:?<>|\\\u2227\u2a53\u2261\u2afd\u03bb\u2192]/,
				punctuation: /\.\.|[{}\[\](),./]/,
				'class-name': /\b[A-Z]\w*\b/
			};
			Prism.languages.dhall.string.inside.interpolation.inside.expression.inside =
				Prism.languages.dhall;
		}
	}
});

// node_modules/refractor/lang/diff.js
var require_diff = __commonJS({
	'node_modules/refractor/lang/diff.js'(exports, module2) {
		'use strict';
		module2.exports = diff;
		diff.displayName = 'diff';
		diff.aliases = [];
		function diff(Prism) {
			(function (Prism2) {
				Prism2.languages.diff = {
					coord: [/^(?:\*{3}|-{3}|\+{3}).*$/m, /^@@.*@@$/m, /^\d.*$/m]
				};
				var PREFIXES = {
					'deleted-sign': '-',
					'deleted-arrow': '<',
					'inserted-sign': '+',
					'inserted-arrow': '>',
					unchanged: ' ',
					diff: '!'
				};
				Object.keys(PREFIXES).forEach(function (name) {
					var prefix = PREFIXES[name];
					var alias = [];
					if (!/^\w+$/.test(name)) {
						alias.push(/\w+/.exec(name)[0]);
					}
					if (name === 'diff') {
						alias.push('bold');
					}
					Prism2.languages.diff[name] = {
						pattern: RegExp('^(?:[' + prefix + '].*(?:\r\n?|\n|(?![\\s\\S])))+', 'm'),
						alias,
						inside: {
							line: {
								pattern: /(.)(?=[\s\S]).*(?:\r\n?|\n)?/,
								lookbehind: true
							},
							prefix: {
								pattern: /[\s\S]/,
								alias: /\w+/.exec(name)[0]
							}
						}
					};
				});
				Object.defineProperty(Prism2.languages.diff, 'PREFIXES', {
					value: PREFIXES
				});
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/markup-templating.js
var require_markup_templating = __commonJS({
	'node_modules/refractor/lang/markup-templating.js'(exports, module2) {
		'use strict';
		module2.exports = markupTemplating;
		markupTemplating.displayName = 'markupTemplating';
		markupTemplating.aliases = [];
		function markupTemplating(Prism) {
			(function (Prism2) {
				function getPlaceholder(language, index6) {
					return '___' + language.toUpperCase() + index6 + '___';
				}
				Object.defineProperties((Prism2.languages['markup-templating'] = {}), {
					buildPlaceholders: {
						value: function (env, language, placeholderPattern, replaceFilter) {
							if (env.language !== language) {
								return;
							}
							var tokenStack = (env.tokenStack = []);
							env.code = env.code.replace(placeholderPattern, function (match) {
								if (typeof replaceFilter === 'function' && !replaceFilter(match)) {
									return match;
								}
								var i2 = tokenStack.length;
								var placeholder;
								while (env.code.indexOf((placeholder = getPlaceholder(language, i2))) !== -1) {
									++i2;
								}
								tokenStack[i2] = match;
								return placeholder;
							});
							env.grammar = Prism2.languages.markup;
						}
					},
					tokenizePlaceholders: {
						value: function (env, language) {
							if (env.language !== language || !env.tokenStack) {
								return;
							}
							env.grammar = Prism2.languages[language];
							var j = 0;
							var keys2 = Object.keys(env.tokenStack);
							function walkTokens(tokens) {
								for (var i2 = 0; i2 < tokens.length; i2++) {
									if (j >= keys2.length) {
										break;
									}
									var token = tokens[i2];
									if (
										typeof token === 'string' ||
										(token.content && typeof token.content === 'string')
									) {
										var k = keys2[j];
										var t2 = env.tokenStack[k];
										var s4 = typeof token === 'string' ? token : token.content;
										var placeholder = getPlaceholder(language, k);
										var index6 = s4.indexOf(placeholder);
										if (index6 > -1) {
											++j;
											var before = s4.substring(0, index6);
											var middle = new Prism2.Token(
												language,
												Prism2.tokenize(t2, env.grammar),
												'language-' + language,
												t2
											);
											var after = s4.substring(index6 + placeholder.length);
											var replacement = [];
											if (before) {
												replacement.push.apply(replacement, walkTokens([before]));
											}
											replacement.push(middle);
											if (after) {
												replacement.push.apply(replacement, walkTokens([after]));
											}
											if (typeof token === 'string') {
												tokens.splice.apply(tokens, [i2, 1].concat(replacement));
											} else {
												token.content = replacement;
											}
										}
									} else if (token.content) {
										walkTokens(token.content);
									}
								}
								return tokens;
							}
							walkTokens(env.tokens);
						}
					}
				});
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/django.js
var require_django = __commonJS({
	'node_modules/refractor/lang/django.js'(exports, module2) {
		'use strict';
		var refractorMarkupTemplating = require_markup_templating();
		module2.exports = django;
		django.displayName = 'django';
		django.aliases = ['jinja2'];
		function django(Prism) {
			Prism.register(refractorMarkupTemplating);
			(function (Prism2) {
				Prism2.languages.django = {
					comment: /^\{#[\s\S]*?#\}$/,
					tag: {
						pattern: /(^\{%[+-]?\s*)\w+/,
						lookbehind: true,
						alias: 'keyword'
					},
					delimiter: {
						pattern: /^\{[{%][+-]?|[+-]?[}%]\}$/,
						alias: 'punctuation'
					},
					string: {
						pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
						greedy: true
					},
					filter: {
						pattern: /(\|)\w+/,
						lookbehind: true,
						alias: 'function'
					},
					test: {
						pattern: /(\bis\s+(?:not\s+)?)(?!not\b)\w+/,
						lookbehind: true,
						alias: 'function'
					},
					function: /\b[a-z_]\w+(?=\s*\()/i,
					keyword: /\b(?:and|as|by|else|for|if|import|in|is|loop|not|or|recursive|with|without)\b/,
					operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
					number: /\b\d+(?:\.\d+)?\b/,
					boolean: /[Ff]alse|[Nn]one|[Tt]rue/,
					variable: /\b\w+\b/,
					punctuation: /[{}[\](),.:;]/
				};
				var pattern = /\{\{[\s\S]*?\}\}|\{%[\s\S]*?%\}|\{#[\s\S]*?#\}/g;
				var markupTemplating = Prism2.languages['markup-templating'];
				Prism2.hooks.add('before-tokenize', function (env) {
					markupTemplating.buildPlaceholders(env, 'django', pattern);
				});
				Prism2.hooks.add('after-tokenize', function (env) {
					markupTemplating.tokenizePlaceholders(env, 'django');
				});
				Prism2.languages.jinja2 = Prism2.languages.django;
				Prism2.hooks.add('before-tokenize', function (env) {
					markupTemplating.buildPlaceholders(env, 'jinja2', pattern);
				});
				Prism2.hooks.add('after-tokenize', function (env) {
					markupTemplating.tokenizePlaceholders(env, 'jinja2');
				});
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/dns-zone-file.js
var require_dns_zone_file = __commonJS({
	'node_modules/refractor/lang/dns-zone-file.js'(exports, module2) {
		'use strict';
		module2.exports = dnsZoneFile;
		dnsZoneFile.displayName = 'dnsZoneFile';
		dnsZoneFile.aliases = [];
		function dnsZoneFile(Prism) {
			Prism.languages['dns-zone-file'] = {
				comment: /;.*/,
				string: {
					pattern: /"(?:\\.|[^"\\\r\n])*"/,
					greedy: true
				},
				variable: [
					{
						pattern: /(^\$ORIGIN[ \t]+)\S+/m,
						lookbehind: true
					},
					{
						pattern: /(^|\s)@(?=\s|$)/,
						lookbehind: true
					}
				],
				keyword: /^\$(?:INCLUDE|ORIGIN|TTL)(?=\s|$)/m,
				class: {
					pattern: /(^|\s)(?:CH|CS|HS|IN)(?=\s|$)/,
					lookbehind: true,
					alias: 'keyword'
				},
				type: {
					pattern:
						/(^|\s)(?:A|A6|AAAA|AFSDB|APL|ATMA|CAA|CDNSKEY|CDS|CERT|CNAME|DHCID|DLV|DNAME|DNSKEY|DS|EID|GID|GPOS|HINFO|HIP|IPSECKEY|ISDN|KEY|KX|LOC|MAILA|MAILB|MB|MD|MF|MG|MINFO|MR|MX|NAPTR|NB|NBSTAT|NIMLOC|NINFO|NS|NSAP|NSAP-PTR|NSEC|NSEC3|NSEC3PARAM|NULL|NXT|OPENPGPKEY|PTR|PX|RKEY|RP|RRSIG|RT|SIG|SINK|SMIMEA|SOA|SPF|SRV|SSHFP|TA|TKEY|TLSA|TSIG|TXT|UID|UINFO|UNSPEC|URI|WKS|X25)(?=\s|$)/,
					lookbehind: true,
					alias: 'keyword'
				},
				punctuation: /[()]/
			};
			Prism.languages['dns-zone'] = Prism.languages['dns-zone-file'];
		}
	}
});

// node_modules/refractor/lang/docker.js
var require_docker = __commonJS({
	'node_modules/refractor/lang/docker.js'(exports, module2) {
		'use strict';
		module2.exports = docker;
		docker.displayName = 'docker';
		docker.aliases = ['dockerfile'];
		function docker(Prism) {
			(function (Prism2) {
				var spaceAfterBackSlash = /\\[\r\n](?:\s|\\[\r\n]|#.*(?!.))*(?![\s#]|\\[\r\n])/.source;
				var space = /(?:[ \t]+(?![ \t])(?:<SP_BS>)?|<SP_BS>)/.source.replace(
					/<SP_BS>/g,
					function () {
						return spaceAfterBackSlash;
					}
				);
				var string3 = /"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*"|'(?:[^'\\\r\n]|\\(?:\r\n|[\s\S]))*'/
					.source;
				var option2 = /--[\w-]+=(?:<STR>|(?!["'])(?:[^\s\\]|\\.)+)/.source.replace(
					/<STR>/g,
					function () {
						return string3;
					}
				);
				var stringRule = {
					pattern: RegExp(string3),
					greedy: true
				};
				var commentRule = {
					pattern: /(^[ \t]*)#.*/m,
					lookbehind: true,
					greedy: true
				};
				function re(source, flags) {
					source = source
						.replace(/<OPT>/g, function () {
							return option2;
						})
						.replace(/<SP>/g, function () {
							return space;
						});
					return RegExp(source, flags);
				}
				Prism2.languages.docker = {
					instruction: {
						pattern:
							/(^[ \t]*)(?:ADD|ARG|CMD|COPY|ENTRYPOINT|ENV|EXPOSE|FROM|HEALTHCHECK|LABEL|MAINTAINER|ONBUILD|RUN|SHELL|STOPSIGNAL|USER|VOLUME|WORKDIR)(?=\s)(?:\\.|[^\r\n\\])*(?:\\$(?:\s|#.*$)*(?![\s#])(?:\\.|[^\r\n\\])*)*/im,
						lookbehind: true,
						greedy: true,
						inside: {
							options: {
								pattern: re(/(^(?:ONBUILD<SP>)?\w+<SP>)<OPT>(?:<SP><OPT>)*/.source, 'i'),
								lookbehind: true,
								greedy: true,
								inside: {
									property: {
										pattern: /(^|\s)--[\w-]+/,
										lookbehind: true
									},
									string: [
										stringRule,
										{
											pattern: /(=)(?!["'])(?:[^\s\\]|\\.)+/,
											lookbehind: true
										}
									],
									operator: /\\$/m,
									punctuation: /=/
								}
							},
							keyword: [
								{
									pattern: re(
										/(^(?:ONBUILD<SP>)?HEALTHCHECK<SP>(?:<OPT><SP>)*)(?:CMD|NONE)\b/.source,
										'i'
									),
									lookbehind: true,
									greedy: true
								},
								{
									pattern: re(
										/(^(?:ONBUILD<SP>)?FROM<SP>(?:<OPT><SP>)*(?!--)[^ \t\\]+<SP>)AS/.source,
										'i'
									),
									lookbehind: true,
									greedy: true
								},
								{
									pattern: re(/(^ONBUILD<SP>)\w+/.source, 'i'),
									lookbehind: true,
									greedy: true
								},
								{
									pattern: /^\w+/,
									greedy: true
								}
							],
							comment: commentRule,
							string: stringRule,
							variable: /\$(?:\w+|\{[^{}"'\\]*\})/,
							operator: /\\$/m
						}
					},
					comment: commentRule
				};
				Prism2.languages.dockerfile = Prism2.languages.docker;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/dot.js
var require_dot = __commonJS({
	'node_modules/refractor/lang/dot.js'(exports, module2) {
		'use strict';
		module2.exports = dot;
		dot.displayName = 'dot';
		dot.aliases = ['gv'];
		function dot(Prism) {
			(function (Prism2) {
				var ID =
					'(?:' +
					[
						/[a-zA-Z_\x80-\uFFFF][\w\x80-\uFFFF]*/.source,
						/-?(?:\.\d+|\d+(?:\.\d*)?)/.source,
						/"[^"\\]*(?:\\[\s\S][^"\\]*)*"/.source,
						/<(?:[^<>]|(?!<!--)<(?:[^<>"']|"[^"]*"|'[^']*')+>|<!--(?:[^-]|-(?!->))*-->)*>/.source
					].join('|') +
					')';
				var IDInside = {
					markup: {
						pattern: /(^<)[\s\S]+(?=>$)/,
						lookbehind: true,
						alias: ['language-markup', 'language-html', 'language-xml'],
						inside: Prism2.languages.markup
					}
				};
				function withID(source, flags) {
					return RegExp(
						source.replace(/<ID>/g, function () {
							return ID;
						}),
						flags
					);
				}
				Prism2.languages.dot = {
					comment: {
						pattern: /\/\/.*|\/\*[\s\S]*?\*\/|^#.*/m,
						greedy: true
					},
					'graph-name': {
						pattern: withID(/(\b(?:digraph|graph|subgraph)[ \t\r\n]+)<ID>/.source, 'i'),
						lookbehind: true,
						greedy: true,
						alias: 'class-name',
						inside: IDInside
					},
					'attr-value': {
						pattern: withID(/(=[ \t\r\n]*)<ID>/.source),
						lookbehind: true,
						greedy: true,
						inside: IDInside
					},
					'attr-name': {
						pattern: withID(/([\[;, \t\r\n])<ID>(?=[ \t\r\n]*=)/.source),
						lookbehind: true,
						greedy: true,
						inside: IDInside
					},
					keyword: /\b(?:digraph|edge|graph|node|strict|subgraph)\b/i,
					'compass-point': {
						pattern: /(:[ \t\r\n]*)(?:[ewc_]|[ns][ew]?)(?![\w\x80-\uFFFF])/,
						lookbehind: true,
						alias: 'builtin'
					},
					node: {
						pattern: withID(/(^|[^-.\w\x80-\uFFFF\\])<ID>/.source),
						lookbehind: true,
						greedy: true,
						inside: IDInside
					},
					operator: /[=:]|-[->]/,
					punctuation: /[\[\]{};,]/
				};
				Prism2.languages.gv = Prism2.languages.dot;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/ebnf.js
var require_ebnf = __commonJS({
	'node_modules/refractor/lang/ebnf.js'(exports, module2) {
		'use strict';
		module2.exports = ebnf;
		ebnf.displayName = 'ebnf';
		ebnf.aliases = [];
		function ebnf(Prism) {
			Prism.languages.ebnf = {
				comment: /\(\*[\s\S]*?\*\)/,
				string: {
					pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
					greedy: true
				},
				special: {
					pattern: /\?[^?\r\n]*\?/,
					greedy: true,
					alias: 'class-name'
				},
				definition: {
					pattern: /^([\t ]*)[a-z]\w*(?:[ \t]+[a-z]\w*)*(?=\s*=)/im,
					lookbehind: true,
					alias: ['rule', 'keyword']
				},
				rule: /\b[a-z]\w*(?:[ \t]+[a-z]\w*)*\b/i,
				punctuation: /\([:/]|[:/]\)|[.,;()[\]{}]/,
				operator: /[-=|*/!]/
			};
		}
	}
});

// node_modules/refractor/lang/editorconfig.js
var require_editorconfig = __commonJS({
	'node_modules/refractor/lang/editorconfig.js'(exports, module2) {
		'use strict';
		module2.exports = editorconfig;
		editorconfig.displayName = 'editorconfig';
		editorconfig.aliases = [];
		function editorconfig(Prism) {
			Prism.languages.editorconfig = {
				comment: /[;#].*/,
				section: {
					pattern: /(^[ \t]*)\[.+\]/m,
					lookbehind: true,
					alias: 'selector',
					inside: {
						regex: /\\\\[\[\]{},!?.*]/,
						operator: /[!?]|\.\.|\*{1,2}/,
						punctuation: /[\[\]{},]/
					}
				},
				key: {
					pattern: /(^[ \t]*)[^\s=]+(?=[ \t]*=)/m,
					lookbehind: true,
					alias: 'attr-name'
				},
				value: {
					pattern: /=.*/,
					alias: 'attr-value',
					inside: {
						punctuation: /^=/
					}
				}
			};
		}
	}
});

// node_modules/refractor/lang/eiffel.js
var require_eiffel = __commonJS({
	'node_modules/refractor/lang/eiffel.js'(exports, module2) {
		'use strict';
		module2.exports = eiffel;
		eiffel.displayName = 'eiffel';
		eiffel.aliases = [];
		function eiffel(Prism) {
			Prism.languages.eiffel = {
				comment: /--.*/,
				string: [
					{
						pattern: /"([^[]*)\[[\s\S]*?\]\1"/,
						greedy: true
					},
					{
						pattern: /"([^{]*)\{[\s\S]*?\}\1"/,
						greedy: true
					},
					{
						pattern: /"(?:%(?:(?!\n)\s)*\n\s*%|%\S|[^%"\r\n])*"/,
						greedy: true
					}
				],
				char: /'(?:%.|[^%'\r\n])+'/,
				keyword:
					/\b(?:across|agent|alias|all|and|as|assign|attached|attribute|check|class|convert|create|Current|debug|deferred|detachable|do|else|elseif|end|ensure|expanded|export|external|feature|from|frozen|if|implies|inherit|inspect|invariant|like|local|loop|not|note|obsolete|old|once|or|Precursor|redefine|rename|require|rescue|Result|retry|select|separate|some|then|undefine|until|variant|Void|when|xor)\b/i,
				boolean: /\b(?:False|True)\b/i,
				'class-name': /\b[A-Z][\dA-Z_]*\b/,
				number: [
					/\b0[xcb][\da-f](?:_*[\da-f])*\b/i,
					/(?:\b\d(?:_*\d)*)?\.(?:(?:\d(?:_*\d)*)?e[+-]?)?\d(?:_*\d)*\b|\b\d(?:_*\d)*\b\.?/i
				],
				punctuation: /:=|<<|>>|\(\||\|\)|->|\.(?=\w)|[{}[\];(),:?]/,
				operator: /\\\\|\|\.\.\||\.\.|\/[~\/=]?|[><]=?|[-+*^=~]/
			};
		}
	}
});

// node_modules/refractor/lang/ejs.js
var require_ejs = __commonJS({
	'node_modules/refractor/lang/ejs.js'(exports, module2) {
		'use strict';
		var refractorMarkupTemplating = require_markup_templating();
		module2.exports = ejs;
		ejs.displayName = 'ejs';
		ejs.aliases = ['eta'];
		function ejs(Prism) {
			Prism.register(refractorMarkupTemplating);
			(function (Prism2) {
				Prism2.languages.ejs = {
					delimiter: {
						pattern: /^<%[-_=]?|[-_]?%>$/,
						alias: 'punctuation'
					},
					comment: /^#[\s\S]*/,
					'language-javascript': {
						pattern: /[\s\S]+/,
						inside: Prism2.languages.javascript
					}
				};
				Prism2.hooks.add('before-tokenize', function (env) {
					var ejsPattern = /<%(?!%)[\s\S]+?%>/g;
					Prism2.languages['markup-templating'].buildPlaceholders(env, 'ejs', ejsPattern);
				});
				Prism2.hooks.add('after-tokenize', function (env) {
					Prism2.languages['markup-templating'].tokenizePlaceholders(env, 'ejs');
				});
				Prism2.languages.eta = Prism2.languages.ejs;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/elixir.js
var require_elixir = __commonJS({
	'node_modules/refractor/lang/elixir.js'(exports, module2) {
		'use strict';
		module2.exports = elixir;
		elixir.displayName = 'elixir';
		elixir.aliases = [];
		function elixir(Prism) {
			Prism.languages.elixir = {
				doc: {
					pattern:
						/@(?:doc|moduledoc)\s+(?:("""|''')[\s\S]*?\1|("|')(?:\\(?:\r\n|[\s\S])|(?!\2)[^\\\r\n])*\2)/,
					inside: {
						attribute: /^@\w+/,
						string: /['"][\s\S]+/
					}
				},
				comment: {
					pattern: /#.*/,
					greedy: true
				},
				regex: {
					pattern:
						/~[rR](?:("""|''')(?:\\[\s\S]|(?!\1)[^\\])+\1|([\/|"'])(?:\\.|(?!\2)[^\\\r\n])+\2|\((?:\\.|[^\\)\r\n])+\)|\[(?:\\.|[^\\\]\r\n])+\]|\{(?:\\.|[^\\}\r\n])+\}|<(?:\\.|[^\\>\r\n])+>)[uismxfr]*/,
					greedy: true
				},
				string: [
					{
						pattern:
							/~[cCsSwW](?:("""|''')(?:\\[\s\S]|(?!\1)[^\\])+\1|([\/|"'])(?:\\.|(?!\2)[^\\\r\n])+\2|\((?:\\.|[^\\)\r\n])+\)|\[(?:\\.|[^\\\]\r\n])+\]|\{(?:\\.|#\{[^}]+\}|#(?!\{)|[^#\\}\r\n])+\}|<(?:\\.|[^\\>\r\n])+>)[csa]?/,
						greedy: true,
						inside: {}
					},
					{
						pattern: /("""|''')[\s\S]*?\1/,
						greedy: true,
						inside: {}
					},
					{
						pattern: /("|')(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
						greedy: true,
						inside: {}
					}
				],
				atom: {
					pattern: /(^|[^:]):\w+/,
					lookbehind: true,
					alias: 'symbol'
				},
				module: {
					pattern: /\b[A-Z]\w*\b/,
					alias: 'class-name'
				},
				'attr-name': /\b\w+\??:(?!:)/,
				argument: {
					pattern: /(^|[^&])&\d+/,
					lookbehind: true,
					alias: 'variable'
				},
				attribute: {
					pattern: /@\w+/,
					alias: 'variable'
				},
				function: /\b[_a-zA-Z]\w*[?!]?(?:(?=\s*(?:\.\s*)?\()|(?=\/\d))/,
				number: /\b(?:0[box][a-f\d_]+|\d[\d_]*)(?:\.[\d_]+)?(?:e[+-]?[\d_]+)?\b/i,
				keyword:
					/\b(?:after|alias|and|case|catch|cond|def(?:callback|delegate|exception|impl|macro|module|n|np|p|protocol|struct)?|do|else|end|fn|for|if|import|not|or|quote|raise|require|rescue|try|unless|unquote|use|when)\b/,
				boolean: /\b(?:false|nil|true)\b/,
				operator: [
					/\bin\b|&&?|\|[|>]?|\\\\|::|\.\.\.?|\+\+?|-[->]?|<[-=>]|>=|!==?|\B!|=(?:==?|[>~])?|[*\/^]/,
					{
						pattern: /([^<])<(?!<)/,
						lookbehind: true
					},
					{
						pattern: /([^>])>(?!>)/,
						lookbehind: true
					}
				],
				punctuation: /<<|>>|[.,%\[\]{}()]/
			};
			Prism.languages.elixir.string.forEach(function (o) {
				o.inside = {
					interpolation: {
						pattern: /#\{[^}]+\}/,
						inside: {
							delimiter: {
								pattern: /^#\{|\}$/,
								alias: 'punctuation'
							},
							rest: Prism.languages.elixir
						}
					}
				};
			});
		}
	}
});

// node_modules/refractor/lang/elm.js
var require_elm = __commonJS({
	'node_modules/refractor/lang/elm.js'(exports, module2) {
		'use strict';
		module2.exports = elm;
		elm.displayName = 'elm';
		elm.aliases = [];
		function elm(Prism) {
			Prism.languages.elm = {
				comment: /--.*|\{-[\s\S]*?-\}/,
				char: {
					pattern: /'(?:[^\\'\r\n]|\\(?:[abfnrtv\\']|\d+|x[0-9a-fA-F]+|u\{[0-9a-fA-F]+\}))'/,
					greedy: true
				},
				string: [
					{
						pattern: /"""[\s\S]*?"""/,
						greedy: true
					},
					{
						pattern: /"(?:[^\\"\r\n]|\\.)*"/,
						greedy: true
					}
				],
				'import-statement': {
					pattern:
						/(^[\t ]*)import\s+[A-Z]\w*(?:\.[A-Z]\w*)*(?:\s+as\s+(?:[A-Z]\w*)(?:\.[A-Z]\w*)*)?(?:\s+exposing\s+)?/m,
					lookbehind: true,
					inside: {
						keyword: /\b(?:as|exposing|import)\b/
					}
				},
				keyword: /\b(?:alias|as|case|else|exposing|if|in|infixl|infixr|let|module|of|then|type)\b/,
				builtin:
					/\b(?:abs|acos|always|asin|atan|atan2|ceiling|clamp|compare|cos|curry|degrees|e|flip|floor|fromPolar|identity|isInfinite|isNaN|logBase|max|min|negate|never|not|pi|radians|rem|round|sin|sqrt|tan|toFloat|toPolar|toString|truncate|turns|uncurry|xor)\b/,
				number: /\b(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?|0x[0-9a-f]+)\b/i,
				operator: /\s\.\s|[+\-/*=.$<>:&|^?%#@~!]{2,}|[+\-/*=$<>:&|^?%#@~!]/,
				hvariable: /\b(?:[A-Z]\w*\.)*[a-z]\w*\b/,
				constant: /\b(?:[A-Z]\w*\.)*[A-Z]\w*\b/,
				punctuation: /[{}[\]|(),.:]/
			};
		}
	}
});

// node_modules/refractor/lang/erb.js
var require_erb = __commonJS({
	'node_modules/refractor/lang/erb.js'(exports, module2) {
		'use strict';
		var refractorRuby = require_ruby();
		var refractorMarkupTemplating = require_markup_templating();
		module2.exports = erb;
		erb.displayName = 'erb';
		erb.aliases = [];
		function erb(Prism) {
			Prism.register(refractorRuby);
			Prism.register(refractorMarkupTemplating);
			(function (Prism2) {
				Prism2.languages.erb = {
					delimiter: {
						pattern: /^(\s*)<%=?|%>(?=\s*$)/,
						lookbehind: true,
						alias: 'punctuation'
					},
					ruby: {
						pattern: /\s*\S[\s\S]*/,
						alias: 'language-ruby',
						inside: Prism2.languages.ruby
					}
				};
				Prism2.hooks.add('before-tokenize', function (env) {
					var erbPattern =
						/<%=?(?:[^\r\n]|[\r\n](?!=begin)|[\r\n]=begin\s(?:[^\r\n]|[\r\n](?!=end))*[\r\n]=end)+?%>/g;
					Prism2.languages['markup-templating'].buildPlaceholders(env, 'erb', erbPattern);
				});
				Prism2.hooks.add('after-tokenize', function (env) {
					Prism2.languages['markup-templating'].tokenizePlaceholders(env, 'erb');
				});
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/erlang.js
var require_erlang = __commonJS({
	'node_modules/refractor/lang/erlang.js'(exports, module2) {
		'use strict';
		module2.exports = erlang;
		erlang.displayName = 'erlang';
		erlang.aliases = [];
		function erlang(Prism) {
			Prism.languages.erlang = {
				comment: /%.+/,
				string: {
					pattern: /"(?:\\.|[^\\"\r\n])*"/,
					greedy: true
				},
				'quoted-function': {
					pattern: /'(?:\\.|[^\\'\r\n])+'(?=\()/,
					alias: 'function'
				},
				'quoted-atom': {
					pattern: /'(?:\\.|[^\\'\r\n])+'/,
					alias: 'atom'
				},
				boolean: /\b(?:false|true)\b/,
				keyword: /\b(?:after|case|catch|end|fun|if|of|receive|try|when)\b/,
				number: [/\$\\?./, /\b\d+#[a-z0-9]+/i, /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i],
				function: /\b[a-z][\w@]*(?=\()/,
				variable: {
					pattern: /(^|[^@])(?:\b|\?)[A-Z_][\w@]*/,
					lookbehind: true
				},
				operator: [
					/[=\/<>:]=|=[:\/]=|\+\+?|--?|[=*\/!]|\b(?:and|andalso|band|bnot|bor|bsl|bsr|bxor|div|not|or|orelse|rem|xor)\b/,
					{
						pattern: /(^|[^<])<(?!<)/,
						lookbehind: true
					},
					{
						pattern: /(^|[^>])>(?!>)/,
						lookbehind: true
					}
				],
				atom: /\b[a-z][\w@]*/,
				punctuation: /[()[\]{}:;,.#|]|<<|>>/
			};
		}
	}
});

// node_modules/refractor/lang/lua.js
var require_lua = __commonJS({
	'node_modules/refractor/lang/lua.js'(exports, module2) {
		'use strict';
		module2.exports = lua;
		lua.displayName = 'lua';
		lua.aliases = [];
		function lua(Prism) {
			Prism.languages.lua = {
				comment: /^#!.+|--(?:\[(=*)\[[\s\S]*?\]\1\]|.*)/m,
				string: {
					pattern:
						/(["'])(?:(?!\1)[^\\\r\n]|\\z(?:\r\n|\s)|\\(?:\r\n|[^z]))*\1|\[(=*)\[[\s\S]*?\]\2\]/,
					greedy: true
				},
				number:
					/\b0x[a-f\d]+(?:\.[a-f\d]*)?(?:p[+-]?\d+)?\b|\b\d+(?:\.\B|(?:\.\d*)?(?:e[+-]?\d+)?\b)|\B\.\d+(?:e[+-]?\d+)?\b/i,
				keyword:
					/\b(?:and|break|do|else|elseif|end|false|for|function|goto|if|in|local|nil|not|or|repeat|return|then|true|until|while)\b/,
				function: /(?!\d)\w+(?=\s*(?:[({]))/,
				operator: [
					/[-+*%^&|#]|\/\/?|<[<=]?|>[>=]?|[=~]=?/,
					{
						pattern: /(^|[^.])\.\.(?!\.)/,
						lookbehind: true
					}
				],
				punctuation: /[\[\](){},;]|\.+|:+/
			};
		}
	}
});

// node_modules/refractor/lang/etlua.js
var require_etlua = __commonJS({
	'node_modules/refractor/lang/etlua.js'(exports, module2) {
		'use strict';
		var refractorLua = require_lua();
		var refractorMarkupTemplating = require_markup_templating();
		module2.exports = etlua;
		etlua.displayName = 'etlua';
		etlua.aliases = [];
		function etlua(Prism) {
			Prism.register(refractorLua);
			Prism.register(refractorMarkupTemplating);
			(function (Prism2) {
				Prism2.languages.etlua = {
					delimiter: {
						pattern: /^<%[-=]?|-?%>$/,
						alias: 'punctuation'
					},
					'language-lua': {
						pattern: /[\s\S]+/,
						inside: Prism2.languages.lua
					}
				};
				Prism2.hooks.add('before-tokenize', function (env) {
					var pattern = /<%[\s\S]+?%>/g;
					Prism2.languages['markup-templating'].buildPlaceholders(env, 'etlua', pattern);
				});
				Prism2.hooks.add('after-tokenize', function (env) {
					Prism2.languages['markup-templating'].tokenizePlaceholders(env, 'etlua');
				});
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/excel-formula.js
var require_excel_formula = __commonJS({
	'node_modules/refractor/lang/excel-formula.js'(exports, module2) {
		'use strict';
		module2.exports = excelFormula;
		excelFormula.displayName = 'excelFormula';
		excelFormula.aliases = [];
		function excelFormula(Prism) {
			Prism.languages['excel-formula'] = {
				comment: {
					pattern: /(\bN\(\s*)"(?:[^"]|"")*"(?=\s*\))/i,
					lookbehind: true,
					greedy: true
				},
				string: {
					pattern: /"(?:[^"]|"")*"(?!")/,
					greedy: true
				},
				reference: {
					pattern: /(?:'[^']*'|(?:[^\s()[\]{}<>*?"';,$&]*\[[^^\s()[\]{}<>*?"']+\])?\w+)!/,
					greedy: true,
					alias: 'string',
					inside: {
						operator: /!$/,
						punctuation: /'/,
						sheet: {
							pattern: /[^[\]]+$/,
							alias: 'function'
						},
						file: {
							pattern: /\[[^[\]]+\]$/,
							inside: {
								punctuation: /[[\]]/
							}
						},
						path: /[\s\S]+/
					}
				},
				'function-name': {
					pattern: /\b[A-Z]\w*(?=\()/i,
					alias: 'keyword'
				},
				range: {
					pattern: /\$?\b(?:[A-Z]+\$?\d+:\$?[A-Z]+\$?\d+|[A-Z]+:\$?[A-Z]+|\d+:\$?\d+)\b/i,
					alias: 'property',
					inside: {
						operator: /:/,
						cell: /\$?[A-Z]+\$?\d+/i,
						column: /\$?[A-Z]+/i,
						row: /\$?\d+/
					}
				},
				cell: {
					pattern: /\b[A-Z]+\d+\b|\$[A-Za-z]+\$?\d+\b|\b[A-Za-z]+\$\d+\b/,
					alias: 'property'
				},
				number: /(?:\b\d+(?:\.\d+)?|\B\.\d+)(?:e[+-]?\d+)?\b/i,
				boolean: /\b(?:FALSE|TRUE)\b/i,
				operator: /[-+*/^%=&,]|<[=>]?|>=?/,
				punctuation: /[[\]();{}|]/
			};
			Prism.languages['xlsx'] = Prism.languages['xls'] = Prism.languages['excel-formula'];
		}
	}
});

// node_modules/refractor/lang/factor.js
var require_factor = __commonJS({
	'node_modules/refractor/lang/factor.js'(exports, module2) {
		'use strict';
		module2.exports = factor;
		factor.displayName = 'factor';
		factor.aliases = [];
		function factor(Prism) {
			(function (Prism2) {
				var comment_inside = {
					function: /\b(?:BUGS?|FIX(?:MES?)?|NOTES?|TODOS?|XX+|HACKS?|WARN(?:ING)?|\?{2,}|!{2,})\b/
				};
				var string_inside = {
					number: /\\[^\s']|%\w/
				};
				var factor2 = {
					comment: [
						{
							pattern: /(^|\s)(?:! .*|!$)/,
							lookbehind: true,
							inside: comment_inside
						},
						{
							pattern: /(^|\s)\/\*\s[\s\S]*?\*\/(?=\s|$)/,
							lookbehind: true,
							greedy: true,
							inside: comment_inside
						},
						{
							pattern: /(^|\s)!\[(={0,6})\[\s[\s\S]*?\]\2\](?=\s|$)/,
							lookbehind: true,
							greedy: true,
							inside: comment_inside
						}
					],
					number: [
						{
							pattern: /(^|\s)[+-]?\d+(?=\s|$)/,
							lookbehind: true
						},
						{
							pattern: /(^|\s)[+-]?0(?:b[01]+|o[0-7]+|d\d+|x[\dA-F]+)(?=\s|$)/i,
							lookbehind: true
						},
						{
							pattern: /(^|\s)[+-]?\d+\/\d+\.?(?=\s|$)/,
							lookbehind: true
						},
						{
							pattern: /(^|\s)\+?\d+\+\d+\/\d+(?=\s|$)/,
							lookbehind: true
						},
						{
							pattern: /(^|\s)-\d+-\d+\/\d+(?=\s|$)/,
							lookbehind: true
						},
						{
							pattern: /(^|\s)[+-]?(?:\d*\.\d+|\d+\.\d*|\d+)(?:e[+-]?\d+)?(?=\s|$)/i,
							lookbehind: true
						},
						{
							pattern: /(^|\s)NAN:\s+[\da-fA-F]+(?=\s|$)/,
							lookbehind: true
						},
						{
							pattern: /(^|\s)[+-]?0(?:b1\.[01]*|o1\.[0-7]*|d1\.\d*|x1\.[\dA-F]*)p\d+(?=\s|$)/i,
							lookbehind: true
						}
					],
					regexp: {
						pattern: /(^|\s)R\/\s(?:\\\S|[^\\/])*\/(?:[idmsr]*|[idmsr]+-[idmsr]+)(?=\s|$)/,
						lookbehind: true,
						alias: 'number',
						inside: {
							variable: /\\\S/,
							keyword: /[+?*\[\]^$(){}.|]/,
							operator: {
								pattern: /(\/)[idmsr]+(?:-[idmsr]+)?/,
								lookbehind: true
							}
						}
					},
					boolean: {
						pattern: /(^|\s)[tf](?=\s|$)/,
						lookbehind: true
					},
					'custom-string': {
						pattern: /(^|\s)[A-Z0-9\-]+"\s(?:\\\S|[^"\\])*"/,
						lookbehind: true,
						greedy: true,
						alias: 'string',
						inside: {
							number: /\\\S|%\w|\//
						}
					},
					'multiline-string': [
						{
							pattern: /(^|\s)STRING:\s+\S+(?:\n|\r\n).*(?:\n|\r\n)\s*;(?=\s|$)/,
							lookbehind: true,
							greedy: true,
							alias: 'string',
							inside: {
								number: string_inside.number,
								'semicolon-or-setlocal': {
									pattern: /([\r\n][ \t]*);(?=\s|$)/,
									lookbehind: true,
									alias: 'function'
								}
							}
						},
						{
							pattern: /(^|\s)HEREDOC:\s+\S+(?:\n|\r\n).*(?:\n|\r\n)\s*\S+(?=\s|$)/,
							lookbehind: true,
							greedy: true,
							alias: 'string',
							inside: string_inside
						},
						{
							pattern: /(^|\s)\[(={0,6})\[\s[\s\S]*?\]\2\](?=\s|$)/,
							lookbehind: true,
							greedy: true,
							alias: 'string',
							inside: string_inside
						}
					],
					'special-using': {
						pattern: /(^|\s)USING:(?:\s\S+)*(?=\s+;(?:\s|$))/,
						lookbehind: true,
						alias: 'function',
						inside: {
							string: {
								pattern: /(\s)[^:\s]+/,
								lookbehind: true
							}
						}
					},
					'stack-effect-delimiter': [
						{
							pattern: /(^|\s)(?:call|eval|execute)?\((?=\s)/,
							lookbehind: true,
							alias: 'operator'
						},
						{
							pattern: /(\s)--(?=\s)/,
							lookbehind: true,
							alias: 'operator'
						},
						{
							pattern: /(\s)\)(?=\s|$)/,
							lookbehind: true,
							alias: 'operator'
						}
					],
					combinators: {
						pattern: null,
						lookbehind: true,
						alias: 'keyword'
					},
					'kernel-builtin': {
						pattern: null,
						lookbehind: true,
						alias: 'variable'
					},
					'sequences-builtin': {
						pattern: null,
						lookbehind: true,
						alias: 'variable'
					},
					'math-builtin': {
						pattern: null,
						lookbehind: true,
						alias: 'variable'
					},
					'constructor-word': {
						pattern: /(^|\s)<(?!=+>|-+>)\S+>(?=\s|$)/,
						lookbehind: true,
						alias: 'keyword'
					},
					'other-builtin-syntax': {
						pattern: null,
						lookbehind: true,
						alias: 'operator'
					},
					'conventionally-named-word': {
						pattern:
							/(^|\s)(?!")(?:(?:change|new|set|with)-\S+|\$\S+|>[^>\s]+|[^:>\s]+>|[^>\s]+>[^>\s]+|\+[^+\s]+\+|[^?\s]+\?|\?[^?\s]+|[^>\s]+>>|>>[^>\s]+|[^<\s]+<<|\([^()\s]+\)|[^!\s]+!|[^*\s]\S*\*|[^.\s]\S*\.)(?=\s|$)/,
						lookbehind: true,
						alias: 'keyword'
					},
					'colon-syntax': {
						pattern: /(^|\s)(?:[A-Z0-9\-]+#?)?:{1,2}\s+(?:;\S+|(?!;)\S+)(?=\s|$)/,
						lookbehind: true,
						greedy: true,
						alias: 'function'
					},
					'semicolon-or-setlocal': {
						pattern: /(\s)(?:;|:>)(?=\s|$)/,
						lookbehind: true,
						alias: 'function'
					},
					'curly-brace-literal-delimiter': [
						{
							pattern: /(^|\s)[a-z]*\{(?=\s)/i,
							lookbehind: true,
							alias: 'operator'
						},
						{
							pattern: /(\s)\}(?=\s|$)/,
							lookbehind: true,
							alias: 'operator'
						}
					],
					'quotation-delimiter': [
						{
							pattern: /(^|\s)\[(?=\s)/,
							lookbehind: true,
							alias: 'operator'
						},
						{
							pattern: /(\s)\](?=\s|$)/,
							lookbehind: true,
							alias: 'operator'
						}
					],
					'normal-word': {
						pattern: /(^|\s)[^"\s]\S*(?=\s|$)/,
						lookbehind: true
					},
					string: {
						pattern: /"(?:\\\S|[^"\\])*"/,
						greedy: true,
						inside: string_inside
					}
				};
				var escape2 = function (str) {
					return (str + '').replace(/([.?*+\^$\[\]\\(){}|\-])/g, '\\$1');
				};
				var arrToWordsRegExp = function (arr) {
					return new RegExp('(^|\\s)(?:' + arr.map(escape2).join('|') + ')(?=\\s|$)');
				};
				var builtins = {
					'kernel-builtin': [
						'or',
						'2nipd',
						'4drop',
						'tuck',
						'wrapper',
						'nip',
						'wrapper?',
						'callstack>array',
						'die',
						'dupd',
						'callstack',
						'callstack?',
						'3dup',
						'hashcode',
						'pick',
						'4nip',
						'build',
						'>boolean',
						'nipd',
						'clone',
						'5nip',
						'eq?',
						'?',
						'=',
						'swapd',
						'2over',
						'clear',
						'2dup',
						'get-retainstack',
						'not',
						'tuple?',
						'dup',
						'3nipd',
						'call',
						'-rotd',
						'object',
						'drop',
						'assert=',
						'assert?',
						'-rot',
						'execute',
						'boa',
						'get-callstack',
						'curried?',
						'3drop',
						'pickd',
						'overd',
						'over',
						'roll',
						'3nip',
						'swap',
						'and',
						'2nip',
						'rotd',
						'throw',
						'(clone)',
						'hashcode*',
						'spin',
						'reach',
						'4dup',
						'equal?',
						'get-datastack',
						'assert',
						'2drop',
						'<wrapper>',
						'boolean?',
						'identity-hashcode',
						'identity-tuple?',
						'null',
						'composed?',
						'new',
						'5drop',
						'rot',
						'-roll',
						'xor',
						'identity-tuple',
						'boolean'
					],
					'other-builtin-syntax': [
						'=======',
						'recursive',
						'flushable',
						'>>',
						'<<<<<<',
						'M\\',
						'B',
						'PRIVATE>',
						'\\',
						'======',
						'final',
						'inline',
						'delimiter',
						'deprecated',
						'<PRIVATE',
						'>>>>>>',
						'<<<<<<<',
						'parse-complex',
						'malformed-complex',
						'read-only',
						'>>>>>>>',
						'call-next-method',
						'<<',
						'foldable',
						'$',
						'$[',
						'${'
					],
					'sequences-builtin': [
						'member-eq?',
						'mismatch',
						'append',
						'assert-sequence=',
						'longer',
						'repetition',
						'clone-like',
						'3sequence',
						'assert-sequence?',
						'last-index-from',
						'reversed',
						'index-from',
						'cut*',
						'pad-tail',
						'join-as',
						'remove-eq!',
						'concat-as',
						'but-last',
						'snip',
						'nths',
						'nth',
						'sequence',
						'longest',
						'slice?',
						'<slice>',
						'remove-nth',
						'tail-slice',
						'empty?',
						'tail*',
						'member?',
						'virtual-sequence?',
						'set-length',
						'drop-prefix',
						'iota',
						'unclip',
						'bounds-error?',
						'unclip-last-slice',
						'non-negative-integer-expected',
						'non-negative-integer-expected?',
						'midpoint@',
						'longer?',
						'?set-nth',
						'?first',
						'rest-slice',
						'prepend-as',
						'prepend',
						'fourth',
						'sift',
						'subseq-start',
						'new-sequence',
						'?last',
						'like',
						'first4',
						'1sequence',
						'reverse',
						'slice',
						'virtual@',
						'repetition?',
						'set-last',
						'index',
						'4sequence',
						'max-length',
						'set-second',
						'immutable-sequence',
						'first2',
						'first3',
						'supremum',
						'unclip-slice',
						'suffix!',
						'insert-nth',
						'tail',
						'3append',
						'short',
						'suffix',
						'concat',
						'flip',
						'immutable?',
						'reverse!',
						'2sequence',
						'sum',
						'delete-all',
						'indices',
						'snip-slice',
						'<iota>',
						'check-slice',
						'sequence?',
						'head',
						'append-as',
						'halves',
						'sequence=',
						'collapse-slice',
						'?second',
						'slice-error?',
						'product',
						'bounds-check?',
						'bounds-check',
						'immutable',
						'virtual-exemplar',
						'harvest',
						'remove',
						'pad-head',
						'last',
						'set-fourth',
						'cartesian-product',
						'remove-eq',
						'shorten',
						'shorter',
						'reversed?',
						'shorter?',
						'shortest',
						'head-slice',
						'pop*',
						'tail-slice*',
						'but-last-slice',
						'iota?',
						'append!',
						'cut-slice',
						'new-resizable',
						'head-slice*',
						'sequence-hashcode',
						'pop',
						'set-nth',
						'?nth',
						'second',
						'join',
						'immutable-sequence?',
						'<reversed>',
						'3append-as',
						'virtual-sequence',
						'subseq?',
						'remove-nth!',
						'length',
						'last-index',
						'lengthen',
						'assert-sequence',
						'copy',
						'move',
						'third',
						'first',
						'tail?',
						'set-first',
						'prefix',
						'bounds-error',
						'<repetition>',
						'exchange',
						'surround',
						'cut',
						'min-length',
						'set-third',
						'push-all',
						'head?',
						'subseq-start-from',
						'delete-slice',
						'rest',
						'sum-lengths',
						'head*',
						'infimum',
						'remove!',
						'glue',
						'slice-error',
						'subseq',
						'push',
						'replace-slice',
						'subseq-as',
						'unclip-last'
					],
					'math-builtin': [
						'number=',
						'next-power-of-2',
						'?1+',
						'fp-special?',
						'imaginary-part',
						'float>bits',
						'number?',
						'fp-infinity?',
						'bignum?',
						'fp-snan?',
						'denominator',
						'gcd',
						'*',
						'+',
						'fp-bitwise=',
						'-',
						'u>=',
						'/',
						'>=',
						'bitand',
						'power-of-2?',
						'log2-expects-positive',
						'neg?',
						'<',
						'log2',
						'>',
						'integer?',
						'number',
						'bits>double',
						'2/',
						'zero?',
						'bits>float',
						'float?',
						'shift',
						'ratio?',
						'rect>',
						'even?',
						'ratio',
						'fp-sign',
						'bitnot',
						'>fixnum',
						'complex?',
						'/i',
						'integer>fixnum',
						'/f',
						'sgn',
						'>bignum',
						'next-float',
						'u<',
						'u>',
						'mod',
						'recip',
						'rational',
						'>float',
						'2^',
						'integer',
						'fixnum?',
						'neg',
						'fixnum',
						'sq',
						'bignum',
						'>rect',
						'bit?',
						'fp-qnan?',
						'simple-gcd',
						'complex',
						'<fp-nan>',
						'real',
						'>fraction',
						'double>bits',
						'bitor',
						'rem',
						'fp-nan-payload',
						'real-part',
						'log2-expects-positive?',
						'prev-float',
						'align',
						'unordered?',
						'float',
						'fp-nan?',
						'abs',
						'bitxor',
						'integer>fixnum-strict',
						'u<=',
						'odd?',
						'<=',
						'/mod',
						'>integer',
						'real?',
						'rational?',
						'numerator'
					]
				};
				Object.keys(builtins).forEach(function (k) {
					factor2[k].pattern = arrToWordsRegExp(builtins[k]);
				});
				var combinators = [
					'2bi',
					'while',
					'2tri',
					'bi*',
					'4dip',
					'both?',
					'same?',
					'tri@',
					'curry',
					'prepose',
					'3bi',
					'?if',
					'tri*',
					'2keep',
					'3keep',
					'curried',
					'2keepd',
					'when',
					'2bi*',
					'2tri*',
					'4keep',
					'bi@',
					'keepdd',
					'do',
					'unless*',
					'tri-curry',
					'if*',
					'loop',
					'bi-curry*',
					'when*',
					'2bi@',
					'2tri@',
					'with',
					'2with',
					'either?',
					'bi',
					'until',
					'3dip',
					'3curry',
					'tri-curry*',
					'tri-curry@',
					'bi-curry',
					'keepd',
					'compose',
					'2dip',
					'if',
					'3tri',
					'unless',
					'tuple',
					'keep',
					'2curry',
					'tri',
					'most',
					'while*',
					'dip',
					'composed',
					'bi-curry@',
					'find-last-from',
					'trim-head-slice',
					'map-as',
					'each-from',
					'none?',
					'trim-tail',
					'partition',
					'if-empty',
					'accumulate*',
					'reject!',
					'find-from',
					'accumulate-as',
					'collector-for-as',
					'reject',
					'map',
					'map-sum',
					'accumulate!',
					'2each-from',
					'follow',
					'supremum-by',
					'map!',
					'unless-empty',
					'collector',
					'padding',
					'reduce-index',
					'replicate-as',
					'infimum-by',
					'trim-tail-slice',
					'count',
					'find-index',
					'filter',
					'accumulate*!',
					'reject-as',
					'map-integers',
					'map-find',
					'reduce',
					'selector',
					'interleave',
					'2map',
					'filter-as',
					'binary-reduce',
					'map-index-as',
					'find',
					'produce',
					'filter!',
					'replicate',
					'cartesian-map',
					'cartesian-each',
					'find-index-from',
					'map-find-last',
					'3map-as',
					'3map',
					'find-last',
					'selector-as',
					'2map-as',
					'2map-reduce',
					'accumulate',
					'each',
					'each-index',
					'accumulate*-as',
					'when-empty',
					'all?',
					'collector-as',
					'push-either',
					'new-like',
					'collector-for',
					'2selector',
					'push-if',
					'2all?',
					'map-reduce',
					'3each',
					'any?',
					'trim-slice',
					'2reduce',
					'change-nth',
					'produce-as',
					'2each',
					'trim',
					'trim-head',
					'cartesian-find',
					'map-index',
					'if-zero',
					'each-integer',
					'unless-zero',
					'(find-integer)',
					'when-zero',
					'find-last-integer',
					'(all-integers?)',
					'times',
					'(each-integer)',
					'find-integer',
					'all-integers?',
					'unless-negative',
					'if-positive',
					'when-positive',
					'when-negative',
					'unless-positive',
					'if-negative',
					'case',
					'2cleave',
					'cond>quot',
					'case>quot',
					'3cleave',
					'wrong-values',
					'to-fixed-point',
					'alist>quot',
					'cond',
					'cleave',
					'call-effect',
					'recursive-hashcode',
					'spread',
					'deep-spread>quot',
					'2||',
					'0||',
					'n||',
					'0&&',
					'2&&',
					'3||',
					'1||',
					'1&&',
					'n&&',
					'3&&',
					'smart-unless*',
					'keep-inputs',
					'reduce-outputs',
					'smart-when*',
					'cleave>array',
					'smart-with',
					'smart-apply',
					'smart-if',
					'inputs/outputs',
					'output>sequence-n',
					'map-outputs',
					'map-reduce-outputs',
					'dropping',
					'output>array',
					'smart-map-reduce',
					'smart-2map-reduce',
					'output>array-n',
					'nullary',
					'input<sequence',
					'append-outputs',
					'drop-inputs',
					'inputs',
					'smart-2reduce',
					'drop-outputs',
					'smart-reduce',
					'preserving',
					'smart-when',
					'outputs',
					'append-outputs-as',
					'smart-unless',
					'smart-if*',
					'sum-outputs',
					'input<sequence-unsafe',
					'output>sequence'
				];
				factor2.combinators.pattern = arrToWordsRegExp(combinators);
				Prism2.languages.factor = factor2;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/false.js
var require_false = __commonJS({
	'node_modules/refractor/lang/false.js'(exports, module2) {
		'use strict';
		module2.exports = $false;
		$false.displayName = '$false';
		$false.aliases = [];
		function $false(Prism) {
			(function (Prism2) {
				Prism2.languages['false'] = {
					comment: {
						pattern: /\{[^}]*\}/
					},
					string: {
						pattern: /"[^"]*"/,
						greedy: true
					},
					'character-code': {
						pattern: /'(?:[^\r]|\r\n?)/,
						alias: 'number'
					},
					'assembler-code': {
						pattern: /\d+`/,
						alias: 'important'
					},
					number: /\d+/,
					operator: /[-!#$%&'*+,./:;=>?@\\^_`|~]/,
					punctuation: /\[|\]/,
					variable: /[a-z]/,
					'non-standard': {
						pattern: /[()<BDO]/,
						alias: 'bold'
					}
				};
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/firestore-security-rules.js
var require_firestore_security_rules = __commonJS({
	'node_modules/refractor/lang/firestore-security-rules.js'(exports, module2) {
		'use strict';
		module2.exports = firestoreSecurityRules;
		firestoreSecurityRules.displayName = 'firestoreSecurityRules';
		firestoreSecurityRules.aliases = [];
		function firestoreSecurityRules(Prism) {
			Prism.languages['firestore-security-rules'] = Prism.languages.extend('clike', {
				comment: /\/\/.*/,
				keyword: /\b(?:allow|function|if|match|null|return|rules_version|service)\b/,
				operator: /&&|\|\||[<>!=]=?|[-+*/%]|\b(?:in|is)\b/
			});
			delete Prism.languages['firestore-security-rules']['class-name'];
			Prism.languages.insertBefore('firestore-security-rules', 'keyword', {
				path: {
					pattern:
						/(^|[\s(),])(?:\/(?:[\w\xA0-\uFFFF]+|\{[\w\xA0-\uFFFF]+(?:=\*\*)?\}|\$\([\w\xA0-\uFFFF.]+\)))+/,
					lookbehind: true,
					greedy: true,
					inside: {
						variable: {
							pattern: /\{[\w\xA0-\uFFFF]+(?:=\*\*)?\}|\$\([\w\xA0-\uFFFF.]+\)/,
							inside: {
								operator: /=/,
								keyword: /\*\*/,
								punctuation: /[.$(){}]/
							}
						},
						punctuation: /\//
					}
				},
				method: {
					pattern: /(\ballow\s+)[a-z]+(?:\s*,\s*[a-z]+)*(?=\s*[:;])/,
					lookbehind: true,
					alias: 'builtin',
					inside: {
						punctuation: /,/
					}
				}
			});
		}
	}
});

// node_modules/refractor/lang/flow.js
var require_flow = __commonJS({
	'node_modules/refractor/lang/flow.js'(exports, module2) {
		'use strict';
		module2.exports = flow3;
		flow3.displayName = 'flow';
		flow3.aliases = [];
		function flow3(Prism) {
			(function (Prism2) {
				Prism2.languages.flow = Prism2.languages.extend('javascript', {});
				Prism2.languages.insertBefore('flow', 'keyword', {
					type: [
						{
							pattern: /\b(?:[Bb]oolean|Function|[Nn]umber|[Ss]tring|any|mixed|null|void)\b/,
							alias: 'tag'
						}
					]
				});
				Prism2.languages.flow['function-variable'].pattern =
					/(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*=\s*(?:function\b|(?:\([^()]*\)(?:\s*:\s*\w+)?|(?!\s)[_$a-z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)\s*=>))/i;
				delete Prism2.languages.flow['parameter'];
				Prism2.languages.insertBefore('flow', 'operator', {
					'flow-punctuation': {
						pattern: /\{\||\|\}/,
						alias: 'punctuation'
					}
				});
				if (!Array.isArray(Prism2.languages.flow.keyword)) {
					Prism2.languages.flow.keyword = [Prism2.languages.flow.keyword];
				}
				Prism2.languages.flow.keyword.unshift(
					{
						pattern: /(^|[^$]\b)(?:Class|declare|opaque|type)\b(?!\$)/,
						lookbehind: true
					},
					{
						pattern:
							/(^|[^$]\B)\$(?:Diff|Enum|Exact|Keys|ObjMap|PropertyType|Record|Shape|Subtype|Supertype|await)\b(?!\$)/,
						lookbehind: true
					}
				);
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/fortran.js
var require_fortran = __commonJS({
	'node_modules/refractor/lang/fortran.js'(exports, module2) {
		'use strict';
		module2.exports = fortran;
		fortran.displayName = 'fortran';
		fortran.aliases = [];
		function fortran(Prism) {
			Prism.languages.fortran = {
				'quoted-number': {
					pattern: /[BOZ](['"])[A-F0-9]+\1/i,
					alias: 'number'
				},
				string: {
					pattern:
						/(?:\b\w+_)?(['"])(?:\1\1|&(?:\r\n?|\n)(?:[ \t]*!.*(?:\r\n?|\n)|(?![ \t]*!))|(?!\1).)*(?:\1|&)/,
					inside: {
						comment: {
							pattern: /(&(?:\r\n?|\n)\s*)!.*/,
							lookbehind: true
						}
					}
				},
				comment: {
					pattern: /!.*/,
					greedy: true
				},
				boolean: /\.(?:FALSE|TRUE)\.(?:_\w+)?/i,
				number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[ED][+-]?\d+)?(?:_\w+)?/i,
				keyword: [
					/\b(?:CHARACTER|COMPLEX|DOUBLE ?PRECISION|INTEGER|LOGICAL|REAL)\b/i,
					/\b(?:END ?)?(?:BLOCK ?DATA|DO|FILE|FORALL|FUNCTION|IF|INTERFACE|MODULE(?! PROCEDURE)|PROGRAM|SELECT|SUBROUTINE|TYPE|WHERE)\b/i,
					/\b(?:ALLOCATABLE|ALLOCATE|BACKSPACE|CALL|CASE|CLOSE|COMMON|CONTAINS|CONTINUE|CYCLE|DATA|DEALLOCATE|DIMENSION|DO|END|EQUIVALENCE|EXIT|EXTERNAL|FORMAT|GO ?TO|IMPLICIT(?: NONE)?|INQUIRE|INTENT|INTRINSIC|MODULE PROCEDURE|NAMELIST|NULLIFY|OPEN|OPTIONAL|PARAMETER|POINTER|PRINT|PRIVATE|PUBLIC|READ|RETURN|REWIND|SAVE|SELECT|STOP|TARGET|WHILE|WRITE)\b/i,
					/\b(?:ASSIGNMENT|DEFAULT|ELEMENTAL|ELSE|ELSEIF|ELSEWHERE|ENTRY|IN|INCLUDE|INOUT|KIND|NULL|ONLY|OPERATOR|OUT|PURE|RECURSIVE|RESULT|SEQUENCE|STAT|THEN|USE)\b/i
				],
				operator: [
					/\*\*|\/\/|=>|[=\/]=|[<>]=?|::|[+\-*=%]|\.[A-Z]+\./i,
					{
						pattern: /(^|(?!\().)\/(?!\))/,
						lookbehind: true
					}
				],
				punctuation: /\(\/|\/\)|[(),;:&]/
			};
		}
	}
});

// node_modules/refractor/lang/fsharp.js
var require_fsharp = __commonJS({
	'node_modules/refractor/lang/fsharp.js'(exports, module2) {
		'use strict';
		module2.exports = fsharp;
		fsharp.displayName = 'fsharp';
		fsharp.aliases = [];
		function fsharp(Prism) {
			Prism.languages.fsharp = Prism.languages.extend('clike', {
				comment: [
					{
						pattern: /(^|[^\\])\(\*(?!\))[\s\S]*?\*\)/,
						lookbehind: true,
						greedy: true
					},
					{
						pattern: /(^|[^\\:])\/\/.*/,
						lookbehind: true,
						greedy: true
					}
				],
				string: {
					pattern: /(?:"""[\s\S]*?"""|@"(?:""|[^"])*"|"(?:\\[\s\S]|[^\\"])*")B?/,
					greedy: true
				},
				'class-name': {
					pattern:
						/(\b(?:exception|inherit|interface|new|of|type)\s+|\w\s*:\s*|\s:\??>\s*)[.\w]+\b(?:\s*(?:->|\*)\s*[.\w]+\b)*(?!\s*[:.])/,
					lookbehind: true,
					inside: {
						operator: /->|\*/,
						punctuation: /\./
					}
				},
				keyword:
					/\b(?:let|return|use|yield)(?:!\B|\b)|\b(?:abstract|and|as|asr|assert|atomic|base|begin|break|checked|class|component|const|constraint|constructor|continue|default|delegate|do|done|downcast|downto|eager|elif|else|end|event|exception|extern|external|false|finally|fixed|for|fun|function|functor|global|if|in|include|inherit|inline|interface|internal|land|lazy|lor|lsl|lsr|lxor|match|member|method|mixin|mod|module|mutable|namespace|new|not|null|object|of|open|or|override|parallel|private|process|protected|public|pure|rec|sealed|select|sig|static|struct|tailcall|then|to|trait|true|try|type|upcast|val|virtual|void|volatile|when|while|with)\b/,
				number: [
					/\b0x[\da-fA-F]+(?:LF|lf|un)?\b/,
					/\b0b[01]+(?:uy|y)?\b/,
					/(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[fm]|e[+-]?\d+)?\b/i,
					/\b\d+(?:[IlLsy]|UL|u[lsy]?)?\b/
				],
				operator:
					/([<>~&^])\1\1|([*.:<>&])\2|<-|->|[!=:]=|<?\|{1,3}>?|\??(?:<=|>=|<>|[-+*/%=<>])\??|[!?^&]|~[+~-]|:>|:\?>?/
			});
			Prism.languages.insertBefore('fsharp', 'keyword', {
				preprocessor: {
					pattern: /(^[\t ]*)#.*/m,
					lookbehind: true,
					alias: 'property',
					inside: {
						directive: {
							pattern: /(^#)\b(?:else|endif|if|light|line|nowarn)\b/,
							lookbehind: true,
							alias: 'keyword'
						}
					}
				}
			});
			Prism.languages.insertBefore('fsharp', 'punctuation', {
				'computation-expression': {
					pattern: /\b[_a-z]\w*(?=\s*\{)/i,
					alias: 'keyword'
				}
			});
			Prism.languages.insertBefore('fsharp', 'string', {
				annotation: {
					pattern: /\[<.+?>\]/,
					greedy: true,
					inside: {
						punctuation: /^\[<|>\]$/,
						'class-name': {
							pattern: /^\w+$|(^|;\s*)[A-Z]\w*(?=\()/,
							lookbehind: true
						},
						'annotation-content': {
							pattern: /[\s\S]+/,
							inside: Prism.languages.fsharp
						}
					}
				},
				char: {
					pattern: /'(?:[^\\']|\\(?:.|\d{3}|x[a-fA-F\d]{2}|u[a-fA-F\d]{4}|U[a-fA-F\d]{8}))'B?/,
					greedy: true
				}
			});
		}
	}
});

// node_modules/refractor/lang/ftl.js
var require_ftl = __commonJS({
	'node_modules/refractor/lang/ftl.js'(exports, module2) {
		'use strict';
		var refractorMarkupTemplating = require_markup_templating();
		module2.exports = ftl;
		ftl.displayName = 'ftl';
		ftl.aliases = [];
		function ftl(Prism) {
			Prism.register(refractorMarkupTemplating);
			(function (Prism2) {
				var FTL_EXPR =
					/[^<()"']|\((?:<expr>)*\)|<(?!#--)|<#--(?:[^-]|-(?!->))*-->|"(?:[^\\"]|\\.)*"|'(?:[^\\']|\\.)*'/
						.source;
				for (var i2 = 0; i2 < 2; i2++) {
					FTL_EXPR = FTL_EXPR.replace(/<expr>/g, function () {
						return FTL_EXPR;
					});
				}
				FTL_EXPR = FTL_EXPR.replace(/<expr>/g, /[^\s\S]/.source);
				var ftl2 = {
					comment: /<#--[\s\S]*?-->/,
					string: [
						{
							pattern: /\br("|')(?:(?!\1)[^\\]|\\.)*\1/,
							greedy: true
						},
						{
							pattern: RegExp(
								/("|')(?:(?!\1|\$\{)[^\\]|\\.|\$\{(?:(?!\})(?:<expr>))*\})*\1/.source.replace(
									/<expr>/g,
									function () {
										return FTL_EXPR;
									}
								)
							),
							greedy: true,
							inside: {
								interpolation: {
									pattern: RegExp(
										/((?:^|[^\\])(?:\\\\)*)\$\{(?:(?!\})(?:<expr>))*\}/.source.replace(
											/<expr>/g,
											function () {
												return FTL_EXPR;
											}
										)
									),
									lookbehind: true,
									inside: {
										'interpolation-punctuation': {
											pattern: /^\$\{|\}$/,
											alias: 'punctuation'
										},
										rest: null
									}
								}
							}
						}
					],
					keyword: /\b(?:as)\b/,
					boolean: /\b(?:false|true)\b/,
					'builtin-function': {
						pattern: /((?:^|[^?])\?\s*)\w+/,
						lookbehind: true,
						alias: 'function'
					},
					function: /\b\w+(?=\s*\()/,
					number: /\b\d+(?:\.\d+)?\b/,
					operator: /\.\.[<*!]?|->|--|\+\+|&&|\|\||\?{1,2}|[-+*/%!=<>]=?|\b(?:gt|gte|lt|lte)\b/,
					punctuation: /[,;.:()[\]{}]/
				};
				ftl2.string[1].inside.interpolation.inside.rest = ftl2;
				Prism2.languages.ftl = {
					'ftl-comment': {
						pattern: /^<#--[\s\S]*/,
						alias: 'comment'
					},
					'ftl-directive': {
						pattern: /^<[\s\S]+>$/,
						inside: {
							directive: {
								pattern: /(^<\/?)[#@][a-z]\w*/i,
								lookbehind: true,
								alias: 'keyword'
							},
							punctuation: /^<\/?|\/?>$/,
							content: {
								pattern: /\s*\S[\s\S]*/,
								alias: 'ftl',
								inside: ftl2
							}
						}
					},
					'ftl-interpolation': {
						pattern: /^\$\{[\s\S]*\}$/,
						inside: {
							punctuation: /^\$\{|\}$/,
							content: {
								pattern: /\s*\S[\s\S]*/,
								alias: 'ftl',
								inside: ftl2
							}
						}
					}
				};
				Prism2.hooks.add('before-tokenize', function (env) {
					var pattern = RegExp(
						/<#--[\s\S]*?-->|<\/?[#@][a-zA-Z](?:<expr>)*?>|\$\{(?:<expr>)*?\}/.source.replace(
							/<expr>/g,
							function () {
								return FTL_EXPR;
							}
						),
						'gi'
					);
					Prism2.languages['markup-templating'].buildPlaceholders(env, 'ftl', pattern);
				});
				Prism2.hooks.add('after-tokenize', function (env) {
					Prism2.languages['markup-templating'].tokenizePlaceholders(env, 'ftl');
				});
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/gap.js
var require_gap = __commonJS({
	'node_modules/refractor/lang/gap.js'(exports, module2) {
		'use strict';
		module2.exports = gap;
		gap.displayName = 'gap';
		gap.aliases = [];
		function gap(Prism) {
			Prism.languages.gap = {
				shell: {
					pattern: /^gap>[\s\S]*?(?=^gap>|$(?![\s\S]))/m,
					greedy: true,
					inside: {
						gap: {
							pattern: /^(gap>).+(?:(?:\r(?:\n|(?!\n))|\n)>.*)*/,
							lookbehind: true,
							inside: null
						},
						punctuation: /^gap>/
					}
				},
				comment: {
					pattern: /#.*/,
					greedy: true
				},
				string: {
					pattern:
						/(^|[^\\'"])(?:'(?:[^\r\n\\']|\\.){1,10}'|"(?:[^\r\n\\"]|\\.)*"(?!")|"""[\s\S]*?""")/,
					lookbehind: true,
					greedy: true,
					inside: {
						continuation: {
							pattern: /([\r\n])>/,
							lookbehind: true,
							alias: 'punctuation'
						}
					}
				},
				keyword:
					/\b(?:Assert|Info|IsBound|QUIT|TryNextMethod|Unbind|and|atomic|break|continue|do|elif|else|end|fi|for|function|if|in|local|mod|not|od|or|quit|readonly|readwrite|rec|repeat|return|then|until|while)\b/,
				boolean: /\b(?:false|true)\b/,
				function: /\b[a-z_]\w*(?=\s*\()/i,
				number: {
					pattern:
						/(^|[^\w.]|\.\.)(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?(?:_[a-z]?)?(?=$|[^\w.]|\.\.)/,
					lookbehind: true
				},
				continuation: {
					pattern: /([\r\n])>/,
					lookbehind: true,
					alias: 'punctuation'
				},
				operator: /->|[-+*/^~=!]|<>|[<>]=?|:=|\.\./,
				punctuation: /[()[\]{},;.:]/
			};
			Prism.languages.gap.shell.inside.gap.inside = Prism.languages.gap;
		}
	}
});

// node_modules/refractor/lang/gcode.js
var require_gcode = __commonJS({
	'node_modules/refractor/lang/gcode.js'(exports, module2) {
		'use strict';
		module2.exports = gcode;
		gcode.displayName = 'gcode';
		gcode.aliases = [];
		function gcode(Prism) {
			Prism.languages.gcode = {
				comment: /;.*|\B\(.*?\)\B/,
				string: {
					pattern: /"(?:""|[^"])*"/,
					greedy: true
				},
				keyword: /\b[GM]\d+(?:\.\d+)?\b/,
				property: /\b[A-Z]/,
				checksum: {
					pattern: /(\*)\d+/,
					lookbehind: true,
					alias: 'number'
				},
				punctuation: /[:*]/
			};
		}
	}
});

// node_modules/refractor/lang/gdscript.js
var require_gdscript = __commonJS({
	'node_modules/refractor/lang/gdscript.js'(exports, module2) {
		'use strict';
		module2.exports = gdscript;
		gdscript.displayName = 'gdscript';
		gdscript.aliases = [];
		function gdscript(Prism) {
			Prism.languages.gdscript = {
				comment: /#.*/,
				string: {
					pattern: /@?(?:("|')(?:(?!\1)[^\n\\]|\\[\s\S])*\1(?!"|')|"""(?:[^\\]|\\[\s\S])*?""")/,
					greedy: true
				},
				'class-name': {
					pattern:
						/(^(?:class|class_name|extends)[ \t]+|^export\([ \t]*|\bas[ \t]+|(?:\b(?:const|var)[ \t]|[,(])[ \t]*\w+[ \t]*:[ \t]*|->[ \t]*)[a-zA-Z_]\w*/m,
					lookbehind: true
				},
				keyword:
					/\b(?:and|as|assert|break|breakpoint|class|class_name|const|continue|elif|else|enum|export|extends|for|func|if|in|is|master|mastersync|match|not|null|onready|or|pass|preload|puppet|puppetsync|remote|remotesync|return|self|setget|signal|static|tool|var|while|yield)\b/,
				function: /\b[a-z_]\w*(?=[ \t]*\()/i,
				variable: /\$\w+/,
				number: [
					/\b0b[01_]+\b|\b0x[\da-fA-F_]+\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.[\d_]+)(?:e[+-]?[\d_]+)?\b/,
					/\b(?:INF|NAN|PI|TAU)\b/
				],
				constant: /\b[A-Z][A-Z_\d]*\b/,
				boolean: /\b(?:false|true)\b/,
				operator: /->|:=|&&|\|\||<<|>>|[-+*/%&|!<>=]=?|[~^]/,
				punctuation: /[.:,;()[\]{}]/
			};
		}
	}
});

// node_modules/refractor/lang/gedcom.js
var require_gedcom = __commonJS({
	'node_modules/refractor/lang/gedcom.js'(exports, module2) {
		'use strict';
		module2.exports = gedcom;
		gedcom.displayName = 'gedcom';
		gedcom.aliases = [];
		function gedcom(Prism) {
			Prism.languages.gedcom = {
				'line-value': {
					pattern:
						/(^[\t ]*\d+ +(?:@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@ +)?\w+ ).+/m,
					lookbehind: true,
					inside: {
						pointer: {
							pattern: /^@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@$/,
							alias: 'variable'
						}
					}
				},
				tag: {
					pattern: /(^[\t ]*\d+ +(?:@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@ +)?)\w+/m,
					lookbehind: true,
					alias: 'string'
				},
				level: {
					pattern: /(^[\t ]*)\d+/m,
					lookbehind: true,
					alias: 'number'
				},
				pointer: {
					pattern: /@\w[\w!"$%&'()*+,\-./:;<=>?[\\\]^`{|}~\x80-\xfe #]*@/,
					alias: 'variable'
				}
			};
		}
	}
});

// node_modules/refractor/lang/gherkin.js
var require_gherkin = __commonJS({
	'node_modules/refractor/lang/gherkin.js'(exports, module2) {
		'use strict';
		module2.exports = gherkin;
		gherkin.displayName = 'gherkin';
		gherkin.aliases = [];
		function gherkin(Prism) {
			(function (Prism2) {
				var tableRow = /(?:\r?\n|\r)[ \t]*\|.+\|(?:(?!\|).)*/.source;
				Prism2.languages.gherkin = {
					pystring: {
						pattern: /("""|''')[\s\S]+?\1/,
						alias: 'string'
					},
					comment: {
						pattern: /(^[ \t]*)#.*/m,
						lookbehind: true
					},
					tag: {
						pattern: /(^[ \t]*)@\S*/m,
						lookbehind: true
					},
					feature: {
						pattern:
							/((?:^|\r?\n|\r)[ \t]*)(?:Ability|Ahoy matey!|Arwedd|Aspekt|Besigheid Behoefte|Business Need|Caracteristica|Caracterstica|Egenskab|Egenskap|Eiginleiki|Feature|Fa|Fitur|Fonctionnalit|Fonksyonalite|Funcionalidade|Funcionalitat|Functionalitate|Funcionalitate|Funcionalitate|Functionaliteit|Fungsi|Funkcia|Funkcija|Funkcionalitte|Funkcionalnost|Funkcja|Funksie|Funktionalitt|Funktionalitit|Funzionalit|Hwaet|Hwt|Jellemz|Karakteristik|Lastnost|Mak|Mogucnost|laH|Mogunost|Moznosti|Monosti|OH HAI|Omadus|Ominaisuus|Osobina|zellik|Potrzeba biznesowa|perbogh|poQbogh malja'|Poadavek|Poiadavka|Pretty much|Qap|Qu'meH 'ut|Savyb|Tnh nng|Trajto|Vermo|Vlastnos|Waciwo|Znailnost||||||||||||||||  || || ||||||||||):(?:[^:\r\n]+(?:\r?\n|\r|$))*/,
						lookbehind: true,
						inside: {
							important: {
								pattern: /(:)[^\r\n]+/,
								lookbehind: true
							},
							keyword: /[^:\r\n]+:/
						}
					},
					scenario: {
						pattern:
							/(^[ \t]*)(?:Abstract Scenario|Abstrakt Scenario|Achtergrond|Aer|r|Agtergrond|All y'all|Antecedentes|Antecedents|Atburars|Atburarsir|Awww, look mate|B4|Background|Baggrund|Bakgrund|Bakgrunn|Bakgrunnur|Beispiele|Beispiller|Bi cnh|Cefndir|Cenario|Cenrio|Cenario de Fundo|Cenrio de Fundo|Cenarios|Cenrios|Contesto|Context|Contexte|Contexto|Conto|Contoh|Contone|Dmi|Dasar|Dead men tell no tales|Delineacao do Cenario|Delineao do Cenrio|Dis is what went down|D liu|Dyagram Senaryo|Dyagram senaryo|Egzanp|Ejemplos|Eksempler|Ekzemploj|Enghreifftiau|Esbozo do escenario|Escenari|Escenario|Esempi|Esquema de l'escenari|Esquema del escenario|Esquema do Cenario|Esquema do Cenrio|EXAMPLZ|Examples|Exempel|Exemple|Exemples|Exemplos|First off|Fono|Forgatknyv|Forgatknyv vzlat|Fundo|Gemi|Grundlage|Hannergrond|ghantoH|Httr|Heave to|Istorik|Juhtumid|Keadaan|Khung kch bn|Khung tnh hung|Kch bn|Koncept|Konsep skenario|Kontks|Kontekst|Kontekstas|Konteksts|Kontext|Konturo de la scenaro|Latar Belakang|lut chovnatlh|lut|lutmey|Lsing Atburarsar|Lsing Dma|MISHUN SRSLY|MISHUN|Menggariskan Senario|mo'|Nrt Scenra|Nrt Scne|Nrt Scenru|Oris scenarija|rnekler|Osnova|Osnova Scenra|Osnova scne|Osnutek|Ozadje|Paraugs|Pavyzdiai|Pldk|Piemri|Plan du scnario|Plan du Scnario|Plan Senaryo|Plan senaryo|Plang vum Szenario|Pozad|Pozadie|Pozadina|Prklady|Pklady|Primer|Primeri|Primjeri|Przykady|Raamstsenaarium|Reckon it's like|Rerefons|Scenr|Scn|Scenarie|Scenarij|Scenarijai|Scenarijaus ablonas|Scenariji|Scenrijs|Scenrijs pc parauga|Scenarijus|Scenario|Scnario|Scenario Amlinellol|Scenario Outline|Scenario Template|Scenariomal|Scenariomall|Scenarios|Scenariu|Scenariusz|Scenaro|Schema dello scenario|Se e|Se the|Se e|Senario|Senaryo Deskripsyon|Senaryo deskripsyon|Senaryo|Senaryo tasla|Shiver me timbers|Situcija|Situai|Situasie Uiteensetting|Situasie|Skenario konsep|Skenario|Skica|Structura scenariu|Structur scenariu|Struktura scenarija|Stsenaarium|Swa hwaer swa|Swa|Swa hwr swa|Szablon scenariusza|Szenario|Szenariogrundriss|Tapaukset|Tapaus|Tapausaihio|Taust|Tausta|Template Keadaan|Template Senario|Template Situai|The thing of it is|Tnh hung|Variantai|Voorbeelde|Voorbeelden|Wharrimean is|Yo-ho-ho|You'll wanna|Zaoenia|| ||||||||||||||||||  || | | || | |||||||| ||| || |||| ||   || ||| |||| |  |||||||||||||||||| ||||||||||||||||||):[^:\r\n]*/m,
						lookbehind: true,
						inside: {
							important: {
								pattern: /(:)[^\r\n]*/,
								lookbehind: true
							},
							keyword: /[^:\r\n]+:/
						}
					},
					'table-body': {
						pattern: RegExp('(' + tableRow + ')(?:' + tableRow + ')+'),
						lookbehind: true,
						inside: {
							outline: {
								pattern: /<[^>]+>/,
								alias: 'variable'
							},
							td: {
								pattern: /\s*[^\s|][^|]*/,
								alias: 'string'
							},
							punctuation: /\|/
						}
					},
					'table-head': {
						pattern: RegExp(tableRow),
						inside: {
							th: {
								pattern: /\s*[^\s|][^|]*/,
								alias: 'variable'
							},
							punctuation: /\|/
						}
					},
					atrule: {
						pattern:
							/(^[ \t]+)(?:'a|'ach|'ej|7|a|A tak|A taktie|A tie|A zrove|Aber|Ac|Adott|Akkor|Ak|Aleshores|Ale|Ali|Allora|Alors|Als|Ama|Amennyiben|Amikor|Ampak|an|AN|Ananging|And y'all|And|Angenommen|Anrhegedig a|An|Apabila|Ats|Atesa|Atunci|Avast!|Aye|A|awer|Bagi|Banjur|Bet|Bit|Blimey!|Buh|But at the end of the day I reckon|But y'all|But|BUT|Cal|Cnd|Cand|Cando|Ce|Cuando|e|a e|a|Dadas|Dada|Dados|Dado|DaH ghu' bejlu'|dann|Dann|Dano|Dan|Dar|Dat fiind|Data|Date fiind|Date|Dati fiind|Dati|Dai fiind|Dai fiind|DEN|Dato|De|Den youse gotta|Dengan|Diberi|Diyelim ki|Donada|Donat|Donitao|Do|Dun|Duota|urh|Eeldades|Ef|Eer ki|Entao|Ento|Entn|E|En|Entonces|Epi|s|Etant donne|Etant donn|Et|tant donnes|tant donne|tant donn|Etant donnes|Etant donns|tant donns|Fakat|Gangway!|Gdy|Gegeben seien|Gegeben sei|Gegeven|Gegewe|ghu' noblu'|Gitt|Given y'all|Given|Givet|Givun|Ha|Cho|I CAN HAZ|In|Ir|It's just unbelievable|I|Ja|Jeli|Jeeli|Kad|Kada|Kadar|Kai|Kaj|Kdy|Ke|Kemudian|Ketika|Khi|Kiedy|Ko|Kuid|Kui|Kun|Lan|latlh|Le sa a|Let go and haul|Le|L sa a|L|Logo|Lorsqu'<|Lorsque|m|Maar|Mais|Majc|Ma|Majd|Maka|Manawa|Mas|Men|Menawa|Mutta|Nalika|Nalikaning|Nanging|Nr|Nr|Nato|Nhng|Niin|Njuk|O zaman|Och|Og|Oletetaan|Ond|Onda|Oraz|Pak|Pero|Per|Podano|Pokia|Pokud|Potem|Potom|Privzeto|Pryd|Quan|Quand|Quando|qaSDI'|S|Sed|Se|Siis|Sipoze ke|Sipoze Ke|Sipoze|Si|i|i|Soit|Stel|Tada|Tad|Takrat|Tak|Tapi|Ter|Tetapi|Tha the|Tha|Then y'all|Then|Th|Thurh|Toda|Too right|Un|Und|ugeholl|V|vaj|Vendar|Ve|wann|Wanneer|WEN|Wenn|When y'all|When|Wtedy|Wun|Y'know|Yeah nah|Yna|Youse know like when|Youse know when youse got|Y|Za predpokladu|Za pedpokladu|Zadan|Zadani|Zadano|Zadate|Zadato|Zakadajc|Zaradi|Zatati|a e|a||egar|urh|||||| |||||||||||||||||||||  ||||||||||||, |||||||||||||||||||||| |||||||| |||||||||||||||||||| ||||| ||||||||||||||<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<|<)(?=[ \t])/m,
						lookbehind: true
					},
					string: {
						pattern: /"(?:\\.|[^"\\\r\n])*"|'(?:\\.|[^'\\\r\n])*'/,
						inside: {
							outline: {
								pattern: /<[^>]+>/,
								alias: 'variable'
							}
						}
					},
					outline: {
						pattern: /<[^>]+>/,
						alias: 'variable'
					}
				};
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/git.js
var require_git = __commonJS({
	'node_modules/refractor/lang/git.js'(exports, module2) {
		'use strict';
		module2.exports = git;
		git.displayName = 'git';
		git.aliases = [];
		function git(Prism) {
			Prism.languages.git = {
				comment: /^#.*/m,
				deleted: /^[-].*/m,
				inserted: /^\+.*/m,
				string: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
				command: {
					pattern: /^.*\$ git .*$/m,
					inside: {
						parameter: /\s--?\w+/
					}
				},
				coord: /^@@.*@@$/m,
				'commit-sha1': /^commit \w{40}$/m
			};
		}
	}
});

// node_modules/refractor/lang/glsl.js
var require_glsl = __commonJS({
	'node_modules/refractor/lang/glsl.js'(exports, module2) {
		'use strict';
		var refractorC = require_c();
		module2.exports = glsl;
		glsl.displayName = 'glsl';
		glsl.aliases = [];
		function glsl(Prism) {
			Prism.register(refractorC);
			Prism.languages.glsl = Prism.languages.extend('c', {
				keyword:
					/\b(?:active|asm|atomic_uint|attribute|[ibdu]?vec[234]|bool|break|buffer|case|cast|centroid|class|coherent|common|const|continue|d?mat[234](?:x[234])?|default|discard|do|double|else|enum|extern|external|false|filter|fixed|flat|float|for|fvec[234]|goto|half|highp|hvec[234]|[iu]?sampler2DMS(?:Array)?|[iu]?sampler2DRect|[iu]?samplerBuffer|[iu]?samplerCube|[iu]?samplerCubeArray|[iu]?sampler[123]D|[iu]?sampler[12]DArray|[iu]?image2DMS(?:Array)?|[iu]?image2DRect|[iu]?imageBuffer|[iu]?imageCube|[iu]?imageCubeArray|[iu]?image[123]D|[iu]?image[12]DArray|if|in|inline|inout|input|int|interface|invariant|layout|long|lowp|mediump|namespace|noinline|noperspective|out|output|partition|patch|precise|precision|public|readonly|resource|restrict|return|sample|sampler[12]DArrayShadow|sampler[12]DShadow|sampler2DRectShadow|sampler3DRect|samplerCubeArrayShadow|samplerCubeShadow|shared|short|sizeof|smooth|static|struct|subroutine|superp|switch|template|this|true|typedef|uint|uniform|union|unsigned|using|varying|void|volatile|while|writeonly)\b/
			});
		}
	}
});

// node_modules/refractor/lang/gml.js
var require_gml = __commonJS({
	'node_modules/refractor/lang/gml.js'(exports, module2) {
		'use strict';
		module2.exports = gml;
		gml.displayName = 'gml';
		gml.aliases = [];
		function gml(Prism) {
			Prism.languages.gamemakerlanguage = Prism.languages.gml = Prism.languages.extend('clike', {
				keyword:
					/\b(?:break|case|continue|default|do|else|enum|exit|for|globalvar|if|repeat|return|switch|until|var|while)\b/,
				number: /(?:\b0x[\da-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[ulf]{0,4}/i,
				operator:
					/--|\+\+|[-+%/=]=?|!=|\*\*?=?|<[<=>]?|>[=>]?|&&?|\^\^?|\|\|?|~|\b(?:and|at|not|or|with|xor)\b/,
				constant:
					/\b(?:GM_build_date|GM_version|action_(?:continue|restart|reverse|stop)|all|gamespeed_(?:fps|microseconds)|global|local|noone|other|pi|pointer_(?:invalid|null)|self|timezone_(?:local|utc)|undefined|ev_(?:create|destroy|step|alarm|keyboard|mouse|collision|other|draw|draw_(?:begin|end|post|pre)|keypress|keyrelease|trigger|(?:left|middle|no|right)_button|(?:left|middle|right)_press|(?:left|middle|right)_release|mouse_(?:enter|leave|wheel_down|wheel_up)|global_(?:left|middle|right)_button|global_(?:left|middle|right)_press|global_(?:left|middle|right)_release|joystick(?:1|2)_(?:button1|button2|button3|button4|button5|button6|button7|button8|down|left|right|up)|outside|boundary|game_start|game_end|room_start|room_end|no_more_lives|animation_end|end_of_path|no_more_health|user\d|gui|gui_begin|gui_end|step_(?:begin|end|normal))|vk_(?:alt|anykey|backspace|control|delete|down|end|enter|escape|home|insert|left|nokey|pagedown|pageup|pause|printscreen|return|right|shift|space|tab|up|f\d|numpad\d|add|decimal|divide|lalt|lcontrol|lshift|multiply|ralt|rcontrol|rshift|subtract)|achievement_(?:filter_(?:all_players|favorites_only|friends_only)|friends_info|info|leaderboard_info|our_info|pic_loaded|show_(?:achievement|bank|friend_picker|leaderboard|profile|purchase_prompt|ui)|type_challenge|type_score_challenge)|asset_(?:font|object|path|room|script|shader|sound|sprite|tiles|timeline|unknown)|audio_(?:3d|falloff_(?:exponent_distance|exponent_distance_clamped|inverse_distance|inverse_distance_clamped|linear_distance|linear_distance_clamped|none)|mono|new_system|old_system|stereo)|bm_(?:add|complex|dest_alpha|dest_color|dest_colour|inv_dest_alpha|inv_dest_color|inv_dest_colour|inv_src_alpha|inv_src_color|inv_src_colour|max|normal|one|src_alpha|src_alpha_sat|src_color|src_colour|subtract|zero)|browser_(?:chrome|firefox|ie|ie_mobile|not_a_browser|opera|safari|safari_mobile|tizen|unknown|windows_store)|buffer_(?:bool|f16|f32|f64|fast|fixed|generalerror|grow|invalidtype|network|outofbounds|outofspace|s16|s32|s8|seek_end|seek_relative|seek_start|string|text|u16|u32|u64|u8|vbuffer|wrap)|c_(?:aqua|black|blue|dkgray|fuchsia|gray|green|lime|ltgray|maroon|navy|olive|orange|purple|red|silver|teal|white|yellow)|cmpfunc_(?:always|equal|greater|greaterequal|less|lessequal|never|notequal)|cr_(?:appstart|arrow|beam|cross|default|drag|handpoint|hourglass|none|size_all|size_nesw|size_ns|size_nwse|size_we|uparrow)|cull_(?:clockwise|counterclockwise|noculling)|device_(?:emulator|tablet)|device_ios_(?:ipad|ipad_retina|iphone|iphone5|iphone6|iphone6plus|iphone_retina|unknown)|display_(?:landscape|landscape_flipped|portrait|portrait_flipped)|dll_(?:cdecl|cdel|stdcall)|ds_type_(?:grid|list|map|priority|queue|stack)|ef_(?:cloud|ellipse|explosion|firework|flare|rain|ring|smoke|smokeup|snow|spark|star)|fa_(?:archive|bottom|center|directory|hidden|left|middle|readonly|right|sysfile|top|volumeid)|fb_login_(?:default|fallback_to_webview|forcing_safari|forcing_webview|no_fallback_to_webview|use_system_account)|iap_(?:available|canceled|ev_consume|ev_product|ev_purchase|ev_restore|ev_storeload|failed|purchased|refunded|status_available|status_loading|status_processing|status_restoring|status_unavailable|status_uninitialised|storeload_failed|storeload_ok|unavailable)|leaderboard_type_(?:number|time_mins_secs)|lighttype_(?:dir|point)|matrix_(?:projection|view|world)|mb_(?:any|left|middle|none|right)|network_(?:config_(?:connect_timeout|disable_reliable_udp|enable_reliable_udp|use_non_blocking_socket)|socket_(?:bluetooth|tcp|udp)|type_(?:connect|data|disconnect|non_blocking_connect))|of_challenge_(?:lose|tie|win)|os_(?:android|ios|linux|macosx|ps3|ps4|psvita|unknown|uwp|win32|win8native|windows|winphone|xboxone)|phy_debug_render_(?:aabb|collision_pairs|coms|core_shapes|joints|obb|shapes)|phy_joint_(?:anchor_1_x|anchor_1_y|anchor_2_x|anchor_2_y|angle|angle_limits|damping_ratio|frequency|length_1|length_2|lower_angle_limit|max_force|max_length|max_motor_force|max_motor_torque|max_torque|motor_force|motor_speed|motor_torque|reaction_force_x|reaction_force_y|reaction_torque|speed|translation|upper_angle_limit)|phy_particle_data_flag_(?:category|color|colour|position|typeflags|velocity)|phy_particle_flag_(?:colormixing|colourmixing|elastic|powder|spring|tensile|viscous|wall|water|zombie)|phy_particle_group_flag_(?:rigid|solid)|pr_(?:linelist|linestrip|pointlist|trianglefan|trianglelist|trianglestrip)|ps_(?:distr|shape)_(?:diamond|ellipse|gaussian|invgaussian|line|linear|rectangle)|pt_shape_(?:circle|cloud|disk|explosion|flare|line|pixel|ring|smoke|snow|spark|sphere|square|star)|ty_(?:real|string)|gp_(?:face\d|axislh|axislv|axisrh|axisrv|padd|padl|padr|padu|select|shoulderl|shoulderlb|shoulderr|shoulderrb|start|stickl|stickr)|lb_disp_(?:none|numeric|time_ms|time_sec)|lb_sort_(?:ascending|descending|none)|ov_(?:achievements|community|friends|gamegroup|players|settings)|ugc_(?:filetype_(?:community|microtrans)|list_(?:Favorited|Followed|Published|Subscribed|UsedOrPlayed|VotedDown|VotedOn|VotedUp|WillVoteLater)|match_(?:AllGuides|Artwork|Collections|ControllerBindings|IntegratedGuides|Items|Items_Mtx|Items_ReadyToUse|Screenshots|UsableInGame|Videos|WebGuides)|query_(?:AcceptedForGameRankedByAcceptanceDate|CreatedByFriendsRankedByPublicationDate|FavoritedByFriendsRankedByPublicationDate|NotYetRated)|query_RankedBy(?:NumTimesReported|PublicationDate|TextSearch|TotalVotesAsc|Trend|Vote|VotesUp)|result_success|sortorder_CreationOrder(?:Asc|Desc)|sortorder_(?:ForModeration|LastUpdatedDesc|SubscriptionDateDesc|TitleAsc|VoteScoreDesc)|visibility_(?:friends_only|private|public))|vertex_usage_(?:binormal|blendindices|blendweight|color|colour|depth|fog|normal|position|psize|sample|tangent|texcoord|textcoord)|vertex_type_(?:float\d|color|colour|ubyte4)|input_type|layerelementtype_(?:background|instance|oldtilemap|particlesystem|sprite|tile|tilemap|undefined)|se_(?:chorus|compressor|echo|equalizer|flanger|gargle|none|reverb)|text_type|tile_(?:flip|index_mask|mirror|rotate)|(?:obj|rm|scr|spr)\w+)\b/,
				variable:
					/\b(?:alarm|application_surface|async_load|background_(?:alpha|blend|color|colour|foreground|height|hspeed|htiled|index|showcolor|showcolour|visible|vspeed|vtiled|width|x|xscale|y|yscale)|bbox_(?:bottom|left|right|top)|browser_(?:height|width)|caption_(?:health|lives|score)|current_(?:day|hour|minute|month|second|time|weekday|year)|cursor_sprite|debug_mode|delta_time|direction|display_aa|error_(?:last|occurred)|event_(?:action|number|object|type)|fps|fps_real|friction|game_(?:display|project|save)_(?:id|name)|gamemaker_(?:pro|registered|version)|gravity|gravity_direction|(?:h|v)speed|health|iap_data|id|image_(?:alpha|angle|blend|depth|index|number|speed|xscale|yscale)|instance_(?:count|id)|keyboard_(?:key|lastchar|lastkey|string)|layer|lives|mask_index|mouse_(?:button|lastbutton|x|y)|object_index|os_(?:browser|device|type|version)|path_(?:endaction|index|orientation|position|positionprevious|scale|speed)|persistent|phy_(?:rotation|(?:col_normal|collision|com|linear_velocity|position|speed)_(?:x|y)|angular_(?:damping|velocity)|position_(?:x|y)previous|speed|linear_damping|bullet|fixed_rotation|active|mass|inertia|dynamic|kinematic|sleeping|collision_points)|pointer_(?:invalid|null)|room|room_(?:caption|first|height|last|persistent|speed|width)|score|secure_mode|show_(?:health|lives|score)|solid|speed|sprite_(?:height|index|width|xoffset|yoffset)|temp_directory|timeline_(?:index|loop|position|running|speed)|transition_(?:color|kind|steps)|undefined|view_(?:angle|current|enabled|(?:h|v)(?:border|speed)|(?:h|w|x|y)port|(?:h|w|x|y)view|object|surface_id|visible)|visible|webgl_enabled|working_directory|(?:x|y)(?:previous|start)|x|y|argument(?:_relitive|_count|\d)|argument|global|local|other|self)\b/
			});
		}
	}
});

// node_modules/refractor/lang/gn.js
var require_gn = __commonJS({
	'node_modules/refractor/lang/gn.js'(exports, module2) {
		'use strict';
		module2.exports = gn;
		gn.displayName = 'gn';
		gn.aliases = ['gni'];
		function gn(Prism) {
			Prism.languages.gn = {
				comment: {
					pattern: /#.*/,
					greedy: true
				},
				'string-literal': {
					pattern: /(^|[^\\"])"(?:[^\r\n"\\]|\\.)*"/,
					lookbehind: true,
					greedy: true,
					inside: {
						interpolation: {
							pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:\{[\s\S]*?\}|[a-zA-Z_]\w*|0x[a-fA-F0-9]{2})/,
							lookbehind: true,
							inside: {
								number: /^\$0x[\s\S]{2}$/,
								variable: /^\$\w+$/,
								'interpolation-punctuation': {
									pattern: /^\$\{|\}$/,
									alias: 'punctuation'
								},
								expression: {
									pattern: /[\s\S]+/,
									inside: null
								}
							}
						},
						string: /[\s\S]+/
					}
				},
				keyword: /\b(?:else|if)\b/,
				boolean: /\b(?:false|true)\b/,
				'builtin-function': {
					pattern:
						/\b(?:assert|defined|foreach|import|pool|print|template|tool|toolchain)(?=\s*\()/i,
					alias: 'keyword'
				},
				function: /\b[a-z_]\w*(?=\s*\()/i,
				constant:
					/\b(?:current_cpu|current_os|current_toolchain|default_toolchain|host_cpu|host_os|root_build_dir|root_gen_dir|root_out_dir|target_cpu|target_gen_dir|target_os|target_out_dir)\b/,
				number: /-?\b\d+\b/,
				operator: /[-+!=<>]=?|&&|\|\|/,
				punctuation: /[(){}[\],.]/
			};
			Prism.languages.gn['string-literal'].inside['interpolation'].inside['expression'].inside =
				Prism.languages.gn;
			Prism.languages.gni = Prism.languages.gn;
		}
	}
});

// node_modules/refractor/lang/go-module.js
var require_go_module = __commonJS({
	'node_modules/refractor/lang/go-module.js'(exports, module2) {
		'use strict';
		module2.exports = goModule;
		goModule.displayName = 'goModule';
		goModule.aliases = [];
		function goModule(Prism) {
			Prism.languages['go-mod'] = Prism.languages['go-module'] = {
				comment: {
					pattern: /\/\/.*/,
					greedy: true
				},
				version: {
					pattern: /(^|[\s()[\],])v\d+\.\d+\.\d+(?:[+-][-+.\w]*)?(?![^\s()[\],])/,
					lookbehind: true,
					alias: 'number'
				},
				'go-version': {
					pattern: /((?:^|\s)go\s+)\d+(?:\.\d+){1,2}/,
					lookbehind: true,
					alias: 'number'
				},
				keyword: {
					pattern: /^([ \t]*)(?:exclude|go|module|replace|require|retract)\b/m,
					lookbehind: true
				},
				operator: /=>/,
				punctuation: /[()[\],]/
			};
		}
	}
});

// node_modules/refractor/lang/go.js
var require_go = __commonJS({
	'node_modules/refractor/lang/go.js'(exports, module2) {
		'use strict';
		module2.exports = go;
		go.displayName = 'go';
		go.aliases = [];
		function go(Prism) {
			Prism.languages.go = Prism.languages.extend('clike', {
				string: {
					pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"|`[^`]*`/,
					lookbehind: true,
					greedy: true
				},
				keyword:
					/\b(?:break|case|chan|const|continue|default|defer|else|fallthrough|for|func|go(?:to)?|if|import|interface|map|package|range|return|select|struct|switch|type|var)\b/,
				boolean: /\b(?:_|false|iota|nil|true)\b/,
				number: [
					/\b0(?:b[01_]+|o[0-7_]+)i?\b/i,
					/\b0x(?:[a-f\d_]+(?:\.[a-f\d_]*)?|\.[a-f\d_]+)(?:p[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
					/(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?[\d_]+)?i?(?!\w)/i
				],
				operator:
					/[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\./,
				builtin:
					/\b(?:append|bool|byte|cap|close|complex|complex(?:64|128)|copy|delete|error|float(?:32|64)|u?int(?:8|16|32|64)?|imag|len|make|new|panic|print(?:ln)?|real|recover|rune|string|uintptr)\b/
			});
			Prism.languages.insertBefore('go', 'string', {
				char: {
					pattern: /'(?:\\.|[^'\\\r\n]){0,10}'/,
					greedy: true
				}
			});
			delete Prism.languages.go['class-name'];
		}
	}
});

// node_modules/refractor/lang/graphql.js
var require_graphql = __commonJS({
	'node_modules/refractor/lang/graphql.js'(exports, module2) {
		'use strict';
		module2.exports = graphql;
		graphql.displayName = 'graphql';
		graphql.aliases = [];
		function graphql(Prism) {
			Prism.languages.graphql = {
				comment: /#.*/,
				description: {
					pattern: /(?:"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*")(?=\s*[a-z_])/i,
					greedy: true,
					alias: 'string',
					inside: {
						'language-markdown': {
							pattern: /(^"(?:"")?)(?!\1)[\s\S]+(?=\1$)/,
							lookbehind: true,
							inside: Prism.languages.markdown
						}
					}
				},
				string: {
					pattern: /"""(?:[^"]|(?!""")")*"""|"(?:\\.|[^\\"\r\n])*"/,
					greedy: true
				},
				number: /(?:\B-|\b)\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
				boolean: /\b(?:false|true)\b/,
				variable: /\$[a-z_]\w*/i,
				directive: {
					pattern: /@[a-z_]\w*/i,
					alias: 'function'
				},
				'attr-name': {
					pattern: /\b[a-z_]\w*(?=\s*(?:\((?:[^()"]|"(?:\\.|[^\\"\r\n])*")*\))?:)/i,
					greedy: true
				},
				'atom-input': {
					pattern: /\b[A-Z]\w*Input\b/,
					alias: 'class-name'
				},
				scalar: /\b(?:Boolean|Float|ID|Int|String)\b/,
				constant: /\b[A-Z][A-Z_\d]*\b/,
				'class-name': {
					pattern:
						/(\b(?:enum|implements|interface|on|scalar|type|union)\s+|&\s*|:\s*|\[)[A-Z_]\w*/,
					lookbehind: true
				},
				fragment: {
					pattern: /(\bfragment\s+|\.{3}\s*(?!on\b))[a-zA-Z_]\w*/,
					lookbehind: true,
					alias: 'function'
				},
				'definition-mutation': {
					pattern: /(\bmutation\s+)[a-zA-Z_]\w*/,
					lookbehind: true,
					alias: 'function'
				},
				'definition-query': {
					pattern: /(\bquery\s+)[a-zA-Z_]\w*/,
					lookbehind: true,
					alias: 'function'
				},
				keyword:
					/\b(?:directive|enum|extend|fragment|implements|input|interface|mutation|on|query|repeatable|scalar|schema|subscription|type|union)\b/,
				operator: /[!=|&]|\.{3}/,
				'property-query': /\w+(?=\s*\()/,
				object: /\w+(?=\s*\{)/,
				punctuation: /[!(){}\[\]:=,]/,
				property: /\w+/
			};
			Prism.hooks.add('after-tokenize', function afterTokenizeGraphql(env) {
				if (env.language !== 'graphql') {
					return;
				}
				var validTokens = env.tokens.filter(function (token) {
					return typeof token !== 'string' && token.type !== 'comment' && token.type !== 'scalar';
				});
				var currentIndex = 0;
				function getToken(offset) {
					return validTokens[currentIndex + offset];
				}
				function isTokenType(types2, offset) {
					offset = offset || 0;
					for (var i3 = 0; i3 < types2.length; i3++) {
						var token = getToken(i3 + offset);
						if (!token || token.type !== types2[i3]) {
							return false;
						}
					}
					return true;
				}
				function findClosingBracket(open, close) {
					var stackHeight = 1;
					for (var i3 = currentIndex; i3 < validTokens.length; i3++) {
						var token = validTokens[i3];
						var content3 = token.content;
						if (token.type === 'punctuation' && typeof content3 === 'string') {
							if (open.test(content3)) {
								stackHeight++;
							} else if (close.test(content3)) {
								stackHeight--;
								if (stackHeight === 0) {
									return i3;
								}
							}
						}
					}
					return -1;
				}
				function addAlias(token, alias) {
					var aliases = token.alias;
					if (!aliases) {
						token.alias = aliases = [];
					} else if (!Array.isArray(aliases)) {
						token.alias = aliases = [aliases];
					}
					aliases.push(alias);
				}
				for (; currentIndex < validTokens.length; ) {
					var startToken = validTokens[currentIndex++];
					if (startToken.type === 'keyword' && startToken.content === 'mutation') {
						var inputVariables = [];
						if (
							isTokenType(['definition-mutation', 'punctuation']) &&
							getToken(1).content === '('
						) {
							currentIndex += 2;
							var definitionEnd = findClosingBracket(/^\($/, /^\)$/);
							if (definitionEnd === -1) {
								continue;
							}
							for (; currentIndex < definitionEnd; currentIndex++) {
								var t2 = getToken(0);
								if (t2.type === 'variable') {
									addAlias(t2, 'variable-input');
									inputVariables.push(t2.content);
								}
							}
							currentIndex = definitionEnd + 1;
						}
						if (isTokenType(['punctuation', 'property-query']) && getToken(0).content === '{') {
							currentIndex++;
							addAlias(getToken(0), 'property-mutation');
							if (inputVariables.length > 0) {
								var mutationEnd = findClosingBracket(/^\{$/, /^\}$/);
								if (mutationEnd === -1) {
									continue;
								}
								for (var i2 = currentIndex; i2 < mutationEnd; i2++) {
									var varToken = validTokens[i2];
									if (
										varToken.type === 'variable' &&
										inputVariables.indexOf(varToken.content) >= 0
									) {
										addAlias(varToken, 'variable-input');
									}
								}
							}
						}
					}
				}
			});
		}
	}
});

// node_modules/refractor/lang/groovy.js
var require_groovy = __commonJS({
	'node_modules/refractor/lang/groovy.js'(exports, module2) {
		'use strict';
		module2.exports = groovy;
		groovy.displayName = 'groovy';
		groovy.aliases = [];
		function groovy(Prism) {
			Prism.languages.groovy = Prism.languages.extend('clike', {
				string: [
					{
						pattern:
							/("""|''')(?:[^\\]|\\[\s\S])*?\1|\$\/(?:[^/$]|\$(?:[/$]|(?![/$]))|\/(?!\$))*\/\$/,
						greedy: true
					},
					{
						pattern: /(["'/])(?:\\.|(?!\1)[^\\\r\n])*\1/,
						greedy: true
					}
				],
				keyword:
					/\b(?:abstract|as|assert|boolean|break|byte|case|catch|char|class|const|continue|def|default|do|double|else|enum|extends|final|finally|float|for|goto|if|implements|import|in|instanceof|int|interface|long|native|new|package|private|protected|public|return|short|static|strictfp|super|switch|synchronized|this|throw|throws|trait|transient|try|void|volatile|while)\b/,
				number:
					/\b(?:0b[01_]+|0x[\da-f_]+(?:\.[\da-f_p\-]+)?|[\d_]+(?:\.[\d_]+)?(?:e[+-]?\d+)?)[glidf]?\b/i,
				operator: {
					pattern:
						/(^|[^.])(?:~|==?~?|\?[.:]?|\*(?:[.=]|\*=?)?|\.[@&]|\.\.<|\.\.(?!\.)|-[-=>]?|\+[+=]?|!=?|<(?:<=?|=>?)?|>(?:>>?=?|=)?|&[&=]?|\|[|=]?|\/=?|\^=?|%=?)/,
					lookbehind: true
				},
				punctuation: /\.+|[{}[\];(),:$]/
			});
			Prism.languages.insertBefore('groovy', 'string', {
				shebang: {
					pattern: /#!.+/,
					alias: 'comment'
				}
			});
			Prism.languages.insertBefore('groovy', 'punctuation', {
				'spock-block': /\b(?:and|cleanup|expect|given|setup|then|when|where):/
			});
			Prism.languages.insertBefore('groovy', 'function', {
				annotation: {
					pattern: /(^|[^.])@\w+/,
					lookbehind: true,
					alias: 'punctuation'
				}
			});
			Prism.hooks.add('wrap', function (env) {
				if (env.language === 'groovy' && env.type === 'string') {
					var delimiter = env.content.value[0];
					if (delimiter != "'") {
						var pattern = /([^\\])(?:\$(?:\{.*?\}|[\w.]+))/;
						if (delimiter === '$') {
							pattern = /([^\$])(?:\$(?:\{.*?\}|[\w.]+))/;
						}
						env.content.value = env.content.value.replace(/&lt;/g, '<').replace(/&amp;/g, '&');
						env.content = Prism.highlight(env.content.value, {
							expression: {
								pattern,
								lookbehind: true,
								inside: Prism.languages.groovy
							}
						});
						env.classes.push(delimiter === '/' ? 'regex' : 'gstring');
					}
				}
			});
		}
	}
});

// node_modules/refractor/lang/haml.js
var require_haml = __commonJS({
	'node_modules/refractor/lang/haml.js'(exports, module2) {
		'use strict';
		var refractorRuby = require_ruby();
		module2.exports = haml;
		haml.displayName = 'haml';
		haml.aliases = [];
		function haml(Prism) {
			Prism.register(refractorRuby);
			(function (Prism2) {
				Prism2.languages.haml = {
					'multiline-comment': {
						pattern: /((?:^|\r?\n|\r)([\t ]*))(?:\/|-#).*(?:(?:\r?\n|\r)\2[\t ].+)*/,
						lookbehind: true,
						alias: 'comment'
					},
					'multiline-code': [
						{
							pattern:
								/((?:^|\r?\n|\r)([\t ]*)(?:[~-]|[&!]?=)).*,[\t ]*(?:(?:\r?\n|\r)\2[\t ].*,[\t ]*)*(?:(?:\r?\n|\r)\2[\t ].+)/,
							lookbehind: true,
							inside: Prism2.languages.ruby
						},
						{
							pattern:
								/((?:^|\r?\n|\r)([\t ]*)(?:[~-]|[&!]?=)).*\|[\t ]*(?:(?:\r?\n|\r)\2[\t ].*\|[\t ]*)*/,
							lookbehind: true,
							inside: Prism2.languages.ruby
						}
					],
					filter: {
						pattern:
							/((?:^|\r?\n|\r)([\t ]*)):[\w-]+(?:(?:\r?\n|\r)(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/,
						lookbehind: true,
						inside: {
							'filter-name': {
								pattern: /^:[\w-]+/,
								alias: 'symbol'
							}
						}
					},
					markup: {
						pattern: /((?:^|\r?\n|\r)[\t ]*)<.+/,
						lookbehind: true,
						inside: Prism2.languages.markup
					},
					doctype: {
						pattern: /((?:^|\r?\n|\r)[\t ]*)!!!(?: .+)?/,
						lookbehind: true
					},
					tag: {
						pattern:
							/((?:^|\r?\n|\r)[\t ]*)[%.#][\w\-#.]*[\w\-](?:\([^)]+\)|\{(?:\{[^}]+\}|[^{}])+\}|\[[^\]]+\])*[\/<>]*/,
						lookbehind: true,
						inside: {
							attributes: [
								{
									pattern: /(^|[^#])\{(?:\{[^}]+\}|[^{}])+\}/,
									lookbehind: true,
									inside: Prism2.languages.ruby
								},
								{
									pattern: /\([^)]+\)/,
									inside: {
										'attr-value': {
											pattern: /(=\s*)(?:"(?:\\.|[^\\"\r\n])*"|[^)\s]+)/,
											lookbehind: true
										},
										'attr-name': /[\w:-]+(?=\s*!?=|\s*[,)])/,
										punctuation: /[=(),]/
									}
								},
								{
									pattern: /\[[^\]]+\]/,
									inside: Prism2.languages.ruby
								}
							],
							punctuation: /[<>]/
						}
					},
					code: {
						pattern: /((?:^|\r?\n|\r)[\t ]*(?:[~-]|[&!]?=)).+/,
						lookbehind: true,
						inside: Prism2.languages.ruby
					},
					interpolation: {
						pattern: /#\{[^}]+\}/,
						inside: {
							delimiter: {
								pattern: /^#\{|\}$/,
								alias: 'punctuation'
							},
							ruby: {
								pattern: /[\s\S]+/,
								inside: Prism2.languages.ruby
							}
						}
					},
					punctuation: {
						pattern: /((?:^|\r?\n|\r)[\t ]*)[~=\-&!]+/,
						lookbehind: true
					}
				};
				var filter_pattern =
					'((?:^|\\r?\\n|\\r)([\\t ]*)):{{filter_name}}(?:(?:\\r?\\n|\\r)(?:\\2[\\t ].+|\\s*?(?=\\r?\\n|\\r)))+';
				var filters = [
					'css',
					{
						filter: 'coffee',
						language: 'coffeescript'
					},
					'erb',
					'javascript',
					'less',
					'markdown',
					'ruby',
					'scss',
					'textile'
				];
				var all_filters = {};
				for (var i2 = 0, l = filters.length; i2 < l; i2++) {
					var filter = filters[i2];
					filter =
						typeof filter === 'string'
							? {
									filter,
									language: filter
							  }
							: filter;
					if (Prism2.languages[filter.language]) {
						all_filters['filter-' + filter.filter] = {
							pattern: RegExp(
								filter_pattern.replace('{{filter_name}}', function () {
									return filter.filter;
								})
							),
							lookbehind: true,
							inside: {
								'filter-name': {
									pattern: /^:[\w-]+/,
									alias: 'symbol'
								},
								text: {
									pattern: /[\s\S]+/,
									alias: [filter.language, 'language-' + filter.language],
									inside: Prism2.languages[filter.language]
								}
							}
						};
					}
				}
				Prism2.languages.insertBefore('haml', 'filter', all_filters);
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/handlebars.js
var require_handlebars = __commonJS({
	'node_modules/refractor/lang/handlebars.js'(exports, module2) {
		'use strict';
		var refractorMarkupTemplating = require_markup_templating();
		module2.exports = handlebars;
		handlebars.displayName = 'handlebars';
		handlebars.aliases = ['hbs'];
		function handlebars(Prism) {
			Prism.register(refractorMarkupTemplating);
			(function (Prism2) {
				Prism2.languages.handlebars = {
					comment: /\{\{![\s\S]*?\}\}/,
					delimiter: {
						pattern: /^\{\{\{?|\}\}\}?$/,
						alias: 'punctuation'
					},
					string: /(["'])(?:\\.|(?!\1)[^\\\r\n])*\1/,
					number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][+-]?\d+)?/,
					boolean: /\b(?:false|true)\b/,
					block: {
						pattern: /^(\s*(?:~\s*)?)[#\/]\S+?(?=\s*(?:~\s*)?$|\s)/,
						lookbehind: true,
						alias: 'keyword'
					},
					brackets: {
						pattern: /\[[^\]]+\]/,
						inside: {
							punctuation: /\[|\]/,
							variable: /[\s\S]+/
						}
					},
					punctuation: /[!"#%&':()*+,.\/;<=>@\[\\\]^`{|}~]/,
					variable: /[^!"#%&'()*+,\/;<=>@\[\\\]^`{|}~\s]+/
				};
				Prism2.hooks.add('before-tokenize', function (env) {
					var handlebarsPattern = /\{\{\{[\s\S]+?\}\}\}|\{\{[\s\S]+?\}\}/g;
					Prism2.languages['markup-templating'].buildPlaceholders(
						env,
						'handlebars',
						handlebarsPattern
					);
				});
				Prism2.hooks.add('after-tokenize', function (env) {
					Prism2.languages['markup-templating'].tokenizePlaceholders(env, 'handlebars');
				});
				Prism2.languages.hbs = Prism2.languages.handlebars;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/haskell.js
var require_haskell = __commonJS({
	'node_modules/refractor/lang/haskell.js'(exports, module2) {
		'use strict';
		module2.exports = haskell;
		haskell.displayName = 'haskell';
		haskell.aliases = ['hs'];
		function haskell(Prism) {
			Prism.languages.haskell = {
				comment: {
					pattern:
						/(^|[^-!#$%*+=?&@|~.:<>^\\\/])(?:--(?:(?=.)[^-!#$%*+=?&@|~.:<>^\\\/].*|$)|\{-[\s\S]*?-\})/m,
					lookbehind: true
				},
				char: {
					pattern:
						/'(?:[^\\']|\\(?:[abfnrtv\\"'&]|\^[A-Z@[\]^_]|ACK|BEL|BS|CAN|CR|DC1|DC2|DC3|DC4|DEL|DLE|EM|ENQ|EOT|ESC|ETB|ETX|FF|FS|GS|HT|LF|NAK|NUL|RS|SI|SO|SOH|SP|STX|SUB|SYN|US|VT|\d+|o[0-7]+|x[0-9a-fA-F]+))'/,
					alias: 'string'
				},
				string: {
					pattern: /"(?:[^\\"]|\\(?:\S|\s+\\))*"/,
					greedy: true
				},
				keyword:
					/\b(?:case|class|data|deriving|do|else|if|in|infixl|infixr|instance|let|module|newtype|of|primitive|then|type|where)\b/,
				'import-statement': {
					pattern:
						/(^[\t ]*)import\s+(?:qualified\s+)?(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*(?:\s+as\s+(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*)?(?:\s+hiding\b)?/m,
					lookbehind: true,
					inside: {
						keyword: /\b(?:as|hiding|import|qualified)\b/,
						punctuation: /\./
					}
				},
				builtin:
					/\b(?:abs|acos|acosh|all|and|any|appendFile|approxRational|asTypeOf|asin|asinh|atan|atan2|atanh|basicIORun|break|catch|ceiling|chr|compare|concat|concatMap|const|cos|cosh|curry|cycle|decodeFloat|denominator|digitToInt|div|divMod|drop|dropWhile|either|elem|encodeFloat|enumFrom|enumFromThen|enumFromThenTo|enumFromTo|error|even|exp|exponent|fail|filter|flip|floatDigits|floatRadix|floatRange|floor|fmap|foldl|foldl1|foldr|foldr1|fromDouble|fromEnum|fromInt|fromInteger|fromIntegral|fromRational|fst|gcd|getChar|getContents|getLine|group|head|id|inRange|index|init|intToDigit|interact|ioError|isAlpha|isAlphaNum|isAscii|isControl|isDenormalized|isDigit|isHexDigit|isIEEE|isInfinite|isLower|isNaN|isNegativeZero|isOctDigit|isPrint|isSpace|isUpper|iterate|last|lcm|length|lex|lexDigits|lexLitChar|lines|log|logBase|lookup|map|mapM|mapM_|max|maxBound|maximum|maybe|min|minBound|minimum|mod|negate|not|notElem|null|numerator|odd|or|ord|otherwise|pack|pi|pred|primExitWith|print|product|properFraction|putChar|putStr|putStrLn|quot|quotRem|range|rangeSize|read|readDec|readFile|readFloat|readHex|readIO|readInt|readList|readLitChar|readLn|readOct|readParen|readSigned|reads|readsPrec|realToFrac|recip|rem|repeat|replicate|return|reverse|round|scaleFloat|scanl|scanl1|scanr|scanr1|seq|sequence|sequence_|show|showChar|showInt|showList|showLitChar|showParen|showSigned|showString|shows|showsPrec|significand|signum|sin|sinh|snd|sort|span|splitAt|sqrt|subtract|succ|sum|tail|take|takeWhile|tan|tanh|threadToIOResult|toEnum|toInt|toInteger|toLower|toRational|toUpper|truncate|uncurry|undefined|unlines|until|unwords|unzip|unzip3|userError|words|writeFile|zip|zip3|zipWith|zipWith3)\b/,
				number: /\b(?:\d+(?:\.\d+)?(?:e[+-]?\d+)?|0o[0-7]+|0x[0-9a-f]+)\b/i,
				operator: [
					{
						pattern: /`(?:[A-Z][\w']*\.)*[_a-z][\w']*`/,
						greedy: true
					},
					{
						pattern: /(\s)\.(?=\s)/,
						lookbehind: true
					},
					/[-!#$%*+=?&@|~:<>^\\\/][-!#$%*+=?&@|~.:<>^\\\/]*|\.[-!#$%*+=?&@|~.:<>^\\\/]+/
				],
				hvariable: {
					pattern: /\b(?:[A-Z][\w']*\.)*[_a-z][\w']*/,
					inside: {
						punctuation: /\./
					}
				},
				constant: {
					pattern: /\b(?:[A-Z][\w']*\.)*[A-Z][\w']*/,
					inside: {
						punctuation: /\./
					}
				},
				punctuation: /[{}[\];(),.:]/
			};
			Prism.languages.hs = Prism.languages.haskell;
		}
	}
});

// node_modules/refractor/lang/haxe.js
var require_haxe = __commonJS({
	'node_modules/refractor/lang/haxe.js'(exports, module2) {
		'use strict';
		module2.exports = haxe;
		haxe.displayName = 'haxe';
		haxe.aliases = [];
		function haxe(Prism) {
			Prism.languages.haxe = Prism.languages.extend('clike', {
				string: {
					pattern: /"(?:[^"\\]|\\[\s\S])*"/,
					greedy: true
				},
				'class-name': [
					{
						pattern:
							/(\b(?:abstract|class|enum|extends|implements|interface|new|typedef)\s+)[A-Z_]\w*/,
						lookbehind: true
					},
					/\b[A-Z]\w*/
				],
				keyword:
					/\bthis\b|\b(?:abstract|as|break|case|cast|catch|class|continue|default|do|dynamic|else|enum|extends|extern|final|for|from|function|if|implements|import|in|inline|interface|macro|new|null|operator|overload|override|package|private|public|return|static|super|switch|throw|to|try|typedef|untyped|using|var|while)(?!\.)\b/,
				function: {
					pattern: /\b[a-z_]\w*(?=\s*(?:<[^<>]*>\s*)?\()/i,
					greedy: true
				},
				operator: /\.{3}|\+\+|--|&&|\|\||->|=>|(?:<<?|>{1,3}|[-+*/%!=&|^])=?|[?:~]/
			});
			Prism.languages.insertBefore('haxe', 'string', {
				'string-interpolation': {
					pattern: /'(?:[^'\\]|\\[\s\S])*'/,
					greedy: true,
					inside: {
						interpolation: {
							pattern: /(^|[^\\])\$(?:\w+|\{[^{}]+\})/,
							lookbehind: true,
							inside: {
								'interpolation-punctuation': {
									pattern: /^\$\{?|\}$/,
									alias: 'punctuation'
								},
								expression: {
									pattern: /[\s\S]+/,
									inside: Prism.languages.haxe
								}
							}
						},
						string: /[\s\S]+/
					}
				}
			});
			Prism.languages.insertBefore('haxe', 'class-name', {
				regex: {
					pattern: /~\/(?:[^\/\\\r\n]|\\.)+\/[a-z]*/,
					greedy: true,
					inside: {
						'regex-flags': /\b[a-z]+$/,
						'regex-source': {
							pattern: /^(~\/)[\s\S]+(?=\/$)/,
							lookbehind: true,
							alias: 'language-regex',
							inside: Prism.languages.regex
						},
						'regex-delimiter': /^~\/|\/$/
					}
				}
			});
			Prism.languages.insertBefore('haxe', 'keyword', {
				preprocessor: {
					pattern: /#(?:else|elseif|end|if)\b.*/,
					alias: 'property'
				},
				metadata: {
					pattern: /@:?[\w.]+/,
					alias: 'symbol'
				},
				reification: {
					pattern: /\$(?:\w+|(?=\{))/,
					alias: 'important'
				}
			});
		}
	}
});

// node_modules/refractor/lang/hcl.js
var require_hcl = __commonJS({
	'node_modules/refractor/lang/hcl.js'(exports, module2) {
		'use strict';
		module2.exports = hcl;
		hcl.displayName = 'hcl';
		hcl.aliases = [];
		function hcl(Prism) {
			Prism.languages.hcl = {
				comment: /(?:\/\/|#).*|\/\*[\s\S]*?(?:\*\/|$)/,
				heredoc: {
					pattern: /<<-?(\w+\b)[\s\S]*?^[ \t]*\1/m,
					greedy: true,
					alias: 'string'
				},
				keyword: [
					{
						pattern: /(?:data|resource)\s+(?:"(?:\\[\s\S]|[^\\"])*")(?=\s+"[\w-]+"\s+\{)/i,
						inside: {
							type: {
								pattern: /(resource|data|\s+)(?:"(?:\\[\s\S]|[^\\"])*")/i,
								lookbehind: true,
								alias: 'variable'
							}
						}
					},
					{
						pattern:
							/(?:backend|module|output|provider|provisioner|variable)\s+(?:[\w-]+|"(?:\\[\s\S]|[^\\"])*")\s+(?=\{)/i,
						inside: {
							type: {
								pattern:
									/(backend|module|output|provider|provisioner|variable)\s+(?:[\w-]+|"(?:\\[\s\S]|[^\\"])*")\s+/i,
								lookbehind: true,
								alias: 'variable'
							}
						}
					},
					/[\w-]+(?=\s+\{)/
				],
				property: [/[-\w\.]+(?=\s*=(?!=))/, /"(?:\\[\s\S]|[^\\"])+"(?=\s*[:=])/],
				string: {
					pattern:
						/"(?:[^\\$"]|\\[\s\S]|\$(?:(?=")|\$+(?!\$)|[^"${])|\$\{(?:[^{}"]|"(?:[^\\"]|\\[\s\S])*")*\})*"/,
					greedy: true,
					inside: {
						interpolation: {
							pattern: /(^|[^$])\$\{(?:[^{}"]|"(?:[^\\"]|\\[\s\S])*")*\}/,
							lookbehind: true,
							inside: {
								type: {
									pattern: /(\b(?:count|data|local|module|path|self|terraform|var)\b\.)[\w\*]+/i,
									lookbehind: true,
									alias: 'variable'
								},
								keyword: /\b(?:count|data|local|module|path|self|terraform|var)\b/i,
								function: /\w+(?=\()/,
								string: {
									pattern: /"(?:\\[\s\S]|[^\\"])*"/,
									greedy: true
								},
								number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
								punctuation: /[!\$#%&'()*+,.\/;<=>@\[\\\]^`{|}~?:]/
							}
						}
					}
				},
				number: /\b0x[\da-f]+\b|\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
				boolean: /\b(?:false|true)\b/i,
				punctuation: /[=\[\]{}]/
			};
		}
	}
});

// node_modules/refractor/lang/hlsl.js
var require_hlsl = __commonJS({
	'node_modules/refractor/lang/hlsl.js'(exports, module2) {
		'use strict';
		var refractorC = require_c();
		module2.exports = hlsl;
		hlsl.displayName = 'hlsl';
		hlsl.aliases = [];
		function hlsl(Prism) {
			Prism.register(refractorC);
			Prism.languages.hlsl = Prism.languages.extend('c', {
				'class-name': [
					Prism.languages.c['class-name'],
					/\b(?:AppendStructuredBuffer|BlendState|Buffer|ByteAddressBuffer|CompileShader|ComputeShader|ConsumeStructuredBuffer|DepthStencilState|DepthStencilView|DomainShader|GeometryShader|Hullshader|InputPatch|LineStream|OutputPatch|PixelShader|PointStream|RWBuffer|RWByteAddressBuffer|RWStructuredBuffer|RWTexture(?:1D|1DArray|2D|2DArray|3D)|RasterizerState|RenderTargetView|SamplerComparisonState|SamplerState|StructuredBuffer|Texture(?:1D|1DArray|2D|2DArray|2DMS|2DMSArray|3D|Cube|CubeArray)|TriangleStream|VertexShader)\b/
				],
				keyword: [
					/\b(?:asm|asm_fragment|auto|break|case|catch|cbuffer|centroid|char|class|column_major|compile|compile_fragment|const|const_cast|continue|default|delete|discard|do|dynamic_cast|else|enum|explicit|export|extern|for|friend|fxgroup|goto|groupshared|if|in|inline|inout|interface|line|lineadj|linear|long|matrix|mutable|namespace|new|nointerpolation|noperspective|operator|out|packoffset|pass|pixelfragment|point|precise|private|protected|public|register|reinterpret_cast|return|row_major|sample|sampler|shared|short|signed|sizeof|snorm|stateblock|stateblock_state|static|static_cast|string|struct|switch|tbuffer|technique|technique10|technique11|template|texture|this|throw|triangle|triangleadj|try|typedef|typename|uniform|union|unorm|unsigned|using|vector|vertexfragment|virtual|void|volatile|while)\b/,
					/\b(?:bool|double|dword|float|half|int|min(?:10float|12int|16(?:float|int|uint))|uint)(?:[1-4](?:x[1-4])?)?\b/
				],
				number: /(?:(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+)?|\b0x[\da-fA-F]+)[fFhHlLuU]?\b/,
				boolean: /\b(?:false|true)\b/
			});
		}
	}
});

// node_modules/refractor/lang/hoon.js
var require_hoon = __commonJS({
	'node_modules/refractor/lang/hoon.js'(exports, module2) {
		'use strict';
		module2.exports = hoon;
		hoon.displayName = 'hoon';
		hoon.aliases = [];
		function hoon(Prism) {
			Prism.languages.hoon = {
				comment: {
					pattern: /::.*/,
					greedy: true
				},
				string: {
					pattern: /"[^"]*"|'[^']*'/,
					greedy: true
				},
				constant: /%(?:\.[ny]|[\w-]+)/,
				'class-name': /@(?:[a-z0-9-]*[a-z0-9])?|\*/i,
				function: /(?:\+[-+] {2})?(?:[a-z](?:[a-z0-9-]*[a-z0-9])?)/,
				keyword:
					/\.[\^\+\*=\?]|![><:\.=\?!]|=[>|:,\.\-\^<+;/~\*\?]|\?[>|:\.\-\^<\+&~=@!]|\|[\$_%:\.\-\^~\*=@\?]|\+[|\$\+\*]|:[_\-\^\+~\*]|%[_:\.\-\^\+~\*=]|\^[|:\.\-\+&~\*=\?]|\$[|_%:<>\-\^&~@=\?]|;[:<\+;\/~\*=]|~[>|\$_%<\+\/&=\?!]|--|==/
			};
		}
	}
});

// node_modules/refractor/lang/hpkp.js
var require_hpkp = __commonJS({
	'node_modules/refractor/lang/hpkp.js'(exports, module2) {
		'use strict';
		module2.exports = hpkp;
		hpkp.displayName = 'hpkp';
		hpkp.aliases = [];
		function hpkp(Prism) {
			Prism.languages.hpkp = {
				directive: {
					pattern:
						/\b(?:includeSubDomains|max-age|pin-sha256|preload|report-to|report-uri|strict)(?=[\s;=]|$)/i,
					alias: 'property'
				},
				operator: /=/,
				punctuation: /;/
			};
		}
	}
});

// node_modules/refractor/lang/hsts.js
var require_hsts = __commonJS({
	'node_modules/refractor/lang/hsts.js'(exports, module2) {
		'use strict';
		module2.exports = hsts;
		hsts.displayName = 'hsts';
		hsts.aliases = [];
		function hsts(Prism) {
			Prism.languages.hsts = {
				directive: {
					pattern: /\b(?:includeSubDomains|max-age|preload)(?=[\s;=]|$)/i,
					alias: 'property'
				},
				operator: /=/,
				punctuation: /;/
			};
		}
	}
});

// node_modules/refractor/lang/http.js
var require_http = __commonJS({
	'node_modules/refractor/lang/http.js'(exports, module2) {
		'use strict';
		module2.exports = http2;
		http2.displayName = 'http';
		http2.aliases = [];
		function http2(Prism) {
			(function (Prism2) {
				function headerValueOf(name) {
					return RegExp('(^(?:' + name + '):[ 	]*(?![ 	]))[^]+', 'i');
				}
				Prism2.languages.http = {
					'request-line': {
						pattern:
							/^(?:CONNECT|DELETE|GET|HEAD|OPTIONS|PATCH|POST|PRI|PUT|SEARCH|TRACE)\s(?:https?:\/\/|\/)\S*\sHTTP\/[\d.]+/m,
						inside: {
							method: {
								pattern: /^[A-Z]+\b/,
								alias: 'property'
							},
							'request-target': {
								pattern: /^(\s)(?:https?:\/\/|\/)\S*(?=\s)/,
								lookbehind: true,
								alias: 'url',
								inside: Prism2.languages.uri
							},
							'http-version': {
								pattern: /^(\s)HTTP\/[\d.]+/,
								lookbehind: true,
								alias: 'property'
							}
						}
					},
					'response-status': {
						pattern: /^HTTP\/[\d.]+ \d+ .+/m,
						inside: {
							'http-version': {
								pattern: /^HTTP\/[\d.]+/,
								alias: 'property'
							},
							'status-code': {
								pattern: /^(\s)\d+(?=\s)/,
								lookbehind: true,
								alias: 'number'
							},
							'reason-phrase': {
								pattern: /^(\s).+/,
								lookbehind: true,
								alias: 'string'
							}
						}
					},
					header: {
						pattern: /^[\w-]+:.+(?:(?:\r\n?|\n)[ \t].+)*/m,
						inside: {
							'header-value': [
								{
									pattern: headerValueOf(/Content-Security-Policy/.source),
									lookbehind: true,
									alias: ['csp', 'languages-csp'],
									inside: Prism2.languages.csp
								},
								{
									pattern: headerValueOf(/Public-Key-Pins(?:-Report-Only)?/.source),
									lookbehind: true,
									alias: ['hpkp', 'languages-hpkp'],
									inside: Prism2.languages.hpkp
								},
								{
									pattern: headerValueOf(/Strict-Transport-Security/.source),
									lookbehind: true,
									alias: ['hsts', 'languages-hsts'],
									inside: Prism2.languages.hsts
								},
								{
									pattern: headerValueOf(/[^:]+/.source),
									lookbehind: true
								}
							],
							'header-name': {
								pattern: /^[^:]+/,
								alias: 'keyword'
							},
							punctuation: /^:/
						}
					}
				};
				var langs = Prism2.languages;
				var httpLanguages = {
					'application/javascript': langs.javascript,
					'application/json': langs.json || langs.javascript,
					'application/xml': langs.xml,
					'text/xml': langs.xml,
					'text/html': langs.html,
					'text/css': langs.css,
					'text/plain': langs.plain
				};
				var suffixTypes = {
					'application/json': true,
					'application/xml': true
				};
				function getSuffixPattern(contentType2) {
					var suffix = contentType2.replace(/^[a-z]+\//, '');
					var suffixPattern = '\\w+/(?:[\\w.-]+\\+)+' + suffix + '(?![+\\w.-])';
					return '(?:' + contentType2 + '|' + suffixPattern + ')';
				}
				var options;
				for (var contentType in httpLanguages) {
					if (httpLanguages[contentType]) {
						options = options || {};
						var pattern = suffixTypes[contentType] ? getSuffixPattern(contentType) : contentType;
						options[contentType.replace(/\//g, '-')] = {
							pattern: RegExp(
								'(' +
									/content-type:\s*/.source +
									pattern +
									/(?:(?:\r\n?|\n)[\w-].*)*(?:\r(?:\n|(?!\n))|\n)/.source +
									')' +
									/[^ \t\w-][\s\S]*/.source,
								'i'
							),
							lookbehind: true,
							inside: httpLanguages[contentType]
						};
					}
				}
				if (options) {
					Prism2.languages.insertBefore('http', 'header', options);
				}
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/ichigojam.js
var require_ichigojam = __commonJS({
	'node_modules/refractor/lang/ichigojam.js'(exports, module2) {
		'use strict';
		module2.exports = ichigojam;
		ichigojam.displayName = 'ichigojam';
		ichigojam.aliases = [];
		function ichigojam(Prism) {
			Prism.languages.ichigojam = {
				comment: /(?:\B'|REM)(?:[^\n\r]*)/i,
				string: {
					pattern: /"(?:""|[!#$%&'()*,\/:;<=>?^\w +\-.])*"/,
					greedy: true
				},
				number: /\B#[0-9A-F]+|\B`[01]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i,
				keyword:
					/\b(?:BEEP|BPS|CASE|CLEAR|CLK|CLO|CLP|CLS|CLT|CLV|CONT|COPY|ELSE|END|FILE|FILES|FOR|GOSUB|GOTO|GSB|IF|INPUT|KBD|LED|LET|LIST|LOAD|LOCATE|LRUN|NEW|NEXT|OUT|PLAY|POKE|PRINT|PWM|REM|RENUM|RESET|RETURN|RIGHT|RTN|RUN|SAVE|SCROLL|SLEEP|SRND|STEP|STOP|SUB|TEMPO|THEN|TO|UART|VIDEO|WAIT)(?:\$|\b)/i,
				function:
					/\b(?:ABS|ANA|ASC|BIN|BTN|DEC|END|FREE|HELP|HEX|I2CR|I2CW|IN|INKEY|LEN|LINE|PEEK|RND|SCR|SOUND|STR|TICK|USR|VER|VPEEK|ZER)(?:\$|\b)/i,
				label: /(?:\B@\S+)/,
				operator: /<[=>]?|>=?|\|\||&&|[+\-*\/=|&^~!]|\b(?:AND|NOT|OR)\b/i,
				punctuation: /[\[,;:()\]]/
			};
		}
	}
});

// node_modules/refractor/lang/icon.js
var require_icon = __commonJS({
	'node_modules/refractor/lang/icon.js'(exports, module2) {
		'use strict';
		module2.exports = icon;
		icon.displayName = 'icon';
		icon.aliases = [];
		function icon(Prism) {
			Prism.languages.icon = {
				comment: /#.*/,
				string: {
					pattern: /(["'])(?:(?!\1)[^\\\r\n_]|\\.|_(?!\1)(?:\r\n|[\s\S]))*\1/,
					greedy: true
				},
				number: /\b(?:\d+r[a-z\d]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b|\.\d+\b/i,
				'builtin-keyword': {
					pattern:
						/&(?:allocated|ascii|clock|collections|cset|current|date|dateline|digits|dump|e|error(?:number|text|value)?|errout|fail|features|file|host|input|lcase|letters|level|line|main|null|output|phi|pi|pos|progname|random|regions|source|storage|subject|time|trace|ucase|version)\b/,
					alias: 'variable'
				},
				directive: {
					pattern: /\$\w+/,
					alias: 'builtin'
				},
				keyword:
					/\b(?:break|by|case|create|default|do|else|end|every|fail|global|if|initial|invocable|link|local|next|not|of|procedure|record|repeat|return|static|suspend|then|to|until|while)\b/,
				function: /\b(?!\d)\w+(?=\s*[({]|\s*!\s*\[)/,
				operator:
					/[+-]:(?!=)|(?:[\/?@^%&]|\+\+?|--?|==?=?|~==?=?|\*\*?|\|\|\|?|<(?:->?|<?=?)|>>?=?)(?::=)?|:(?:=:?)?|[!.\\|~]/,
				punctuation: /[\[\](){},;]/
			};
		}
	}
});

// node_modules/refractor/lang/icu-message-format.js
var require_icu_message_format = __commonJS({
	'node_modules/refractor/lang/icu-message-format.js'(exports, module2) {
		'use strict';
		module2.exports = icuMessageFormat;
		icuMessageFormat.displayName = 'icuMessageFormat';
		icuMessageFormat.aliases = [];
		function icuMessageFormat(Prism) {
			(function (Prism2) {
				function nested(source, level) {
					if (level <= 0) {
						return /[]/.source;
					} else {
						return source.replace(/<SELF>/g, function () {
							return nested(source, level - 1);
						});
					}
				}
				var stringPattern = /'[{}:=,](?:[^']|'')*'(?!')/;
				var escape2 = {
					pattern: /''/,
					greedy: true,
					alias: 'operator'
				};
				var string3 = {
					pattern: stringPattern,
					greedy: true,
					inside: {
						escape: escape2
					}
				};
				var argumentSource = nested(
					/\{(?:[^{}']|'(?![{},'])|''|<STR>|<SELF>)*\}/.source.replace(/<STR>/g, function () {
						return stringPattern.source;
					}),
					8
				);
				var nestedMessage = {
					pattern: RegExp(argumentSource),
					inside: {
						message: {
							pattern: /^(\{)[\s\S]+(?=\}$)/,
							lookbehind: true,
							inside: null
						},
						'message-delimiter': {
							pattern: /./,
							alias: 'punctuation'
						}
					}
				};
				Prism2.languages['icu-message-format'] = {
					argument: {
						pattern: RegExp(argumentSource),
						greedy: true,
						inside: {
							content: {
								pattern: /^(\{)[\s\S]+(?=\}$)/,
								lookbehind: true,
								inside: {
									'argument-name': {
										pattern: /^(\s*)[^{}:=,\s]+/,
										lookbehind: true
									},
									'choice-style': {
										pattern: /^(\s*,\s*choice\s*,\s*)\S(?:[\s\S]*\S)?/,
										lookbehind: true,
										inside: {
											punctuation: /\|/,
											range: {
												pattern: /^(\s*)[+-]?(?:\d+(?:\.\d*)?|\u221e)\s*[<#\u2264]/,
												lookbehind: true,
												inside: {
													operator: /[<#\u2264]/,
													number: /\S+/
												}
											},
											rest: null
										}
									},
									'plural-style': {
										pattern: /^(\s*,\s*(?:plural|selectordinal)\s*,\s*)\S(?:[\s\S]*\S)?/,
										lookbehind: true,
										inside: {
											offset: /^offset:\s*\d+/,
											'nested-message': nestedMessage,
											selector: {
												pattern: /=\d+|[^{}:=,\s]+/,
												inside: {
													keyword: /^(?:few|many|one|other|two|zero)$/
												}
											}
										}
									},
									'select-style': {
										pattern: /^(\s*,\s*select\s*,\s*)\S(?:[\s\S]*\S)?/,
										lookbehind: true,
										inside: {
											'nested-message': nestedMessage,
											selector: {
												pattern: /[^{}:=,\s]+/,
												inside: {
													keyword: /^other$/
												}
											}
										}
									},
									keyword: /\b(?:choice|plural|select|selectordinal)\b/,
									'arg-type': {
										pattern: /\b(?:date|duration|number|ordinal|spellout|time)\b/,
										alias: 'keyword'
									},
									'arg-skeleton': {
										pattern: /(,\s*)::[^{}:=,\s]+/,
										lookbehind: true
									},
									'arg-style': {
										pattern: /(,\s*)(?:currency|full|integer|long|medium|percent|short)(?=\s*$)/,
										lookbehind: true
									},
									'arg-style-text': {
										pattern: RegExp(
											/(^\s*,\s*(?=\S))/.source +
												nested(/(?:[^{}']|'[^']*'|\{(?:<SELF>)?\})+/.source, 8) +
												'$'
										),
										lookbehind: true,
										alias: 'string'
									},
									punctuation: /,/
								}
							},
							'argument-delimiter': {
								pattern: /./,
								alias: 'operator'
							}
						}
					},
					escape: escape2,
					string: string3
				};
				nestedMessage.inside.message.inside = Prism2.languages['icu-message-format'];
				Prism2.languages['icu-message-format'].argument.inside.content.inside[
					'choice-style'
				].inside.rest = Prism2.languages['icu-message-format'];
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/idris.js
var require_idris = __commonJS({
	'node_modules/refractor/lang/idris.js'(exports, module2) {
		'use strict';
		var refractorHaskell = require_haskell();
		module2.exports = idris;
		idris.displayName = 'idris';
		idris.aliases = ['idr'];
		function idris(Prism) {
			Prism.register(refractorHaskell);
			Prism.languages.idris = Prism.languages.extend('haskell', {
				comment: {
					pattern: /(?:(?:--|\|\|\|).*$|\{-[\s\S]*?-\})/m
				},
				keyword:
					/\b(?:Type|case|class|codata|constructor|corecord|data|do|dsl|else|export|if|implementation|implicit|import|impossible|in|infix|infixl|infixr|instance|interface|let|module|mutual|namespace|of|parameters|partial|postulate|private|proof|public|quoteGoal|record|rewrite|syntax|then|total|using|where|with)\b/,
				builtin: void 0
			});
			Prism.languages.insertBefore('idris', 'keyword', {
				'import-statement': {
					pattern: /(^\s*import\s+)(?:[A-Z][\w']*)(?:\.[A-Z][\w']*)*/m,
					lookbehind: true,
					inside: {
						punctuation: /\./
					}
				}
			});
			Prism.languages.idr = Prism.languages.idris;
		}
	}
});

// node_modules/refractor/lang/iecst.js
var require_iecst = __commonJS({
	'node_modules/refractor/lang/iecst.js'(exports, module2) {
		'use strict';
		module2.exports = iecst;
		iecst.displayName = 'iecst';
		iecst.aliases = [];
		function iecst(Prism) {
			Prism.languages.iecst = {
				comment: [
					{
						pattern:
							/(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\(\*[\s\S]*?(?:\*\)|$)|\{[\s\S]*?(?:\}|$))/,
						lookbehind: true,
						greedy: true
					},
					{
						pattern: /(^|[^\\:])\/\/.*/,
						lookbehind: true,
						greedy: true
					}
				],
				string: {
					pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
					greedy: true
				},
				keyword: [
					/\b(?:END_)?(?:PROGRAM|CONFIGURATION|INTERFACE|FUNCTION_BLOCK|FUNCTION|ACTION|TRANSITION|TYPE|STRUCT|(?:INITIAL_)?STEP|NAMESPACE|LIBRARY|CHANNEL|FOLDER|RESOURCE|VAR_(?:ACCESS|CONFIG|EXTERNAL|GLOBAL|INPUT|IN_OUT|OUTPUT|TEMP)|VAR|METHOD|PROPERTY)\b/i,
					/\b(?:AT|BY|(?:END_)?(?:CASE|FOR|IF|REPEAT|WHILE)|CONSTANT|CONTINUE|DO|ELSE|ELSIF|EXIT|EXTENDS|FROM|GET|GOTO|IMPLEMENTS|JMP|NON_RETAIN|OF|PRIVATE|PROTECTED|PUBLIC|RETAIN|RETURN|SET|TASK|THEN|TO|UNTIL|USING|WITH|__CATCH|__ENDTRY|__FINALLY|__TRY)\b/
				],
				'class-name':
					/\b(?:ANY|ARRAY|BOOL|BYTE|U?(?:D|L|S)?INT|(?:D|L)?WORD|DATE(?:_AND_TIME)?|DT|L?REAL|POINTER|STRING|TIME(?:_OF_DAY)?|TOD)\b/,
				address: {
					pattern: /%[IQM][XBWDL][\d.]*|%[IQ][\d.]*/,
					alias: 'symbol'
				},
				number:
					/\b(?:16#[\da-f]+|2#[01_]+|0x[\da-f]+)\b|\b(?:D|DT|T|TOD)#[\d_shmd:]*|\b[A-Z]*#[\d.,_]*|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
				boolean: /\b(?:FALSE|NULL|TRUE)\b/,
				operator:
					/S?R?:?=>?|&&?|\*\*?|<[=>]?|>=?|[-:^/+#]|\b(?:AND|EQ|EXPT|GE|GT|LE|LT|MOD|NE|NOT|OR|XOR)\b/,
				function: /\b[a-z_]\w*(?=\s*\()/i,
				punctuation: /[()[\].,;]/
			};
		}
	}
});

// node_modules/refractor/lang/ignore.js
var require_ignore = __commonJS({
	'node_modules/refractor/lang/ignore.js'(exports, module2) {
		'use strict';
		module2.exports = ignore2;
		ignore2.displayName = 'ignore';
		ignore2.aliases = ['gitignore', 'hgignore', 'npmignore'];
		function ignore2(Prism) {
			(function (Prism2) {
				Prism2.languages.ignore = {
					comment: /^#.*/m,
					entry: {
						pattern: /\S(?:.*(?:(?:\\ )|\S))?/,
						alias: 'string',
						inside: {
							operator: /^!|\*\*?|\?/,
							regex: {
								pattern: /(^|[^\\])\[[^\[\]]*\]/,
								lookbehind: true
							},
							punctuation: /\//
						}
					}
				};
				Prism2.languages.gitignore = Prism2.languages.ignore;
				Prism2.languages.hgignore = Prism2.languages.ignore;
				Prism2.languages.npmignore = Prism2.languages.ignore;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/inform7.js
var require_inform7 = __commonJS({
	'node_modules/refractor/lang/inform7.js'(exports, module2) {
		'use strict';
		module2.exports = inform7;
		inform7.displayName = 'inform7';
		inform7.aliases = [];
		function inform7(Prism) {
			Prism.languages.inform7 = {
				string: {
					pattern: /"[^"]*"/,
					inside: {
						substitution: {
							pattern: /\[[^\[\]]+\]/,
							inside: {
								delimiter: {
									pattern: /\[|\]/,
									alias: 'punctuation'
								}
							}
						}
					}
				},
				comment: {
					pattern: /\[[^\[\]]+\]/,
					greedy: true
				},
				title: {
					pattern: /^[ \t]*(?:book|chapter|part(?! of)|section|table|volume)\b.+/im,
					alias: 'important'
				},
				number: {
					pattern:
						/(^|[^-])(?:\b\d+(?:\.\d+)?(?:\^\d+)?(?:(?!\d)\w+)?|\b(?:eight|eleven|five|four|nine|one|seven|six|ten|three|twelve|two))\b(?!-)/i,
					lookbehind: true
				},
				verb: {
					pattern:
						/(^|[^-])\b(?:answering|applying to|are|asking|attacking|be(?:ing)?|burning|buying|called|carries|carry(?! out)|carrying|climbing|closing|conceal(?:ing|s)?|consulting|contain(?:ing|s)?|cutting|drinking|dropping|eating|enclos(?:es?|ing)|entering|examining|exiting|getting|giving|going|ha(?:s|ve|ving)|hold(?:ing|s)?|impl(?:ies|y)|incorporat(?:es?|ing)|inserting|is|jumping|kissing|listening|locking|looking|mean(?:ing|s)?|opening|provid(?:es?|ing)|pulling|pushing|putting|relat(?:es?|ing)|removing|searching|see(?:ing|s)?|setting|showing|singing|sleeping|smelling|squeezing|support(?:ing|s)?|swearing|switching|taking|tasting|telling|thinking|throwing|touching|turning|tying|unlock(?:ing|s)?|var(?:ies|y|ying)|waiting|waking|waving|wear(?:ing|s)?)\b(?!-)/i,
					lookbehind: true,
					alias: 'operator'
				},
				keyword: {
					pattern:
						/(^|[^-])\b(?:after|before|carry out|check|continue the action|definition(?= *:)|do nothing|else|end (?:if|the story|unless)|every turn|if|include|instead(?: of)?|let|move|no|now|otherwise|repeat|report|resume the story|rule for|running through|say(?:ing)?|stop the action|test|try(?:ing)?|understand|unless|use|when|while|yes)\b(?!-)/i,
					lookbehind: true
				},
				property: {
					pattern:
						/(^|[^-])\b(?:adjacent(?! to)|carried|closed|concealed|contained|dark|described|edible|empty|enclosed|enterable|even|female|fixed in place|full|handled|held|improper-named|incorporated|inedible|invisible|lighted|lit|lock(?:able|ed)|male|marked for listing|mentioned|negative|neuter|non-(?:empty|full|recurring)|odd|opaque|open(?:able)?|plural-named|portable|positive|privately-named|proper-named|provided|publically-named|pushable between rooms|recurring|related|rubbing|scenery|seen|singular-named|supported|swinging|switch(?:able|ed(?: off| on)?)|touch(?:able|ed)|transparent|unconcealed|undescribed|unlit|unlocked|unmarked for listing|unmentioned|unopenable|untouchable|unvisited|variable|visible|visited|wearable|worn)\b(?!-)/i,
					lookbehind: true,
					alias: 'symbol'
				},
				position: {
					pattern:
						/(^|[^-])\b(?:above|adjacent to|back side of|below|between|down|east|everywhere|front side|here|in|inside(?: from)?|north(?:east|west)?|nowhere|on(?: top of)?|other side|outside(?: from)?|parts? of|regionally in|south(?:east|west)?|through|up|west|within)\b(?!-)/i,
					lookbehind: true,
					alias: 'keyword'
				},
				type: {
					pattern:
						/(^|[^-])\b(?:actions?|activit(?:ies|y)|actors?|animals?|backdrops?|containers?|devices?|directions?|doors?|holders?|kinds?|lists?|m[ae]n|nobody|nothing|nouns?|numbers?|objects?|people|persons?|player(?:'s holdall)?|regions?|relations?|rooms?|rule(?:book)?s?|scenes?|someone|something|supporters?|tables?|texts?|things?|time|vehicles?|wom[ae]n)\b(?!-)/i,
					lookbehind: true,
					alias: 'variable'
				},
				punctuation: /[.,:;(){}]/
			};
			Prism.languages.inform7['string'].inside['substitution'].inside.rest =
				Prism.languages.inform7;
			Prism.languages.inform7['string'].inside['substitution'].inside.rest.text = {
				pattern: /\S(?:\s*\S)*/,
				alias: 'comment'
			};
		}
	}
});

// node_modules/refractor/lang/ini.js
var require_ini = __commonJS({
	'node_modules/refractor/lang/ini.js'(exports, module2) {
		'use strict';
		module2.exports = ini;
		ini.displayName = 'ini';
		ini.aliases = [];
		function ini(Prism) {
			Prism.languages.ini = {
				comment: {
					pattern: /(^[ \f\t\v]*)[#;][^\n\r]*/m,
					lookbehind: true
				},
				section: {
					pattern: /(^[ \f\t\v]*)\[[^\n\r\]]*\]?/m,
					lookbehind: true,
					inside: {
						'section-name': {
							pattern: /(^\[[ \f\t\v]*)[^ \f\t\v\]]+(?:[ \f\t\v]+[^ \f\t\v\]]+)*/,
							lookbehind: true,
							alias: 'selector'
						},
						punctuation: /\[|\]/
					}
				},
				key: {
					pattern: /(^[ \f\t\v]*)[^ \f\n\r\t\v=]+(?:[ \f\t\v]+[^ \f\n\r\t\v=]+)*(?=[ \f\t\v]*=)/m,
					lookbehind: true,
					alias: 'attr-name'
				},
				value: {
					pattern: /(=[ \f\t\v]*)[^ \f\n\r\t\v]+(?:[ \f\t\v]+[^ \f\n\r\t\v]+)*/,
					lookbehind: true,
					alias: 'attr-value',
					inside: {
						'inner-value': {
							pattern: /^("|').+(?=\1$)/,
							lookbehind: true
						}
					}
				},
				punctuation: /=/
			};
		}
	}
});

// node_modules/refractor/lang/io.js
var require_io = __commonJS({
	'node_modules/refractor/lang/io.js'(exports, module2) {
		'use strict';
		module2.exports = io;
		io.displayName = 'io';
		io.aliases = [];
		function io(Prism) {
			Prism.languages.io = {
				comment: {
					pattern: /(^|[^\\])(?:\/\*[\s\S]*?(?:\*\/|$)|\/\/.*|#.*)/,
					lookbehind: true,
					greedy: true
				},
				'triple-quoted-string': {
					pattern: /"""(?:\\[\s\S]|(?!""")[^\\])*"""/,
					greedy: true,
					alias: 'string'
				},
				string: {
					pattern: /"(?:\\.|[^\\\r\n"])*"/,
					greedy: true
				},
				keyword:
					/\b(?:activate|activeCoroCount|asString|block|break|call|catch|clone|collectGarbage|compileString|continue|do|doFile|doMessage|doString|else|elseif|exit|for|foreach|forward|getEnvironmentVariable|getSlot|hasSlot|if|ifFalse|ifNil|ifNilEval|ifTrue|isActive|isNil|isResumable|list|message|method|parent|pass|pause|perform|performWithArgList|print|println|proto|raise|raiseResumable|removeSlot|resend|resume|schedulerSleepSeconds|self|sender|setSchedulerSleepSeconds|setSlot|shallowCopy|slotNames|super|system|then|thisBlock|thisContext|try|type|uniqueId|updateSlot|wait|while|write|yield)\b/,
				builtin:
					/\b(?:Array|AudioDevice|AudioMixer|BigNum|Block|Box|Buffer|CFunction|CGI|Color|Curses|DBM|DNSResolver|DOConnection|DOProxy|DOServer|Date|Directory|Duration|DynLib|Error|Exception|FFT|File|Fnmatch|Font|Future|GL|GLE|GLScissor|GLU|GLUCylinder|GLUQuadric|GLUSphere|GLUT|Host|Image|Importer|LinkList|List|Lobby|Locals|MD5|MP3Decoder|MP3Encoder|Map|Message|Movie|Notification|Number|Object|OpenGL|Point|Protos|Random|Regex|SGML|SGMLElement|SGMLParser|SQLite|Sequence|Server|ShowMessage|SleepyCat|SleepyCatCursor|Socket|SocketManager|Sound|Soup|Store|String|Tree|UDPSender|UPDReceiver|URL|User|Warning|WeakLink)\b/,
				boolean: /\b(?:false|nil|true)\b/,
				number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e-?\d+)?/i,
				operator:
					/[=!*/%+\-^&|]=|>>?=?|<<?=?|:?:?=|\+\+?|--?|\*\*?|\/\/?|%|\|\|?|&&?|\b(?:and|not|or|return)\b|@@?|\?\??|\.\./,
				punctuation: /[{}[\];(),.:]/
			};
		}
	}
});

// node_modules/refractor/lang/j.js
var require_j = __commonJS({
	'node_modules/refractor/lang/j.js'(exports, module2) {
		'use strict';
		module2.exports = j;
		j.displayName = 'j';
		j.aliases = [];
		function j(Prism) {
			Prism.languages.j = {
				comment: {
					pattern: /\bNB\..*/,
					greedy: true
				},
				string: {
					pattern: /'(?:''|[^'\r\n])*'/,
					greedy: true
				},
				keyword:
					/\b(?:(?:CR|LF|adverb|conjunction|def|define|dyad|monad|noun|verb)\b|(?:assert|break|case|catch[dt]?|continue|do|else|elseif|end|fcase|for|for_\w+|goto_\w+|if|label_\w+|return|select|throw|try|while|whilst)\.)/,
				verb: {
					pattern:
						/(?!\^:|;\.|[=!][.:])(?:\{(?:\.|::?)?|p(?:\.\.?|:)|[=!\]]|[<>+*\-%$|,#][.:]?|[?^]\.?|[;\[]:?|[~}"i][.:]|[ACeEIjLor]\.|(?:[_\/\\qsux]|_?\d):)/,
					alias: 'keyword'
				},
				number:
					/\b_?(?:(?!\d:)\d+(?:\.\d+)?(?:(?:ad|ar|[ejpx])_?\d+(?:\.\d+)?)*(?:b_?[\da-z]+(?:\.[\da-z]+)?)?|_\b(?!\.))/,
				adverb: {
					pattern: /[~}]|[\/\\]\.?|[bfM]\.|t[.:]/,
					alias: 'builtin'
				},
				operator: /[=a][.:]|_\./,
				conjunction: {
					pattern: /&(?:\.:?|:)?|[.:@][.:]?|[!D][.:]|[;dHT]\.|`:?|[\^LS]:|"/,
					alias: 'variable'
				},
				punctuation: /[()]/
			};
		}
	}
});

// node_modules/refractor/lang/java.js
var require_java = __commonJS({
	'node_modules/refractor/lang/java.js'(exports, module2) {
		'use strict';
		module2.exports = java;
		java.displayName = 'java';
		java.aliases = [];
		function java(Prism) {
			(function (Prism2) {
				var keywords =
					/\b(?:abstract|assert|boolean|break|byte|case|catch|char|class|const|continue|default|do|double|else|enum|exports|extends|final|finally|float|for|goto|if|implements|import|instanceof|int|interface|long|module|native|new|non-sealed|null|open|opens|package|permits|private|protected|provides|public|record|requires|return|sealed|short|static|strictfp|super|switch|synchronized|this|throw|throws|to|transient|transitive|try|uses|var|void|volatile|while|with|yield)\b/;
				var classNamePrefix = /(^|[^\w.])(?:[a-z]\w*\s*\.\s*)*(?:[A-Z]\w*\s*\.\s*)*/.source;
				var className = {
					pattern: RegExp(classNamePrefix + /[A-Z](?:[\d_A-Z]*[a-z]\w*)?\b/.source),
					lookbehind: true,
					inside: {
						namespace: {
							pattern: /^[a-z]\w*(?:\s*\.\s*[a-z]\w*)*(?:\s*\.)?/,
							inside: {
								punctuation: /\./
							}
						},
						punctuation: /\./
					}
				};
				Prism2.languages.java = Prism2.languages.extend('clike', {
					string: {
						pattern: /(^|[^\\])"(?:\\.|[^"\\\r\n])*"/,
						lookbehind: true,
						greedy: true
					},
					'class-name': [
						className,
						{
							pattern: RegExp(classNamePrefix + /[A-Z]\w*(?=\s+\w+\s*[;,=()])/.source),
							lookbehind: true,
							inside: className.inside
						}
					],
					keyword: keywords,
					function: [
						Prism2.languages.clike.function,
						{
							pattern: /(::\s*)[a-z_]\w*/,
							lookbehind: true
						}
					],
					number:
						/\b0b[01][01_]*L?\b|\b0x(?:\.[\da-f_p+-]+|[\da-f_]+(?:\.[\da-f_p+-]+)?)\b|(?:\b\d[\d_]*(?:\.[\d_]*)?|\B\.\d[\d_]*)(?:e[+-]?\d[\d_]*)?[dfl]?/i,
					operator: {
						pattern: /(^|[^.])(?:<<=?|>>>?=?|->|--|\+\+|&&|\|\||::|[?:~]|[-+*/%&|^!=<>]=?)/m,
						lookbehind: true
					}
				});
				Prism2.languages.insertBefore('java', 'string', {
					'triple-quoted-string': {
						pattern: /"""[ \t]*[\r\n](?:(?:"|"")?(?:\\.|[^"\\]))*"""/,
						greedy: true,
						alias: 'string'
					},
					char: {
						pattern: /'(?:\\.|[^'\\\r\n]){1,6}'/,
						greedy: true
					}
				});
				Prism2.languages.insertBefore('java', 'class-name', {
					annotation: {
						pattern: /(^|[^.])@\w+(?:\s*\.\s*\w+)*/,
						lookbehind: true,
						alias: 'punctuation'
					},
					generics: {
						pattern:
							/<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&)|<(?:[\w\s,.?]|&(?!&))*>)*>)*>)*>/,
						inside: {
							'class-name': className,
							keyword: keywords,
							punctuation: /[<>(),.:]/,
							operator: /[?&|]/
						}
					},
					namespace: {
						pattern: RegExp(
							/(\b(?:exports|import(?:\s+static)?|module|open|opens|package|provides|requires|to|transitive|uses|with)\s+)(?!<keyword>)[a-z]\w*(?:\.[a-z]\w*)*\.?/.source.replace(
								/<keyword>/g,
								function () {
									return keywords.source;
								}
							)
						),
						lookbehind: true,
						inside: {
							punctuation: /\./
						}
					}
				});
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/javadoclike.js
var require_javadoclike = __commonJS({
	'node_modules/refractor/lang/javadoclike.js'(exports, module2) {
		'use strict';
		module2.exports = javadoclike;
		javadoclike.displayName = 'javadoclike';
		javadoclike.aliases = [];
		function javadoclike(Prism) {
			(function (Prism2) {
				var javaDocLike = (Prism2.languages.javadoclike = {
					parameter: {
						pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*@(?:arg|arguments|param)\s+)\w+/m,
						lookbehind: true
					},
					keyword: {
						pattern: /(^[\t ]*(?:\/{3}|\*|\/\*\*)\s*|\{)@[a-z][a-zA-Z-]+\b/m,
						lookbehind: true
					},
					punctuation: /[{}]/
				});
				function docCommentSupport(lang, callback) {
					var tokenName = 'doc-comment';
					var grammar = Prism2.languages[lang];
					if (!grammar) {
						return;
					}
					var token = grammar[tokenName];
					if (!token) {
						var definition3 = {};
						definition3[tokenName] = {
							pattern: /(^|[^\\])\/\*\*[^/][\s\S]*?(?:\*\/|$)/,
							lookbehind: true,
							alias: 'comment'
						};
						grammar = Prism2.languages.insertBefore(lang, 'comment', definition3);
						token = grammar[tokenName];
					}
					if (token instanceof RegExp) {
						token = grammar[tokenName] = {
							pattern: token
						};
					}
					if (Array.isArray(token)) {
						for (var i2 = 0, l = token.length; i2 < l; i2++) {
							if (token[i2] instanceof RegExp) {
								token[i2] = {
									pattern: token[i2]
								};
							}
							callback(token[i2]);
						}
					} else {
						callback(token);
					}
				}
				function addSupport(languages, docLanguage) {
					if (typeof languages === 'string') {
						languages = [languages];
					}
					languages.forEach(function (lang) {
						docCommentSupport(lang, function (pattern) {
							if (!pattern.inside) {
								pattern.inside = {};
							}
							pattern.inside.rest = docLanguage;
						});
					});
				}
				Object.defineProperty(javaDocLike, 'addSupport', {
					value: addSupport
				});
				javaDocLike.addSupport(['java', 'javascript', 'php'], javaDocLike);
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/javadoc.js
var require_javadoc = __commonJS({
	'node_modules/refractor/lang/javadoc.js'(exports, module2) {
		'use strict';
		var refractorJava = require_java();
		var refractorJavadoclike = require_javadoclike();
		module2.exports = javadoc;
		javadoc.displayName = 'javadoc';
		javadoc.aliases = [];
		function javadoc(Prism) {
			Prism.register(refractorJava);
			Prism.register(refractorJavadoclike);
			(function (Prism2) {
				var codeLinePattern = /(^(?:[\t ]*(?:\*\s*)*))[^*\s].*$/m;
				var memberReference = /#\s*\w+(?:\s*\([^()]*\))?/.source;
				var reference = /(?:\b[a-zA-Z]\w+\s*\.\s*)*\b[A-Z]\w*(?:\s*<mem>)?|<mem>/.source.replace(
					/<mem>/g,
					function () {
						return memberReference;
					}
				);
				Prism2.languages.javadoc = Prism2.languages.extend('javadoclike', {});
				Prism2.languages.insertBefore('javadoc', 'keyword', {
					reference: {
						pattern: RegExp(
							/(@(?:exception|link|linkplain|see|throws|value)\s+(?:\*\s*)?)/.source +
								'(?:' +
								reference +
								')'
						),
						lookbehind: true,
						inside: {
							function: {
								pattern: /(#\s*)\w+(?=\s*\()/,
								lookbehind: true
							},
							field: {
								pattern: /(#\s*)\w+/,
								lookbehind: true
							},
							namespace: {
								pattern: /\b(?:[a-z]\w*\s*\.\s*)+/,
								inside: {
									punctuation: /\./
								}
							},
							'class-name': /\b[A-Z]\w*/,
							keyword: Prism2.languages.java.keyword,
							punctuation: /[#()[\],.]/
						}
					},
					'class-name': {
						pattern: /(@param\s+)<[A-Z]\w*>/,
						lookbehind: true,
						inside: {
							punctuation: /[.<>]/
						}
					},
					'code-section': [
						{
							pattern:
								/(\{@code\s+(?!\s))(?:[^\s{}]|\s+(?![\s}])|\{(?:[^{}]|\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})*\})*\})+(?=\s*\})/,
							lookbehind: true,
							inside: {
								code: {
									pattern: codeLinePattern,
									lookbehind: true,
									inside: Prism2.languages.java,
									alias: 'language-java'
								}
							}
						},
						{
							pattern: /(<(code|pre|tt)>(?!<code>)\s*)\S(?:\S|\s+\S)*?(?=\s*<\/\2>)/,
							lookbehind: true,
							inside: {
								line: {
									pattern: codeLinePattern,
									lookbehind: true,
									inside: {
										tag: Prism2.languages.markup.tag,
										entity: Prism2.languages.markup.entity,
										code: {
											pattern: /.+/,
											inside: Prism2.languages.java,
											alias: 'language-java'
										}
									}
								}
							}
						}
					],
					tag: Prism2.languages.markup.tag,
					entity: Prism2.languages.markup.entity
				});
				Prism2.languages.javadoclike.addSupport('java', Prism2.languages.javadoc);
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/javastacktrace.js
var require_javastacktrace = __commonJS({
	'node_modules/refractor/lang/javastacktrace.js'(exports, module2) {
		'use strict';
		module2.exports = javastacktrace;
		javastacktrace.displayName = 'javastacktrace';
		javastacktrace.aliases = [];
		function javastacktrace(Prism) {
			Prism.languages.javastacktrace = {
				summary: {
					pattern:
						/^([\t ]*)(?:(?:Caused by:|Suppressed:|Exception in thread "[^"]*")[\t ]+)?[\w$.]+(?::.*)?$/m,
					lookbehind: true,
					inside: {
						keyword: {
							pattern: /^([\t ]*)(?:(?:Caused by|Suppressed)(?=:)|Exception in thread)/m,
							lookbehind: true
						},
						string: {
							pattern: /^(\s*)"[^"]*"/,
							lookbehind: true
						},
						exceptions: {
							pattern: /^(:?\s*)[\w$.]+(?=:|$)/,
							lookbehind: true,
							inside: {
								'class-name': /[\w$]+$/,
								namespace: /\b[a-z]\w*\b/,
								punctuation: /\./
							}
						},
						message: {
							pattern: /(:\s*)\S.*/,
							lookbehind: true,
							alias: 'string'
						},
						punctuation: /:/
					}
				},
				'stack-frame': {
					pattern: /^([\t ]*)at (?:[\w$./]|@[\w$.+-]*\/)+(?:<init>)?\([^()]*\)/m,
					lookbehind: true,
					inside: {
						keyword: {
							pattern: /^(\s*)at(?= )/,
							lookbehind: true
						},
						source: [
							{
								pattern: /(\()\w+\.\w+:\d+(?=\))/,
								lookbehind: true,
								inside: {
									file: /^\w+\.\w+/,
									punctuation: /:/,
									'line-number': {
										pattern: /\b\d+\b/,
										alias: 'number'
									}
								}
							},
							{
								pattern: /(\()[^()]*(?=\))/,
								lookbehind: true,
								inside: {
									keyword: /^(?:Native Method|Unknown Source)$/
								}
							}
						],
						'class-name': /[\w$]+(?=\.(?:<init>|[\w$]+)\()/,
						function: /(?:<init>|[\w$]+)(?=\()/,
						'class-loader': {
							pattern: /(\s)[a-z]\w*(?:\.[a-z]\w*)*(?=\/[\w@$.]*\/)/,
							lookbehind: true,
							alias: 'namespace',
							inside: {
								punctuation: /\./
							}
						},
						module: {
							pattern: /([\s/])[a-z]\w*(?:\.[a-z]\w*)*(?:@[\w$.+-]*)?(?=\/)/,
							lookbehind: true,
							inside: {
								version: {
									pattern: /(@)[\s\S]+/,
									lookbehind: true,
									alias: 'number'
								},
								punctuation: /[@.]/
							}
						},
						namespace: {
							pattern: /(?:\b[a-z]\w*\.)+/,
							inside: {
								punctuation: /\./
							}
						},
						punctuation: /[()/.]/
					}
				},
				more: {
					pattern: /^([\t ]*)\.{3} \d+ [a-z]+(?: [a-z]+)*/m,
					lookbehind: true,
					inside: {
						punctuation: /\.{3}/,
						number: /\d+/,
						keyword: /\b[a-z]+(?: [a-z]+)*\b/
					}
				}
			};
		}
	}
});

// node_modules/refractor/lang/jexl.js
var require_jexl = __commonJS({
	'node_modules/refractor/lang/jexl.js'(exports, module2) {
		'use strict';
		module2.exports = jexl;
		jexl.displayName = 'jexl';
		jexl.aliases = [];
		function jexl(Prism) {
			Prism.languages.jexl = {
				string: /(["'])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
				transform: {
					pattern:
						/(\|\s*)[a-zA-Z--_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$][\w--\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$]*/,
					alias: 'function',
					lookbehind: true
				},
				function:
					/[a-zA-Z--_\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$][\w--\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u00FF$]*\s*(?=\()/,
				number: /\b\d+(?:\.\d+)?\b|\B\.\d+\b/,
				operator: /[<>!]=?|-|\+|&&|==|\|\|?|\/\/?|[?:*^%]/,
				boolean: /\b(?:false|true)\b/,
				keyword: /\bin\b/,
				punctuation: /[{}[\](),.]/
			};
		}
	}
});

// node_modules/refractor/lang/jolie.js
var require_jolie = __commonJS({
	'node_modules/refractor/lang/jolie.js'(exports, module2) {
		'use strict';
		module2.exports = jolie;
		jolie.displayName = 'jolie';
		jolie.aliases = [];
		function jolie(Prism) {
			Prism.languages.jolie = Prism.languages.extend('clike', {
				string: {
					pattern: /(^|[^\\])"(?:\\[\s\S]|[^"\\])*"/,
					lookbehind: true,
					greedy: true
				},
				'class-name': {
					pattern: /((?:\b(?:as|courier|embed|in|inputPort|outputPort|service)\b|@)[ \t]*)\w+/,
					lookbehind: true
				},
				keyword:
					/\b(?:as|cH|comp|concurrent|constants|courier|cset|csets|default|define|else|embed|embedded|execution|exit|extender|for|foreach|forward|from|global|if|import|in|include|init|inputPort|install|instanceof|interface|is_defined|linkIn|linkOut|main|new|nullProcess|outputPort|over|private|provide|public|scope|sequential|service|single|spawn|synchronized|this|throw|throws|type|undef|until|while|with)\b/,
				function: /\b[a-z_]\w*(?=[ \t]*[@(])/i,
				number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?l?/i,
				operator: /-[-=>]?|\+[+=]?|<[<=]?|[>=*!]=?|&&|\|\||[?\/%^@|]/,
				punctuation: /[()[\]{},;.:]/,
				builtin:
					/\b(?:Byte|any|bool|char|double|enum|float|int|length|long|ranges|regex|string|undefined|void)\b/
			});
			Prism.languages.insertBefore('jolie', 'keyword', {
				aggregates: {
					pattern: /(\bAggregates\s*:\s*)(?:\w+(?:\s+with\s+\w+)?\s*,\s*)*\w+(?:\s+with\s+\w+)?/,
					lookbehind: true,
					inside: {
						keyword: /\bwith\b/,
						'class-name': /\w+/,
						punctuation: /,/
					}
				},
				redirects: {
					pattern: /(\bRedirects\s*:\s*)(?:\w+\s*=>\s*\w+\s*,\s*)*(?:\w+\s*=>\s*\w+)/,
					lookbehind: true,
					inside: {
						punctuation: /,/,
						'class-name': /\w+/,
						operator: /=>/
					}
				},
				property: {
					pattern:
						/\b(?:Aggregates|[Ii]nterfaces|Java|Javascript|Jolie|[Ll]ocation|OneWay|[Pp]rotocol|Redirects|RequestResponse)\b(?=[ \t]*:)/
				}
			});
		}
	}
});

// node_modules/refractor/lang/jq.js
var require_jq = __commonJS({
	'node_modules/refractor/lang/jq.js'(exports, module2) {
		'use strict';
		module2.exports = jq;
		jq.displayName = 'jq';
		jq.aliases = [];
		function jq(Prism) {
			(function (Prism2) {
				var interpolation = /\\\((?:[^()]|\([^()]*\))*\)/.source;
				var string3 = RegExp(
					/(^|[^\\])"(?:[^"\r\n\\]|\\[^\r\n(]|__)*"/.source.replace(/__/g, function () {
						return interpolation;
					})
				);
				var stringInterpolation = {
					interpolation: {
						pattern: RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + interpolation),
						lookbehind: true,
						inside: {
							content: {
								pattern: /^(\\\()[\s\S]+(?=\)$)/,
								lookbehind: true,
								inside: null
							},
							punctuation: /^\\\(|\)$/
						}
					}
				};
				var jq2 = (Prism2.languages.jq = {
					comment: /#.*/,
					property: {
						pattern: RegExp(string3.source + /(?=\s*:(?!:))/.source),
						lookbehind: true,
						greedy: true,
						inside: stringInterpolation
					},
					string: {
						pattern: string3,
						lookbehind: true,
						greedy: true,
						inside: stringInterpolation
					},
					function: {
						pattern: /(\bdef\s+)[a-z_]\w+/i,
						lookbehind: true
					},
					variable: /\B\$\w+/,
					'property-literal': {
						pattern: /\b[a-z_]\w*(?=\s*:(?!:))/i,
						alias: 'property'
					},
					keyword:
						/\b(?:as|break|catch|def|elif|else|end|foreach|if|import|include|label|module|modulemeta|null|reduce|then|try|while)\b/,
					boolean: /\b(?:false|true)\b/,
					number: /(?:\b\d+\.|\B\.)?\b\d+(?:[eE][+-]?\d+)?\b/,
					operator: [
						{
							pattern: /\|=?/,
							alias: 'pipe'
						},
						/\.\.|[!=<>]?=|\?\/\/|\/\/=?|[-+*/%]=?|[<>?]|\b(?:and|not|or)\b/
					],
					'c-style-function': {
						pattern: /\b[a-z_]\w*(?=\s*\()/i,
						alias: 'function'
					},
					punctuation: /::|[()\[\]{},:;]|\.(?=\s*[\[\w$])/,
					dot: {
						pattern: /\./,
						alias: 'important'
					}
				});
				stringInterpolation.interpolation.inside.content.inside = jq2;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/js-extras.js
var require_js_extras = __commonJS({
	'node_modules/refractor/lang/js-extras.js'(exports, module2) {
		'use strict';
		module2.exports = jsExtras;
		jsExtras.displayName = 'jsExtras';
		jsExtras.aliases = [];
		function jsExtras(Prism) {
			(function (Prism2) {
				Prism2.languages.insertBefore('javascript', 'function-variable', {
					'method-variable': {
						pattern: RegExp(
							'(\\.\\s*)' + Prism2.languages.javascript['function-variable'].pattern.source
						),
						lookbehind: true,
						alias: ['function-variable', 'method', 'function', 'property-access']
					}
				});
				Prism2.languages.insertBefore('javascript', 'function', {
					method: {
						pattern: RegExp('(\\.\\s*)' + Prism2.languages.javascript['function'].source),
						lookbehind: true,
						alias: ['function', 'property-access']
					}
				});
				Prism2.languages.insertBefore('javascript', 'constant', {
					'known-class-name': [
						{
							pattern:
								/\b(?:(?:Float(?:32|64)|(?:Int|Uint)(?:8|16|32)|Uint8Clamped)?Array|ArrayBuffer|BigInt|Boolean|DataView|Date|Error|Function|Intl|JSON|(?:Weak)?(?:Map|Set)|Math|Number|Object|Promise|Proxy|Reflect|RegExp|String|Symbol|WebAssembly)\b/,
							alias: 'class-name'
						},
						{
							pattern: /\b(?:[A-Z]\w*)Error\b/,
							alias: 'class-name'
						}
					]
				});
				function withId(source, flags) {
					return RegExp(
						source.replace(/<ID>/g, function () {
							return /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/.source;
						}),
						flags
					);
				}
				Prism2.languages.insertBefore('javascript', 'keyword', {
					imports: {
						pattern: withId(
							/(\bimport\b\s*)(?:<ID>(?:\s*,\s*(?:\*\s*as\s+<ID>|\{[^{}]*\}))?|\*\s*as\s+<ID>|\{[^{}]*\})(?=\s*\bfrom\b)/
								.source
						),
						lookbehind: true,
						inside: Prism2.languages.javascript
					},
					exports: {
						pattern: withId(
							/(\bexport\b\s*)(?:\*(?:\s*as\s+<ID>)?(?=\s*\bfrom\b)|\{[^{}]*\})/.source
						),
						lookbehind: true,
						inside: Prism2.languages.javascript
					}
				});
				Prism2.languages.javascript['keyword'].unshift(
					{
						pattern: /\b(?:as|default|export|from|import)\b/,
						alias: 'module'
					},
					{
						pattern:
							/\b(?:await|break|catch|continue|do|else|finally|for|if|return|switch|throw|try|while|yield)\b/,
						alias: 'control-flow'
					},
					{
						pattern: /\bnull\b/,
						alias: ['null', 'nil']
					},
					{
						pattern: /\bundefined\b/,
						alias: 'nil'
					}
				);
				Prism2.languages.insertBefore('javascript', 'operator', {
					spread: {
						pattern: /\.{3}/,
						alias: 'operator'
					},
					arrow: {
						pattern: /=>/,
						alias: 'operator'
					}
				});
				Prism2.languages.insertBefore('javascript', 'punctuation', {
					'property-access': {
						pattern: withId(/(\.\s*)#?<ID>/.source),
						lookbehind: true
					},
					'maybe-class-name': {
						pattern: /(^|[^$\w\xA0-\uFFFF])[A-Z][$\w\xA0-\uFFFF]+/,
						lookbehind: true
					},
					dom: {
						pattern:
							/\b(?:document|(?:local|session)Storage|location|navigator|performance|window)\b/,
						alias: 'variable'
					},
					console: {
						pattern: /\bconsole(?=\s*\.)/,
						alias: 'class-name'
					}
				});
				var maybeClassNameTokens = [
					'function',
					'function-variable',
					'method',
					'method-variable',
					'property-access'
				];
				for (var i2 = 0; i2 < maybeClassNameTokens.length; i2++) {
					var token = maybeClassNameTokens[i2];
					var value = Prism2.languages.javascript[token];
					if (Prism2.util.type(value) === 'RegExp') {
						value = Prism2.languages.javascript[token] = {
							pattern: value
						};
					}
					var inside = value.inside || {};
					value.inside = inside;
					inside['maybe-class-name'] = /^[A-Z][\s\S]*/;
				}
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/js-templates.js
var require_js_templates = __commonJS({
	'node_modules/refractor/lang/js-templates.js'(exports, module2) {
		'use strict';
		module2.exports = jsTemplates;
		jsTemplates.displayName = 'jsTemplates';
		jsTemplates.aliases = [];
		function jsTemplates(Prism) {
			(function (Prism2) {
				var templateString = Prism2.languages.javascript['template-string'];
				var templateLiteralPattern = templateString.pattern.source;
				var interpolationObject = templateString.inside['interpolation'];
				var interpolationPunctuationObject =
					interpolationObject.inside['interpolation-punctuation'];
				var interpolationPattern = interpolationObject.pattern.source;
				function createTemplate(language, tag) {
					if (!Prism2.languages[language]) {
						return void 0;
					}
					return {
						pattern: RegExp('((?:' + tag + ')\\s*)' + templateLiteralPattern),
						lookbehind: true,
						greedy: true,
						inside: {
							'template-punctuation': {
								pattern: /^`|`$/,
								alias: 'string'
							},
							'embedded-code': {
								pattern: /[\s\S]+/,
								alias: language
							}
						}
					};
				}
				Prism2.languages.javascript['template-string'] = [
					createTemplate(
						'css',
						/\b(?:styled(?:\([^)]*\))?(?:\s*\.\s*\w+(?:\([^)]*\))*)*|css(?:\s*\.\s*(?:global|resolve))?|createGlobalStyle|keyframes)/
							.source
					),
					createTemplate('html', /\bhtml|\.\s*(?:inner|outer)HTML\s*\+?=/.source),
					createTemplate('svg', /\bsvg/.source),
					createTemplate('markdown', /\b(?:markdown|md)/.source),
					createTemplate('graphql', /\b(?:gql|graphql(?:\s*\.\s*experimental)?)/.source),
					createTemplate('sql', /\bsql/.source),
					templateString
				].filter(Boolean);
				function getPlaceholder(counter, language) {
					return '___' + language.toUpperCase() + '_' + counter + '___';
				}
				function tokenizeWithHooks(code3, grammar, language) {
					var env = {
						code: code3,
						grammar,
						language
					};
					Prism2.hooks.run('before-tokenize', env);
					env.tokens = Prism2.tokenize(env.code, env.grammar);
					Prism2.hooks.run('after-tokenize', env);
					return env.tokens;
				}
				function tokenizeInterpolationExpression(expression) {
					var tempGrammar = {};
					tempGrammar['interpolation-punctuation'] = interpolationPunctuationObject;
					var tokens = Prism2.tokenize(expression, tempGrammar);
					if (tokens.length === 3) {
						var args = [1, 1];
						args.push.apply(
							args,
							tokenizeWithHooks(tokens[1], Prism2.languages.javascript, 'javascript')
						);
						tokens.splice.apply(tokens, args);
					}
					return new Prism2.Token('interpolation', tokens, interpolationObject.alias, expression);
				}
				function tokenizeEmbedded(code3, grammar, language) {
					var _tokens = Prism2.tokenize(code3, {
						interpolation: {
							pattern: RegExp(interpolationPattern),
							lookbehind: true
						}
					});
					var placeholderCounter = 0;
					var placeholderMap = {};
					var embeddedCode = _tokens
						.map(function (token) {
							if (typeof token === 'string') {
								return token;
							} else {
								var interpolationExpression = token.content;
								var placeholder;
								while (
									code3.indexOf((placeholder = getPlaceholder(placeholderCounter++, language))) !==
									-1
								) {}
								placeholderMap[placeholder] = interpolationExpression;
								return placeholder;
							}
						})
						.join('');
					var embeddedTokens = tokenizeWithHooks(embeddedCode, grammar, language);
					var placeholders = Object.keys(placeholderMap);
					placeholderCounter = 0;
					function walkTokens(tokens) {
						for (var i2 = 0; i2 < tokens.length; i2++) {
							if (placeholderCounter >= placeholders.length) {
								return;
							}
							var token = tokens[i2];
							if (typeof token === 'string' || typeof token.content === 'string') {
								var placeholder = placeholders[placeholderCounter];
								var s4 = typeof token === 'string' ? token : token.content;
								var index6 = s4.indexOf(placeholder);
								if (index6 !== -1) {
									++placeholderCounter;
									var before = s4.substring(0, index6);
									var middle = tokenizeInterpolationExpression(placeholderMap[placeholder]);
									var after = s4.substring(index6 + placeholder.length);
									var replacement = [];
									if (before) {
										replacement.push(before);
									}
									replacement.push(middle);
									if (after) {
										var afterTokens = [after];
										walkTokens(afterTokens);
										replacement.push.apply(replacement, afterTokens);
									}
									if (typeof token === 'string') {
										tokens.splice.apply(tokens, [i2, 1].concat(replacement));
										i2 += replacement.length - 1;
									} else {
										token.content = replacement;
									}
								}
							} else {
								var content3 = token.content;
								if (Array.isArray(content3)) {
									walkTokens(content3);
								} else {
									walkTokens([content3]);
								}
							}
						}
					}
					walkTokens(embeddedTokens);
					return new Prism2.Token(language, embeddedTokens, 'language-' + language, code3);
				}
				var supportedLanguages = {
					javascript: true,
					js: true,
					typescript: true,
					ts: true,
					jsx: true,
					tsx: true
				};
				Prism2.hooks.add('after-tokenize', function (env) {
					if (!(env.language in supportedLanguages)) {
						return;
					}
					function findTemplateStrings(tokens) {
						for (var i2 = 0, l = tokens.length; i2 < l; i2++) {
							var token = tokens[i2];
							if (typeof token === 'string') {
								continue;
							}
							var content3 = token.content;
							if (!Array.isArray(content3)) {
								if (typeof content3 !== 'string') {
									findTemplateStrings([content3]);
								}
								continue;
							}
							if (token.type === 'template-string') {
								var embedded = content3[1];
								if (
									content3.length === 3 &&
									typeof embedded !== 'string' &&
									embedded.type === 'embedded-code'
								) {
									var code3 = stringContent(embedded);
									var alias = embedded.alias;
									var language = Array.isArray(alias) ? alias[0] : alias;
									var grammar = Prism2.languages[language];
									if (!grammar) {
										continue;
									}
									content3[1] = tokenizeEmbedded(code3, grammar, language);
								}
							} else {
								findTemplateStrings(content3);
							}
						}
					}
					findTemplateStrings(env.tokens);
				});
				function stringContent(value) {
					if (typeof value === 'string') {
						return value;
					} else if (Array.isArray(value)) {
						return value.map(stringContent).join('');
					} else {
						return stringContent(value.content);
					}
				}
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/typescript.js
var require_typescript = __commonJS({
	'node_modules/refractor/lang/typescript.js'(exports, module2) {
		'use strict';
		module2.exports = typescript;
		typescript.displayName = 'typescript';
		typescript.aliases = ['ts'];
		function typescript(Prism) {
			(function (Prism2) {
				Prism2.languages.typescript = Prism2.languages.extend('javascript', {
					'class-name': {
						pattern:
							/(\b(?:class|extends|implements|instanceof|interface|new|type)\s+)(?!keyof\b)(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?:\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>)?/,
						lookbehind: true,
						greedy: true,
						inside: null
					},
					builtin:
						/\b(?:Array|Function|Promise|any|boolean|console|never|number|string|symbol|unknown)\b/
				});
				Prism2.languages.typescript.keyword.push(
					/\b(?:abstract|declare|is|keyof|readonly|require)\b/,
					/\b(?:asserts|infer|interface|module|namespace|type)\b(?=\s*(?:[{_$a-zA-Z\xA0-\uFFFF]|$))/,
					/\btype\b(?=\s*(?:[\{*]|$))/
				);
				delete Prism2.languages.typescript['parameter'];
				delete Prism2.languages.typescript['literal-property'];
				var typeInside = Prism2.languages.extend('typescript', {});
				delete typeInside['class-name'];
				Prism2.languages.typescript['class-name'].inside = typeInside;
				Prism2.languages.insertBefore('typescript', 'function', {
					decorator: {
						pattern: /@[$\w\xA0-\uFFFF]+/,
						inside: {
							at: {
								pattern: /^@/,
								alias: 'operator'
							},
							function: /^[\s\S]+/
						}
					},
					'generic-function': {
						pattern:
							/#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*<(?:[^<>]|<(?:[^<>]|<[^<>]*>)*>)*>(?=\s*\()/,
						greedy: true,
						inside: {
							function: /^#?(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*/,
							generic: {
								pattern: /<[\s\S]+/,
								alias: 'class-name',
								inside: typeInside
							}
						}
					}
				});
				Prism2.languages.ts = Prism2.languages.typescript;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/jsdoc.js
var require_jsdoc = __commonJS({
	'node_modules/refractor/lang/jsdoc.js'(exports, module2) {
		'use strict';
		var refractorJavadoclike = require_javadoclike();
		var refractorTypescript = require_typescript();
		module2.exports = jsdoc;
		jsdoc.displayName = 'jsdoc';
		jsdoc.aliases = [];
		function jsdoc(Prism) {
			Prism.register(refractorJavadoclike);
			Prism.register(refractorTypescript);
			(function (Prism2) {
				var javascript = Prism2.languages.javascript;
				var type = /\{(?:[^{}]|\{(?:[^{}]|\{[^{}]*\})*\})+\}/.source;
				var parameterPrefix = '(@(?:arg|argument|param|property)\\s+(?:' + type + '\\s+)?)';
				Prism2.languages.jsdoc = Prism2.languages.extend('javadoclike', {
					parameter: {
						pattern: RegExp(parameterPrefix + /(?:(?!\s)[$\w\xA0-\uFFFF.])+(?=\s|$)/.source),
						lookbehind: true,
						inside: {
							punctuation: /\./
						}
					}
				});
				Prism2.languages.insertBefore('jsdoc', 'keyword', {
					'optional-parameter': {
						pattern: RegExp(
							parameterPrefix + /\[(?:(?!\s)[$\w\xA0-\uFFFF.])+(?:=[^[\]]+)?\](?=\s|$)/.source
						),
						lookbehind: true,
						inside: {
							parameter: {
								pattern: /(^\[)[$\w\xA0-\uFFFF\.]+/,
								lookbehind: true,
								inside: {
									punctuation: /\./
								}
							},
							code: {
								pattern: /(=)[\s\S]*(?=\]$)/,
								lookbehind: true,
								inside: javascript,
								alias: 'language-javascript'
							},
							punctuation: /[=[\]]/
						}
					},
					'class-name': [
						{
							pattern: RegExp(
								/(@(?:augments|class|extends|interface|memberof!?|template|this|typedef)\s+(?:<TYPE>\s+)?)[A-Z]\w*(?:\.[A-Z]\w*)*/.source.replace(
									/<TYPE>/g,
									function () {
										return type;
									}
								)
							),
							lookbehind: true,
							inside: {
								punctuation: /\./
							}
						},
						{
							pattern: RegExp('(@[a-z]+\\s+)' + type),
							lookbehind: true,
							inside: {
								string: javascript.string,
								number: javascript.number,
								boolean: javascript.boolean,
								keyword: Prism2.languages.typescript.keyword,
								operator: /=>|\.\.\.|[&|?:*]/,
								punctuation: /[.,;=<>{}()[\]]/
							}
						}
					],
					example: {
						pattern: /(@example\s+(?!\s))(?:[^@\s]|\s+(?!\s))+?(?=\s*(?:\*\s*)?(?:@\w|\*\/))/,
						lookbehind: true,
						inside: {
							code: {
								pattern: /^([\t ]*(?:\*\s*)?)\S.*$/m,
								lookbehind: true,
								inside: javascript,
								alias: 'language-javascript'
							}
						}
					}
				});
				Prism2.languages.javadoclike.addSupport('javascript', Prism2.languages.jsdoc);
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/json.js
var require_json2 = __commonJS({
	'node_modules/refractor/lang/json.js'(exports, module2) {
		'use strict';
		module2.exports = json;
		json.displayName = 'json';
		json.aliases = ['webmanifest'];
		function json(Prism) {
			Prism.languages.json = {
				property: {
					pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?=\s*:)/,
					lookbehind: true,
					greedy: true
				},
				string: {
					pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"(?!\s*:)/,
					lookbehind: true,
					greedy: true
				},
				comment: {
					pattern: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
					greedy: true
				},
				number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
				punctuation: /[{}[\],]/,
				operator: /:/,
				boolean: /\b(?:false|true)\b/,
				null: {
					pattern: /\bnull\b/,
					alias: 'keyword'
				}
			};
			Prism.languages.webmanifest = Prism.languages.json;
		}
	}
});

// node_modules/refractor/lang/json5.js
var require_json5 = __commonJS({
	'node_modules/refractor/lang/json5.js'(exports, module2) {
		'use strict';
		var refractorJson = require_json2();
		module2.exports = json5;
		json5.displayName = 'json5';
		json5.aliases = [];
		function json5(Prism) {
			Prism.register(refractorJson);
			(function (Prism2) {
				var string3 = /("|')(?:\\(?:\r\n?|\n|.)|(?!\1)[^\\\r\n])*\1/;
				Prism2.languages.json5 = Prism2.languages.extend('json', {
					property: [
						{
							pattern: RegExp(string3.source + '(?=\\s*:)'),
							greedy: true
						},
						{
							pattern: /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*:)/,
							alias: 'unquoted'
						}
					],
					string: {
						pattern: string3,
						greedy: true
					},
					number:
						/[+-]?\b(?:NaN|Infinity|0x[a-fA-F\d]+)\b|[+-]?(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+\b)?/
				});
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/jsonp.js
var require_jsonp = __commonJS({
	'node_modules/refractor/lang/jsonp.js'(exports, module2) {
		'use strict';
		var refractorJson = require_json2();
		module2.exports = jsonp;
		jsonp.displayName = 'jsonp';
		jsonp.aliases = [];
		function jsonp(Prism) {
			Prism.register(refractorJson);
			Prism.languages.jsonp = Prism.languages.extend('json', {
				punctuation: /[{}[\]();,.]/
			});
			Prism.languages.insertBefore('jsonp', 'punctuation', {
				function: /(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*(?=\s*\()/
			});
		}
	}
});

// node_modules/refractor/lang/jsstacktrace.js
var require_jsstacktrace = __commonJS({
	'node_modules/refractor/lang/jsstacktrace.js'(exports, module2) {
		'use strict';
		module2.exports = jsstacktrace;
		jsstacktrace.displayName = 'jsstacktrace';
		jsstacktrace.aliases = [];
		function jsstacktrace(Prism) {
			Prism.languages.jsstacktrace = {
				'error-message': {
					pattern: /^\S.*/m,
					alias: 'string'
				},
				'stack-frame': {
					pattern: /(^[ \t]+)at[ \t].*/m,
					lookbehind: true,
					inside: {
						'not-my-code': {
							pattern:
								/^at[ \t]+(?!\s)(?:node\.js|<unknown>|.*(?:node_modules|\(<anonymous>\)|\(<unknown>|<anonymous>$|\(internal\/|\(node\.js)).*/m,
							alias: 'comment'
						},
						filename: {
							pattern: /(\bat\s+(?!\s)|\()(?:[a-zA-Z]:)?[^():]+(?=:)/,
							lookbehind: true,
							alias: 'url'
						},
						function: {
							pattern: /(\bat\s+(?:new\s+)?)(?!\s)[_$a-zA-Z\xA0-\uFFFF<][.$\w\xA0-\uFFFF<>]*/,
							lookbehind: true,
							inside: {
								punctuation: /\./
							}
						},
						punctuation: /[()]/,
						keyword: /\b(?:at|new)\b/,
						alias: {
							pattern: /\[(?:as\s+)?(?!\s)[_$a-zA-Z\xA0-\uFFFF][$\w\xA0-\uFFFF]*\]/,
							alias: 'variable'
						},
						'line-number': {
							pattern: /:\d+(?::\d+)?\b/,
							alias: 'number',
							inside: {
								punctuation: /:/
							}
						}
					}
				}
			};
		}
	}
});

// node_modules/refractor/lang/jsx.js
var require_jsx = __commonJS({
	'node_modules/refractor/lang/jsx.js'(exports, module2) {
		'use strict';
		module2.exports = jsx;
		jsx.displayName = 'jsx';
		jsx.aliases = [];
		function jsx(Prism) {
			(function (Prism2) {
				var javascript = Prism2.util.clone(Prism2.languages.javascript);
				var space = /(?:\s|\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))\*\/)/.source;
				var braces = /(?:\{(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])*\})/.source;
				var spread = /(?:\{<S>*\.{3}(?:[^{}]|<BRACES>)*\})/.source;
				function re(source, flags) {
					source = source
						.replace(/<S>/g, function () {
							return space;
						})
						.replace(/<BRACES>/g, function () {
							return braces;
						})
						.replace(/<SPREAD>/g, function () {
							return spread;
						});
					return RegExp(source, flags);
				}
				spread = re(spread).source;
				Prism2.languages.jsx = Prism2.languages.extend('markup', javascript);
				Prism2.languages.jsx.tag.pattern = re(
					/<\/?(?:[\w.:-]+(?:<S>+(?:[\w.:$-]+(?:=(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s{'"/>=]+|<BRACES>))?|<SPREAD>))*<S>*\/?)?>/
						.source
				);
				Prism2.languages.jsx.tag.inside['tag'].pattern = /^<\/?[^\s>\/]*/;
				Prism2.languages.jsx.tag.inside['attr-value'].pattern =
					/=(?!\{)(?:"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*'|[^\s'">]+)/;
				Prism2.languages.jsx.tag.inside['tag'].inside['class-name'] = /^[A-Z]\w*(?:\.[A-Z]\w*)*$/;
				Prism2.languages.jsx.tag.inside['comment'] = javascript['comment'];
				Prism2.languages.insertBefore(
					'inside',
					'attr-name',
					{
						spread: {
							pattern: re(/<SPREAD>/.source),
							inside: Prism2.languages.jsx
						}
					},
					Prism2.languages.jsx.tag
				);
				Prism2.languages.insertBefore(
					'inside',
					'special-attr',
					{
						script: {
							pattern: re(/=<BRACES>/.source),
							alias: 'language-javascript',
							inside: {
								'script-punctuation': {
									pattern: /^=(?=\{)/,
									alias: 'punctuation'
								},
								rest: Prism2.languages.jsx
							}
						}
					},
					Prism2.languages.jsx.tag
				);
				var stringifyToken = function (token) {
					if (!token) {
						return '';
					}
					if (typeof token === 'string') {
						return token;
					}
					if (typeof token.content === 'string') {
						return token.content;
					}
					return token.content.map(stringifyToken).join('');
				};
				var walkTokens = function (tokens) {
					var openedTags = [];
					for (var i2 = 0; i2 < tokens.length; i2++) {
						var token = tokens[i2];
						var notTagNorBrace = false;
						if (typeof token !== 'string') {
							if (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {
								if (token.content[0].content[0].content === '</') {
									if (
										openedTags.length > 0 &&
										openedTags[openedTags.length - 1].tagName ===
											stringifyToken(token.content[0].content[1])
									) {
										openedTags.pop();
									}
								} else {
									if (token.content[token.content.length - 1].content === '/>') {
									} else {
										openedTags.push({
											tagName: stringifyToken(token.content[0].content[1]),
											openedBraces: 0
										});
									}
								}
							} else if (
								openedTags.length > 0 &&
								token.type === 'punctuation' &&
								token.content === '{'
							) {
								openedTags[openedTags.length - 1].openedBraces++;
							} else if (
								openedTags.length > 0 &&
								openedTags[openedTags.length - 1].openedBraces > 0 &&
								token.type === 'punctuation' &&
								token.content === '}'
							) {
								openedTags[openedTags.length - 1].openedBraces--;
							} else {
								notTagNorBrace = true;
							}
						}
						if (notTagNorBrace || typeof token === 'string') {
							if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
								var plainText = stringifyToken(token);
								if (
									i2 < tokens.length - 1 &&
									(typeof tokens[i2 + 1] === 'string' || tokens[i2 + 1].type === 'plain-text')
								) {
									plainText += stringifyToken(tokens[i2 + 1]);
									tokens.splice(i2 + 1, 1);
								}
								if (
									i2 > 0 &&
									(typeof tokens[i2 - 1] === 'string' || tokens[i2 - 1].type === 'plain-text')
								) {
									plainText = stringifyToken(tokens[i2 - 1]) + plainText;
									tokens.splice(i2 - 1, 1);
									i2--;
								}
								tokens[i2] = new Prism2.Token('plain-text', plainText, null, plainText);
							}
						}
						if (token.content && typeof token.content !== 'string') {
							walkTokens(token.content);
						}
					}
				};
				Prism2.hooks.add('after-tokenize', function (env) {
					if (env.language !== 'jsx' && env.language !== 'tsx') {
						return;
					}
					walkTokens(env.tokens);
				});
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/julia.js
var require_julia = __commonJS({
	'node_modules/refractor/lang/julia.js'(exports, module2) {
		'use strict';
		module2.exports = julia;
		julia.displayName = 'julia';
		julia.aliases = [];
		function julia(Prism) {
			Prism.languages.julia = {
				comment: {
					pattern: /(^|[^\\])(?:#=(?:[^#=]|=(?!#)|#(?!=)|#=(?:[^#=]|=(?!#)|#(?!=))*=#)*=#|#.*)/,
					lookbehind: true
				},
				regex: {
					pattern: /r"(?:\\.|[^"\\\r\n])*"[imsx]{0,4}/,
					greedy: true
				},
				string: {
					pattern: /"""[\s\S]+?"""|(?:\b\w+)?"(?:\\.|[^"\\\r\n])*"|`(?:[^\\`\r\n]|\\.)*`/,
					greedy: true
				},
				char: {
					pattern: /(^|[^\w'])'(?:\\[^\r\n][^'\r\n]*|[^\\\r\n])'/,
					lookbehind: true,
					greedy: true
				},
				keyword:
					/\b(?:abstract|baremodule|begin|bitstype|break|catch|ccall|const|continue|do|else|elseif|end|export|finally|for|function|global|if|immutable|import|importall|in|let|local|macro|module|print|println|quote|return|struct|try|type|typealias|using|while)\b/,
				boolean: /\b(?:false|true)\b/,
				number:
					/(?:\b(?=\d)|\B(?=\.))(?:0[box])?(?:[\da-f]+(?:_[\da-f]+)*(?:\.(?:\d+(?:_\d+)*)?)?|\.\d+(?:_\d+)*)(?:[efp][+-]?\d+(?:_\d+)*)?j?/i,
				operator:
					/&&|\|\||[-+*^%&$\\]=?|\/[\/=]?|!=?=?|\|[=>]?|<(?:<=?|[=:|])?|>(?:=|>>?=?)?|==?=?|[~']/,
				punctuation: /::?|[{}[\]();,.?]/,
				constant: /\b(?:(?:Inf|NaN)(?:16|32|64)?|im|pi)\b|[]/
			};
		}
	}
});

// node_modules/refractor/lang/keepalived.js
var require_keepalived = __commonJS({
	'node_modules/refractor/lang/keepalived.js'(exports, module2) {
		'use strict';
		module2.exports = keepalived;
		keepalived.displayName = 'keepalived';
		keepalived.aliases = [];
		function keepalived(Prism) {
			Prism.languages.keepalived = {
				comment: {
					pattern: /[#!].*/,
					greedy: true
				},
				string: {
					pattern:
						/(^|[^\\])(?:"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"|'(?:\\(?:\r\n|[\s\S])|[^'\\\r\n])*')/,
					lookbehind: true,
					greedy: true
				},
				ip: {
					pattern: RegExp(
						/\b(?:(?:(?:[\da-f]{1,4}:){7}[\da-f]{1,4}|(?:[\da-f]{1,4}:){6}:[\da-f]{1,4}|(?:[\da-f]{1,4}:){5}:(?:[\da-f]{1,4}:)?[\da-f]{1,4}|(?:[\da-f]{1,4}:){4}:(?:[\da-f]{1,4}:){0,2}[\da-f]{1,4}|(?:[\da-f]{1,4}:){3}:(?:[\da-f]{1,4}:){0,3}[\da-f]{1,4}|(?:[\da-f]{1,4}:){2}:(?:[\da-f]{1,4}:){0,4}[\da-f]{1,4}|(?:[\da-f]{1,4}:){6}<ipv4>|(?:[\da-f]{1,4}:){0,5}:<ipv4>|::(?:[\da-f]{1,4}:){0,5}<ipv4>|[\da-f]{1,4}::(?:[\da-f]{1,4}:){0,5}[\da-f]{1,4}|::(?:[\da-f]{1,4}:){0,6}[\da-f]{1,4}|(?:[\da-f]{1,4}:){1,7}:)(?:\/\d{1,3})?|<ipv4>(?:\/\d{1,2})?)\b/.source.replace(
							/<ipv4>/g,
							function () {
								return /(?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d)\.){3}(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]\d|\d))/
									.source;
							}
						),
						'i'
					),
					alias: 'number'
				},
				path: {
					pattern: /(\s)\/(?:[^\/\s]+\/)*[^\/\s]*|\b[a-zA-Z]:\\(?:[^\\\s]+\\)*[^\\\s]*/,
					lookbehind: true,
					alias: 'string'
				},
				variable: /\$\{?\w+\}?/,
				email: {
					pattern: /[\w-]+@[\w-]+(?:\.[\w-]{2,3}){1,2}/,
					alias: 'string'
				},
				'conditional-configuration': {
					pattern: /@\^?[\w-]+/,
					alias: 'variable'
				},
				operator: /=/,
				property:
					/\b(?:BFD_CHECK|DNS_CHECK|FILE_CHECK|HTTP_GET|MISC_CHECK|NAME|PING_CHECK|SCRIPTS|SMTP_CHECK|SSL|SSL_GET|TCP_CHECK|UDP_CHECK|accept|advert_int|alpha|auth_pass|auth_type|authentication|bfd_cpu_affinity|bfd_instance|bfd_no_swap|bfd_priority|bfd_process_name|bfd_rlimit_rttime|bfd_rt_priority|bind_if|bind_port|bindto|ca|certificate|check_unicast_src|checker|checker_cpu_affinity|checker_log_all_failures|checker_no_swap|checker_priority|checker_rlimit_rttime|checker_rt_priority|child_wait_time|connect_ip|connect_port|connect_timeout|dbus_service_name|debug|default_interface|delay|delay_before_retry|delay_loop|digest|dont_track_primary|dynamic|dynamic_interfaces|enable_(?:dbus|script_security|sni|snmp_checker|snmp_rfc|snmp_rfcv2|snmp_rfcv3|snmp_vrrp|traps)|end|fall|fast_recovery|file|flag-[123]|fork_delay|full_command|fwmark|garp_group|garp_interval|garp_lower_prio_delay|garp_lower_prio_repeat|garp_master_delay|garp_master_refresh|garp_master_refresh_repeat|garp_master_repeat|global_defs|global_tracking|gna_interval|group|ha_suspend|hashed|helo_name|higher_prio_send_advert|hoplimit|http_protocol|hysteresis|idle_tx|include|inhibit_on_failure|init_fail|init_file|instance|interface|interfaces|interval|ip_family|ipvs_process_name|keepalived.conf|kernel_rx_buf_size|key|linkbeat_interfaces|linkbeat_use_polling|log_all_failures|log_unknown_vrids|lower_prio_no_advert|lthreshold|lvs_flush|lvs_flush_onstop|lvs_method|lvs_netlink_cmd_rcv_bufs|lvs_netlink_cmd_rcv_bufs_force|lvs_netlink_monitor_rcv_bufs|lvs_netlink_monitor_rcv_bufs_force|lvs_notify_fifo|lvs_notify_fifo_script|lvs_sched|lvs_sync_daemon|max_auto_priority|max_hops|mcast_src_ip|mh-fallback|mh-port|min_auto_priority_delay|min_rx|min_tx|misc_dynamic|misc_path|misc_timeout|multiplier|name|namespace_with_ipsets|native_ipv6|neighbor_ip|net_namespace|net_namespace_ipvs|nftables|nftables_counters|nftables_ifindex|nftables_priority|no_accept|no_checker_emails|no_email_faults|nopreempt|notification_email|notification_email_from|notify|notify_backup|notify_deleted|notify_down|notify_fault|notify_fifo|notify_fifo_script|notify_master|notify_master_rx_lower_pri|notify_priority_changes|notify_stop|notify_up|old_unicast_checksum|omega|ops|param_match|passive|password|path|persistence_engine|persistence_granularity|persistence_timeout|preempt|preempt_delay|priority|process|process_monitor_rcv_bufs|process_monitor_rcv_bufs_force|process_name|process_names|promote_secondaries|protocol|proxy_arp|proxy_arp_pvlan|quorum|quorum_down|quorum_max|quorum_up|random_seed|real_server|regex|regex_max_offset|regex_min_offset|regex_no_match|regex_options|regex_stack|reload_repeat|reload_time_file|require_reply|retry|rise|router_id|rs_init_notifies|script|script_user|sh-fallback|sh-port|shutdown_script|shutdown_script_timeout|skip_check_adv_addr|smtp_alert|smtp_alert_checker|smtp_alert_vrrp|smtp_connect_timeout|smtp_helo_name|smtp_server|snmp_socket|sorry_server|sorry_server_inhibit|sorry_server_lvs_method|source_ip|start|startup_script|startup_script_timeout|state|static_ipaddress|static_routes|static_rules|status_code|step|strict_mode|sync_group_tracking_weight|terminate_delay|timeout|track_bfd|track_file|track_group|track_interface|track_process|track_script|track_src_ip|ttl|type|umask|unicast_peer|unicast_src_ip|unicast_ttl|url|use_ipvlan|use_pid_dir|use_vmac|user|uthreshold|val[123]|version|virtual_ipaddress|virtual_ipaddress_excluded|virtual_router_id|virtual_routes|virtual_rules|virtual_server|virtual_server_group|virtualhost|vmac_xmit_base|vrrp|vrrp_(?:check_unicast_src|cpu_affinity|garp_interval|garp_lower_prio_delay|garp_lower_prio_repeat|garp_master_delay|garp_master_refresh|garp_master_refresh_repeat|garp_master_repeat|gna_interval|higher_prio_send_advert|instance|ipsets|iptables|lower_prio_no_advert|mcast_group4|mcast_group6|min_garp|netlink_cmd_rcv_bufs|netlink_cmd_rcv_bufs_force|netlink_monitor_rcv_bufs|netlink_monitor_rcv_bufs_force|no_swap|notify_fifo|notify_fifo_script|notify_priority_changes|priority|process_name|rlimit_rttime|rt_priority|rx_bufs_multiplier|rx_bufs_policy|script|skip_check_adv_addr|startup_delay|strict|sync_group|track_process|version)|warmup|weight)\b/,
				constant:
					/\b(?:A|AAAA|AH|BACKUP|CNAME|DR|MASTER|MX|NAT|NS|PASS|SCTP|SOA|TCP|TUN|TXT|UDP|dh|fo|lblc|lblcr|lc|mh|nq|ovf|rr|sed|sh|wlc|wrr)\b/,
				number: {
					pattern: /(^|[^\w.-])-?\d+(?:\.\d+)?/,
					lookbehind: true
				},
				boolean: /\b(?:false|no|off|on|true|yes)\b/,
				punctuation: /[\{\}]/
			};
		}
	}
});

// node_modules/refractor/lang/keyman.js
var require_keyman = __commonJS({
	'node_modules/refractor/lang/keyman.js'(exports, module2) {
		'use strict';
		module2.exports = keyman;
		keyman.displayName = 'keyman';
		keyman.aliases = [];
		function keyman(Prism) {
			Prism.languages.keyman = {
				comment: {
					pattern: /\bc .*/i,
					greedy: true
				},
				string: {
					pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
					greedy: true
				},
				'virtual-key': {
					pattern:
						/\[\s*(?:(?:ALT|CAPS|CTRL|LALT|LCTRL|NCAPS|RALT|RCTRL|SHIFT)\s+)*(?:[TKU]_[\w?]+|[A-E]\d\d?|"[^"\r\n]*"|'[^'\r\n]*')\s*\]/i,
					greedy: true,
					alias: 'function'
				},
				'header-keyword': {
					pattern: /&\w+/,
					alias: 'bold'
				},
				'header-statement': {
					pattern:
						/\b(?:bitmap|bitmaps|caps always off|caps on only|copyright|hotkey|language|layout|message|name|shift frees caps|version)\b/i,
					alias: 'bold'
				},
				'rule-keyword': {
					pattern:
						/\b(?:any|baselayout|beep|call|context|deadkey|dk|if|index|layer|notany|nul|outs|platform|reset|return|save|set|store|use)\b/i,
					alias: 'keyword'
				},
				'structural-keyword': {
					pattern: /\b(?:ansi|begin|group|match|nomatch|unicode|using keys)\b/i,
					alias: 'keyword'
				},
				'compile-target': {
					pattern: /\$(?:keyman|keymanonly|keymanweb|kmfl|weaver):/i,
					alias: 'property'
				},
				number: /\b(?:U\+[\dA-F]+|d\d+|x[\da-f]+|\d+)\b/i,
				operator: /[+>\\$]|\.\./,
				punctuation: /[()=,]/
			};
		}
	}
});

// node_modules/refractor/lang/kotlin.js
var require_kotlin = __commonJS({
	'node_modules/refractor/lang/kotlin.js'(exports, module2) {
		'use strict';
		module2.exports = kotlin;
		kotlin.displayName = 'kotlin';
		kotlin.aliases = ['kt', 'kts'];
		function kotlin(Prism) {
			(function (Prism2) {
				Prism2.languages.kotlin = Prism2.languages.extend('clike', {
					keyword: {
						pattern:
							/(^|[^.])\b(?:abstract|actual|annotation|as|break|by|catch|class|companion|const|constructor|continue|crossinline|data|do|dynamic|else|enum|expect|external|final|finally|for|fun|get|if|import|in|infix|init|inline|inner|interface|internal|is|lateinit|noinline|null|object|open|operator|out|override|package|private|protected|public|reified|return|sealed|set|super|suspend|tailrec|this|throw|to|try|typealias|val|var|vararg|when|where|while)\b/,
						lookbehind: true
					},
					function: [
						{
							pattern: /(?:`[^\r\n`]+`|\b\w+)(?=\s*\()/,
							greedy: true
						},
						{
							pattern: /(\.)(?:`[^\r\n`]+`|\w+)(?=\s*\{)/,
							lookbehind: true,
							greedy: true
						}
					],
					number:
						/\b(?:0[xX][\da-fA-F]+(?:_[\da-fA-F]+)*|0[bB][01]+(?:_[01]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?[fFL]?)\b/,
					operator:
						/\+[+=]?|-[-=>]?|==?=?|!(?:!|==?)?|[\/*%<>]=?|[?:]:?|\.\.|&&|\|\||\b(?:and|inv|or|shl|shr|ushr|xor)\b/
				});
				delete Prism2.languages.kotlin['class-name'];
				var interpolationInside = {
					'interpolation-punctuation': {
						pattern: /^\$\{?|\}$/,
						alias: 'punctuation'
					},
					expression: {
						pattern: /[\s\S]+/,
						inside: Prism2.languages.kotlin
					}
				};
				Prism2.languages.insertBefore('kotlin', 'string', {
					'string-literal': [
						{
							pattern: /"""(?:[^$]|\$(?:(?!\{)|\{[^{}]*\}))*?"""/,
							alias: 'multiline',
							inside: {
								interpolation: {
									pattern: /\$(?:[a-z_]\w*|\{[^{}]*\})/i,
									inside: interpolationInside
								},
								string: /[\s\S]+/
							}
						},
						{
							pattern: /"(?:[^"\\\r\n$]|\\.|\$(?:(?!\{)|\{[^{}]*\}))*"/,
							alias: 'singleline',
							inside: {
								interpolation: {
									pattern: /((?:^|[^\\])(?:\\{2})*)\$(?:[a-z_]\w*|\{[^{}]*\})/i,
									lookbehind: true,
									inside: interpolationInside
								},
								string: /[\s\S]+/
							}
						}
					],
					char: {
						pattern: /'(?:[^'\\\r\n]|\\(?:.|u[a-fA-F0-9]{0,4}))'/,
						greedy: true
					}
				});
				delete Prism2.languages.kotlin['string'];
				Prism2.languages.insertBefore('kotlin', 'keyword', {
					annotation: {
						pattern: /\B@(?:\w+:)?(?:[A-Z]\w*|\[[^\]]+\])/,
						alias: 'builtin'
					}
				});
				Prism2.languages.insertBefore('kotlin', 'function', {
					label: {
						pattern: /\b\w+@|@\w+\b/,
						alias: 'symbol'
					}
				});
				Prism2.languages.kt = Prism2.languages.kotlin;
				Prism2.languages.kts = Prism2.languages.kotlin;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/kumir.js
var require_kumir = __commonJS({
	'node_modules/refractor/lang/kumir.js'(exports, module2) {
		'use strict';
		module2.exports = kumir;
		kumir.displayName = 'kumir';
		kumir.aliases = ['kum'];
		function kumir(Prism) {
			(function (Prism2) {
				var nonId = /\s\x00-\x1f\x22-\x2f\x3a-\x3f\x5b-\x5e\x60\x7b-\x7e/.source;
				function wrapId(pattern, flags) {
					return RegExp(pattern.replace(/<nonId>/g, nonId), flags);
				}
				Prism2.languages.kumir = {
					comment: {
						pattern: /\|.*/
					},
					prolog: {
						pattern: /#.*/,
						greedy: true
					},
					string: {
						pattern: /"[^\n\r"]*"|'[^\n\r']*'/,
						greedy: true
					},
					boolean: {
						pattern: wrapId(/(^|[<nonId>])(?:|)(?=[<nonId>]|$)/.source),
						lookbehind: true
					},
					'operator-word': {
						pattern: wrapId(/(^|[<nonId>])(?:||)(?=[<nonId>]|$)/.source),
						lookbehind: true,
						alias: 'keyword'
					},
					'system-variable': {
						pattern: wrapId(/(^|[<nonId>])(?=[<nonId>]|$)/.source),
						lookbehind: true,
						alias: 'keyword'
					},
					type: [
						{
							pattern: wrapId(
								/(^|[<nonId>])(?:||||)(?:\x20*)?(?=[<nonId>]|$)/.source
							),
							lookbehind: true,
							alias: 'builtin'
						},
						{
							pattern: wrapId(/(^|[<nonId>])(?:|||)(?=[<nonId>]|$)/.source),
							lookbehind: true,
							alias: 'important'
						}
					],
					keyword: {
						pattern: wrapId(
							/(^|[<nonId>])(?:|(?:\x20*)?|||[]||||||||||||(?:(?:\x20+|_))?|(?:(?:\x20+|_))?|||||||||?||||||)(?=[<nonId>]|$)/
								.source
						),
						lookbehind: true
					},
					name: {
						pattern: wrapId(
							/(^|[<nonId>])[^\d<nonId>][^<nonId>]*(?:\x20+[^<nonId>]+)*(?=[<nonId>]|$)/.source
						),
						lookbehind: true
					},
					number: {
						pattern: wrapId(
							/(^|[<nonId>])(?:\B\$[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)(?=[<nonId>]|$)/
								.source,
							'i'
						),
						lookbehind: true
					},
					punctuation: /:=|[(),:;\[\]]/,
					'operator-char': {
						pattern: /\*\*?|<[=>]?|>=?|[-+/=]/,
						alias: 'operator'
					}
				};
				Prism2.languages.kum = Prism2.languages.kumir;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/kusto.js
var require_kusto = __commonJS({
	'node_modules/refractor/lang/kusto.js'(exports, module2) {
		'use strict';
		module2.exports = kusto;
		kusto.displayName = 'kusto';
		kusto.aliases = [];
		function kusto(Prism) {
			Prism.languages.kusto = {
				comment: {
					pattern: /\/\/.*/,
					greedy: true
				},
				string: {
					pattern:
						/```[\s\S]*?```|[hH]?(?:"(?:[^\r\n\\"]|\\.)*"|'(?:[^\r\n\\']|\\.)*'|@(?:"[^\r\n"]*"|'[^\r\n']*'))/,
					greedy: true
				},
				verb: {
					pattern: /(\|\s*)[a-z][\w-]*/i,
					lookbehind: true,
					alias: 'keyword'
				},
				command: {
					pattern: /\.[a-z][a-z\d-]*\b/,
					alias: 'keyword'
				},
				'class-name': /\b(?:bool|datetime|decimal|dynamic|guid|int|long|real|string|timespan)\b/,
				keyword:
					/\b(?:access|alias|and|anti|as|asc|auto|between|by|(?:contains|(?:ends|starts)with|has(?:perfix|suffix)?)(?:_cs)?|database|declare|desc|external|from|fullouter|has_all|in|ingestion|inline|inner|innerunique|into|(?:left|right)(?:anti(?:semi)?|inner|outer|semi)?|let|like|local|not|of|on|or|pattern|print|query_parameters|range|restrict|schema|set|step|table|tables|to|view|where|with|matches\s+regex|nulls\s+(?:first|last))(?![\w-])/,
				boolean: /\b(?:false|null|true)\b/,
				function: /\b[a-z_]\w*(?=\s*\()/,
				datetime: [
					{
						pattern:
							/\b(?:(?:Fri|Friday|Mon|Monday|Sat|Saturday|Sun|Sunday|Thu|Thursday|Tue|Tuesday|Wed|Wednesday)\s*,\s*)?\d{1,2}(?:\s+|-)(?:Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)(?:\s+|-)\d{2}\s+\d{2}:\d{2}(?::\d{2})?(?:\s*(?:\b(?:[A-Z]|(?:[ECMT][DS]|GM|U)T)|[+-]\d{4}))?\b/,
						alias: 'number'
					},
					{
						pattern:
							/[+-]?\b(?:\d{4}-\d{2}-\d{2}(?:[ T]\d{2}:\d{2}(?::\d{2}(?:\.\d+)?)?)?|\d{2}:\d{2}(?::\d{2}(?:\.\d+)?)?)Z?/,
						alias: 'number'
					}
				],
				number:
					/\b(?:0x[0-9A-Fa-f]+|\d+(?:\.\d+)?(?:[Ee][+-]?\d+)?)(?:(?:min|sec|[mn]s|[dhms]|microsecond|tick)\b)?|[+-]?\binf\b/,
				operator: /=>|[!=]~|[!=<>]=?|[-+*/%|]|\.\./,
				punctuation: /[()\[\]{},;.:]/
			};
		}
	}
});

// node_modules/refractor/lang/latex.js
var require_latex = __commonJS({
	'node_modules/refractor/lang/latex.js'(exports, module2) {
		'use strict';
		module2.exports = latex;
		latex.displayName = 'latex';
		latex.aliases = ['tex', 'context'];
		function latex(Prism) {
			(function (Prism2) {
				var funcPattern = /\\(?:[^a-z()[\]]|[a-z*]+)/i;
				var insideEqu = {
					'equation-command': {
						pattern: funcPattern,
						alias: 'regex'
					}
				};
				Prism2.languages.latex = {
					comment: /%.*/,
					cdata: {
						pattern: /(\\begin\{((?:lstlisting|verbatim)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
						lookbehind: true
					},
					equation: [
						{
							pattern:
								/\$\$(?:\\[\s\S]|[^\\$])+\$\$|\$(?:\\[\s\S]|[^\\$])+\$|\\\([\s\S]*?\\\)|\\\[[\s\S]*?\\\]/,
							inside: insideEqu,
							alias: 'string'
						},
						{
							pattern:
								/(\\begin\{((?:align|eqnarray|equation|gather|math|multline)\*?)\})[\s\S]*?(?=\\end\{\2\})/,
							lookbehind: true,
							inside: insideEqu,
							alias: 'string'
						}
					],
					keyword: {
						pattern:
							/(\\(?:begin|cite|documentclass|end|label|ref|usepackage)(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
						lookbehind: true
					},
					url: {
						pattern: /(\\url\{)[^}]+(?=\})/,
						lookbehind: true
					},
					headline: {
						pattern:
							/(\\(?:chapter|frametitle|paragraph|part|section|subparagraph|subsection|subsubparagraph|subsubsection|subsubsubparagraph)\*?(?:\[[^\]]+\])?\{)[^}]+(?=\})/,
						lookbehind: true,
						alias: 'class-name'
					},
					function: {
						pattern: funcPattern,
						alias: 'selector'
					},
					punctuation: /[[\]{}&]/
				};
				Prism2.languages.tex = Prism2.languages.latex;
				Prism2.languages.context = Prism2.languages.latex;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/php.js
var require_php = __commonJS({
	'node_modules/refractor/lang/php.js'(exports, module2) {
		'use strict';
		var refractorMarkupTemplating = require_markup_templating();
		module2.exports = php;
		php.displayName = 'php';
		php.aliases = [];
		function php(Prism) {
			Prism.register(refractorMarkupTemplating);
			(function (Prism2) {
				var comment4 = /\/\*[\s\S]*?\*\/|\/\/.*|#(?!\[).*/;
				var constant = [
					{
						pattern: /\b(?:false|true)\b/i,
						alias: 'boolean'
					},
					{
						pattern: /(::\s*)\b[a-z_]\w*\b(?!\s*\()/i,
						greedy: true,
						lookbehind: true
					},
					{
						pattern: /(\b(?:case|const)\s+)\b[a-z_]\w*(?=\s*[;=])/i,
						greedy: true,
						lookbehind: true
					},
					/\b(?:null)\b/i,
					/\b[A-Z_][A-Z0-9_]*\b(?!\s*\()/
				];
				var number3 =
					/\b0b[01]+(?:_[01]+)*\b|\b0o[0-7]+(?:_[0-7]+)*\b|\b0x[\da-f]+(?:_[\da-f]+)*\b|(?:\b\d+(?:_\d+)*\.?(?:\d+(?:_\d+)*)?|\B\.\d+)(?:e[+-]?\d+)?/i;
				var operator =
					/<?=>|\?\?=?|\.{3}|\??->|[!=]=?=?|::|\*\*=?|--|\+\+|&&|\|\||<<|>>|[?~]|[/^|%*&<>.+-]=?/;
				var punctuation = /[{}\[\](),:;]/;
				Prism2.languages.php = {
					delimiter: {
						pattern: /\?>$|^<\?(?:php(?=\s)|=)?/i,
						alias: 'important'
					},
					comment: comment4,
					variable: /\$+(?:\w+\b|(?=\{))/,
					package: {
						pattern: /(namespace\s+|use\s+(?:function\s+)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
						lookbehind: true,
						inside: {
							punctuation: /\\/
						}
					},
					'class-name-definition': {
						pattern: /(\b(?:class|enum|interface|trait)\s+)\b[a-z_]\w*(?!\\)\b/i,
						lookbehind: true,
						alias: 'class-name'
					},
					'function-definition': {
						pattern: /(\bfunction\s+)[a-z_]\w*(?=\s*\()/i,
						lookbehind: true,
						alias: 'function'
					},
					keyword: [
						{
							pattern:
								/(\(\s*)\b(?:array|bool|boolean|float|int|integer|object|string)\b(?=\s*\))/i,
							alias: 'type-casting',
							greedy: true,
							lookbehind: true
						},
						{
							pattern:
								/([(,?]\s*)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string)\b(?=\s*\$)/i,
							alias: 'type-hint',
							greedy: true,
							lookbehind: true
						},
						{
							pattern:
								/(\)\s*:\s*(?:\?\s*)?)\b(?:array(?!\s*\()|bool|callable|(?:false|null)(?=\s*\|)|float|int|iterable|mixed|object|self|static|string|void)\b/i,
							alias: 'return-type',
							greedy: true,
							lookbehind: true
						},
						{
							pattern: /\b(?:array(?!\s*\()|bool|float|int|iterable|mixed|object|string|void)\b/i,
							alias: 'type-declaration',
							greedy: true
						},
						{
							pattern: /(\|\s*)(?:false|null)\b|\b(?:false|null)(?=\s*\|)/i,
							alias: 'type-declaration',
							greedy: true,
							lookbehind: true
						},
						{
							pattern: /\b(?:parent|self|static)(?=\s*::)/i,
							alias: 'static-context',
							greedy: true
						},
						{
							pattern: /(\byield\s+)from\b/i,
							lookbehind: true
						},
						/\bclass\b/i,
						{
							pattern:
								/((?:^|[^\s>:]|(?:^|[^-])>|(?:^|[^:]):)\s*)\b(?:abstract|and|array|as|break|callable|case|catch|clone|const|continue|declare|default|die|do|echo|else|elseif|empty|enddeclare|endfor|endforeach|endif|endswitch|endwhile|enum|eval|exit|extends|final|finally|fn|for|foreach|function|global|goto|if|implements|include|include_once|instanceof|insteadof|interface|isset|list|match|namespace|new|or|parent|print|private|protected|public|require|require_once|return|self|static|switch|throw|trait|try|unset|use|var|while|xor|yield|__halt_compiler)\b/i,
							lookbehind: true
						}
					],
					'argument-name': {
						pattern: /([(,]\s+)\b[a-z_]\w*(?=\s*:(?!:))/i,
						lookbehind: true
					},
					'class-name': [
						{
							pattern:
								/(\b(?:extends|implements|instanceof|new(?!\s+self|\s+static))\s+|\bcatch\s*\()\b[a-z_]\w*(?!\\)\b/i,
							greedy: true,
							lookbehind: true
						},
						{
							pattern: /(\|\s*)\b[a-z_]\w*(?!\\)\b/i,
							greedy: true,
							lookbehind: true
						},
						{
							pattern: /\b[a-z_]\w*(?!\\)\b(?=\s*\|)/i,
							greedy: true
						},
						{
							pattern: /(\|\s*)(?:\\?\b[a-z_]\w*)+\b/i,
							alias: 'class-name-fully-qualified',
							greedy: true,
							lookbehind: true,
							inside: {
								punctuation: /\\/
							}
						},
						{
							pattern: /(?:\\?\b[a-z_]\w*)+\b(?=\s*\|)/i,
							alias: 'class-name-fully-qualified',
							greedy: true,
							inside: {
								punctuation: /\\/
							}
						},
						{
							pattern:
								/(\b(?:extends|implements|instanceof|new(?!\s+self\b|\s+static\b))\s+|\bcatch\s*\()(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
							alias: 'class-name-fully-qualified',
							greedy: true,
							lookbehind: true,
							inside: {
								punctuation: /\\/
							}
						},
						{
							pattern: /\b[a-z_]\w*(?=\s*\$)/i,
							alias: 'type-declaration',
							greedy: true
						},
						{
							pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
							alias: ['class-name-fully-qualified', 'type-declaration'],
							greedy: true,
							inside: {
								punctuation: /\\/
							}
						},
						{
							pattern: /\b[a-z_]\w*(?=\s*::)/i,
							alias: 'static-context',
							greedy: true
						},
						{
							pattern: /(?:\\?\b[a-z_]\w*)+(?=\s*::)/i,
							alias: ['class-name-fully-qualified', 'static-context'],
							greedy: true,
							inside: {
								punctuation: /\\/
							}
						},
						{
							pattern: /([(,?]\s*)[a-z_]\w*(?=\s*\$)/i,
							alias: 'type-hint',
							greedy: true,
							lookbehind: true
						},
						{
							pattern: /([(,?]\s*)(?:\\?\b[a-z_]\w*)+(?=\s*\$)/i,
							alias: ['class-name-fully-qualified', 'type-hint'],
							greedy: true,
							lookbehind: true,
							inside: {
								punctuation: /\\/
							}
						},
						{
							pattern: /(\)\s*:\s*(?:\?\s*)?)\b[a-z_]\w*(?!\\)\b/i,
							alias: 'return-type',
							greedy: true,
							lookbehind: true
						},
						{
							pattern: /(\)\s*:\s*(?:\?\s*)?)(?:\\?\b[a-z_]\w*)+\b(?!\\)/i,
							alias: ['class-name-fully-qualified', 'return-type'],
							greedy: true,
							lookbehind: true,
							inside: {
								punctuation: /\\/
							}
						}
					],
					constant,
					function: {
						pattern: /(^|[^\\\w])\\?[a-z_](?:[\w\\]*\w)?(?=\s*\()/i,
						lookbehind: true,
						inside: {
							punctuation: /\\/
						}
					},
					property: {
						pattern: /(->\s*)\w+/,
						lookbehind: true
					},
					number: number3,
					operator,
					punctuation
				};
				var string_interpolation = {
					pattern:
						/\{\$(?:\{(?:\{[^{}]+\}|[^{}]+)\}|[^{}])+\}|(^|[^\\{])\$+(?:\w+(?:\[[^\r\n\[\]]+\]|->\w+)?)/,
					lookbehind: true,
					inside: Prism2.languages.php
				};
				var string3 = [
					{
						pattern: /<<<'([^']+)'[\r\n](?:.*[\r\n])*?\1;/,
						alias: 'nowdoc-string',
						greedy: true,
						inside: {
							delimiter: {
								pattern: /^<<<'[^']+'|[a-z_]\w*;$/i,
								alias: 'symbol',
								inside: {
									punctuation: /^<<<'?|[';]$/
								}
							}
						}
					},
					{
						pattern: /<<<(?:"([^"]+)"[\r\n](?:.*[\r\n])*?\1;|([a-z_]\w*)[\r\n](?:.*[\r\n])*?\2;)/i,
						alias: 'heredoc-string',
						greedy: true,
						inside: {
							delimiter: {
								pattern: /^<<<(?:"[^"]+"|[a-z_]\w*)|[a-z_]\w*;$/i,
								alias: 'symbol',
								inside: {
									punctuation: /^<<<"?|[";]$/
								}
							},
							interpolation: string_interpolation
						}
					},
					{
						pattern: /`(?:\\[\s\S]|[^\\`])*`/,
						alias: 'backtick-quoted-string',
						greedy: true
					},
					{
						pattern: /'(?:\\[\s\S]|[^\\'])*'/,
						alias: 'single-quoted-string',
						greedy: true
					},
					{
						pattern: /"(?:\\[\s\S]|[^\\"])*"/,
						alias: 'double-quoted-string',
						greedy: true,
						inside: {
							interpolation: string_interpolation
						}
					}
				];
				Prism2.languages.insertBefore('php', 'variable', {
					string: string3,
					attribute: {
						pattern:
							/#\[(?:[^"'\/#]|\/(?![*/])|\/\/.*$|#(?!\[).*$|\/\*(?:[^*]|\*(?!\/))*\*\/|"(?:\\[\s\S]|[^\\"])*"|'(?:\\[\s\S]|[^\\'])*')+\](?=\s*[a-z$#])/im,
						greedy: true,
						inside: {
							'attribute-content': {
								pattern: /^(#\[)[\s\S]+(?=\]$)/,
								lookbehind: true,
								inside: {
									comment: comment4,
									string: string3,
									'attribute-class-name': [
										{
											pattern: /([^:]|^)\b[a-z_]\w*(?!\\)\b/i,
											alias: 'class-name',
											greedy: true,
											lookbehind: true
										},
										{
											pattern: /([^:]|^)(?:\\?\b[a-z_]\w*)+/i,
											alias: ['class-name', 'class-name-fully-qualified'],
											greedy: true,
											lookbehind: true,
											inside: {
												punctuation: /\\/
											}
										}
									],
									constant,
									number: number3,
									operator,
									punctuation
								}
							},
							delimiter: {
								pattern: /^#\[|\]$/,
								alias: 'punctuation'
							}
						}
					}
				});
				Prism2.hooks.add('before-tokenize', function (env) {
					if (!/<\?/.test(env.code)) {
						return;
					}
					var phpPattern =
						/<\?(?:[^"'/#]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|(?:\/\/|#(?!\[))(?:[^?\n\r]|\?(?!>))*(?=$|\?>|[\r\n])|#\[|\/\*(?:[^*]|\*(?!\/))*(?:\*\/|$))*?(?:\?>|$)/g;
					Prism2.languages['markup-templating'].buildPlaceholders(env, 'php', phpPattern);
				});
				Prism2.hooks.add('after-tokenize', function (env) {
					Prism2.languages['markup-templating'].tokenizePlaceholders(env, 'php');
				});
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/latte.js
var require_latte = __commonJS({
	'node_modules/refractor/lang/latte.js'(exports, module2) {
		'use strict';
		var refractorMarkupTemplating = require_markup_templating();
		var refractorPhp = require_php();
		module2.exports = latte;
		latte.displayName = 'latte';
		latte.aliases = [];
		function latte(Prism) {
			Prism.register(refractorMarkupTemplating);
			Prism.register(refractorPhp);
			(function (Prism2) {
				Prism2.languages.latte = {
					comment: /^\{\*[\s\S]*/,
					'latte-tag': {
						pattern: /(^\{(?:\/(?=[a-z]))?)(?:[=_]|[a-z]\w*\b(?!\())/i,
						lookbehind: true,
						alias: 'important'
					},
					delimiter: {
						pattern: /^\{\/?|\}$/,
						alias: 'punctuation'
					},
					php: {
						pattern: /\S(?:[\s\S]*\S)?/,
						alias: 'language-php',
						inside: Prism2.languages.php
					}
				};
				var markupLatte = Prism2.languages.extend('markup', {});
				Prism2.languages.insertBefore(
					'inside',
					'attr-value',
					{
						'n-attr': {
							pattern: /n:[\w-]+(?:\s*=\s*(?:"[^"]*"|'[^']*'|[^\s'">=]+))?/,
							inside: {
								'attr-name': {
									pattern: /^[^\s=]+/,
									alias: 'important'
								},
								'attr-value': {
									pattern: /=[\s\S]+/,
									inside: {
										punctuation: [
											/^=/,
											{
												pattern: /^(\s*)["']|["']$/,
												lookbehind: true
											}
										],
										php: {
											pattern: /\S(?:[\s\S]*\S)?/,
											inside: Prism2.languages.php
										}
									}
								}
							}
						}
					},
					markupLatte.tag
				);
				Prism2.hooks.add('before-tokenize', function (env) {
					if (env.language !== 'latte') {
						return;
					}
					var lattePattern =
						/\{\*[\s\S]*?\*\}|\{[^'"\s{}*](?:[^"'/{}]|\/(?![*/])|("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|\/\*(?:[^*]|\*(?!\/))*\*\/)*\}/g;
					Prism2.languages['markup-templating'].buildPlaceholders(env, 'latte', lattePattern);
					env.grammar = markupLatte;
				});
				Prism2.hooks.add('after-tokenize', function (env) {
					Prism2.languages['markup-templating'].tokenizePlaceholders(env, 'latte');
				});
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/less.js
var require_less = __commonJS({
	'node_modules/refractor/lang/less.js'(exports, module2) {
		'use strict';
		module2.exports = less;
		less.displayName = 'less';
		less.aliases = [];
		function less(Prism) {
			Prism.languages.less = Prism.languages.extend('css', {
				comment: [
					/\/\*[\s\S]*?\*\//,
					{
						pattern: /(^|[^\\])\/\/.*/,
						lookbehind: true
					}
				],
				atrule: {
					pattern: /@[\w-](?:\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};\s]|\s+(?!\s))*?(?=\s*\{)/,
					inside: {
						punctuation: /[:()]/
					}
				},
				selector: {
					pattern:
						/(?:@\{[\w-]+\}|[^{};\s@])(?:@\{[\w-]+\}|\((?:[^(){}]|\([^(){}]*\))*\)|[^(){};@\s]|\s+(?!\s))*?(?=\s*\{)/,
					inside: {
						variable: /@+[\w-]+/
					}
				},
				property: /(?:@\{[\w-]+\}|[\w-])+(?:\+_?)?(?=\s*:)/,
				operator: /[+\-*\/]/
			});
			Prism.languages.insertBefore('less', 'property', {
				variable: [
					{
						pattern: /@[\w-]+\s*:/,
						inside: {
							punctuation: /:/
						}
					},
					/@@?[\w-]+/
				],
				'mixin-usage': {
					pattern: /([{;]\s*)[.#](?!\d)[\w-].*?(?=[(;])/,
					lookbehind: true,
					alias: 'function'
				}
			});
		}
	}
});

// node_modules/refractor/lang/scheme.js
var require_scheme = __commonJS({
	'node_modules/refractor/lang/scheme.js'(exports, module2) {
		'use strict';
		module2.exports = scheme2;
		scheme2.displayName = 'scheme';
		scheme2.aliases = [];
		function scheme2(Prism) {
			(function (Prism2) {
				Prism2.languages.scheme = {
					comment:
						/;.*|#;\s*(?:\((?:[^()]|\([^()]*\))*\)|\[(?:[^\[\]]|\[[^\[\]]*\])*\])|#\|(?:[^#|]|#(?!\|)|\|(?!#)|#\|(?:[^#|]|#(?!\|)|\|(?!#))*\|#)*\|#/,
					string: {
						pattern: /"(?:[^"\\]|\\.)*"/,
						greedy: true
					},
					symbol: {
						pattern: /'[^()\[\]#'\s]+/,
						greedy: true
					},
					char: {
						pattern: /#\\(?:[ux][a-fA-F\d]+\b|[-a-zA-Z]+\b|[\uD800-\uDBFF][\uDC00-\uDFFF]|\S)/,
						greedy: true
					},
					'lambda-parameter': [
						{
							pattern: /((?:^|[^'`#])[(\[]lambda\s+)(?:[^|()\[\]'\s]+|\|(?:[^\\|]|\\.)*\|)/,
							lookbehind: true
						},
						{
							pattern: /((?:^|[^'`#])[(\[]lambda\s+[(\[])[^()\[\]']+/,
							lookbehind: true
						}
					],
					keyword: {
						pattern:
							/((?:^|[^'`#])[(\[])(?:begin|case(?:-lambda)?|cond(?:-expand)?|define(?:-library|-macro|-record-type|-syntax|-values)?|defmacro|delay(?:-force)?|do|else|except|export|guard|if|import|include(?:-ci|-library-declarations)?|lambda|let(?:rec)?(?:-syntax|-values|\*)?|let\*-values|only|parameterize|prefix|(?:quasi-?)?quote|rename|set!|syntax-(?:case|rules)|unless|unquote(?:-splicing)?|when)(?=[()\[\]\s]|$)/,
						lookbehind: true
					},
					builtin: {
						pattern:
							/((?:^|[^'`#])[(\[])(?:abs|and|append|apply|assoc|ass[qv]|binary-port\?|boolean=?\?|bytevector(?:-append|-copy|-copy!|-length|-u8-ref|-u8-set!|\?)?|caar|cadr|call-with-(?:current-continuation|port|values)|call\/cc|car|cdar|cddr|cdr|ceiling|char(?:->integer|-ready\?|\?|<\?|<=\?|=\?|>\?|>=\?)|close-(?:input-port|output-port|port)|complex\?|cons|current-(?:error|input|output)-port|denominator|dynamic-wind|eof-object\??|eq\?|equal\?|eqv\?|error|error-object(?:-irritants|-message|\?)|eval|even\?|exact(?:-integer-sqrt|-integer\?|\?)?|expt|features|file-error\?|floor(?:-quotient|-remainder|\/)?|flush-output-port|for-each|gcd|get-output-(?:bytevector|string)|inexact\??|input-port(?:-open\?|\?)|integer(?:->char|\?)|lcm|length|list(?:->string|->vector|-copy|-ref|-set!|-tail|\?)?|make-(?:bytevector|list|parameter|string|vector)|map|max|member|memq|memv|min|modulo|negative\?|newline|not|null\?|number(?:->string|\?)|numerator|odd\?|open-(?:input|output)-(?:bytevector|string)|or|output-port(?:-open\?|\?)|pair\?|peek-char|peek-u8|port\?|positive\?|procedure\?|quotient|raise|raise-continuable|rational\?|rationalize|read-(?:bytevector|bytevector!|char|error\?|line|string|u8)|real\?|remainder|reverse|round|set-c[ad]r!|square|string(?:->list|->number|->symbol|->utf8|->vector|-append|-copy|-copy!|-fill!|-for-each|-length|-map|-ref|-set!|\?|<\?|<=\?|=\?|>\?|>=\?)?|substring|symbol(?:->string|\?|=\?)|syntax-error|textual-port\?|truncate(?:-quotient|-remainder|\/)?|u8-ready\?|utf8->string|values|vector(?:->list|->string|-append|-copy|-copy!|-fill!|-for-each|-length|-map|-ref|-set!|\?)?|with-exception-handler|write-(?:bytevector|char|string|u8)|zero\?)(?=[()\[\]\s]|$)/,
						lookbehind: true
					},
					operator: {
						pattern: /((?:^|[^'`#])[(\[])(?:[-+*%/]|[<>]=?|=>?)(?=[()\[\]\s]|$)/,
						lookbehind: true
					},
					number: {
						pattern: RegExp(
							SortedBNF({
								'<ureal dec>': /\d+(?:\/\d+)|(?:\d+(?:\.\d*)?|\.\d+)(?:[esfdl][+-]?\d+)?/.source,
								'<real dec>': /[+-]?<ureal dec>|[+-](?:inf|nan)\.0/.source,
								'<imaginary dec>': /[+-](?:<ureal dec>|(?:inf|nan)\.0)?i/.source,
								'<complex dec>': /<real dec>(?:@<real dec>|<imaginary dec>)?|<imaginary dec>/
									.source,
								'<num dec>': /(?:#d(?:#[ei])?|#[ei](?:#d)?)?<complex dec>/.source,
								'<ureal box>': /[0-9a-f]+(?:\/[0-9a-f]+)?/.source,
								'<real box>': /[+-]?<ureal box>|[+-](?:inf|nan)\.0/.source,
								'<imaginary box>': /[+-](?:<ureal box>|(?:inf|nan)\.0)?i/.source,
								'<complex box>': /<real box>(?:@<real box>|<imaginary box>)?|<imaginary box>/
									.source,
								'<num box>': /#[box](?:#[ei])?|(?:#[ei])?#[box]<complex box>/.source,
								'<number>': /(^|[()\[\]\s])(?:<num dec>|<num box>)(?=[()\[\]\s]|$)/.source
							}),
							'i'
						),
						lookbehind: true
					},
					boolean: {
						pattern: /(^|[()\[\]\s])#(?:[ft]|false|true)(?=[()\[\]\s]|$)/,
						lookbehind: true
					},
					function: {
						pattern: /((?:^|[^'`#])[(\[])(?:[^|()\[\]'\s]+|\|(?:[^\\|]|\\.)*\|)(?=[()\[\]\s]|$)/,
						lookbehind: true
					},
					identifier: {
						pattern: /(^|[()\[\]\s])\|(?:[^\\|]|\\.)*\|(?=[()\[\]\s]|$)/,
						lookbehind: true,
						greedy: true
					},
					punctuation: /[()\[\]']/
				};
				function SortedBNF(grammar) {
					for (var key3 in grammar) {
						grammar[key3] = grammar[key3].replace(/<[\w\s]+>/g, function (key4) {
							return '(?:' + grammar[key4].trim() + ')';
						});
					}
					return grammar[key3];
				}
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/lilypond.js
var require_lilypond = __commonJS({
	'node_modules/refractor/lang/lilypond.js'(exports, module2) {
		'use strict';
		var refractorScheme = require_scheme();
		module2.exports = lilypond;
		lilypond.displayName = 'lilypond';
		lilypond.aliases = [];
		function lilypond(Prism) {
			Prism.register(refractorScheme);
			(function (Prism2) {
				var schemeExpression =
					/\((?:[^();"#\\]|\\[\s\S]|;.*(?!.)|"(?:[^"\\]|\\.)*"|#(?:\{(?:(?!#\})[\s\S])*#\}|[^{])|<expr>)*\)/
						.source;
				var recursivenessLog2 = 5;
				for (var i2 = 0; i2 < recursivenessLog2; i2++) {
					schemeExpression = schemeExpression.replace(/<expr>/g, function () {
						return schemeExpression;
					});
				}
				schemeExpression = schemeExpression.replace(/<expr>/g, /[^\s\S]/.source);
				var lilypond2 = (Prism2.languages.lilypond = {
					comment: /%(?:(?!\{).*|\{[\s\S]*?%\})/,
					'embedded-scheme': {
						pattern: RegExp(
							/(^|[=\s])#(?:"(?:[^"\\]|\\.)*"|[^\s()"]*(?:[^\s()]|<expr>))/.source.replace(
								/<expr>/g,
								function () {
									return schemeExpression;
								}
							),
							'm'
						),
						lookbehind: true,
						greedy: true,
						inside: {
							scheme: {
								pattern: /^(#)[\s\S]+$/,
								lookbehind: true,
								alias: 'language-scheme',
								inside: {
									'embedded-lilypond': {
										pattern: /#\{[\s\S]*?#\}/,
										greedy: true,
										inside: {
											punctuation: /^#\{|#\}$/,
											lilypond: {
												pattern: /[\s\S]+/,
												alias: 'language-lilypond',
												inside: null
											}
										}
									},
									rest: Prism2.languages.scheme
								}
							},
							punctuation: /#/
						}
					},
					string: {
						pattern: /"(?:[^"\\]|\\.)*"/,
						greedy: true
					},
					'class-name': {
						pattern: /(\\new\s+)[\w-]+/,
						lookbehind: true
					},
					keyword: {
						pattern: /\\[a-z][-\w]*/i,
						inside: {
							punctuation: /^\\/
						}
					},
					operator: /[=|]|<<|>>/,
					punctuation: {
						pattern:
							/(^|[a-z\d])(?:'+|,+|[_^]?-[_^]?(?:[-+^!>._]|(?=\d))|[_^]\.?|[.!])|[{}()[\]<>^~]|\\[()[\]<>\\!]|--|__/,
						lookbehind: true
					},
					number: /\b\d+(?:\/\d+)?\b/
				});
				lilypond2['embedded-scheme'].inside['scheme'].inside['embedded-lilypond'].inside[
					'lilypond'
				].inside = lilypond2;
				Prism2.languages.ly = lilypond2;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/liquid.js
var require_liquid = __commonJS({
	'node_modules/refractor/lang/liquid.js'(exports, module2) {
		'use strict';
		var refractorMarkupTemplating = require_markup_templating();
		module2.exports = liquid;
		liquid.displayName = 'liquid';
		liquid.aliases = [];
		function liquid(Prism) {
			Prism.register(refractorMarkupTemplating);
			Prism.languages.liquid = {
				comment: {
					pattern: /(^\{%\s*comment\s*%\})[\s\S]+(?=\{%\s*endcomment\s*%\}$)/,
					lookbehind: true
				},
				delimiter: {
					pattern: /^\{(?:\{\{|[%\{])-?|-?(?:\}\}|[%\}])\}$/,
					alias: 'punctuation'
				},
				string: {
					pattern: /"[^"]*"|'[^']*'/,
					greedy: true
				},
				keyword:
					/\b(?:as|assign|break|(?:end)?(?:capture|case|comment|for|form|if|paginate|raw|style|tablerow|unless)|continue|cycle|decrement|echo|else|elsif|in|include|increment|limit|liquid|offset|range|render|reversed|section|when|with)\b/,
				object:
					/\b(?:address|all_country_option_tags|article|block|blog|cart|checkout|collection|color|country|country_option_tags|currency|current_page|current_tags|customer|customer_address|date|discount_allocation|discount_application|external_video|filter|filter_value|font|forloop|fulfillment|generic_file|gift_card|group|handle|image|line_item|link|linklist|localization|location|measurement|media|metafield|model|model_source|order|page|page_description|page_image|page_title|part|policy|product|product_option|recommendations|request|robots|routes|rule|script|search|selling_plan|selling_plan_allocation|selling_plan_group|shipping_method|shop|shop_locale|sitemap|store_availability|tax_line|template|theme|transaction|unit_price_measurement|user_agent|variant|video|video_source)\b/,
				function: [
					{
						pattern: /(\|\s*)\w+/,
						lookbehind: true,
						alias: 'filter'
					},
					{
						pattern: /(\.\s*)(?:first|last|size)/,
						lookbehind: true
					}
				],
				boolean: /\b(?:false|nil|true)\b/,
				range: {
					pattern: /\.\./,
					alias: 'operator'
				},
				number: /\b\d+(?:\.\d+)?\b/,
				operator: /[!=]=|<>|[<>]=?|[|?:=-]|\b(?:and|contains(?=\s)|or)\b/,
				punctuation: /[.,\[\]()]/,
				empty: {
					pattern: /\bempty\b/,
					alias: 'keyword'
				}
			};
			Prism.hooks.add('before-tokenize', function (env) {
				var liquidPattern =
					/\{%\s*comment\s*%\}[\s\S]*?\{%\s*endcomment\s*%\}|\{(?:%[\s\S]*?%|\{\{[\s\S]*?\}\}|\{[\s\S]*?\})\}/g;
				var insideRaw = false;
				Prism.languages['markup-templating'].buildPlaceholders(
					env,
					'liquid',
					liquidPattern,
					function (match) {
						var tagMatch = /^\{%-?\s*(\w+)/.exec(match);
						if (tagMatch) {
							var tag = tagMatch[1];
							if (tag === 'raw' && !insideRaw) {
								insideRaw = true;
								return true;
							} else if (tag === 'endraw') {
								insideRaw = false;
								return true;
							}
						}
						return !insideRaw;
					}
				);
			});
			Prism.hooks.add('after-tokenize', function (env) {
				Prism.languages['markup-templating'].tokenizePlaceholders(env, 'liquid');
			});
		}
	}
});

// node_modules/refractor/lang/lisp.js
var require_lisp = __commonJS({
	'node_modules/refractor/lang/lisp.js'(exports, module2) {
		'use strict';
		module2.exports = lisp;
		lisp.displayName = 'lisp';
		lisp.aliases = [];
		function lisp(Prism) {
			(function (Prism2) {
				function simple_form(name) {
					return RegExp(/(\()/.source + '(?:' + name + ')' + /(?=[\s\)])/.source);
				}
				function primitive(pattern) {
					return RegExp(/([\s([])/.source + '(?:' + pattern + ')' + /(?=[\s)])/.source);
				}
				var symbol = /(?!\d)[-+*/~!@$%^=<>{}\w]+/.source;
				var marker = '&' + symbol;
				var par = '(\\()';
				var endpar = '(?=\\))';
				var space = '(?=\\s)';
				var nestedPar =
					/(?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\))*\))*\))*/
						.source;
				var language = {
					heading: {
						pattern: /;;;.*/,
						alias: ['comment', 'title']
					},
					comment: /;.*/,
					string: {
						pattern: /"(?:[^"\\]|\\.)*"/,
						greedy: true,
						inside: {
							argument: /[-A-Z]+(?=[.,\s])/,
							symbol: RegExp('`' + symbol + "'")
						}
					},
					'quoted-symbol': {
						pattern: RegExp("#?'" + symbol),
						alias: ['variable', 'symbol']
					},
					'lisp-property': {
						pattern: RegExp(':' + symbol),
						alias: 'property'
					},
					splice: {
						pattern: RegExp(',@?' + symbol),
						alias: ['symbol', 'variable']
					},
					keyword: [
						{
							pattern: RegExp(
								par +
									'(?:and|(?:cl-)?letf|cl-loop|cond|cons|error|if|(?:lexical-)?let\\*?|message|not|null|or|provide|require|setq|unless|use-package|when|while)' +
									space
							),
							lookbehind: true
						},
						{
							pattern: RegExp(
								par + '(?:append|by|collect|concat|do|finally|for|in|return)' + space
							),
							lookbehind: true
						}
					],
					declare: {
						pattern: simple_form(/declare/.source),
						lookbehind: true,
						alias: 'keyword'
					},
					interactive: {
						pattern: simple_form(/interactive/.source),
						lookbehind: true,
						alias: 'keyword'
					},
					boolean: {
						pattern: primitive(/nil|t/.source),
						lookbehind: true
					},
					number: {
						pattern: primitive(/[-+]?\d+(?:\.\d*)?/.source),
						lookbehind: true
					},
					defvar: {
						pattern: RegExp(par + 'def(?:const|custom|group|var)\\s+' + symbol),
						lookbehind: true,
						inside: {
							keyword: /^def[a-z]+/,
							variable: RegExp(symbol)
						}
					},
					defun: {
						pattern: RegExp(
							par +
								/(?:cl-)?(?:defmacro|defun\*?)\s+/.source +
								symbol +
								/\s+\(/.source +
								nestedPar +
								/\)/.source
						),
						lookbehind: true,
						greedy: true,
						inside: {
							keyword: /^(?:cl-)?def\S+/,
							arguments: null,
							function: {
								pattern: RegExp('(^\\s)' + symbol),
								lookbehind: true
							},
							punctuation: /[()]/
						}
					},
					lambda: {
						pattern: RegExp(
							par + 'lambda\\s+\\(\\s*(?:&?' + symbol + '(?:\\s+&?' + symbol + ')*\\s*)?\\)'
						),
						lookbehind: true,
						greedy: true,
						inside: {
							keyword: /^lambda/,
							arguments: null,
							punctuation: /[()]/
						}
					},
					car: {
						pattern: RegExp(par + symbol),
						lookbehind: true
					},
					punctuation: [
						/(?:['`,]?\(|[)\[\]])/,
						{
							pattern: /(\s)\.(?=\s)/,
							lookbehind: true
						}
					]
				};
				var arg = {
					'lisp-marker': RegExp(marker),
					varform: {
						pattern: RegExp(/\(/.source + symbol + /\s+(?=\S)/.source + nestedPar + /\)/.source),
						inside: language
					},
					argument: {
						pattern: RegExp(/(^|[\s(])/.source + symbol),
						lookbehind: true,
						alias: 'variable'
					},
					rest: language
				};
				var forms = '\\S+(?:\\s+\\S+)*';
				var arglist = {
					pattern: RegExp(par + nestedPar + endpar),
					lookbehind: true,
					inside: {
						'rest-vars': {
							pattern: RegExp('&(?:body|rest)\\s+' + forms),
							inside: arg
						},
						'other-marker-vars': {
							pattern: RegExp('&(?:aux|optional)\\s+' + forms),
							inside: arg
						},
						keys: {
							pattern: RegExp('&key\\s+' + forms + '(?:\\s+&allow-other-keys)?'),
							inside: arg
						},
						argument: {
							pattern: RegExp(symbol),
							alias: 'variable'
						},
						punctuation: /[()]/
					}
				};
				language['lambda'].inside.arguments = arglist;
				language['defun'].inside.arguments = Prism2.util.clone(arglist);
				language['defun'].inside.arguments.inside.sublist = arglist;
				Prism2.languages.lisp = language;
				Prism2.languages.elisp = language;
				Prism2.languages.emacs = language;
				Prism2.languages['emacs-lisp'] = language;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/livescript.js
var require_livescript = __commonJS({
	'node_modules/refractor/lang/livescript.js'(exports, module2) {
		'use strict';
		module2.exports = livescript;
		livescript.displayName = 'livescript';
		livescript.aliases = [];
		function livescript(Prism) {
			Prism.languages.livescript = {
				comment: [
					{
						pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
						lookbehind: true
					},
					{
						pattern: /(^|[^\\])#.*/,
						lookbehind: true
					}
				],
				'interpolated-string': {
					pattern: /(^|[^"])("""|")(?:\\[\s\S]|(?!\2)[^\\])*\2(?!")/,
					lookbehind: true,
					greedy: true,
					inside: {
						variable: {
							pattern: /(^|[^\\])#[a-z_](?:-?[a-z]|[\d_])*/m,
							lookbehind: true
						},
						interpolation: {
							pattern: /(^|[^\\])#\{[^}]+\}/m,
							lookbehind: true,
							inside: {
								'interpolation-punctuation': {
									pattern: /^#\{|\}$/,
									alias: 'variable'
								}
							}
						},
						string: /[\s\S]+/
					}
				},
				string: [
					{
						pattern: /('''|')(?:\\[\s\S]|(?!\1)[^\\])*\1/,
						greedy: true
					},
					{
						pattern: /<\[[\s\S]*?\]>/,
						greedy: true
					},
					/\\[^\s,;\])}]+/
				],
				regex: [
					{
						pattern: /\/\/(?:\[[^\r\n\]]*\]|\\.|(?!\/\/)[^\\\[])+\/\/[gimyu]{0,5}/,
						greedy: true,
						inside: {
							comment: {
								pattern: /(^|[^\\])#.*/,
								lookbehind: true
							}
						}
					},
					{
						pattern: /\/(?:\[[^\r\n\]]*\]|\\.|[^/\\\r\n\[])+\/[gimyu]{0,5}/,
						greedy: true
					}
				],
				keyword: {
					pattern:
						/(^|(?!-).)\b(?:break|case|catch|class|const|continue|default|do|else|extends|fallthrough|finally|for(?: ever)?|function|if|implements|it|let|loop|new|null|otherwise|own|return|super|switch|that|then|this|throw|try|unless|until|var|void|when|while|yield)(?!-)\b/m,
					lookbehind: true
				},
				'keyword-operator': {
					pattern:
						/(^|[^-])\b(?:(?:delete|require|typeof)!|(?:and|by|delete|export|from|import(?: all)?|in|instanceof|is(?: not|nt)?|not|of|or|til|to|typeof|with|xor)(?!-)\b)/m,
					lookbehind: true,
					alias: 'operator'
				},
				boolean: {
					pattern: /(^|[^-])\b(?:false|no|off|on|true|yes)(?!-)\b/m,
					lookbehind: true
				},
				argument: {
					pattern: /(^|(?!\.&\.)[^&])&(?!&)\d*/m,
					lookbehind: true,
					alias: 'variable'
				},
				number: /\b(?:\d+~[\da-z]+|\d[\d_]*(?:\.\d[\d_]*)?(?:[a-z]\w*)?)/i,
				identifier: /[a-z_](?:-?[a-z]|[\d_])*/i,
				operator: [
					{
						pattern: /( )\.(?= )/,
						lookbehind: true
					},
					/\.(?:[=~]|\.\.?)|\.(?:[&|^]|<<|>>>?)\.|:(?:=|:=?)|&&|\|[|>]|<(?:<<?<?|--?!?|~~?!?|[|=?])?|>[>=?]?|-(?:->?|>)?|\+\+?|@@?|%%?|\*\*?|!(?:~?=|--?>|~?~>)?|~(?:~?>|=)?|==?|\^\^?|[\/?]/
				],
				punctuation: /[(){}\[\]|.,:;`]/
			};
			Prism.languages.livescript['interpolated-string'].inside['interpolation'].inside.rest =
				Prism.languages.livescript;
		}
	}
});

// node_modules/refractor/lang/llvm.js
var require_llvm = __commonJS({
	'node_modules/refractor/lang/llvm.js'(exports, module2) {
		'use strict';
		module2.exports = llvm;
		llvm.displayName = 'llvm';
		llvm.aliases = [];
		function llvm(Prism) {
			(function (Prism2) {
				Prism2.languages.llvm = {
					comment: /;.*/,
					string: {
						pattern: /"[^"]*"/,
						greedy: true
					},
					boolean: /\b(?:false|true)\b/,
					variable: /[%@!#](?:(?!\d)(?:[-$.\w]|\\[a-f\d]{2})+|\d+)/i,
					label: /(?!\d)(?:[-$.\w]|\\[a-f\d]{2})+:/i,
					type: {
						pattern:
							/\b(?:double|float|fp128|half|i[1-9]\d*|label|metadata|ppc_fp128|token|void|x86_fp80|x86_mmx)\b/,
						alias: 'class-name'
					},
					keyword: /\b[a-z_][a-z_0-9]*\b/,
					number:
						/[+-]?\b\d+(?:\.\d+)?(?:[eE][+-]?\d+)?\b|\b0x[\dA-Fa-f]+\b|\b0xK[\dA-Fa-f]{20}\b|\b0x[ML][\dA-Fa-f]{32}\b|\b0xH[\dA-Fa-f]{4}\b/,
					punctuation: /[{}[\];(),.!*=<>]/
				};
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/log.js
var require_log = __commonJS({
	'node_modules/refractor/lang/log.js'(exports, module2) {
		'use strict';
		module2.exports = log;
		log.displayName = 'log';
		log.aliases = [];
		function log(Prism) {
			Prism.languages.log = {
				string: {
					pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?![st] | \w)(?:[^'\\\r\n]|\\.)*'/,
					greedy: true
				},
				exception: {
					pattern:
						/(^|[^\w.])[a-z][\w.]*(?:Error|Exception):.*(?:(?:\r\n?|\n)[ \t]*(?:at[ \t].+|\.{3}.*|Caused by:.*))+(?:(?:\r\n?|\n)[ \t]*\.\.\. .*)?/,
					lookbehind: true,
					greedy: true,
					alias: ['javastacktrace', 'language-javastacktrace'],
					inside: Prism.languages['javastacktrace'] || {
						keyword: /\bat\b/,
						function: /[a-z_][\w$]*(?=\()/,
						punctuation: /[.:()]/
					}
				},
				level: [
					{
						pattern: /\b(?:ALERT|CRIT|CRITICAL|EMERG|EMERGENCY|ERR|ERROR|FAILURE|FATAL|SEVERE)\b/,
						alias: ['error', 'important']
					},
					{
						pattern: /\b(?:WARN|WARNING|WRN)\b/,
						alias: ['warning', 'important']
					},
					{
						pattern: /\b(?:DISPLAY|INF|INFO|NOTICE|STATUS)\b/,
						alias: ['info', 'keyword']
					},
					{
						pattern: /\b(?:DBG|DEBUG|FINE)\b/,
						alias: ['debug', 'keyword']
					},
					{
						pattern: /\b(?:FINER|FINEST|TRACE|TRC|VERBOSE|VRB)\b/,
						alias: ['trace', 'comment']
					}
				],
				property: {
					pattern:
						/((?:^|[\]|])[ \t]*)[a-z_](?:[\w-]|\b\/\b)*(?:[. ]\(?\w(?:[\w-]|\b\/\b)*\)?)*:(?=\s)/im,
					lookbehind: true
				},
				separator: {
					pattern: /(^|[^-+])-{3,}|={3,}|\*{3,}|- - /m,
					lookbehind: true,
					alias: 'comment'
				},
				url: /\b(?:file|ftp|https?):\/\/[^\s|,;'"]*[^\s|,;'">.]/,
				email: {
					pattern: /(^|\s)[-\w+.]+@[a-z][a-z0-9-]*(?:\.[a-z][a-z0-9-]*)+(?=\s)/,
					lookbehind: true,
					alias: 'url'
				},
				'ip-address': {
					pattern: /\b(?:\d{1,3}(?:\.\d{1,3}){3})\b/,
					alias: 'constant'
				},
				'mac-address': {
					pattern: /\b[a-f0-9]{2}(?::[a-f0-9]{2}){5}\b/i,
					alias: 'constant'
				},
				domain: {
					pattern: /(^|\s)[a-z][a-z0-9-]*(?:\.[a-z][a-z0-9-]*)*\.[a-z][a-z0-9-]+(?=\s)/,
					lookbehind: true,
					alias: 'constant'
				},
				uuid: {
					pattern: /\b[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}\b/i,
					alias: 'constant'
				},
				hash: {
					pattern: /\b(?:[a-f0-9]{32}){1,2}\b/i,
					alias: 'constant'
				},
				'file-path': {
					pattern:
						/\b[a-z]:[\\/][^\s|,;:(){}\[\]"']+|(^|[\s:\[\](>|])\.{0,2}\/\w[^\s|,;:(){}\[\]"']*/i,
					lookbehind: true,
					greedy: true,
					alias: 'string'
				},
				date: {
					pattern: RegExp(
						/\b\d{4}[-/]\d{2}[-/]\d{2}(?:T(?=\d{1,2}:)|(?=\s\d{1,2}:))/.source +
							'|' +
							/\b\d{1,4}[-/ ](?:\d{1,2}|Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)[-/ ]\d{2,4}T?\b/
								.source +
							'|' +
							/\b(?:(?:Fri|Mon|Sat|Sun|Thu|Tue|Wed)(?:\s{1,2}(?:Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep))?|Apr|Aug|Dec|Feb|Jan|Jul|Jun|Mar|May|Nov|Oct|Sep)\s{1,2}\d{1,2}\b/
								.source,
						'i'
					),
					alias: 'number'
				},
				time: {
					pattern: /\b\d{1,2}:\d{1,2}:\d{1,2}(?:[.,:]\d+)?(?:\s?[+-]\d{2}:?\d{2}|Z)?\b/,
					alias: 'number'
				},
				boolean: /\b(?:false|null|true)\b/i,
				number: {
					pattern:
						/(^|[^.\w])(?:0x[a-f0-9]+|0o[0-7]+|0b[01]+|v?\d[\da-f]*(?:\.\d+)*(?:e[+-]?\d+)?[a-z]{0,3}\b)\b(?!\.\w)/i,
					lookbehind: true
				},
				operator: /[;:?<=>~/@!$%&+\-|^(){}*#]/,
				punctuation: /[\[\].,]/
			};
		}
	}
});

// node_modules/refractor/lang/lolcode.js
var require_lolcode = __commonJS({
	'node_modules/refractor/lang/lolcode.js'(exports, module2) {
		'use strict';
		module2.exports = lolcode;
		lolcode.displayName = 'lolcode';
		lolcode.aliases = [];
		function lolcode(Prism) {
			Prism.languages.lolcode = {
				comment: [/\bOBTW\s[\s\S]*?\sTLDR\b/, /\bBTW.+/],
				string: {
					pattern: /"(?::.|[^":])*"/,
					inside: {
						variable: /:\{[^}]+\}/,
						symbol: [/:\([a-f\d]+\)/i, /:\[[^\]]+\]/, /:[)>o":]/]
					},
					greedy: true
				},
				number: /(?:\B-)?(?:\b\d+(?:\.\d*)?|\B\.\d+)/,
				symbol: {
					pattern: /(^|\s)(?:A )?(?:BUKKIT|NOOB|NUMBAR|NUMBR|TROOF|YARN)(?=\s|,|$)/,
					lookbehind: true,
					inside: {
						keyword: /A(?=\s)/
					}
				},
				label: {
					pattern: /((?:^|\s)(?:IM IN YR|IM OUTTA YR) )[a-zA-Z]\w*/,
					lookbehind: true,
					alias: 'string'
				},
				function: {
					pattern: /((?:^|\s)(?:HOW IZ I|I IZ|IZ) )[a-zA-Z]\w*/,
					lookbehind: true
				},
				keyword: [
					{
						pattern:
							/(^|\s)(?:AN|FOUND YR|GIMMEH|GTFO|HAI|HAS A|HOW IZ I|I HAS A|I IZ|IF U SAY SO|IM IN YR|IM OUTTA YR|IS NOW(?: A)?|ITZ(?: A)?|IZ|KTHX|KTHXBYE|LIEK(?: A)?|MAEK|MEBBE|MKAY|NERFIN|NO WAI|O HAI IM|O RLY\?|OIC|OMG|OMGWTF|R|SMOOSH|SRS|TIL|UPPIN|VISIBLE|WILE|WTF\?|YA RLY|YR)(?=\s|,|$)/,
						lookbehind: true
					},
					/'Z(?=\s|,|$)/
				],
				boolean: {
					pattern: /(^|\s)(?:FAIL|WIN)(?=\s|,|$)/,
					lookbehind: true
				},
				variable: {
					pattern: /(^|\s)IT(?=\s|,|$)/,
					lookbehind: true
				},
				operator: {
					pattern:
						/(^|\s)(?:NOT|BOTH SAEM|DIFFRINT|(?:ALL|ANY|BIGGR|BOTH|DIFF|EITHER|MOD|PRODUKT|QUOSHUNT|SMALLR|SUM|WON) OF)(?=\s|,|$)/,
					lookbehind: true
				},
				punctuation: /\.{3}||,|!/
			};
		}
	}
});

// node_modules/refractor/lang/magma.js
var require_magma = __commonJS({
	'node_modules/refractor/lang/magma.js'(exports, module2) {
		'use strict';
		module2.exports = magma;
		magma.displayName = 'magma';
		magma.aliases = [];
		function magma(Prism) {
			Prism.languages.magma = {
				output: {
					pattern:
						/^(>.*(?:\r(?:\n|(?!\n))|\n))(?!>)(?:.+|(?:\r(?:\n|(?!\n))|\n)(?!>).*)(?:(?:\r(?:\n|(?!\n))|\n)(?!>).*)*/m,
					lookbehind: true,
					greedy: true
				},
				comment: {
					pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
					greedy: true
				},
				string: {
					pattern: /(^|[^\\"])"(?:[^\r\n\\"]|\\.)*"/,
					lookbehind: true,
					greedy: true
				},
				keyword:
					/\b(?:_|adj|and|assert|assert2|assert3|assigned|break|by|case|cat|catch|clear|cmpeq|cmpne|continue|declare|default|delete|diff|div|do|elif|else|end|eq|error|eval|exists|exit|for|forall|forward|fprintf|freeze|function|ge|gt|if|iload|import|in|intrinsic|is|join|le|load|local|lt|meet|mod|ne|not|notadj|notin|notsubset|or|print|printf|procedure|quit|random|read|readi|repeat|require|requirege|requirerange|restore|return|save|sdiff|select|subset|then|time|to|try|until|vprint|vprintf|vtime|when|where|while|xor)\b/,
				boolean: /\b(?:false|true)\b/,
				generator: {
					pattern: /\b[a-z_]\w*(?=\s*<)/i,
					alias: 'class-name'
				},
				function: /\b[a-z_]\w*(?=\s*\()/i,
				number: {
					pattern:
						/(^|[^\w.]|\.\.)(?:\d+(?:\.\d*)?|\.\d+)(?:[eE][+-]?\d+)?(?:_[a-z]?)?(?=$|[^\w.]|\.\.)/,
					lookbehind: true
				},
				operator: /->|[-+*/^~!|#=]|:=|\.\./,
				punctuation: /[()[\]{}<>,;.:]/
			};
		}
	}
});

// node_modules/refractor/lang/makefile.js
var require_makefile = __commonJS({
	'node_modules/refractor/lang/makefile.js'(exports, module2) {
		'use strict';
		module2.exports = makefile;
		makefile.displayName = 'makefile';
		makefile.aliases = [];
		function makefile(Prism) {
			Prism.languages.makefile = {
				comment: {
					pattern: /(^|[^\\])#(?:\\(?:\r\n|[\s\S])|[^\\\r\n])*/,
					lookbehind: true
				},
				string: {
					pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
					greedy: true
				},
				'builtin-target': {
					pattern: /\.[A-Z][^:#=\s]+(?=\s*:(?!=))/,
					alias: 'builtin'
				},
				target: {
					pattern: /^(?:[^:=\s]|[ \t]+(?![\s:]))+(?=\s*:(?!=))/m,
					alias: 'symbol',
					inside: {
						variable: /\$+(?:(?!\$)[^(){}:#=\s]+|(?=[({]))/
					}
				},
				variable: /\$+(?:(?!\$)[^(){}:#=\s]+|\([@*%<^+?][DF]\)|(?=[({]))/,
				keyword:
					/-include\b|\b(?:define|else|endef|endif|export|ifn?def|ifn?eq|include|override|private|sinclude|undefine|unexport|vpath)\b/,
				function: {
					pattern:
						/(\()(?:abspath|addsuffix|and|basename|call|dir|error|eval|file|filter(?:-out)?|findstring|firstword|flavor|foreach|guile|if|info|join|lastword|load|notdir|or|origin|patsubst|realpath|shell|sort|strip|subst|suffix|value|warning|wildcard|word(?:list|s)?)(?=[ \t])/,
					lookbehind: true
				},
				operator: /(?:::|[?:+!])?=|[|@]/,
				punctuation: /[:;(){}]/
			};
		}
	}
});

// node_modules/refractor/lang/markdown.js
var require_markdown = __commonJS({
	'node_modules/refractor/lang/markdown.js'(exports, module2) {
		'use strict';
		module2.exports = markdown;
		markdown.displayName = 'markdown';
		markdown.aliases = ['md'];
		function markdown(Prism) {
			(function (Prism2) {
				var inner = /(?:\\.|[^\\\n\r]|(?:\n|\r\n?)(?![\r\n]))/.source;
				function createInline(pattern) {
					pattern = pattern.replace(/<inner>/g, function () {
						return inner;
					});
					return RegExp(/((?:^|[^\\])(?:\\{2})*)/.source + '(?:' + pattern + ')');
				}
				var tableCell = /(?:\\.|``(?:[^`\r\n]|`(?!`))+``|`[^`\r\n]+`|[^\\|\r\n`])+/.source;
				var tableRow = /\|?__(?:\|__)+\|?(?:(?:\n|\r\n?)|(?![\s\S]))/.source.replace(
					/__/g,
					function () {
						return tableCell;
					}
				);
				var tableLine = /\|?[ \t]*:?-{3,}:?[ \t]*(?:\|[ \t]*:?-{3,}:?[ \t]*)+\|?(?:\n|\r\n?)/
					.source;
				Prism2.languages.markdown = Prism2.languages.extend('markup', {});
				Prism2.languages.insertBefore('markdown', 'prolog', {
					'front-matter-block': {
						pattern: /(^(?:\s*[\r\n])?)---(?!.)[\s\S]*?[\r\n]---(?!.)/,
						lookbehind: true,
						greedy: true,
						inside: {
							punctuation: /^---|---$/,
							'front-matter': {
								pattern: /\S+(?:\s+\S+)*/,
								alias: ['yaml', 'language-yaml'],
								inside: Prism2.languages.yaml
							}
						}
					},
					blockquote: {
						pattern: /^>(?:[\t ]*>)*/m,
						alias: 'punctuation'
					},
					table: {
						pattern: RegExp('^' + tableRow + tableLine + '(?:' + tableRow + ')*', 'm'),
						inside: {
							'table-data-rows': {
								pattern: RegExp('^(' + tableRow + tableLine + ')(?:' + tableRow + ')*$'),
								lookbehind: true,
								inside: {
									'table-data': {
										pattern: RegExp(tableCell),
										inside: Prism2.languages.markdown
									},
									punctuation: /\|/
								}
							},
							'table-line': {
								pattern: RegExp('^(' + tableRow + ')' + tableLine + '$'),
								lookbehind: true,
								inside: {
									punctuation: /\||:?-{3,}:?/
								}
							},
							'table-header-row': {
								pattern: RegExp('^' + tableRow + '$'),
								inside: {
									'table-header': {
										pattern: RegExp(tableCell),
										alias: 'important',
										inside: Prism2.languages.markdown
									},
									punctuation: /\|/
								}
							}
						}
					},
					code: [
						{
							pattern:
								/((?:^|\n)[ \t]*\n|(?:^|\r\n?)[ \t]*\r\n?)(?: {4}|\t).+(?:(?:\n|\r\n?)(?: {4}|\t).+)*/,
							lookbehind: true,
							alias: 'keyword'
						},
						{
							pattern: /^```[\s\S]*?^```$/m,
							greedy: true,
							inside: {
								'code-block': {
									pattern: /^(```.*(?:\n|\r\n?))[\s\S]+?(?=(?:\n|\r\n?)^```$)/m,
									lookbehind: true
								},
								'code-language': {
									pattern: /^(```).+/,
									lookbehind: true
								},
								punctuation: /```/
							}
						}
					],
					title: [
						{
							pattern: /\S.*(?:\n|\r\n?)(?:==+|--+)(?=[ \t]*$)/m,
							alias: 'important',
							inside: {
								punctuation: /==+$|--+$/
							}
						},
						{
							pattern: /(^\s*)#.+/m,
							lookbehind: true,
							alias: 'important',
							inside: {
								punctuation: /^#+|#+$/
							}
						}
					],
					hr: {
						pattern: /(^\s*)([*-])(?:[\t ]*\2){2,}(?=\s*$)/m,
						lookbehind: true,
						alias: 'punctuation'
					},
					list: {
						pattern: /(^\s*)(?:[*+-]|\d+\.)(?=[\t ].)/m,
						lookbehind: true,
						alias: 'punctuation'
					},
					'url-reference': {
						pattern:
							/!?\[[^\]]+\]:[\t ]+(?:\S+|<(?:\\.|[^>\\])+>)(?:[\t ]+(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\)))?/,
						inside: {
							variable: {
								pattern: /^(!?\[)[^\]]+/,
								lookbehind: true
							},
							string: /(?:"(?:\\.|[^"\\])*"|'(?:\\.|[^'\\])*'|\((?:\\.|[^)\\])*\))$/,
							punctuation: /^[\[\]!:]|[<>]/
						},
						alias: 'url'
					},
					bold: {
						pattern: createInline(
							/\b__(?:(?!_)<inner>|_(?:(?!_)<inner>)+_)+__\b|\*\*(?:(?!\*)<inner>|\*(?:(?!\*)<inner>)+\*)+\*\*/
								.source
						),
						lookbehind: true,
						greedy: true,
						inside: {
							content: {
								pattern: /(^..)[\s\S]+(?=..$)/,
								lookbehind: true,
								inside: {}
							},
							punctuation: /\*\*|__/
						}
					},
					italic: {
						pattern: createInline(
							/\b_(?:(?!_)<inner>|__(?:(?!_)<inner>)+__)+_\b|\*(?:(?!\*)<inner>|\*\*(?:(?!\*)<inner>)+\*\*)+\*/
								.source
						),
						lookbehind: true,
						greedy: true,
						inside: {
							content: {
								pattern: /(^.)[\s\S]+(?=.$)/,
								lookbehind: true,
								inside: {}
							},
							punctuation: /[*_]/
						}
					},
					strike: {
						pattern: createInline(/(~~?)(?:(?!~)<inner>)+\2/.source),
						lookbehind: true,
						greedy: true,
						inside: {
							content: {
								pattern: /(^~~?)[\s\S]+(?=\1$)/,
								lookbehind: true,
								inside: {}
							},
							punctuation: /~~?/
						}
					},
					'code-snippet': {
						pattern: /(^|[^\\`])(?:``[^`\r\n]+(?:`[^`\r\n]+)*``(?!`)|`[^`\r\n]+`(?!`))/,
						lookbehind: true,
						greedy: true,
						alias: ['code', 'keyword']
					},
					url: {
						pattern: createInline(
							/!?\[(?:(?!\])<inner>)+\](?:\([^\s)]+(?:[\t ]+"(?:\\.|[^"\\])*")?\)|[ \t]?\[(?:(?!\])<inner>)+\])/
								.source
						),
						lookbehind: true,
						greedy: true,
						inside: {
							operator: /^!/,
							content: {
								pattern: /(^\[)[^\]]+(?=\])/,
								lookbehind: true,
								inside: {}
							},
							variable: {
								pattern: /(^\][ \t]?\[)[^\]]+(?=\]$)/,
								lookbehind: true
							},
							url: {
								pattern: /(^\]\()[^\s)]+/,
								lookbehind: true
							},
							string: {
								pattern: /(^[ \t]+)"(?:\\.|[^"\\])*"(?=\)$)/,
								lookbehind: true
							}
						}
					}
				});
				['url', 'bold', 'italic', 'strike'].forEach(function (token) {
					['url', 'bold', 'italic', 'strike', 'code-snippet'].forEach(function (inside) {
						if (token !== inside) {
							Prism2.languages.markdown[token].inside.content.inside[inside] =
								Prism2.languages.markdown[inside];
						}
					});
				});
				Prism2.hooks.add('after-tokenize', function (env) {
					if (env.language !== 'markdown' && env.language !== 'md') {
						return;
					}
					function walkTokens(tokens) {
						if (!tokens || typeof tokens === 'string') {
							return;
						}
						for (var i2 = 0, l = tokens.length; i2 < l; i2++) {
							var token = tokens[i2];
							if (token.type !== 'code') {
								walkTokens(token.content);
								continue;
							}
							var codeLang = token.content[1];
							var codeBlock = token.content[3];
							if (
								codeLang &&
								codeBlock &&
								codeLang.type === 'code-language' &&
								codeBlock.type === 'code-block' &&
								typeof codeLang.content === 'string'
							) {
								var lang = codeLang.content.replace(/\b#/g, 'sharp').replace(/\b\+\+/g, 'pp');
								lang = (/[a-z][\w-]*/i.exec(lang) || [''])[0].toLowerCase();
								var alias = 'language-' + lang;
								if (!codeBlock.alias) {
									codeBlock.alias = [alias];
								} else if (typeof codeBlock.alias === 'string') {
									codeBlock.alias = [codeBlock.alias, alias];
								} else {
									codeBlock.alias.push(alias);
								}
							}
						}
					}
					walkTokens(env.tokens);
				});
				Prism2.hooks.add('wrap', function (env) {
					if (env.type !== 'code-block') {
						return;
					}
					var codeLang = '';
					for (var i2 = 0, l = env.classes.length; i2 < l; i2++) {
						var cls = env.classes[i2];
						var match = /language-(.+)/.exec(cls);
						if (match) {
							codeLang = match[1];
							break;
						}
					}
					var grammar = Prism2.languages[codeLang];
					if (!grammar) {
						if (codeLang && codeLang !== 'none' && Prism2.plugins.autoloader) {
							var id = 'md-' + new Date().valueOf() + '-' + Math.floor(Math.random() * 1e16);
							env.attributes['id'] = id;
							Prism2.plugins.autoloader.loadLanguages(codeLang, function () {
								var ele = document.getElementById(id);
								if (ele) {
									ele.innerHTML = Prism2.highlight(
										ele.textContent,
										Prism2.languages[codeLang],
										codeLang
									);
								}
							});
						}
					} else {
						env.content = Prism2.highlight(textContent(env.content.value), grammar, codeLang);
					}
				});
				var tagPattern = RegExp(Prism2.languages.markup.tag.pattern.source, 'gi');
				var KNOWN_ENTITY_NAMES = {
					amp: '&',
					lt: '<',
					gt: '>',
					quot: '"'
				};
				var fromCodePoint = String.fromCodePoint || String.fromCharCode;
				function textContent(html9) {
					var text7 = html9.replace(tagPattern, '');
					text7 = text7.replace(/&(\w{1,8}|#x?[\da-f]{1,8});/gi, function (m2, code3) {
						code3 = code3.toLowerCase();
						if (code3[0] === '#') {
							var value;
							if (code3[1] === 'x') {
								value = parseInt(code3.slice(2), 16);
							} else {
								value = Number(code3.slice(1));
							}
							return fromCodePoint(value);
						} else {
							var known = KNOWN_ENTITY_NAMES[code3];
							if (known) {
								return known;
							}
							return m2;
						}
					});
					return text7;
				}
				Prism2.languages.md = Prism2.languages.markdown;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/matlab.js
var require_matlab = __commonJS({
	'node_modules/refractor/lang/matlab.js'(exports, module2) {
		'use strict';
		module2.exports = matlab;
		matlab.displayName = 'matlab';
		matlab.aliases = [];
		function matlab(Prism) {
			Prism.languages.matlab = {
				comment: [/%\{[\s\S]*?\}%/, /%.+/],
				string: {
					pattern: /\B'(?:''|[^'\r\n])*'/,
					greedy: true
				},
				number: /(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[eE][+-]?\d+)?(?:[ij])?|\b[ij]\b/,
				keyword:
					/\b(?:NaN|break|case|catch|continue|else|elseif|end|for|function|if|inf|otherwise|parfor|pause|pi|return|switch|try|while)\b/,
				function: /\b(?!\d)\w+(?=\s*\()/,
				operator: /\.?[*^\/\\']|[+\-:@]|[<>=~]=?|&&?|\|\|?/,
				punctuation: /\.{3}|[.,;\[\](){}!]/
			};
		}
	}
});

// node_modules/refractor/lang/maxscript.js
var require_maxscript = __commonJS({
	'node_modules/refractor/lang/maxscript.js'(exports, module2) {
		'use strict';
		module2.exports = maxscript;
		maxscript.displayName = 'maxscript';
		maxscript.aliases = [];
		function maxscript(Prism) {
			(function (Prism2) {
				var keywords =
					/\b(?:about|and|animate|as|at|attributes|by|case|catch|collect|continue|coordsys|do|else|exit|fn|for|from|function|global|if|in|local|macroscript|mapped|max|not|of|off|on|or|parameters|persistent|plugin|rcmenu|return|rollout|set|struct|then|throw|to|tool|try|undo|utility|when|where|while|with)\b/i;
				Prism2.languages.maxscript = {
					comment: {
						pattern: /\/\*[\s\S]*?(?:\*\/|$)|--.*/,
						greedy: true
					},
					string: {
						pattern: /(^|[^"\\@])(?:"(?:[^"\\]|\\[\s\S])*"|@"[^"]*")/,
						lookbehind: true,
						greedy: true
					},
					path: {
						pattern: /\$(?:[\w/\\.*?]|'[^']*')*/,
						greedy: true,
						alias: 'string'
					},
					'function-call': {
						pattern: RegExp(
							'((?:' +
								(/^/.source +
									'|' +
									/[;=<>+\-*/^({\[]/.source +
									'|' +
									/\b(?:and|by|case|catch|collect|do|else|if|in|not|or|return|then|to|try|where|while|with)\b/
										.source) +
								')[ 	]*)(?!' +
								keywords.source +
								')' +
								/[a-z_]\w*\b/.source +
								'(?=[ 	]*(?:' +
								('(?!' +
									keywords.source +
									')' +
									/[a-z_]/.source +
									'|' +
									/\d|-\.?\d/.source +
									'|' +
									/[({'"$@#?]/.source) +
								'))',
							'im'
						),
						lookbehind: true,
						greedy: true,
						alias: 'function'
					},
					'function-definition': {
						pattern: /(\b(?:fn|function)\s+)\w+\b/i,
						lookbehind: true,
						alias: 'function'
					},
					argument: {
						pattern: /\b[a-z_]\w*(?=:)/i,
						alias: 'attr-name'
					},
					keyword: keywords,
					boolean: /\b(?:false|true)\b/,
					time: {
						pattern:
							/(^|[^\w.])(?:(?:(?:\d+(?:\.\d*)?|\.\d+)(?:[eEdD][+-]\d+|[LP])?[msft])+|\d+:\d+(?:\.\d*)?)(?![\w.:])/,
						lookbehind: true,
						alias: 'number'
					},
					number: [
						{
							pattern:
								/(^|[^\w.])(?:(?:\d+(?:\.\d*)?|\.\d+)(?:[eEdD][+-]\d+|[LP])?|0x[a-fA-F0-9]+)(?![\w.:])/,
							lookbehind: true
						},
						/\b(?:e|pi)\b/
					],
					constant: /\b(?:dontcollect|ok|silentValue|undefined|unsupplied)\b/,
					color: {
						pattern: /\b(?:black|blue|brown|gray|green|orange|red|white|yellow)\b/i,
						alias: 'constant'
					},
					operator: /[-+*/<>=!]=?|[&^?]|#(?!\()/,
					punctuation: /[()\[\]{}.:,;]|#(?=\()|\\$/m
				};
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/mel.js
var require_mel = __commonJS({
	'node_modules/refractor/lang/mel.js'(exports, module2) {
		'use strict';
		module2.exports = mel;
		mel.displayName = 'mel';
		mel.aliases = [];
		function mel(Prism) {
			Prism.languages.mel = {
				comment: /\/\/.*/,
				code: {
					pattern: /`(?:\\.|[^\\`\r\n])*`/,
					greedy: true,
					alias: 'italic',
					inside: {
						delimiter: {
							pattern: /^`|`$/,
							alias: 'punctuation'
						}
					}
				},
				string: {
					pattern: /"(?:\\.|[^\\"\r\n])*"/,
					greedy: true
				},
				variable: /\$\w+/,
				number: /\b0x[\da-fA-F]+\b|\b\d+(?:\.\d*)?|\B\.\d+/,
				flag: {
					pattern: /-[^\d\W]\w*/,
					alias: 'operator'
				},
				keyword:
					/\b(?:break|case|continue|default|do|else|float|for|global|if|in|int|matrix|proc|return|string|switch|vector|while)\b/,
				function:
					/\b\w+(?=\()|\b(?:CBG|HfAddAttractorToAS|HfAssignAS|HfBuildEqualMap|HfBuildFurFiles|HfBuildFurImages|HfCancelAFR|HfConnectASToHF|HfCreateAttractor|HfDeleteAS|HfEditAS|HfPerformCreateAS|HfRemoveAttractorFromAS|HfSelectAttached|HfSelectAttractors|HfUnAssignAS|Mayatomr|about|abs|addAttr|addAttributeEditorNodeHelp|addDynamic|addNewShelfTab|addPP|addPanelCategory|addPrefixToName|advanceToNextDrivenKey|affectedNet|affects|aimConstraint|air|alias|aliasAttr|align|alignCtx|alignCurve|alignSurface|allViewFit|ambientLight|angle|angleBetween|animCone|animCurveEditor|animDisplay|animView|annotate|appendStringArray|applicationName|applyAttrPreset|applyTake|arcLenDimContext|arcLengthDimension|arclen|arrayMapper|art3dPaintCtx|artAttrCtx|artAttrPaintVertexCtx|artAttrSkinPaintCtx|artAttrTool|artBuildPaintMenu|artFluidAttrCtx|artPuttyCtx|artSelectCtx|artSetPaintCtx|artUserPaintCtx|assignCommand|assignInputDevice|assignViewportFactories|attachCurve|attachDeviceAttr|attachSurface|attrColorSliderGrp|attrCompatibility|attrControlGrp|attrEnumOptionMenu|attrEnumOptionMenuGrp|attrFieldGrp|attrFieldSliderGrp|attrNavigationControlGrp|attrPresetEditWin|attributeExists|attributeInfo|attributeMenu|attributeQuery|autoKeyframe|autoPlace|bakeClip|bakeFluidShading|bakePartialHistory|bakeResults|bakeSimulation|basename|basenameEx|batchRender|bessel|bevel|bevelPlus|binMembership|bindSkin|blend2|blendShape|blendShapeEditor|blendShapePanel|blendTwoAttr|blindDataType|boneLattice|boundary|boxDollyCtx|boxZoomCtx|bufferCurve|buildBookmarkMenu|buildKeyframeMenu|button|buttonManip|cacheFile|cacheFileCombine|cacheFileMerge|cacheFileTrack|camera|cameraView|canCreateManip|canvas|capitalizeString|catch|catchQuiet|ceil|changeSubdivComponentDisplayLevel|changeSubdivRegion|channelBox|character|characterMap|characterOutlineEditor|characterize|chdir|checkBox|checkBoxGrp|checkDefaultRenderGlobals|choice|circle|circularFillet|clamp|clear|clearCache|clip|clipEditor|clipEditorCurrentTimeCtx|clipSchedule|clipSchedulerOutliner|clipTrimBefore|closeCurve|closeSurface|cluster|cmdFileOutput|cmdScrollFieldExecuter|cmdScrollFieldReporter|cmdShell|coarsenSubdivSelectionList|collision|color|colorAtPoint|colorEditor|colorIndex|colorIndexSliderGrp|colorSliderButtonGrp|colorSliderGrp|columnLayout|commandEcho|commandLine|commandPort|compactHairSystem|componentEditor|compositingInterop|computePolysetVolume|condition|cone|confirmDialog|connectAttr|connectControl|connectDynamic|connectJoint|connectionInfo|constrain|constrainValue|constructionHistory|container|containsMultibyte|contextInfo|control|convertFromOldLayers|convertIffToPsd|convertLightmap|convertSolidTx|convertTessellation|convertUnit|copyArray|copyFlexor|copyKey|copySkinWeights|cos|cpButton|cpCache|cpClothSet|cpCollision|cpConstraint|cpConvClothToMesh|cpForces|cpGetSolverAttr|cpPanel|cpProperty|cpRigidCollisionFilter|cpSeam|cpSetEdit|cpSetSolverAttr|cpSolver|cpSolverTypes|cpTool|cpUpdateClothUVs|createDisplayLayer|createDrawCtx|createEditor|createLayeredPsdFile|createMotionField|createNewShelf|createNode|createRenderLayer|createSubdivRegion|cross|crossProduct|ctxAbort|ctxCompletion|ctxEditMode|ctxTraverse|currentCtx|currentTime|currentTimeCtx|currentUnit|curve|curveAddPtCtx|curveCVCtx|curveEPCtx|curveEditorCtx|curveIntersect|curveMoveEPCtx|curveOnSurface|curveSketchCtx|cutKey|cycleCheck|cylinder|dagPose|date|defaultLightListCheckBox|defaultNavigation|defineDataServer|defineVirtualDevice|deformer|deg_to_rad|delete|deleteAttr|deleteShadingGroupsAndMaterials|deleteShelfTab|deleteUI|deleteUnusedBrushes|delrandstr|detachCurve|detachDeviceAttr|detachSurface|deviceEditor|devicePanel|dgInfo|dgdirty|dgeval|dgtimer|dimWhen|directKeyCtx|directionalLight|dirmap|dirname|disable|disconnectAttr|disconnectJoint|diskCache|displacementToPoly|displayAffected|displayColor|displayCull|displayLevelOfDetail|displayPref|displayRGBColor|displaySmoothness|displayStats|displayString|displaySurface|distanceDimContext|distanceDimension|doBlur|dolly|dollyCtx|dopeSheetEditor|dot|dotProduct|doubleProfileBirailSurface|drag|dragAttrContext|draggerContext|dropoffLocator|duplicate|duplicateCurve|duplicateSurface|dynCache|dynControl|dynExport|dynExpression|dynGlobals|dynPaintEditor|dynParticleCtx|dynPref|dynRelEdPanel|dynRelEditor|dynamicLoad|editAttrLimits|editDisplayLayerGlobals|editDisplayLayerMembers|editRenderLayerAdjustment|editRenderLayerGlobals|editRenderLayerMembers|editor|editorTemplate|effector|emit|emitter|enableDevice|encodeString|endString|endsWith|env|equivalent|equivalentTol|erf|error|eval|evalDeferred|evalEcho|event|exactWorldBoundingBox|exclusiveLightCheckBox|exec|executeForEachObject|exists|exp|expression|expressionEditorListen|extendCurve|extendSurface|extrude|fcheck|fclose|feof|fflush|fgetline|fgetword|file|fileBrowserDialog|fileDialog|fileExtension|fileInfo|filetest|filletCurve|filter|filterCurve|filterExpand|filterStudioImport|findAllIntersections|findAnimCurves|findKeyframe|findMenuItem|findRelatedSkinCluster|finder|firstParentOf|fitBspline|flexor|floatEq|floatField|floatFieldGrp|floatScrollBar|floatSlider|floatSlider2|floatSliderButtonGrp|floatSliderGrp|floor|flow|fluidCacheInfo|fluidEmitter|fluidVoxelInfo|flushUndo|fmod|fontDialog|fopen|formLayout|format|fprint|frameLayout|fread|freeFormFillet|frewind|fromNativePath|fwrite|gamma|gauss|geometryConstraint|getApplicationVersionAsFloat|getAttr|getClassification|getDefaultBrush|getFileList|getFluidAttr|getInputDeviceRange|getMayaPanelTypes|getModifiers|getPanel|getParticleAttr|getPluginResource|getenv|getpid|glRender|glRenderEditor|globalStitch|gmatch|goal|gotoBindPose|grabColor|gradientControl|gradientControlNoAttr|graphDollyCtx|graphSelectContext|graphTrackCtx|gravity|grid|gridLayout|group|groupObjectsByName|hardenPointCurve|hardware|hardwareRenderPanel|headsUpDisplay|headsUpMessage|help|helpLine|hermite|hide|hilite|hitTest|hotBox|hotkey|hotkeyCheck|hsv_to_rgb|hudButton|hudSlider|hudSliderButton|hwReflectionMap|hwRender|hwRenderLoad|hyperGraph|hyperPanel|hyperShade|hypot|iconTextButton|iconTextCheckBox|iconTextRadioButton|iconTextRadioCollection|iconTextScrollList|iconTextStaticLabel|ikHandle|ikHandleCtx|ikHandleDisplayScale|ikSolver|ikSplineHandleCtx|ikSystem|ikSystemInfo|ikfkDisplayMethod|illustratorCurves|image|imfPlugins|inheritTransform|insertJoint|insertJointCtx|insertKeyCtx|insertKnotCurve|insertKnotSurface|instance|instanceable|instancer|intField|intFieldGrp|intScrollBar|intSlider|intSliderGrp|interToUI|internalVar|intersect|iprEngine|isAnimCurve|isConnected|isDirty|isParentOf|isSameObject|isTrue|isValidObjectName|isValidString|isValidUiName|isolateSelect|itemFilter|itemFilterAttr|itemFilterRender|itemFilterType|joint|jointCluster|jointCtx|jointDisplayScale|jointLattice|keyTangent|keyframe|keyframeOutliner|keyframeRegionCurrentTimeCtx|keyframeRegionDirectKeyCtx|keyframeRegionDollyCtx|keyframeRegionInsertKeyCtx|keyframeRegionMoveKeyCtx|keyframeRegionScaleKeyCtx|keyframeRegionSelectKeyCtx|keyframeRegionSetKeyCtx|keyframeRegionTrackCtx|keyframeStats|lassoContext|lattice|latticeDeformKeyCtx|launch|launchImageEditor|layerButton|layeredShaderPort|layeredTexturePort|layout|layoutDialog|lightList|lightListEditor|lightListPanel|lightlink|lineIntersection|linearPrecision|linstep|listAnimatable|listAttr|listCameras|listConnections|listDeviceAttachments|listHistory|listInputDeviceAxes|listInputDeviceButtons|listInputDevices|listMenuAnnotation|listNodeTypes|listPanelCategories|listRelatives|listSets|listTransforms|listUnselected|listerEditor|loadFluid|loadNewShelf|loadPlugin|loadPluginLanguageResources|loadPrefObjects|localizedPanelLabel|lockNode|loft|log|longNameOf|lookThru|ls|lsThroughFilter|lsType|lsUI|mag|makeIdentity|makeLive|makePaintable|makeRoll|makeSingleSurface|makeTubeOn|makebot|manipMoveContext|manipMoveLimitsCtx|manipOptions|manipRotateContext|manipRotateLimitsCtx|manipScaleContext|manipScaleLimitsCtx|marker|match|max|memory|menu|menuBarLayout|menuEditor|menuItem|menuItemToShelf|menuSet|menuSetPref|messageLine|min|minimizeApp|mirrorJoint|modelCurrentTimeCtx|modelEditor|modelPanel|mouse|movIn|movOut|move|moveIKtoFK|moveKeyCtx|moveVertexAlongDirection|multiProfileBirailSurface|mute|nParticle|nameCommand|nameField|namespace|namespaceInfo|newPanelItems|newton|nodeCast|nodeIconButton|nodeOutliner|nodePreset|nodeType|noise|nonLinear|normalConstraint|normalize|nurbsBoolean|nurbsCopyUVSet|nurbsCube|nurbsEditUV|nurbsPlane|nurbsSelect|nurbsSquare|nurbsToPoly|nurbsToPolygonsPref|nurbsToSubdiv|nurbsToSubdivPref|nurbsUVSet|nurbsViewDirectionVector|objExists|objectCenter|objectLayer|objectType|objectTypeUI|obsoleteProc|oceanNurbsPreviewPlane|offsetCurve|offsetCurveOnSurface|offsetSurface|openGLExtension|openMayaPref|optionMenu|optionMenuGrp|optionVar|orbit|orbitCtx|orientConstraint|outlinerEditor|outlinerPanel|overrideModifier|paintEffectsDisplay|pairBlend|palettePort|paneLayout|panel|panelConfiguration|panelHistory|paramDimContext|paramDimension|paramLocator|parent|parentConstraint|particle|particleExists|particleInstancer|particleRenderInfo|partition|pasteKey|pathAnimation|pause|pclose|percent|performanceOptions|pfxstrokes|pickWalk|picture|pixelMove|planarSrf|plane|play|playbackOptions|playblast|plugAttr|plugNode|pluginInfo|pluginResourceUtil|pointConstraint|pointCurveConstraint|pointLight|pointMatrixMult|pointOnCurve|pointOnSurface|pointPosition|poleVectorConstraint|polyAppend|polyAppendFacetCtx|polyAppendVertex|polyAutoProjection|polyAverageNormal|polyAverageVertex|polyBevel|polyBlendColor|polyBlindData|polyBoolOp|polyBridgeEdge|polyCacheMonitor|polyCheck|polyChipOff|polyClipboard|polyCloseBorder|polyCollapseEdge|polyCollapseFacet|polyColorBlindData|polyColorDel|polyColorPerVertex|polyColorSet|polyCompare|polyCone|polyCopyUV|polyCrease|polyCreaseCtx|polyCreateFacet|polyCreateFacetCtx|polyCube|polyCut|polyCutCtx|polyCylinder|polyCylindricalProjection|polyDelEdge|polyDelFacet|polyDelVertex|polyDuplicateAndConnect|polyDuplicateEdge|polyEditUV|polyEditUVShell|polyEvaluate|polyExtrudeEdge|polyExtrudeFacet|polyExtrudeVertex|polyFlipEdge|polyFlipUV|polyForceUV|polyGeoSampler|polyHelix|polyInfo|polyInstallAction|polyLayoutUV|polyListComponentConversion|polyMapCut|polyMapDel|polyMapSew|polyMapSewMove|polyMergeEdge|polyMergeEdgeCtx|polyMergeFacet|polyMergeFacetCtx|polyMergeUV|polyMergeVertex|polyMirrorFace|polyMoveEdge|polyMoveFacet|polyMoveFacetUV|polyMoveUV|polyMoveVertex|polyNormal|polyNormalPerVertex|polyNormalizeUV|polyOptUvs|polyOptions|polyOutput|polyPipe|polyPlanarProjection|polyPlane|polyPlatonicSolid|polyPoke|polyPrimitive|polyPrism|polyProjection|polyPyramid|polyQuad|polyQueryBlindData|polyReduce|polySelect|polySelectConstraint|polySelectConstraintMonitor|polySelectCtx|polySelectEditCtx|polySeparate|polySetToFaceNormal|polySewEdge|polyShortestPathCtx|polySmooth|polySoftEdge|polySphere|polySphericalProjection|polySplit|polySplitCtx|polySplitEdge|polySplitRing|polySplitVertex|polyStraightenUVBorder|polySubdivideEdge|polySubdivideFacet|polyToSubdiv|polyTorus|polyTransfer|polyTriangulate|polyUVSet|polyUnite|polyWedgeFace|popen|popupMenu|pose|pow|preloadRefEd|print|progressBar|progressWindow|projFileViewer|projectCurve|projectTangent|projectionContext|projectionManip|promptDialog|propModCtx|propMove|psdChannelOutliner|psdEditTextureFile|psdExport|psdTextureFile|putenv|pwd|python|querySubdiv|quit|rad_to_deg|radial|radioButton|radioButtonGrp|radioCollection|radioMenuItemCollection|rampColorPort|rand|randomizeFollicles|randstate|rangeControl|readTake|rebuildCurve|rebuildSurface|recordAttr|recordDevice|redo|reference|referenceEdit|referenceQuery|refineSubdivSelectionList|refresh|refreshAE|registerPluginResource|rehash|reloadImage|removeJoint|removeMultiInstance|removePanelCategory|rename|renameAttr|renameSelectionList|renameUI|render|renderGlobalsNode|renderInfo|renderLayerButton|renderLayerParent|renderLayerPostProcess|renderLayerUnparent|renderManip|renderPartition|renderQualityNode|renderSettings|renderThumbnailUpdate|renderWindowEditor|renderWindowSelectContext|renderer|reorder|reorderDeformers|requires|reroot|resampleFluid|resetAE|resetPfxToPolyCamera|resetTool|resolutionNode|retarget|reverseCurve|reverseSurface|revolve|rgb_to_hsv|rigidBody|rigidSolver|roll|rollCtx|rootOf|rot|rotate|rotationInterpolation|roundConstantRadius|rowColumnLayout|rowLayout|runTimeCommand|runup|sampleImage|saveAllShelves|saveAttrPreset|saveFluid|saveImage|saveInitialState|saveMenu|savePrefObjects|savePrefs|saveShelf|saveToolSettings|scale|scaleBrushBrightness|scaleComponents|scaleConstraint|scaleKey|scaleKeyCtx|sceneEditor|sceneUIReplacement|scmh|scriptCtx|scriptEditorInfo|scriptJob|scriptNode|scriptTable|scriptToShelf|scriptedPanel|scriptedPanelType|scrollField|scrollLayout|sculpt|searchPathArray|seed|selLoadSettings|select|selectContext|selectCurveCV|selectKey|selectKeyCtx|selectKeyframeRegionCtx|selectMode|selectPref|selectPriority|selectType|selectedNodes|selectionConnection|separator|setAttr|setAttrEnumResource|setAttrMapping|setAttrNiceNameResource|setConstraintRestPosition|setDefaultShadingGroup|setDrivenKeyframe|setDynamic|setEditCtx|setEditor|setFluidAttr|setFocus|setInfinity|setInputDeviceMapping|setKeyCtx|setKeyPath|setKeyframe|setKeyframeBlendshapeTargetWts|setMenuMode|setNodeNiceNameResource|setNodeTypeFlag|setParent|setParticleAttr|setPfxToPolyCamera|setPluginResource|setProject|setStampDensity|setStartupMessage|setState|setToolTo|setUITemplate|setXformManip|sets|shadingConnection|shadingGeometryRelCtx|shadingLightRelCtx|shadingNetworkCompare|shadingNode|shapeCompare|shelfButton|shelfLayout|shelfTabLayout|shellField|shortNameOf|showHelp|showHidden|showManipCtx|showSelectionInTitle|showShadingGroupAttrEditor|showWindow|sign|simplify|sin|singleProfileBirailSurface|size|sizeBytes|skinCluster|skinPercent|smoothCurve|smoothTangentSurface|smoothstep|snap2to2|snapKey|snapMode|snapTogetherCtx|snapshot|soft|softMod|softModCtx|sort|sound|soundControl|source|spaceLocator|sphere|sphrand|spotLight|spotLightPreviewPort|spreadSheetEditor|spring|sqrt|squareSurface|srtContext|stackTrace|startString|startsWith|stitchAndExplodeShell|stitchSurface|stitchSurfacePoints|strcmp|stringArrayCatenate|stringArrayContains|stringArrayCount|stringArrayInsertAtIndex|stringArrayIntersector|stringArrayRemove|stringArrayRemoveAtIndex|stringArrayRemoveDuplicates|stringArrayRemoveExact|stringArrayToString|stringToStringArray|strip|stripPrefixFromName|stroke|subdAutoProjection|subdCleanTopology|subdCollapse|subdDuplicateAndConnect|subdEditUV|subdListComponentConversion|subdMapCut|subdMapSewMove|subdMatchTopology|subdMirror|subdToBlind|subdToPoly|subdTransferUVsToCache|subdiv|subdivCrease|subdivDisplaySmoothness|substitute|substituteAllString|substituteGeometry|substring|surface|surfaceSampler|surfaceShaderList|swatchDisplayPort|switchTable|symbolButton|symbolCheckBox|sysFile|system|tabLayout|tan|tangentConstraint|texLatticeDeformContext|texManipContext|texMoveContext|texMoveUVShellContext|texRotateContext|texScaleContext|texSelectContext|texSelectShortestPathCtx|texSmudgeUVContext|texWinToolCtx|text|textCurves|textField|textFieldButtonGrp|textFieldGrp|textManip|textScrollList|textToShelf|textureDisplacePlane|textureHairColor|texturePlacementContext|textureWindow|threadCount|threePointArcCtx|timeControl|timePort|timerX|toNativePath|toggle|toggleAxis|toggleWindowVisibility|tokenize|tokenizeList|tolerance|tolower|toolButton|toolCollection|toolDropped|toolHasOptions|toolPropertyWindow|torus|toupper|trace|track|trackCtx|transferAttributes|transformCompare|transformLimits|translator|trim|trunc|truncateFluidCache|truncateHairCache|tumble|tumbleCtx|turbulence|twoPointArcCtx|uiRes|uiTemplate|unassignInputDevice|undo|undoInfo|ungroup|uniform|unit|unloadPlugin|untangleUV|untitledFileName|untrim|upAxis|updateAE|userCtx|uvLink|uvSnapshot|validateShelfName|vectorize|view2dToolCtx|viewCamera|viewClipPlane|viewFit|viewHeadOn|viewLookAt|viewManip|viewPlace|viewSet|visor|volumeAxis|vortex|waitCursor|warning|webBrowser|webBrowserPrefs|whatIs|window|windowPref|wire|wireContext|workspace|wrinkle|wrinkleContext|writeTake|xbmLangPathList|xform)\b/,
				operator: [
					/\+[+=]?|-[-=]?|&&|\|\||[<>]=|[*\/!=]=?|[%^]/,
					{
						pattern: /(^|[^<])<(?!<)/,
						lookbehind: true
					},
					{
						pattern: /(^|[^>])>(?!>)/,
						lookbehind: true
					}
				],
				punctuation: /<<|>>|[.,:;?\[\](){}]/
			};
			Prism.languages.mel['code'].inside.rest = Prism.languages.mel;
		}
	}
});

// node_modules/refractor/lang/mermaid.js
var require_mermaid = __commonJS({
	'node_modules/refractor/lang/mermaid.js'(exports, module2) {
		'use strict';
		module2.exports = mermaid;
		mermaid.displayName = 'mermaid';
		mermaid.aliases = [];
		function mermaid(Prism) {
			Prism.languages.mermaid = {
				comment: {
					pattern: /%%.*/,
					greedy: true
				},
				style: {
					pattern: /^([ \t]*(?:classDef|linkStyle|style)[ \t]+[\w$-]+[ \t]+)\w.*[^\s;]/m,
					lookbehind: true,
					inside: {
						property: /\b\w[\w-]*(?=[ \t]*:)/,
						operator: /:/,
						punctuation: /,/
					}
				},
				'inter-arrow-label': {
					pattern:
						/([^<>ox.=-])(?:-[-.]|==)(?![<>ox.=-])[ \t]*(?:"[^"\r\n]*"|[^\s".=-](?:[^\r\n.=-]*[^\s.=-])?)[ \t]*(?:\.+->?|--+[->]|==+[=>])(?![<>ox.=-])/,
					lookbehind: true,
					greedy: true,
					inside: {
						arrow: {
							pattern: /(?:\.+->?|--+[->]|==+[=>])$/,
							alias: 'operator'
						},
						label: {
							pattern: /^([\s\S]{2}[ \t]*)\S(?:[\s\S]*\S)?/,
							lookbehind: true,
							alias: 'property'
						},
						'arrow-head': {
							pattern: /^\S+/,
							alias: ['arrow', 'operator']
						}
					}
				},
				arrow: [
					{
						pattern: /(^|[^{}|o.-])[|}][|o](?:--|\.\.)[|o][|{](?![{}|o.-])/,
						lookbehind: true,
						alias: 'operator'
					},
					{
						pattern:
							/(^|[^<>ox.=-])(?:[<ox](?:==+|--+|-\.*-)[>ox]?|(?:==+|--+|-\.*-)[>ox]|===+|---+|-\.+-)(?![<>ox.=-])/,
						lookbehind: true,
						alias: 'operator'
					},
					{
						pattern: /(^|[^<>()x-])(?:--?(?:>>|[x>)])(?![<>()x])|(?:<<|[x<(])--?(?!-))/,
						lookbehind: true,
						alias: 'operator'
					},
					{
						pattern:
							/(^|[^<>|*o.-])(?:[*o]--|--[*o]|<\|?(?:--|\.\.)|(?:--|\.\.)\|?>|--|\.\.)(?![<>|*o.-])/,
						lookbehind: true,
						alias: 'operator'
					}
				],
				label: {
					pattern: /(^|[^|<])\|(?:[^\r\n"|]|"[^"\r\n]*")+\|/,
					lookbehind: true,
					greedy: true,
					alias: 'property'
				},
				text: {
					pattern: /(?:[(\[{]+|\b>)(?:[^\r\n"()\[\]{}]|"[^"\r\n]*")+(?:[)\]}]+|>)/,
					alias: 'string'
				},
				string: {
					pattern: /"[^"\r\n]*"/,
					greedy: true
				},
				annotation: {
					pattern:
						/<<(?:abstract|choice|enumeration|fork|interface|join|service)>>|\[\[(?:choice|fork|join)\]\]/i,
					alias: 'important'
				},
				keyword: [
					{
						pattern:
							/(^[ \t]*)(?:action|callback|class|classDef|classDiagram|click|direction|erDiagram|flowchart|gantt|gitGraph|graph|journey|link|linkStyle|pie|requirementDiagram|sequenceDiagram|stateDiagram|stateDiagram-v2|style|subgraph)(?![\w$-])/m,
						lookbehind: true,
						greedy: true
					},
					{
						pattern:
							/(^[ \t]*)(?:activate|alt|and|as|autonumber|deactivate|else|end(?:[ \t]+note)?|loop|opt|par|participant|rect|state|note[ \t]+(?:over|(?:left|right)[ \t]+of))(?![\w$-])/im,
						lookbehind: true,
						greedy: true
					}
				],
				entity: /#[a-z0-9]+;/,
				operator: {
					pattern: /(\w[ \t]*)&(?=[ \t]*\w)|:::|:/,
					lookbehind: true
				},
				punctuation: /[(){};]/
			};
		}
	}
});

// node_modules/refractor/lang/mizar.js
var require_mizar = __commonJS({
	'node_modules/refractor/lang/mizar.js'(exports, module2) {
		'use strict';
		module2.exports = mizar;
		mizar.displayName = 'mizar';
		mizar.aliases = [];
		function mizar(Prism) {
			Prism.languages.mizar = {
				comment: /::.+/,
				keyword:
					/@proof\b|\b(?:according|aggregate|all|and|antonym|are|as|associativity|assume|asymmetry|attr|be|begin|being|by|canceled|case|cases|clusters?|coherence|commutativity|compatibility|connectedness|consider|consistency|constructors|contradiction|correctness|def|deffunc|define|definitions?|defpred|do|does|end|environ|equals|ex|exactly|existence|for|from|func|given|hence|hereby|holds|idempotence|identity|iff?|implies|involutiveness|irreflexivity|is|it|let|means|mode|non|not|notations?|now|of|or|otherwise|over|per|pred|prefix|projectivity|proof|provided|qua|reconsider|redefine|reduce|reducibility|reflexivity|registrations?|requirements|reserve|sch|schemes?|section|selector|set|sethood|st|struct|such|suppose|symmetry|synonym|take|that|the|then|theorems?|thesis|thus|to|transitivity|uniqueness|vocabular(?:ies|y)|when|where|with|wrt)\b/,
				parameter: {
					pattern: /\$(?:10|\d)/,
					alias: 'variable'
				},
				variable: /\b\w+(?=:)/,
				number: /(?:\b|-)\d+\b/,
				operator: /\.\.\.|->|&|\.?=/,
				punctuation: /\(#|#\)|[,:;\[\](){}]/
			};
		}
	}
});

// node_modules/refractor/lang/mongodb.js
var require_mongodb = __commonJS({
	'node_modules/refractor/lang/mongodb.js'(exports, module2) {
		'use strict';
		module2.exports = mongodb;
		mongodb.displayName = 'mongodb';
		mongodb.aliases = [];
		function mongodb(Prism) {
			(function (Prism2) {
				var operators = [
					'$eq',
					'$gt',
					'$gte',
					'$in',
					'$lt',
					'$lte',
					'$ne',
					'$nin',
					'$and',
					'$not',
					'$nor',
					'$or',
					'$exists',
					'$type',
					'$expr',
					'$jsonSchema',
					'$mod',
					'$regex',
					'$text',
					'$where',
					'$geoIntersects',
					'$geoWithin',
					'$near',
					'$nearSphere',
					'$all',
					'$elemMatch',
					'$size',
					'$bitsAllClear',
					'$bitsAllSet',
					'$bitsAnyClear',
					'$bitsAnySet',
					'$comment',
					'$elemMatch',
					'$meta',
					'$slice',
					'$currentDate',
					'$inc',
					'$min',
					'$max',
					'$mul',
					'$rename',
					'$set',
					'$setOnInsert',
					'$unset',
					'$addToSet',
					'$pop',
					'$pull',
					'$push',
					'$pullAll',
					'$each',
					'$position',
					'$slice',
					'$sort',
					'$bit',
					'$addFields',
					'$bucket',
					'$bucketAuto',
					'$collStats',
					'$count',
					'$currentOp',
					'$facet',
					'$geoNear',
					'$graphLookup',
					'$group',
					'$indexStats',
					'$limit',
					'$listLocalSessions',
					'$listSessions',
					'$lookup',
					'$match',
					'$merge',
					'$out',
					'$planCacheStats',
					'$project',
					'$redact',
					'$replaceRoot',
					'$replaceWith',
					'$sample',
					'$set',
					'$skip',
					'$sort',
					'$sortByCount',
					'$unionWith',
					'$unset',
					'$unwind',
					'$setWindowFields',
					'$abs',
					'$accumulator',
					'$acos',
					'$acosh',
					'$add',
					'$addToSet',
					'$allElementsTrue',
					'$and',
					'$anyElementTrue',
					'$arrayElemAt',
					'$arrayToObject',
					'$asin',
					'$asinh',
					'$atan',
					'$atan2',
					'$atanh',
					'$avg',
					'$binarySize',
					'$bsonSize',
					'$ceil',
					'$cmp',
					'$concat',
					'$concatArrays',
					'$cond',
					'$convert',
					'$cos',
					'$dateFromParts',
					'$dateToParts',
					'$dateFromString',
					'$dateToString',
					'$dayOfMonth',
					'$dayOfWeek',
					'$dayOfYear',
					'$degreesToRadians',
					'$divide',
					'$eq',
					'$exp',
					'$filter',
					'$first',
					'$floor',
					'$function',
					'$gt',
					'$gte',
					'$hour',
					'$ifNull',
					'$in',
					'$indexOfArray',
					'$indexOfBytes',
					'$indexOfCP',
					'$isArray',
					'$isNumber',
					'$isoDayOfWeek',
					'$isoWeek',
					'$isoWeekYear',
					'$last',
					'$last',
					'$let',
					'$literal',
					'$ln',
					'$log',
					'$log10',
					'$lt',
					'$lte',
					'$ltrim',
					'$map',
					'$max',
					'$mergeObjects',
					'$meta',
					'$min',
					'$millisecond',
					'$minute',
					'$mod',
					'$month',
					'$multiply',
					'$ne',
					'$not',
					'$objectToArray',
					'$or',
					'$pow',
					'$push',
					'$radiansToDegrees',
					'$range',
					'$reduce',
					'$regexFind',
					'$regexFindAll',
					'$regexMatch',
					'$replaceOne',
					'$replaceAll',
					'$reverseArray',
					'$round',
					'$rtrim',
					'$second',
					'$setDifference',
					'$setEquals',
					'$setIntersection',
					'$setIsSubset',
					'$setUnion',
					'$size',
					'$sin',
					'$slice',
					'$split',
					'$sqrt',
					'$stdDevPop',
					'$stdDevSamp',
					'$strcasecmp',
					'$strLenBytes',
					'$strLenCP',
					'$substr',
					'$substrBytes',
					'$substrCP',
					'$subtract',
					'$sum',
					'$switch',
					'$tan',
					'$toBool',
					'$toDate',
					'$toDecimal',
					'$toDouble',
					'$toInt',
					'$toLong',
					'$toObjectId',
					'$toString',
					'$toLower',
					'$toUpper',
					'$trim',
					'$trunc',
					'$type',
					'$week',
					'$year',
					'$zip',
					'$count',
					'$dateAdd',
					'$dateDiff',
					'$dateSubtract',
					'$dateTrunc',
					'$getField',
					'$rand',
					'$sampleRate',
					'$setField',
					'$unsetField',
					'$comment',
					'$explain',
					'$hint',
					'$max',
					'$maxTimeMS',
					'$min',
					'$orderby',
					'$query',
					'$returnKey',
					'$showDiskLoc',
					'$natural'
				];
				var builtinFunctions = [
					'ObjectId',
					'Code',
					'BinData',
					'DBRef',
					'Timestamp',
					'NumberLong',
					'NumberDecimal',
					'MaxKey',
					'MinKey',
					'RegExp',
					'ISODate',
					'UUID'
				];
				operators = operators.map(function (operator) {
					return operator.replace('$', '\\$');
				});
				var operatorsSource = '(?:' + operators.join('|') + ')\\b';
				Prism2.languages.mongodb = Prism2.languages.extend('javascript', {});
				Prism2.languages.insertBefore('mongodb', 'string', {
					property: {
						pattern:
							/(?:(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1|(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*)(?=\s*:)/,
						greedy: true,
						inside: {
							keyword: RegExp(`^(['"])?` + operatorsSource + '(?:\\1)?$')
						}
					}
				});
				Prism2.languages.mongodb.string.inside = {
					url: {
						pattern: /https?:\/\/[-\w@:%.+~#=]{1,256}\.[a-z0-9()]{1,6}\b[-\w()@:%+.~#?&/=]*/i,
						greedy: true
					},
					entity: {
						pattern: /\b(?:(?:[01]?\d\d?|2[0-4]\d|25[0-5])\.){3}(?:[01]?\d\d?|2[0-4]\d|25[0-5])\b/,
						greedy: true
					}
				};
				Prism2.languages.insertBefore('mongodb', 'constant', {
					builtin: {
						pattern: RegExp('\\b(?:' + builtinFunctions.join('|') + ')\\b'),
						alias: 'keyword'
					}
				});
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/monkey.js
var require_monkey = __commonJS({
	'node_modules/refractor/lang/monkey.js'(exports, module2) {
		'use strict';
		module2.exports = monkey;
		monkey.displayName = 'monkey';
		monkey.aliases = [];
		function monkey(Prism) {
			Prism.languages.monkey = {
				comment: {
					pattern: /^#Rem\s[\s\S]*?^#End|'.+/im,
					greedy: true
				},
				string: {
					pattern: /"[^"\r\n]*"/,
					greedy: true
				},
				preprocessor: {
					pattern: /(^[ \t]*)#.+/m,
					lookbehind: true,
					greedy: true,
					alias: 'property'
				},
				function: /\b\w+(?=\()/,
				'type-char': {
					pattern: /\b[?%#$]/,
					alias: 'class-name'
				},
				number: {
					pattern: /((?:\.\.)?)(?:(?:\b|\B-\.?|\B\.)\d+(?:(?!\.\.)\.\d*)?|\$[\da-f]+)/i,
					lookbehind: true
				},
				keyword:
					/\b(?:Abstract|Array|Bool|Case|Catch|Class|Const|Continue|Default|Eachin|Else|ElseIf|End|EndIf|Exit|Extends|Extern|False|Field|Final|Float|For|Forever|Function|Global|If|Implements|Import|Inline|Int|Interface|Local|Method|Module|New|Next|Null|Object|Private|Property|Public|Repeat|Return|Select|Self|Step|Strict|String|Super|Then|Throw|To|True|Try|Until|Void|Wend|While)\b/i,
				operator: /\.\.|<[=>]?|>=?|:?=|(?:[+\-*\/&~|]|\b(?:Mod|Shl|Shr)\b)=?|\b(?:And|Not|Or)\b/i,
				punctuation: /[.,:;()\[\]]/
			};
		}
	}
});

// node_modules/refractor/lang/moonscript.js
var require_moonscript = __commonJS({
	'node_modules/refractor/lang/moonscript.js'(exports, module2) {
		'use strict';
		module2.exports = moonscript;
		moonscript.displayName = 'moonscript';
		moonscript.aliases = ['moon'];
		function moonscript(Prism) {
			Prism.languages.moonscript = {
				comment: /--.*/,
				string: [
					{
						pattern: /'[^']*'|\[(=*)\[[\s\S]*?\]\1\]/,
						greedy: true
					},
					{
						pattern: /"[^"]*"/,
						greedy: true,
						inside: {
							interpolation: {
								pattern: /#\{[^{}]*\}/,
								inside: {
									moonscript: {
										pattern: /(^#\{)[\s\S]+(?=\})/,
										lookbehind: true,
										inside: null
									},
									'interpolation-punctuation': {
										pattern: /#\{|\}/,
										alias: 'punctuation'
									}
								}
							}
						}
					}
				],
				'class-name': [
					{
						pattern: /(\b(?:class|extends)[ \t]+)\w+/,
						lookbehind: true
					},
					/\b[A-Z]\w*/
				],
				keyword:
					/\b(?:class|continue|do|else|elseif|export|extends|for|from|if|import|in|local|nil|return|self|super|switch|then|unless|using|when|while|with)\b/,
				variable: /@@?\w*/,
				property: {
					pattern: /\b(?!\d)\w+(?=:)|(:)(?!\d)\w+/,
					lookbehind: true
				},
				function: {
					pattern:
						/\b(?:_G|_VERSION|assert|collectgarbage|coroutine\.(?:create|resume|running|status|wrap|yield)|debug\.(?:debug|getfenv|gethook|getinfo|getlocal|getmetatable|getregistry|getupvalue|setfenv|sethook|setlocal|setmetatable|setupvalue|traceback)|dofile|error|getfenv|getmetatable|io\.(?:close|flush|input|lines|open|output|popen|read|stderr|stdin|stdout|tmpfile|type|write)|ipairs|load|loadfile|loadstring|math\.(?:abs|acos|asin|atan|atan2|ceil|cos|cosh|deg|exp|floor|fmod|frexp|ldexp|log|log10|max|min|modf|pi|pow|rad|random|randomseed|sin|sinh|sqrt|tan|tanh)|module|next|os\.(?:clock|date|difftime|execute|exit|getenv|remove|rename|setlocale|time|tmpname)|package\.(?:cpath|loaded|loadlib|path|preload|seeall)|pairs|pcall|print|rawequal|rawget|rawset|require|select|setfenv|setmetatable|string\.(?:byte|char|dump|find|format|gmatch|gsub|len|lower|match|rep|reverse|sub|upper)|table\.(?:concat|insert|maxn|remove|sort)|tonumber|tostring|type|unpack|xpcall)\b/,
					inside: {
						punctuation: /\./
					}
				},
				boolean: /\b(?:false|true)\b/,
				number:
					/(?:\B\.\d+|\b\d+\.\d+|\b\d+(?=[eE]))(?:[eE][-+]?\d+)?\b|\b(?:0x[a-fA-F\d]+|\d+)(?:U?LL)?\b/,
				operator: /\.{3}|[-=]>|~=|(?:[-+*/%<>!=]|\.\.)=?|[:#^]|\b(?:and|or)\b=?|\b(?:not)\b/,
				punctuation: /[.,()[\]{}\\]/
			};
			Prism.languages.moonscript.string[1].inside.interpolation.inside.moonscript.inside =
				Prism.languages.moonscript;
			Prism.languages.moon = Prism.languages.moonscript;
		}
	}
});

// node_modules/refractor/lang/n1ql.js
var require_n1ql = __commonJS({
	'node_modules/refractor/lang/n1ql.js'(exports, module2) {
		'use strict';
		module2.exports = n1ql;
		n1ql.displayName = 'n1ql';
		n1ql.aliases = [];
		function n1ql(Prism) {
			Prism.languages.n1ql = {
				comment: {
					pattern: /\/\*[\s\S]*?(?:$|\*\/)|--.*/,
					greedy: true
				},
				string: {
					pattern: /(["'])(?:\\[\s\S]|(?!\1)[^\\]|\1\1)*\1/,
					greedy: true
				},
				identifier: {
					pattern: /`(?:\\[\s\S]|[^\\`]|``)*`/,
					greedy: true
				},
				parameter: /\$[\w.]+/,
				keyword:
					/\b(?:ADVISE|ALL|ALTER|ANALYZE|AS|ASC|AT|BEGIN|BINARY|BOOLEAN|BREAK|BUCKET|BUILD|BY|CALL|CAST|CLUSTER|COLLATE|COLLECTION|COMMIT|COMMITTED|CONNECT|CONTINUE|CORRELATE|CORRELATED|COVER|CREATE|CURRENT|DATABASE|DATASET|DATASTORE|DECLARE|DECREMENT|DELETE|DERIVED|DESC|DESCRIBE|DISTINCT|DO|DROP|EACH|ELEMENT|EXCEPT|EXCLUDE|EXECUTE|EXPLAIN|FETCH|FILTER|FLATTEN|FLUSH|FOLLOWING|FOR|FORCE|FROM|FTS|FUNCTION|GOLANG|GRANT|GROUP|GROUPS|GSI|HASH|HAVING|IF|IGNORE|ILIKE|INCLUDE|INCREMENT|INDEX|INFER|INLINE|INNER|INSERT|INTERSECT|INTO|IS|ISOLATION|JAVASCRIPT|JOIN|KEY|KEYS|KEYSPACE|KNOWN|LANGUAGE|LAST|LEFT|LET|LETTING|LEVEL|LIMIT|LSM|MAP|MAPPING|MATCHED|MATERIALIZED|MERGE|MINUS|MISSING|NAMESPACE|NEST|NL|NO|NTH_VALUE|NULL|NULLS|NUMBER|OBJECT|OFFSET|ON|OPTION|OPTIONS|ORDER|OTHERS|OUTER|OVER|PARSE|PARTITION|PASSWORD|PATH|POOL|PRECEDING|PREPARE|PRIMARY|PRIVATE|PRIVILEGE|PROBE|PROCEDURE|PUBLIC|RANGE|RAW|REALM|REDUCE|RENAME|RESPECT|RETURN|RETURNING|REVOKE|RIGHT|ROLE|ROLLBACK|ROW|ROWS|SATISFIES|SAVEPOINT|SCHEMA|SCOPE|SELECT|SELF|SEMI|SET|SHOW|SOME|START|STATISTICS|STRING|SYSTEM|TIES|TO|TRAN|TRANSACTION|TRIGGER|TRUNCATE|UNBOUNDED|UNDER|UNION|UNIQUE|UNKNOWN|UNNEST|UNSET|UPDATE|UPSERT|USE|USER|USING|VALIDATE|VALUE|VALUES|VIA|VIEW|WHERE|WHILE|WINDOW|WITH|WORK|XOR)\b/i,
				function: /\b[a-z_]\w*(?=\s*\()/i,
				boolean: /\b(?:FALSE|TRUE)\b/i,
				number: /(?:\b\d+\.|\B\.)\d+e[+\-]?\d+\b|\b\d+(?:\.\d*)?|\B\.\d+\b/i,
				operator:
					/[-+*\/%]|!=|==?|\|\||<[>=]?|>=?|\b(?:AND|ANY|ARRAY|BETWEEN|CASE|ELSE|END|EVERY|EXISTS|FIRST|IN|LIKE|NOT|OR|THEN|VALUED|WHEN|WITHIN)\b/i,
				punctuation: /[;[\](),.{}:]/
			};
		}
	}
});

// node_modules/refractor/lang/n4js.js
var require_n4js = __commonJS({
	'node_modules/refractor/lang/n4js.js'(exports, module2) {
		'use strict';
		module2.exports = n4js;
		n4js.displayName = 'n4js';
		n4js.aliases = ['n4jsd'];
		function n4js(Prism) {
			Prism.languages.n4js = Prism.languages.extend('javascript', {
				keyword:
					/\b(?:Array|any|boolean|break|case|catch|class|const|constructor|continue|debugger|declare|default|delete|do|else|enum|export|extends|false|finally|for|from|function|get|if|implements|import|in|instanceof|interface|let|module|new|null|number|package|private|protected|public|return|set|static|string|super|switch|this|throw|true|try|typeof|var|void|while|with|yield)\b/
			});
			Prism.languages.insertBefore('n4js', 'constant', {
				annotation: {
					pattern: /@+\w+/,
					alias: 'operator'
				}
			});
			Prism.languages.n4jsd = Prism.languages.n4js;
		}
	}
});

// node_modules/refractor/lang/nand2tetris-hdl.js
var require_nand2tetris_hdl = __commonJS({
	'node_modules/refractor/lang/nand2tetris-hdl.js'(exports, module2) {
		'use strict';
		module2.exports = nand2tetrisHdl;
		nand2tetrisHdl.displayName = 'nand2tetrisHdl';
		nand2tetrisHdl.aliases = [];
		function nand2tetrisHdl(Prism) {
			Prism.languages['nand2tetris-hdl'] = {
				comment: /\/\/.*|\/\*[\s\S]*?(?:\*\/|$)/,
				keyword: /\b(?:BUILTIN|CHIP|CLOCKED|IN|OUT|PARTS)\b/,
				boolean: /\b(?:false|true)\b/,
				function: /\b[A-Za-z][A-Za-z0-9]*(?=\()/,
				number: /\b\d+\b/,
				operator: /=|\.\./,
				punctuation: /[{}[\];(),:]/
			};
		}
	}
});

// node_modules/refractor/lang/naniscript.js
var require_naniscript = __commonJS({
	'node_modules/refractor/lang/naniscript.js'(exports, module2) {
		'use strict';
		module2.exports = naniscript;
		naniscript.displayName = 'naniscript';
		naniscript.aliases = [];
		function naniscript(Prism) {
			(function (Prism2) {
				var expressionDef = /\{[^\r\n\[\]{}]*\}/;
				var params = {
					'quoted-string': {
						pattern: /"(?:[^"\\]|\\.)*"/,
						alias: 'operator'
					},
					'command-param-id': {
						pattern: /(\s)\w+:/,
						lookbehind: true,
						alias: 'property'
					},
					'command-param-value': [
						{
							pattern: expressionDef,
							alias: 'selector'
						},
						{
							pattern: /([\t ])\S+/,
							lookbehind: true,
							greedy: true,
							alias: 'operator'
						},
						{
							pattern: /\S(?:.*\S)?/,
							alias: 'operator'
						}
					]
				};
				Prism2.languages.naniscript = {
					comment: {
						pattern: /^([\t ]*);.*/m,
						lookbehind: true
					},
					define: {
						pattern: /^>.+/m,
						alias: 'tag',
						inside: {
							value: {
								pattern: /(^>\w+[\t ]+)(?!\s)[^{}\r\n]+/,
								lookbehind: true,
								alias: 'operator'
							},
							key: {
								pattern: /(^>)\w+/,
								lookbehind: true
							}
						}
					},
					label: {
						pattern: /^([\t ]*)#[\t ]*\w+[\t ]*$/m,
						lookbehind: true,
						alias: 'regex'
					},
					command: {
						pattern: /^([\t ]*)@\w+(?=[\t ]|$).*/m,
						lookbehind: true,
						alias: 'function',
						inside: {
							'command-name': /^@\w+/,
							expression: {
								pattern: expressionDef,
								greedy: true,
								alias: 'selector'
							},
							'command-params': {
								pattern: /\s*\S[\s\S]*/,
								inside: params
							}
						}
					},
					'generic-text': {
						pattern: /(^[ \t]*)[^#@>;\s].*/m,
						lookbehind: true,
						alias: 'punctuation',
						inside: {
							'escaped-char': /\\[{}\[\]"]/,
							expression: {
								pattern: expressionDef,
								greedy: true,
								alias: 'selector'
							},
							'inline-command': {
								pattern: /\[[\t ]*\w[^\r\n\[\]]*\]/,
								greedy: true,
								alias: 'function',
								inside: {
									'command-params': {
										pattern: /(^\[[\t ]*\w+\b)[\s\S]+(?=\]$)/,
										lookbehind: true,
										inside: params
									},
									'command-param-name': {
										pattern: /^(\[[\t ]*)\w+/,
										lookbehind: true,
										alias: 'name'
									},
									'start-stop-char': /[\[\]]/
								}
							}
						}
					}
				};
				Prism2.languages.nani = Prism2.languages['naniscript'];
				Prism2.hooks.add('after-tokenize', function (env) {
					var tokens = env.tokens;
					tokens.forEach(function (token) {
						if (typeof token !== 'string' && token.type === 'generic-text') {
							var content3 = getTextContent(token);
							if (!isBracketsBalanced(content3)) {
								token.type = 'bad-line';
								token.content = content3;
							}
						}
					});
				});
				function isBracketsBalanced(input) {
					var brackets = '[]{}';
					var stack = [];
					for (var i2 = 0; i2 < input.length; i2++) {
						var bracket = input[i2];
						var bracketsIndex = brackets.indexOf(bracket);
						if (bracketsIndex !== -1) {
							if (bracketsIndex % 2 === 0) {
								stack.push(bracketsIndex + 1);
							} else if (stack.pop() !== bracketsIndex) {
								return false;
							}
						}
					}
					return stack.length === 0;
				}
				function getTextContent(token) {
					if (typeof token === 'string') {
						return token;
					} else if (Array.isArray(token)) {
						return token.map(getTextContent).join('');
					} else {
						return getTextContent(token.content);
					}
				}
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/nasm.js
var require_nasm = __commonJS({
	'node_modules/refractor/lang/nasm.js'(exports, module2) {
		'use strict';
		module2.exports = nasm;
		nasm.displayName = 'nasm';
		nasm.aliases = [];
		function nasm(Prism) {
			Prism.languages.nasm = {
				comment: /;.*$/m,
				string: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
				label: {
					pattern: /(^\s*)[A-Za-z._?$][\w.?$@~#]*:/m,
					lookbehind: true,
					alias: 'function'
				},
				keyword: [
					/\[?BITS (?:16|32|64)\]?/,
					{
						pattern: /(^\s*)section\s*[a-z.]+:?/im,
						lookbehind: true
					},
					/(?:extern|global)[^;\r\n]*/i,
					/(?:CPU|DEFAULT|FLOAT).*$/m
				],
				register: {
					pattern:
						/\b(?:st\d|[xyz]mm\d\d?|[cdt]r\d|r\d\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(?:bp|di|si|sp)|[cdefgs]s)\b/i,
					alias: 'variable'
				},
				number:
					/(?:\b|(?=\$))(?:0[hx](?:\.[\da-f]+|[\da-f]+(?:\.[\da-f]+)?)(?:p[+-]?\d+)?|\d[\da-f]+[hx]|\$\d[\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\d+|(?:\d+(?:\.\d+)?|\.\d+)(?:\.?e[+-]?\d+)?[dt]?)\b/i,
				operator: /[\[\]*+\-\/%<>=&|$!]/
			};
		}
	}
});

// node_modules/refractor/lang/neon.js
var require_neon = __commonJS({
	'node_modules/refractor/lang/neon.js'(exports, module2) {
		'use strict';
		module2.exports = neon;
		neon.displayName = 'neon';
		neon.aliases = [];
		function neon(Prism) {
			Prism.languages.neon = {
				comment: {
					pattern: /#.*/,
					greedy: true
				},
				datetime: {
					pattern:
						/(^|[[{(=:,\s])\d\d\d\d-\d\d?-\d\d?(?:(?:[Tt]| +)\d\d?:\d\d:\d\d(?:\.\d*)? *(?:Z|[-+]\d\d?(?::?\d\d)?)?)?(?=$|[\]}),\s])/,
					lookbehind: true,
					alias: 'number'
				},
				key: {
					pattern: /(^|[[{(,\s])[^,:=[\]{}()'"\s]+(?=\s*:(?:$|[\]}),\s])|\s*=)/,
					lookbehind: true,
					alias: 'atrule'
				},
				number: {
					pattern:
						/(^|[[{(=:,\s])[+-]?(?:0x[\da-fA-F]+|0o[0-7]+|0b[01]+|(?:\d+(?:\.\d*)?|\.?\d+)(?:[eE][+-]?\d+)?)(?=$|[\]}),:=\s])/,
					lookbehind: true
				},
				boolean: {
					pattern: /(^|[[{(=:,\s])(?:false|no|true|yes)(?=$|[\]}),:=\s])/i,
					lookbehind: true
				},
				null: {
					pattern: /(^|[[{(=:,\s])(?:null)(?=$|[\]}),:=\s])/i,
					lookbehind: true,
					alias: 'keyword'
				},
				string: {
					pattern:
						/(^|[[{(=:,\s])(?:('''|""")\r?\n(?:(?:[^\r\n]|\r?\n(?![\t ]*\2))*\r?\n)?[\t ]*\2|'[^'\r\n]*'|"(?:\\.|[^\\"\r\n])*")/,
					lookbehind: true,
					greedy: true
				},
				literal: {
					pattern:
						/(^|[[{(=:,\s])(?:[^#"',:=[\]{}()\s`-]|[:-][^"',=[\]{}()\s])(?:[^,:=\]})(\s]|:(?![\s,\]})]|$)|[ \t]+[^#,:=\]})(\s])*/,
					lookbehind: true,
					alias: 'string'
				},
				punctuation: /[,:=[\]{}()-]/
			};
		}
	}
});

// node_modules/refractor/lang/nevod.js
var require_nevod = __commonJS({
	'node_modules/refractor/lang/nevod.js'(exports, module2) {
		'use strict';
		module2.exports = nevod;
		nevod.displayName = 'nevod';
		nevod.aliases = [];
		function nevod(Prism) {
			Prism.languages.nevod = {
				comment: /\/\/.*|(?:\/\*[\s\S]*?(?:\*\/|$))/,
				string: {
					pattern: /(?:"(?:""|[^"])*"(?!")|'(?:''|[^'])*'(?!'))!?\*?/,
					greedy: true,
					inside: {
						'string-attrs': /!$|!\*$|\*$/
					}
				},
				namespace: {
					pattern: /(@namespace\s+)[a-zA-Z0-9\-.]+(?=\s*\{)/,
					lookbehind: true
				},
				pattern: {
					pattern:
						/(@pattern\s+)?#?[a-zA-Z0-9\-.]+(?:\s*\(\s*(?:~\s*)?[a-zA-Z0-9\-.]+\s*(?:,\s*(?:~\s*)?[a-zA-Z0-9\-.]*)*\))?(?=\s*=)/,
					lookbehind: true,
					inside: {
						'pattern-name': {
							pattern: /^#?[a-zA-Z0-9\-.]+/,
							alias: 'class-name'
						},
						fields: {
							pattern: /\(.*\)/,
							inside: {
								'field-name': {
									pattern: /[a-zA-Z0-9\-.]+/,
									alias: 'variable'
								},
								punctuation: /[,()]/,
								operator: {
									pattern: /~/,
									alias: 'field-hidden-mark'
								}
							}
						}
					}
				},
				search: {
					pattern: /(@search\s+|#)[a-zA-Z0-9\-.]+(?:\.\*)?(?=\s*;)/,
					alias: 'function',
					lookbehind: true
				},
				keyword: /@(?:having|inside|namespace|outside|pattern|require|search|where)\b/,
				'standard-pattern': {
					pattern:
						/\b(?:Alpha|AlphaNum|Any|Blank|End|LineBreak|Num|NumAlpha|Punct|Space|Start|Symbol|Word|WordBreak)\b(?:\([a-zA-Z0-9\-.,\s+]*\))?/,
					inside: {
						'standard-pattern-name': {
							pattern: /^[a-zA-Z0-9\-.]+/,
							alias: 'builtin'
						},
						quantifier: {
							pattern: /\b\d+(?:\s*\+|\s*-\s*\d+)?(?!\w)/,
							alias: 'number'
						},
						'standard-pattern-attr': {
							pattern: /[a-zA-Z0-9\-.]+/,
							alias: 'builtin'
						},
						punctuation: /[,()]/
					}
				},
				quantifier: {
					pattern: /\b\d+(?:\s*\+|\s*-\s*\d+)?(?!\w)/,
					alias: 'number'
				},
				operator: [
					{
						pattern: /=/,
						alias: 'pattern-def'
					},
					{
						pattern: /&/,
						alias: 'conjunction'
					},
					{
						pattern: /~/,
						alias: 'exception'
					},
					{
						pattern: /\?/,
						alias: 'optionality'
					},
					{
						pattern: /[[\]]/,
						alias: 'repetition'
					},
					{
						pattern: /[{}]/,
						alias: 'variation'
					},
					{
						pattern: /[+_]/,
						alias: 'sequence'
					},
					{
						pattern: /\.{2,3}/,
						alias: 'span'
					}
				],
				'field-capture': [
					{
						pattern:
							/([a-zA-Z0-9\-.]+\s*\()\s*[a-zA-Z0-9\-.]+\s*:\s*[a-zA-Z0-9\-.]+(?:\s*,\s*[a-zA-Z0-9\-.]+\s*:\s*[a-zA-Z0-9\-.]+)*(?=\s*\))/,
						lookbehind: true,
						inside: {
							'field-name': {
								pattern: /[a-zA-Z0-9\-.]+/,
								alias: 'variable'
							},
							colon: /:/
						}
					},
					{
						pattern: /[a-zA-Z0-9\-.]+\s*:/,
						inside: {
							'field-name': {
								pattern: /[a-zA-Z0-9\-.]+/,
								alias: 'variable'
							},
							colon: /:/
						}
					}
				],
				punctuation: /[:;,()]/,
				name: /[a-zA-Z0-9\-.]+/
			};
		}
	}
});

// node_modules/refractor/lang/nginx.js
var require_nginx = __commonJS({
	'node_modules/refractor/lang/nginx.js'(exports, module2) {
		'use strict';
		module2.exports = nginx;
		nginx.displayName = 'nginx';
		nginx.aliases = [];
		function nginx(Prism) {
			(function (Prism2) {
				var variable = /\$(?:\w[a-z\d]*(?:_[^\x00-\x1F\s"'\\()$]*)?|\{[^}\s"'\\]+\})/i;
				Prism2.languages.nginx = {
					comment: {
						pattern: /(^|[\s{};])#.*/,
						lookbehind: true,
						greedy: true
					},
					directive: {
						pattern:
							/(^|\s)\w(?:[^;{}"'\\\s]|\\.|"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*'|\s+(?:#.*(?!.)|(?![#\s])))*?(?=\s*[;{])/,
						lookbehind: true,
						greedy: true,
						inside: {
							string: {
								pattern: /((?:^|[^\\])(?:\\\\)*)(?:"(?:[^"\\]|\\.)*"|'(?:[^'\\]|\\.)*')/,
								lookbehind: true,
								greedy: true,
								inside: {
									escape: {
										pattern: /\\["'\\nrt]/,
										alias: 'entity'
									},
									variable
								}
							},
							comment: {
								pattern: /(\s)#.*/,
								lookbehind: true,
								greedy: true
							},
							keyword: {
								pattern: /^\S+/,
								greedy: true
							},
							boolean: {
								pattern: /(\s)(?:off|on)(?!\S)/,
								lookbehind: true
							},
							number: {
								pattern: /(\s)\d+[a-z]*(?!\S)/i,
								lookbehind: true
							},
							variable
						}
					},
					punctuation: /[{};]/
				};
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/nim.js
var require_nim = __commonJS({
	'node_modules/refractor/lang/nim.js'(exports, module2) {
		'use strict';
		module2.exports = nim;
		nim.displayName = 'nim';
		nim.aliases = [];
		function nim(Prism) {
			Prism.languages.nim = {
				comment: {
					pattern: /#.*/,
					greedy: true
				},
				string: {
					pattern:
						/(?:\b(?!\d)(?:\w|\\x[89a-fA-F][0-9a-fA-F])+)?(?:"""[\s\S]*?"""(?!")|"(?:\\[\s\S]|""|[^"\\])*")/,
					greedy: true
				},
				char: {
					pattern: /'(?:\\(?:\d+|x[\da-fA-F]{0,2}|.)|[^'])'/,
					greedy: true
				},
				function: {
					pattern:
						/(?:(?!\d)(?:\w|\\x[89a-fA-F][0-9a-fA-F])+|`[^`\r\n]+`)\*?(?:\[[^\]]+\])?(?=\s*\()/,
					greedy: true,
					inside: {
						operator: /\*$/
					}
				},
				identifier: {
					pattern: /`[^`\r\n]+`/,
					greedy: true,
					inside: {
						punctuation: /`/
					}
				},
				number:
					/\b(?:0[xXoObB][\da-fA-F_]+|\d[\d_]*(?:(?!\.\.)\.[\d_]*)?(?:[eE][+-]?\d[\d_]*)?)(?:'?[iuf]\d*)?/,
				keyword:
					/\b(?:addr|as|asm|atomic|bind|block|break|case|cast|concept|const|continue|converter|defer|discard|distinct|do|elif|else|end|enum|except|export|finally|for|from|func|generic|if|import|include|interface|iterator|let|macro|method|mixin|nil|object|out|proc|ptr|raise|ref|return|static|template|try|tuple|type|using|var|when|while|with|without|yield)\b/,
				operator: {
					pattern:
						/(^|[({\[](?=\.\.)|(?![({\[]\.).)(?:(?:[=+\-*\/<>@$~&%|!?^:\\]|\.\.|\.(?![)}\]]))+|\b(?:and|div|in|is|isnot|mod|not|notin|of|or|shl|shr|xor)\b)/m,
					lookbehind: true
				},
				punctuation: /[({\[]\.|\.[)}\]]|[`(){}\[\],:]/
			};
		}
	}
});

// node_modules/refractor/lang/nix.js
var require_nix = __commonJS({
	'node_modules/refractor/lang/nix.js'(exports, module2) {
		'use strict';
		module2.exports = nix;
		nix.displayName = 'nix';
		nix.aliases = [];
		function nix(Prism) {
			Prism.languages.nix = {
				comment: {
					pattern: /\/\*[\s\S]*?\*\/|#.*/,
					greedy: true
				},
				string: {
					pattern: /"(?:[^"\\]|\\[\s\S])*"|''(?:(?!'')[\s\S]|''(?:'|\\|\$\{))*''/,
					greedy: true,
					inside: {
						interpolation: {
							pattern: /(^|(?:^|(?!'').)[^\\])\$\{(?:[^{}]|\{[^}]*\})*\}/,
							lookbehind: true,
							inside: null
						}
					}
				},
				url: [
					/\b(?:[a-z]{3,7}:\/\/)[\w\-+%~\/.:#=?&]+/,
					{
						pattern:
							/([^\/])(?:[\w\-+%~.:#=?&]*(?!\/\/)[\w\-+%~\/.:#=?&])?(?!\/\/)\/[\w\-+%~\/.:#=?&]*/,
						lookbehind: true
					}
				],
				antiquotation: {
					pattern: /\$(?=\{)/,
					alias: 'important'
				},
				number: /\b\d+\b/,
				keyword: /\b(?:assert|builtins|else|if|in|inherit|let|null|or|then|with)\b/,
				function:
					/\b(?:abort|add|all|any|attrNames|attrValues|baseNameOf|compareVersions|concatLists|currentSystem|deepSeq|derivation|dirOf|div|elem(?:At)?|fetch(?:Tarball|url)|filter(?:Source)?|fromJSON|genList|getAttr|getEnv|hasAttr|hashString|head|import|intersectAttrs|is(?:Attrs|Bool|Function|Int|List|Null|String)|length|lessThan|listToAttrs|map|mul|parseDrvName|pathExists|read(?:Dir|File)|removeAttrs|replaceStrings|seq|sort|stringLength|sub(?:string)?|tail|throw|to(?:File|JSON|Path|String|XML)|trace|typeOf)\b|\bfoldl'\B/,
				boolean: /\b(?:false|true)\b/,
				operator: /[=!<>]=?|\+\+?|\|\||&&|\/\/|->?|[?@]/,
				punctuation: /[{}()[\].,:;]/
			};
			Prism.languages.nix.string.inside.interpolation.inside = Prism.languages.nix;
		}
	}
});

// node_modules/refractor/lang/nsis.js
var require_nsis = __commonJS({
	'node_modules/refractor/lang/nsis.js'(exports, module2) {
		'use strict';
		module2.exports = nsis;
		nsis.displayName = 'nsis';
		nsis.aliases = [];
		function nsis(Prism) {
			Prism.languages.nsis = {
				comment: {
					pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|[#;].*)/,
					lookbehind: true,
					greedy: true
				},
				string: {
					pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
					greedy: true
				},
				keyword: {
					pattern:
						/(^[\t ]*)(?:Abort|Add(?:BrandingImage|Size)|AdvSplash|Allow(?:RootDirInstall|SkipFiles)|AutoCloseWindow|BG(?:Font|Gradient|Image)|Banner|BrandingText|BringToFront|CRCCheck|Call(?:InstDLL)?|Caption|ChangeUI|CheckBitmap|ClearErrors|CompletedText|ComponentText|CopyFiles|Create(?:Directory|Font|ShortCut)|Delete(?:INISec|INIStr|RegKey|RegValue)?|Detail(?:Print|sButtonText)|Dialer|Dir(?:Text|Var|Verify)|EnableWindow|Enum(?:RegKey|RegValue)|Exch|Exec(?:Shell(?:Wait)?|Wait)?|ExpandEnvStrings|File(?:BufSize|Close|ErrorText|Open|Read|ReadByte|ReadUTF16LE|ReadWord|Seek|Write|WriteByte|WriteUTF16LE|WriteWord)?|Find(?:Close|First|Next|Window)|FlushINI|Get(?:CurInstType|CurrentAddress|DLLVersion(?:Local)?|DlgItem|ErrorLevel|FileTime(?:Local)?|FullPathName|Function(?:Address|End)?|InstDirError|LabelAddress|TempFileName)|Goto|HideWindow|Icon|If(?:Abort|Errors|FileExists|RebootFlag|Silent)|InitPluginsDir|InstProgressFlags|Inst(?:Type(?:GetText|SetText)?)|Install(?:ButtonText|Colors|Dir(?:RegKey)?)|Int(?:64|Ptr)?CmpU?|Int(?:64)?Fmt|Int(?:Ptr)?Op|IsWindow|Lang(?:DLL|String)|License(?:BkColor|Data|ForceSelection|LangString|Text)|LoadLanguageFile|LockWindow|Log(?:Set|Text)|Manifest(?:DPIAware|SupportedOS)|Math|MessageBox|MiscButtonText|NSISdl|Name|Nop|OutFile|PE(?:DllCharacteristics|SubsysVer)|Page(?:Callbacks)?|Pop|Push|Quit|RMDir|Read(?:EnvStr|INIStr|RegDWORD|RegStr)|Reboot|RegDLL|Rename|RequestExecutionLevel|ReserveFile|Return|SearchPath|Section(?:End|GetFlags|GetInstTypes|GetSize|GetText|Group|In|SetFlags|SetInstTypes|SetSize|SetText)?|SendMessage|Set(?:AutoClose|BrandingImage|Compress|Compressor(?:DictSize)?|CtlColors|CurInstType|DatablockOptimize|DateSave|Details(?:Print|View)|ErrorLevel|Errors|FileAttributes|Font|OutPath|Overwrite|PluginUnload|RebootFlag|RegView|ShellVarContext|Silent)|Show(?:InstDetails|UninstDetails|Window)|Silent(?:Install|UnInstall)|Sleep|SpaceTexts|Splash|StartMenu|Str(?:CmpS?|Cpy|Len)|SubCaption|System|UnRegDLL|Unicode|UninstPage|Uninstall(?:ButtonText|Caption|Icon|SubCaption|Text)|UserInfo|VI(?:AddVersionKey|FileVersion|ProductVersion)|VPatch|Var|WindowIcon|Write(?:INIStr|Reg(?:Bin|DWORD|ExpandStr|MultiStr|None|Str)|Uninstaller)|XPStyle|ns(?:Dialogs|Exec))\b/m,
					lookbehind: true
				},
				property:
					/\b(?:ARCHIVE|FILE_(?:ATTRIBUTE_ARCHIVE|ATTRIBUTE_NORMAL|ATTRIBUTE_OFFLINE|ATTRIBUTE_READONLY|ATTRIBUTE_SYSTEM|ATTRIBUTE_TEMPORARY)|HK(?:(?:CR|CU|LM)(?:32|64)?|DD|PD|U)|HKEY_(?:CLASSES_ROOT|CURRENT_CONFIG|CURRENT_USER|DYN_DATA|LOCAL_MACHINE|PERFORMANCE_DATA|USERS)|ID(?:ABORT|CANCEL|IGNORE|NO|OK|RETRY|YES)|MB_(?:ABORTRETRYIGNORE|DEFBUTTON1|DEFBUTTON2|DEFBUTTON3|DEFBUTTON4|ICONEXCLAMATION|ICONINFORMATION|ICONQUESTION|ICONSTOP|OK|OKCANCEL|RETRYCANCEL|RIGHT|RTLREADING|SETFOREGROUND|TOPMOST|USERICON|YESNO)|NORMAL|OFFLINE|READONLY|SHCTX|SHELL_CONTEXT|SYSTEM|TEMPORARY|admin|all|auto|both|colored|false|force|hide|highest|lastused|leave|listonly|none|normal|notset|off|on|open|print|show|silent|silentlog|smooth|textonly|true|user)\b/,
				constant: /\$\{[!\w\.:\^-]+\}|\$\([!\w\.:\^-]+\)/,
				variable: /\$\w[\w\.]*/,
				number: /\b0x[\dA-Fa-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee]-?\d+)?/,
				operator: /--?|\+\+?|<=?|>=?|==?=?|&&?|\|\|?|[?*\/~^%]/,
				punctuation: /[{}[\];(),.:]/,
				important: {
					pattern:
						/(^[\t ]*)!(?:addincludedir|addplugindir|appendfile|cd|define|delfile|echo|else|endif|error|execute|finalize|getdllversion|gettlbversion|if|ifdef|ifmacrodef|ifmacrondef|ifndef|include|insertmacro|macro|macroend|makensis|packhdr|pragma|searchparse|searchreplace|system|tempfile|undef|verbose|warning)\b/im,
					lookbehind: true
				}
			};
		}
	}
});

// node_modules/refractor/lang/objectivec.js
var require_objectivec = __commonJS({
	'node_modules/refractor/lang/objectivec.js'(exports, module2) {
		'use strict';
		var refractorC = require_c();
		module2.exports = objectivec;
		objectivec.displayName = 'objectivec';
		objectivec.aliases = ['objc'];
		function objectivec(Prism) {
			Prism.register(refractorC);
			Prism.languages.objectivec = Prism.languages.extend('c', {
				string: {
					pattern: /@?"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
					greedy: true
				},
				keyword:
					/\b(?:asm|auto|break|case|char|const|continue|default|do|double|else|enum|extern|float|for|goto|if|in|inline|int|long|register|return|self|short|signed|sizeof|static|struct|super|switch|typedef|typeof|union|unsigned|void|volatile|while)\b|(?:@interface|@end|@implementation|@protocol|@class|@public|@protected|@private|@property|@try|@catch|@finally|@throw|@synthesize|@dynamic|@selector)\b/,
				operator: /-[->]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|\|?|[~^%?*\/@]/
			});
			delete Prism.languages.objectivec['class-name'];
			Prism.languages.objc = Prism.languages.objectivec;
		}
	}
});

// node_modules/refractor/lang/ocaml.js
var require_ocaml = __commonJS({
	'node_modules/refractor/lang/ocaml.js'(exports, module2) {
		'use strict';
		module2.exports = ocaml;
		ocaml.displayName = 'ocaml';
		ocaml.aliases = [];
		function ocaml(Prism) {
			Prism.languages.ocaml = {
				comment: {
					pattern: /\(\*[\s\S]*?\*\)/,
					greedy: true
				},
				char: {
					pattern: /'(?:[^\\\r\n']|\\(?:.|[ox]?[0-9a-f]{1,3}))'/i,
					greedy: true
				},
				string: [
					{
						pattern: /"(?:\\(?:[\s\S]|\r\n)|[^\\\r\n"])*"/,
						greedy: true
					},
					{
						pattern: /\{([a-z_]*)\|[\s\S]*?\|\1\}/,
						greedy: true
					}
				],
				number: [
					/\b(?:0b[01][01_]*|0o[0-7][0-7_]*)\b/i,
					/\b0x[a-f0-9][a-f0-9_]*(?:\.[a-f0-9_]*)?(?:p[+-]?\d[\d_]*)?(?!\w)/i,
					/\b\d[\d_]*(?:\.[\d_]*)?(?:e[+-]?\d[\d_]*)?(?!\w)/i
				],
				directive: {
					pattern: /\B#\w+/,
					alias: 'property'
				},
				label: {
					pattern: /\B~\w+/,
					alias: 'property'
				},
				'type-variable': {
					pattern: /\B'\w+/,
					alias: 'function'
				},
				variant: {
					pattern: /`\w+/,
					alias: 'symbol'
				},
				keyword:
					/\b(?:as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|match|method|module|mutable|new|nonrec|object|of|open|private|rec|sig|struct|then|to|try|type|val|value|virtual|when|where|while|with)\b/,
				boolean: /\b(?:false|true)\b/,
				'operator-like-punctuation': {
					pattern: /\[[<>|]|[>|]\]|\{<|>\}/,
					alias: 'punctuation'
				},
				operator:
					/\.[.~]|:[=>]|[=<>@^|&+\-*\/$%!?~][!$%&*+\-.\/:<=>?@^|~]*|\b(?:and|asr|land|lor|lsl|lsr|lxor|mod|or)\b/,
				punctuation: /;;|::|[(){}\[\].,:;#]|\b_\b/
			};
		}
	}
});

// node_modules/refractor/lang/opencl.js
var require_opencl = __commonJS({
	'node_modules/refractor/lang/opencl.js'(exports, module2) {
		'use strict';
		var refractorC = require_c();
		module2.exports = opencl;
		opencl.displayName = 'opencl';
		opencl.aliases = [];
		function opencl(Prism) {
			Prism.register(refractorC);
			(function (Prism2) {
				Prism2.languages.opencl = Prism2.languages.extend('c', {
					keyword:
						/\b(?:(?:__)?(?:constant|global|kernel|local|private|read_only|read_write|write_only)|__attribute__|auto|(?:bool|u?(?:char|int|long|short)|half|quad)(?:2|3|4|8|16)?|break|case|complex|const|continue|(?:double|float)(?:16(?:x(?:1|2|4|8|16))?|1x(?:1|2|4|8|16)|2(?:x(?:1|2|4|8|16))?|3|4(?:x(?:1|2|4|8|16))?|8(?:x(?:1|2|4|8|16))?)?|default|do|else|enum|extern|for|goto|if|imaginary|inline|packed|pipe|register|restrict|return|signed|sizeof|static|struct|switch|typedef|uniform|union|unsigned|void|volatile|while)\b/,
					number:
						/(?:\b0x(?:[\da-f]+(?:\.[\da-f]*)?|\.[\da-f]+)(?:p[+-]?\d+)?|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)[fuhl]{0,4}/i,
					boolean: /\b(?:false|true)\b/,
					'constant-opencl-kernel': {
						pattern:
							/\b(?:CHAR_(?:BIT|MAX|MIN)|CLK_(?:ADDRESS_(?:CLAMP(?:_TO_EDGE)?|NONE|REPEAT)|FILTER_(?:LINEAR|NEAREST)|(?:GLOBAL|LOCAL)_MEM_FENCE|NORMALIZED_COORDS_(?:FALSE|TRUE))|CL_(?:BGRA|(?:HALF_)?FLOAT|INTENSITY|LUMINANCE|A?R?G?B?[Ax]?|(?:(?:UN)?SIGNED|[US]NORM)_(?:INT(?:8|16|32))|UNORM_(?:INT_101010|SHORT_(?:555|565)))|(?:DBL|FLT|HALF)_(?:DIG|EPSILON|(?:MAX|MIN)(?:(?:_10)?_EXP)?|MANT_DIG)|FLT_RADIX|HUGE_VALF?|(?:INT|LONG|SCHAR|SHRT)_(?:MAX|MIN)|INFINITY|MAXFLOAT|M_(?:[12]_PI|2_SQRTPI|E|LN(?:2|10)|LOG(?:2|10)E?|PI(?:_[24])?|SQRT(?:1_2|2))(?:_F|_H)?|NAN|(?:UCHAR|UINT|ULONG|USHRT)_MAX)\b/,
						alias: 'constant'
					}
				});
				Prism2.languages.insertBefore('opencl', 'class-name', {
					'builtin-type': {
						pattern:
							/\b(?:_cl_(?:command_queue|context|device_id|event|kernel|mem|platform_id|program|sampler)|cl_(?:image_format|mem_fence_flags)|clk_event_t|event_t|image(?:1d_(?:array_|buffer_)?t|2d_(?:array_(?:depth_|msaa_depth_|msaa_)?|depth_|msaa_depth_|msaa_)?t|3d_t)|intptr_t|ndrange_t|ptrdiff_t|queue_t|reserve_id_t|sampler_t|size_t|uintptr_t)\b/,
						alias: 'keyword'
					}
				});
				var attributes = {
					'type-opencl-host': {
						pattern:
							/\b(?:cl_(?:GLenum|GLint|GLuin|addressing_mode|bitfield|bool|buffer_create_type|build_status|channel_(?:order|type)|(?:u?(?:char|int|long|short)|double|float)(?:2|3|4|8|16)?|command_(?:queue(?:_info|_properties)?|type)|context(?:_info|_properties)?|device_(?:exec_capabilities|fp_config|id|info|local_mem_type|mem_cache_type|type)|(?:event|sampler)(?:_info)?|filter_mode|half|image_info|kernel(?:_info|_work_group_info)?|map_flags|mem(?:_flags|_info|_object_type)?|platform_(?:id|info)|profiling_info|program(?:_build_info|_info)?))\b/,
						alias: 'keyword'
					},
					'boolean-opencl-host': {
						pattern: /\bCL_(?:FALSE|TRUE)\b/,
						alias: 'boolean'
					},
					'constant-opencl-host': {
						pattern:
							/\bCL_(?:A|ABGR|ADDRESS_(?:CLAMP(?:_TO_EDGE)?|MIRRORED_REPEAT|NONE|REPEAT)|ARGB|BGRA|BLOCKING|BUFFER_CREATE_TYPE_REGION|BUILD_(?:ERROR|IN_PROGRESS|NONE|PROGRAM_FAILURE|SUCCESS)|COMMAND_(?:ACQUIRE_GL_OBJECTS|BARRIER|COPY_(?:BUFFER(?:_RECT|_TO_IMAGE)?|IMAGE(?:_TO_BUFFER)?)|FILL_(?:BUFFER|IMAGE)|MAP(?:_BUFFER|_IMAGE)|MARKER|MIGRATE(?:_SVM)?_MEM_OBJECTS|NATIVE_KERNEL|NDRANGE_KERNEL|READ_(?:BUFFER(?:_RECT)?|IMAGE)|RELEASE_GL_OBJECTS|SVM_(?:FREE|MAP|MEMCPY|MEMFILL|UNMAP)|TASK|UNMAP_MEM_OBJECT|USER|WRITE_(?:BUFFER(?:_RECT)?|IMAGE))|COMPILER_NOT_AVAILABLE|COMPILE_PROGRAM_FAILURE|COMPLETE|CONTEXT_(?:DEVICES|INTEROP_USER_SYNC|NUM_DEVICES|PLATFORM|PROPERTIES|REFERENCE_COUNT)|DEPTH(?:_STENCIL)?|DEVICE_(?:ADDRESS_BITS|AFFINITY_DOMAIN_(?:L[1-4]_CACHE|NEXT_PARTITIONABLE|NUMA)|AVAILABLE|BUILT_IN_KERNELS|COMPILER_AVAILABLE|DOUBLE_FP_CONFIG|ENDIAN_LITTLE|ERROR_CORRECTION_SUPPORT|EXECUTION_CAPABILITIES|EXTENSIONS|GLOBAL_(?:MEM_(?:CACHELINE_SIZE|CACHE_SIZE|CACHE_TYPE|SIZE)|VARIABLE_PREFERRED_TOTAL_SIZE)|HOST_UNIFIED_MEMORY|IL_VERSION|IMAGE(?:2D_MAX_(?:HEIGHT|WIDTH)|3D_MAX_(?:DEPTH|HEIGHT|WIDTH)|_BASE_ADDRESS_ALIGNMENT|_MAX_ARRAY_SIZE|_MAX_BUFFER_SIZE|_PITCH_ALIGNMENT|_SUPPORT)|LINKER_AVAILABLE|LOCAL_MEM_SIZE|LOCAL_MEM_TYPE|MAX_(?:CLOCK_FREQUENCY|COMPUTE_UNITS|CONSTANT_ARGS|CONSTANT_BUFFER_SIZE|GLOBAL_VARIABLE_SIZE|MEM_ALLOC_SIZE|NUM_SUB_GROUPS|ON_DEVICE_(?:EVENTS|QUEUES)|PARAMETER_SIZE|PIPE_ARGS|READ_IMAGE_ARGS|READ_WRITE_IMAGE_ARGS|SAMPLERS|WORK_GROUP_SIZE|WORK_ITEM_DIMENSIONS|WORK_ITEM_SIZES|WRITE_IMAGE_ARGS)|MEM_BASE_ADDR_ALIGN|MIN_DATA_TYPE_ALIGN_SIZE|NAME|NATIVE_VECTOR_WIDTH_(?:CHAR|DOUBLE|FLOAT|HALF|INT|LONG|SHORT)|NOT_(?:AVAILABLE|FOUND)|OPENCL_C_VERSION|PARENT_DEVICE|PARTITION_(?:AFFINITY_DOMAIN|BY_AFFINITY_DOMAIN|BY_COUNTS|BY_COUNTS_LIST_END|EQUALLY|FAILED|MAX_SUB_DEVICES|PROPERTIES|TYPE)|PIPE_MAX_(?:ACTIVE_RESERVATIONS|PACKET_SIZE)|PLATFORM|PREFERRED_(?:GLOBAL_ATOMIC_ALIGNMENT|INTEROP_USER_SYNC|LOCAL_ATOMIC_ALIGNMENT|PLATFORM_ATOMIC_ALIGNMENT|VECTOR_WIDTH_(?:CHAR|DOUBLE|FLOAT|HALF|INT|LONG|SHORT))|PRINTF_BUFFER_SIZE|PROFILE|PROFILING_TIMER_RESOLUTION|QUEUE_(?:ON_(?:DEVICE_(?:MAX_SIZE|PREFERRED_SIZE|PROPERTIES)|HOST_PROPERTIES)|PROPERTIES)|REFERENCE_COUNT|SINGLE_FP_CONFIG|SUB_GROUP_INDEPENDENT_FORWARD_PROGRESS|SVM_(?:ATOMICS|CAPABILITIES|COARSE_GRAIN_BUFFER|FINE_GRAIN_BUFFER|FINE_GRAIN_SYSTEM)|TYPE(?:_ACCELERATOR|_ALL|_CPU|_CUSTOM|_DEFAULT|_GPU)?|VENDOR(?:_ID)?|VERSION)|DRIVER_VERSION|EVENT_(?:COMMAND_(?:EXECUTION_STATUS|QUEUE|TYPE)|CONTEXT|REFERENCE_COUNT)|EXEC_(?:KERNEL|NATIVE_KERNEL|STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST)|FILTER_(?:LINEAR|NEAREST)|FLOAT|FP_(?:CORRECTLY_ROUNDED_DIVIDE_SQRT|DENORM|FMA|INF_NAN|ROUND_TO_INF|ROUND_TO_NEAREST|ROUND_TO_ZERO|SOFT_FLOAT)|GLOBAL|HALF_FLOAT|IMAGE_(?:ARRAY_SIZE|BUFFER|DEPTH|ELEMENT_SIZE|FORMAT|FORMAT_MISMATCH|FORMAT_NOT_SUPPORTED|HEIGHT|NUM_MIP_LEVELS|NUM_SAMPLES|ROW_PITCH|SLICE_PITCH|WIDTH)|INTENSITY|INVALID_(?:ARG_INDEX|ARG_SIZE|ARG_VALUE|BINARY|BUFFER_SIZE|BUILD_OPTIONS|COMMAND_QUEUE|COMPILER_OPTIONS|CONTEXT|DEVICE|DEVICE_PARTITION_COUNT|DEVICE_QUEUE|DEVICE_TYPE|EVENT|EVENT_WAIT_LIST|GLOBAL_OFFSET|GLOBAL_WORK_SIZE|GL_OBJECT|HOST_PTR|IMAGE_DESCRIPTOR|IMAGE_FORMAT_DESCRIPTOR|IMAGE_SIZE|KERNEL|KERNEL_ARGS|KERNEL_DEFINITION|KERNEL_NAME|LINKER_OPTIONS|MEM_OBJECT|MIP_LEVEL|OPERATION|PIPE_SIZE|PLATFORM|PROGRAM|PROGRAM_EXECUTABLE|PROPERTY|QUEUE_PROPERTIES|SAMPLER|VALUE|WORK_DIMENSION|WORK_GROUP_SIZE|WORK_ITEM_SIZE)|KERNEL_(?:ARG_(?:ACCESS_(?:NONE|QUALIFIER|READ_ONLY|READ_WRITE|WRITE_ONLY)|ADDRESS_(?:CONSTANT|GLOBAL|LOCAL|PRIVATE|QUALIFIER)|INFO_NOT_AVAILABLE|NAME|TYPE_(?:CONST|NAME|NONE|PIPE|QUALIFIER|RESTRICT|VOLATILE))|ATTRIBUTES|COMPILE_NUM_SUB_GROUPS|COMPILE_WORK_GROUP_SIZE|CONTEXT|EXEC_INFO_SVM_FINE_GRAIN_SYSTEM|EXEC_INFO_SVM_PTRS|FUNCTION_NAME|GLOBAL_WORK_SIZE|LOCAL_MEM_SIZE|LOCAL_SIZE_FOR_SUB_GROUP_COUNT|MAX_NUM_SUB_GROUPS|MAX_SUB_GROUP_SIZE_FOR_NDRANGE|NUM_ARGS|PREFERRED_WORK_GROUP_SIZE_MULTIPLE|PRIVATE_MEM_SIZE|PROGRAM|REFERENCE_COUNT|SUB_GROUP_COUNT_FOR_NDRANGE|WORK_GROUP_SIZE)|LINKER_NOT_AVAILABLE|LINK_PROGRAM_FAILURE|LOCAL|LUMINANCE|MAP_(?:FAILURE|READ|WRITE|WRITE_INVALIDATE_REGION)|MEM_(?:ALLOC_HOST_PTR|ASSOCIATED_MEMOBJECT|CONTEXT|COPY_HOST_PTR|COPY_OVERLAP|FLAGS|HOST_NO_ACCESS|HOST_PTR|HOST_READ_ONLY|HOST_WRITE_ONLY|KERNEL_READ_AND_WRITE|MAP_COUNT|OBJECT_(?:ALLOCATION_FAILURE|BUFFER|IMAGE1D|IMAGE1D_ARRAY|IMAGE1D_BUFFER|IMAGE2D|IMAGE2D_ARRAY|IMAGE3D|PIPE)|OFFSET|READ_ONLY|READ_WRITE|REFERENCE_COUNT|SIZE|SVM_ATOMICS|SVM_FINE_GRAIN_BUFFER|TYPE|USES_SVM_POINTER|USE_HOST_PTR|WRITE_ONLY)|MIGRATE_MEM_OBJECT_(?:CONTENT_UNDEFINED|HOST)|MISALIGNED_SUB_BUFFER_OFFSET|NONE|NON_BLOCKING|OUT_OF_(?:HOST_MEMORY|RESOURCES)|PIPE_(?:MAX_PACKETS|PACKET_SIZE)|PLATFORM_(?:EXTENSIONS|HOST_TIMER_RESOLUTION|NAME|PROFILE|VENDOR|VERSION)|PROFILING_(?:COMMAND_(?:COMPLETE|END|QUEUED|START|SUBMIT)|INFO_NOT_AVAILABLE)|PROGRAM_(?:BINARIES|BINARY_SIZES|BINARY_TYPE(?:_COMPILED_OBJECT|_EXECUTABLE|_LIBRARY|_NONE)?|BUILD_(?:GLOBAL_VARIABLE_TOTAL_SIZE|LOG|OPTIONS|STATUS)|CONTEXT|DEVICES|IL|KERNEL_NAMES|NUM_DEVICES|NUM_KERNELS|REFERENCE_COUNT|SOURCE)|QUEUED|QUEUE_(?:CONTEXT|DEVICE|DEVICE_DEFAULT|ON_DEVICE|ON_DEVICE_DEFAULT|OUT_OF_ORDER_EXEC_MODE_ENABLE|PROFILING_ENABLE|PROPERTIES|REFERENCE_COUNT|SIZE)|R|RA|READ_(?:ONLY|WRITE)_CACHE|RG|RGB|RGBA|RGBx|RGx|RUNNING|Rx|SAMPLER_(?:ADDRESSING_MODE|CONTEXT|FILTER_MODE|LOD_MAX|LOD_MIN|MIP_FILTER_MODE|NORMALIZED_COORDS|REFERENCE_COUNT)|(?:UN)?SIGNED_INT(?:8|16|32)|SNORM_INT(?:8|16)|SUBMITTED|SUCCESS|UNORM_INT(?:8|16|24|_101010|_101010_2)|UNORM_SHORT_(?:555|565)|VERSION_(?:1_0|1_1|1_2|2_0|2_1)|sBGRA|sRGB|sRGBA|sRGBx)\b/,
						alias: 'constant'
					},
					'function-opencl-host': {
						pattern:
							/\bcl(?:BuildProgram|CloneKernel|CompileProgram|Create(?:Buffer|CommandQueue(?:WithProperties)?|Context|ContextFromType|Image|Image2D|Image3D|Kernel|KernelsInProgram|Pipe|ProgramWith(?:Binary|BuiltInKernels|IL|Source)|Sampler|SamplerWithProperties|SubBuffer|SubDevices|UserEvent)|Enqueue(?:(?:Barrier|Marker)(?:WithWaitList)?|Copy(?:Buffer(?:Rect|ToImage)?|Image(?:ToBuffer)?)|(?:Fill|Map)(?:Buffer|Image)|MigrateMemObjects|NDRangeKernel|NativeKernel|(?:Read|Write)(?:Buffer(?:Rect)?|Image)|SVM(?:Free|Map|MemFill|Memcpy|MigrateMem|Unmap)|Task|UnmapMemObject|WaitForEvents)|Finish|Flush|Get(?:CommandQueueInfo|ContextInfo|Device(?:AndHostTimer|IDs|Info)|Event(?:Profiling)?Info|ExtensionFunctionAddress(?:ForPlatform)?|HostTimer|ImageInfo|Kernel(?:ArgInfo|Info|SubGroupInfo|WorkGroupInfo)|MemObjectInfo|PipeInfo|Platform(?:IDs|Info)|Program(?:Build)?Info|SamplerInfo|SupportedImageFormats)|LinkProgram|(?:Release|Retain)(?:CommandQueue|Context|Device|Event|Kernel|MemObject|Program|Sampler)|SVM(?:Alloc|Free)|Set(?:CommandQueueProperty|DefaultDeviceCommandQueue|EventCallback|Kernel|Kernel(?:Arg(?:SVMPointer)?|ExecInfo)|MemObjectDestructorCallback|UserEventStatus)|Unload(?:Platform)?Compiler|WaitForEvents)\b/,
						alias: 'function'
					}
				};
				Prism2.languages.insertBefore('c', 'keyword', attributes);
				if (Prism2.languages.cpp) {
					attributes['type-opencl-host-cpp'] = {
						pattern:
							/\b(?:Buffer|BufferGL|BufferRenderGL|CommandQueue|Context|Device|DeviceCommandQueue|EnqueueArgs|Event|Image|Image1D|Image1DArray|Image1DBuffer|Image2D|Image2DArray|Image2DGL|Image3D|Image3DGL|ImageFormat|ImageGL|Kernel|KernelFunctor|LocalSpaceArg|Memory|NDRange|Pipe|Platform|Program|SVMAllocator|SVMTraitAtomic|SVMTraitCoarse|SVMTraitFine|SVMTraitReadOnly|SVMTraitReadWrite|SVMTraitWriteOnly|Sampler|UserEvent)\b/,
						alias: 'keyword'
					};
					Prism2.languages.insertBefore('cpp', 'keyword', attributes);
				}
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/openqasm.js
var require_openqasm = __commonJS({
	'node_modules/refractor/lang/openqasm.js'(exports, module2) {
		'use strict';
		module2.exports = openqasm;
		openqasm.displayName = 'openqasm';
		openqasm.aliases = ['qasm'];
		function openqasm(Prism) {
			Prism.languages.openqasm = {
				comment: /\/\*[\s\S]*?\*\/|\/\/.*/,
				string: {
					pattern: /"[^"\r\n\t]*"|'[^'\r\n\t]*'/,
					greedy: true
				},
				keyword:
					/\b(?:CX|OPENQASM|U|barrier|boxas|boxto|break|const|continue|ctrl|def|defcal|defcalgrammar|delay|else|end|for|gate|gphase|if|in|include|inv|kernel|lengthof|let|measure|pow|reset|return|rotary|stretchinf|while)\b|#pragma\b/,
				'class-name': /\b(?:angle|bit|bool|creg|fixed|float|int|length|qreg|qubit|stretch|uint)\b/,
				function: /\b(?:cos|exp|ln|popcount|rotl|rotr|sin|sqrt|tan)\b(?=\s*\()/,
				constant: /\b(?:euler|pi|tau)\b|||/,
				number: {
					pattern: /(^|[^.\w$])(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?(?:dt|ns|us|s|ms|s)?/i,
					lookbehind: true
				},
				operator: /->|>>=?|<<=?|&&|\|\||\+\+|--|[!=<>&|~^+\-*/%]=?|@/,
				punctuation: /[(){}\[\];,:.]/
			};
			Prism.languages.qasm = Prism.languages.openqasm;
		}
	}
});

// node_modules/refractor/lang/oz.js
var require_oz = __commonJS({
	'node_modules/refractor/lang/oz.js'(exports, module2) {
		'use strict';
		module2.exports = oz;
		oz.displayName = 'oz';
		oz.aliases = [];
		function oz(Prism) {
			Prism.languages.oz = {
				comment: {
					pattern: /\/\*[\s\S]*?\*\/|%.*/,
					greedy: true
				},
				string: {
					pattern: /"(?:[^"\\]|\\[\s\S])*"/,
					greedy: true
				},
				atom: {
					pattern: /'(?:[^'\\]|\\[\s\S])*'/,
					greedy: true,
					alias: 'builtin'
				},
				keyword:
					/\$|\[\]|\b(?:_|at|attr|case|catch|choice|class|cond|declare|define|dis|else(?:case|if)?|end|export|fail|false|feat|finally|from|fun|functor|if|import|in|local|lock|meth|nil|not|of|or|prepare|proc|prop|raise|require|self|skip|then|thread|true|try|unit)\b/,
				function: [
					/\b[a-z][A-Za-z\d]*(?=\()/,
					{
						pattern: /(\{)[A-Z][A-Za-z\d]*\b/,
						lookbehind: true
					}
				],
				number: /\b(?:0[bx][\da-f]+|\d+(?:\.\d*)?(?:e~?\d+)?)\b|&(?:[^\\]|\\(?:\d{3}|.))/i,
				variable: /`(?:[^`\\]|\\.)+`/,
				'attr-name': /\b\w+(?=[ \t]*:(?![:=]))/,
				operator:
					/:(?:=|::?)|<[-:=]?|=(?:=|<?:?)|>=?:?|\\=:?|!!?|[|#+\-*\/,~^@]|\b(?:andthen|div|mod|orelse)\b/,
				punctuation: /[\[\](){}.:;?]/
			};
		}
	}
});

// node_modules/refractor/lang/parigp.js
var require_parigp = __commonJS({
	'node_modules/refractor/lang/parigp.js'(exports, module2) {
		'use strict';
		module2.exports = parigp;
		parigp.displayName = 'parigp';
		parigp.aliases = [];
		function parigp(Prism) {
			Prism.languages.parigp = {
				comment: /\/\*[\s\S]*?\*\/|\\\\.*/,
				string: {
					pattern: /"(?:[^"\\\r\n]|\\.)*"/,
					greedy: true
				},
				keyword: (function () {
					var keywords = [
						'breakpoint',
						'break',
						'dbg_down',
						'dbg_err',
						'dbg_up',
						'dbg_x',
						'forcomposite',
						'fordiv',
						'forell',
						'forpart',
						'forprime',
						'forstep',
						'forsubgroup',
						'forvec',
						'for',
						'iferr',
						'if',
						'local',
						'my',
						'next',
						'return',
						'until',
						'while'
					];
					keywords = keywords
						.map(function (keyword) {
							return keyword.split('').join(' *');
						})
						.join('|');
					return RegExp('\\b(?:' + keywords + ')\\b');
				})(),
				function: /\b\w(?:[\w ]*\w)?(?= *\()/,
				number: {
					pattern:
						/((?:\. *\. *)?)(?:\b\d(?: *\d)*(?: *(?!\. *\.)\.(?: *\d)*)?|\. *\d(?: *\d)*)(?: *e *(?:[+-] *)?\d(?: *\d)*)?/i,
					lookbehind: true
				},
				operator:
					/\. *\.|[*\/!](?: *=)?|%(?: *=|(?: *#)?(?: *')*)?|\+(?: *[+=])?|-(?: *[-=>])?|<(?: *>|(?: *<)?(?: *=)?)?|>(?: *>)?(?: *=)?|=(?: *=){0,2}|\\(?: *\/)?(?: *=)?|&(?: *&)?|\| *\||['#~^]/,
				punctuation: /[\[\]{}().,:;|]/
			};
		}
	}
});

// node_modules/refractor/lang/parser.js
var require_parser2 = __commonJS({
	'node_modules/refractor/lang/parser.js'(exports, module2) {
		'use strict';
		module2.exports = parser;
		parser.displayName = 'parser';
		parser.aliases = [];
		function parser(Prism) {
			(function (Prism2) {
				var parser2 = (Prism2.languages.parser = Prism2.languages.extend('markup', {
					keyword: {
						pattern:
							/(^|[^^])(?:\^(?:case|eval|for|if|switch|throw)\b|@(?:BASE|CLASS|GET(?:_DEFAULT)?|OPTIONS|SET_DEFAULT|USE)\b)/,
						lookbehind: true
					},
					variable: {
						pattern: /(^|[^^])\B\$(?:\w+|(?=[.{]))(?:(?:\.|::?)\w+)*(?:\.|::?)?/,
						lookbehind: true,
						inside: {
							punctuation: /\.|:+/
						}
					},
					function: {
						pattern: /(^|[^^])\B[@^]\w+(?:(?:\.|::?)\w+)*(?:\.|::?)?/,
						lookbehind: true,
						inside: {
							keyword: {
								pattern: /(^@)(?:GET_|SET_)/,
								lookbehind: true
							},
							punctuation: /\.|:+/
						}
					},
					escape: {
						pattern: /\^(?:[$^;@()\[\]{}"':]|#[a-f\d]*)/i,
						alias: 'builtin'
					},
					punctuation: /[\[\](){};]/
				}));
				parser2 = Prism2.languages.insertBefore('parser', 'keyword', {
					'parser-comment': {
						pattern: /(\s)#.*/,
						lookbehind: true,
						alias: 'comment'
					},
					expression: {
						pattern: /(^|[^^])\((?:[^()]|\((?:[^()]|\((?:[^()])*\))*\))*\)/,
						greedy: true,
						lookbehind: true,
						inside: {
							string: {
								pattern: /(^|[^^])(["'])(?:(?!\2)[^^]|\^[\s\S])*\2/,
								lookbehind: true
							},
							keyword: parser2.keyword,
							variable: parser2.variable,
							function: parser2.function,
							boolean: /\b(?:false|true)\b/,
							number: /\b(?:0x[a-f\d]+|\d+(?:\.\d*)?(?:e[+-]?\d+)?)\b/i,
							escape: parser2.escape,
							operator:
								/[~+*\/\\%]|!(?:\|\|?|=)?|&&?|\|\|?|==|<[<=]?|>[>=]?|-[fd]?|\b(?:def|eq|ge|gt|in|is|le|lt|ne)\b/,
							punctuation: parser2.punctuation
						}
					}
				});
				Prism2.languages.insertBefore(
					'inside',
					'punctuation',
					{
						expression: parser2.expression,
						keyword: parser2.keyword,
						variable: parser2.variable,
						function: parser2.function,
						escape: parser2.escape,
						'parser-punctuation': {
							pattern: parser2.punctuation,
							alias: 'punctuation'
						}
					},
					parser2['tag'].inside['attr-value']
				);
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/pascal.js
var require_pascal = __commonJS({
	'node_modules/refractor/lang/pascal.js'(exports, module2) {
		'use strict';
		module2.exports = pascal;
		pascal.displayName = 'pascal';
		pascal.aliases = ['objectpascal'];
		function pascal(Prism) {
			Prism.languages.pascal = {
				directive: {
					pattern: /\{\$[\s\S]*?\}/,
					greedy: true,
					alias: ['marco', 'property']
				},
				comment: {
					pattern: /\(\*[\s\S]*?\*\)|\{[\s\S]*?\}|\/\/.*/,
					greedy: true
				},
				string: {
					pattern: /(?:'(?:''|[^'\r\n])*'(?!')|#[&$%]?[a-f\d]+)+|\^[a-z]/i,
					greedy: true
				},
				asm: {
					pattern: /(\basm\b)[\s\S]+?(?=\bend\s*[;[])/i,
					lookbehind: true,
					greedy: true,
					inside: null
				},
				keyword: [
					{
						pattern:
							/(^|[^&])\b(?:absolute|array|asm|begin|case|const|constructor|destructor|do|downto|else|end|file|for|function|goto|if|implementation|inherited|inline|interface|label|nil|object|of|operator|packed|procedure|program|record|reintroduce|repeat|self|set|string|then|to|type|unit|until|uses|var|while|with)\b/i,
						lookbehind: true
					},
					{
						pattern: /(^|[^&])\b(?:dispose|exit|false|new|true)\b/i,
						lookbehind: true
					},
					{
						pattern:
							/(^|[^&])\b(?:class|dispinterface|except|exports|finalization|finally|initialization|inline|library|on|out|packed|property|raise|resourcestring|threadvar|try)\b/i,
						lookbehind: true
					},
					{
						pattern:
							/(^|[^&])\b(?:absolute|abstract|alias|assembler|bitpacked|break|cdecl|continue|cppdecl|cvar|default|deprecated|dynamic|enumerator|experimental|export|external|far|far16|forward|generic|helper|implements|index|interrupt|iochecks|local|message|name|near|nodefault|noreturn|nostackframe|oldfpccall|otherwise|overload|override|pascal|platform|private|protected|public|published|read|register|reintroduce|result|safecall|saveregisters|softfloat|specialize|static|stdcall|stored|strict|unaligned|unimplemented|varargs|virtual|write)\b/i,
						lookbehind: true
					}
				],
				number: [/(?:[&%]\d+|\$[a-f\d]+)/i, /\b\d+(?:\.\d+)?(?:e[+-]?\d+)?/i],
				operator: [
					/\.\.|\*\*|:=|<[<=>]?|>[>=]?|[+\-*\/]=?|[@^=]/,
					{
						pattern: /(^|[^&])\b(?:and|as|div|exclude|in|include|is|mod|not|or|shl|shr|xor)\b/,
						lookbehind: true
					}
				],
				punctuation: /\(\.|\.\)|[()\[\]:;,.]/
			};
			Prism.languages.pascal.asm.inside = Prism.languages.extend('pascal', {
				asm: void 0,
				keyword: void 0,
				operator: void 0
			});
			Prism.languages.objectpascal = Prism.languages.pascal;
		}
	}
});

// node_modules/refractor/lang/pascaligo.js
var require_pascaligo = __commonJS({
	'node_modules/refractor/lang/pascaligo.js'(exports, module2) {
		'use strict';
		module2.exports = pascaligo;
		pascaligo.displayName = 'pascaligo';
		pascaligo.aliases = [];
		function pascaligo(Prism) {
			(function (Prism2) {
				var braces = /\((?:[^()]|\((?:[^()]|\([^()]*\))*\))*\)/.source;
				var type = /(?:\b\w+(?:<braces>)?|<braces>)/.source.replace(/<braces>/g, function () {
					return braces;
				});
				var pascaligo2 = (Prism2.languages.pascaligo = {
					comment: /\(\*[\s\S]+?\*\)|\/\/.*/,
					string: {
						pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1|\^[a-z]/i,
						greedy: true
					},
					'class-name': [
						{
							pattern: RegExp(
								/(\btype\s+\w+\s+is\s+)<type>/.source.replace(/<type>/g, function () {
									return type;
								}),
								'i'
							),
							lookbehind: true,
							inside: null
						},
						{
							pattern: RegExp(
								/<type>(?=\s+is\b)/.source.replace(/<type>/g, function () {
									return type;
								}),
								'i'
							),
							inside: null
						},
						{
							pattern: RegExp(
								/(:\s*)<type>/.source.replace(/<type>/g, function () {
									return type;
								})
							),
							lookbehind: true,
							inside: null
						}
					],
					keyword: {
						pattern:
							/(^|[^&])\b(?:begin|block|case|const|else|end|fail|for|from|function|if|is|nil|of|remove|return|skip|then|type|var|while|with)\b/i,
						lookbehind: true
					},
					boolean: {
						pattern: /(^|[^&])\b(?:False|True)\b/i,
						lookbehind: true
					},
					builtin: {
						pattern: /(^|[^&])\b(?:bool|int|list|map|nat|record|string|unit)\b/i,
						lookbehind: true
					},
					function: /\b\w+(?=\s*\()/,
					number: [/%[01]+|&[0-7]+|\$[a-f\d]+/i, /\b\d+(?:\.\d+)?(?:e[+-]?\d+)?(?:mtz|n)?/i],
					operator: /->|=\/=|\.\.|\*\*|:=|<[<=>]?|>[>=]?|[+\-*\/]=?|[@^=|]|\b(?:and|mod|or)\b/,
					punctuation: /\(\.|\.\)|[()\[\]:;,.{}]/
				});
				var classNameInside = ['comment', 'keyword', 'builtin', 'operator', 'punctuation'].reduce(
					function (accum, key3) {
						accum[key3] = pascaligo2[key3];
						return accum;
					},
					{}
				);
				pascaligo2['class-name'].forEach(function (p2) {
					p2.inside = classNameInside;
				});
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/pcaxis.js
var require_pcaxis = __commonJS({
	'node_modules/refractor/lang/pcaxis.js'(exports, module2) {
		'use strict';
		module2.exports = pcaxis;
		pcaxis.displayName = 'pcaxis';
		pcaxis.aliases = ['px'];
		function pcaxis(Prism) {
			Prism.languages.pcaxis = {
				string: /"[^"]*"/,
				keyword: {
					pattern:
						/((?:^|;)\s*)[-A-Z\d]+(?:\s*\[[-\w]+\])?(?:\s*\("[^"]*"(?:,\s*"[^"]*")*\))?(?=\s*=)/,
					lookbehind: true,
					greedy: true,
					inside: {
						keyword: /^[-A-Z\d]+/,
						language: {
							pattern: /^(\s*)\[[-\w]+\]/,
							lookbehind: true,
							inside: {
								punctuation: /^\[|\]$/,
								property: /[-\w]+/
							}
						},
						'sub-key': {
							pattern: /^(\s*)\S[\s\S]*/,
							lookbehind: true,
							inside: {
								parameter: {
									pattern: /"[^"]*"/,
									alias: 'property'
								},
								punctuation: /^\(|\)$|,/
							}
						}
					}
				},
				operator: /=/,
				tlist: {
					pattern: /TLIST\s*\(\s*\w+(?:(?:\s*,\s*"[^"]*")+|\s*,\s*"[^"]*"-"[^"]*")?\s*\)/,
					greedy: true,
					inside: {
						function: /^TLIST/,
						property: {
							pattern: /^(\s*\(\s*)\w+/,
							lookbehind: true
						},
						string: /"[^"]*"/,
						punctuation: /[(),]/,
						operator: /-/
					}
				},
				punctuation: /[;,]/,
				number: {
					pattern: /(^|\s)\d+(?:\.\d+)?(?!\S)/,
					lookbehind: true
				},
				boolean: /NO|YES/
			};
			Prism.languages.px = Prism.languages.pcaxis;
		}
	}
});

// node_modules/refractor/lang/peoplecode.js
var require_peoplecode = __commonJS({
	'node_modules/refractor/lang/peoplecode.js'(exports, module2) {
		'use strict';
		module2.exports = peoplecode;
		peoplecode.displayName = 'peoplecode';
		peoplecode.aliases = ['pcode'];
		function peoplecode(Prism) {
			Prism.languages.peoplecode = {
				comment: RegExp(
					[
						/\/\*[\s\S]*?\*\//.source,
						/\bREM[^;]*;/.source,
						/<\*(?:[^<*]|\*(?!>)|<(?!\*)|<\*(?:(?!\*>)[\s\S])*\*>)*\*>/.source,
						/\/\+[\s\S]*?\+\//.source
					].join('|')
				),
				string: {
					pattern: /'(?:''|[^'\r\n])*'(?!')|"(?:""|[^"\r\n])*"(?!")/,
					greedy: true
				},
				variable: /%\w+/,
				'function-definition': {
					pattern: /((?:^|[^\w-])(?:function|method)\s+)\w+/i,
					lookbehind: true,
					alias: 'function'
				},
				'class-name': {
					pattern:
						/((?:^|[^-\w])(?:as|catch|class|component|create|extends|global|implements|instance|local|of|property|returns)\s+)\w+(?::\w+)*/i,
					lookbehind: true,
					inside: {
						punctuation: /:/
					}
				},
				keyword:
					/\b(?:abstract|alias|as|catch|class|component|constant|create|declare|else|end-(?:class|evaluate|for|function|get|if|method|set|try|while)|evaluate|extends|for|function|get|global|if|implements|import|instance|library|local|method|null|of|out|peopleCode|private|program|property|protected|readonly|ref|repeat|returns?|set|step|then|throw|to|try|until|value|when(?:-other)?|while)\b/i,
				'operator-keyword': {
					pattern: /\b(?:and|not|or)\b/i,
					alias: 'operator'
				},
				function: /[_a-z]\w*(?=\s*\()/i,
				boolean: /\b(?:false|true)\b/i,
				number: /\b\d+(?:\.\d+)?\b/,
				operator: /<>|[<>]=?|!=|\*\*|[-+*/|=@]/,
				punctuation: /[:.;,()[\]]/
			};
			Prism.languages.pcode = Prism.languages.peoplecode;
		}
	}
});

// node_modules/refractor/lang/perl.js
var require_perl = __commonJS({
	'node_modules/refractor/lang/perl.js'(exports, module2) {
		'use strict';
		module2.exports = perl;
		perl.displayName = 'perl';
		perl.aliases = [];
		function perl(Prism) {
			(function (Prism2) {
				var brackets =
					/(?:\((?:[^()\\]|\\[\s\S])*\)|\{(?:[^{}\\]|\\[\s\S])*\}|\[(?:[^[\]\\]|\\[\s\S])*\]|<(?:[^<>\\]|\\[\s\S])*>)/
						.source;
				Prism2.languages.perl = {
					comment: [
						{
							pattern: /(^\s*)=\w[\s\S]*?=cut.*/m,
							lookbehind: true,
							greedy: true
						},
						{
							pattern: /(^|[^\\$])#.*/,
							lookbehind: true,
							greedy: true
						}
					],
					string: [
						{
							pattern: RegExp(
								/\b(?:q|qq|qw|qx)(?![a-zA-Z0-9])\s*/.source +
									'(?:' +
									[
										/([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
										/([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
										brackets
									].join('|') +
									')'
							),
							greedy: true
						},
						{
							pattern: /("|`)(?:(?!\1)[^\\]|\\[\s\S])*\1/,
							greedy: true
						},
						{
							pattern: /'(?:[^'\\\r\n]|\\.)*'/,
							greedy: true
						}
					],
					regex: [
						{
							pattern: RegExp(
								/\b(?:m|qr)(?![a-zA-Z0-9])\s*/.source +
									'(?:' +
									[
										/([^a-zA-Z0-9\s{(\[<])(?:(?!\1)[^\\]|\\[\s\S])*\1/.source,
										/([a-zA-Z0-9])(?:(?!\2)[^\\]|\\[\s\S])*\2/.source,
										brackets
									].join('|') +
									')' +
									/[msixpodualngc]*/.source
							),
							greedy: true
						},
						{
							pattern: RegExp(
								/(^|[^-])\b(?:s|tr|y)(?![a-zA-Z0-9])\s*/.source +
									'(?:' +
									[
										/([^a-zA-Z0-9\s{(\[<])(?:(?!\2)[^\\]|\\[\s\S])*\2(?:(?!\2)[^\\]|\\[\s\S])*\2/
											.source,
										/([a-zA-Z0-9])(?:(?!\3)[^\\]|\\[\s\S])*\3(?:(?!\3)[^\\]|\\[\s\S])*\3/.source,
										brackets + /\s*/.source + brackets
									].join('|') +
									')' +
									/[msixpodualngcer]*/.source
							),
							lookbehind: true,
							greedy: true
						},
						{
							pattern:
								/\/(?:[^\/\\\r\n]|\\.)*\/[msixpodualngc]*(?=\s*(?:$|[\r\n,.;})&|\-+*~<>!?^]|(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|x|xor)\b))/,
							greedy: true
						}
					],
					variable: [
						/[&*$@%]\{\^[A-Z]+\}/,
						/[&*$@%]\^[A-Z_]/,
						/[&*$@%]#?(?=\{)/,
						/[&*$@%]#?(?:(?:::)*'?(?!\d)[\w$]+(?![\w$]))+(?:::)*/,
						/[&*$@%]\d+/,
						/(?!%=)[$@%][!"#$%&'()*+,\-.\/:;<=>?@[\\\]^_`{|}~]/
					],
					filehandle: {
						pattern: /<(?![<=])\S*?>|\b_\b/,
						alias: 'symbol'
					},
					'v-string': {
						pattern: /v\d+(?:\.\d+)*|\d+(?:\.\d+){2,}/,
						alias: 'string'
					},
					function: {
						pattern: /(\bsub[ \t]+)\w+/,
						lookbehind: true
					},
					keyword:
						/\b(?:any|break|continue|default|delete|die|do|else|elsif|eval|for|foreach|given|goto|if|last|local|my|next|our|package|print|redo|require|return|say|state|sub|switch|undef|unless|until|use|when|while)\b/,
					number:
						/\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)\b/,
					operator:
						/-[rwxoRWXOezsfdlpSbctugkTBMAC]\b|\+[+=]?|-[-=>]?|\*\*?=?|\/\/?=?|=[=~>]?|~[~=]?|\|\|?=?|&&?=?|<(?:=>?|<=?)?|>>?=?|![~=]?|[%^]=?|\.(?:=|\.\.?)?|[\\?]|\bx(?:=|\b)|\b(?:and|cmp|eq|ge|gt|le|lt|ne|not|or|xor)\b/,
					punctuation: /[{}[\];(),:]/
				};
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/php-extras.js
var require_php_extras = __commonJS({
	'node_modules/refractor/lang/php-extras.js'(exports, module2) {
		'use strict';
		var refractorPhp = require_php();
		module2.exports = phpExtras;
		phpExtras.displayName = 'phpExtras';
		phpExtras.aliases = [];
		function phpExtras(Prism) {
			Prism.register(refractorPhp);
			Prism.languages.insertBefore('php', 'variable', {
				this: {
					pattern: /\$this\b/,
					alias: 'keyword'
				},
				global:
					/\$(?:GLOBALS|HTTP_RAW_POST_DATA|_(?:COOKIE|ENV|FILES|GET|POST|REQUEST|SERVER|SESSION)|argc|argv|http_response_header|php_errormsg)\b/,
				scope: {
					pattern: /\b[\w\\]+::/,
					inside: {
						keyword: /\b(?:parent|self|static)\b/,
						punctuation: /::|\\/
					}
				}
			});
		}
	}
});

// node_modules/refractor/lang/phpdoc.js
var require_phpdoc = __commonJS({
	'node_modules/refractor/lang/phpdoc.js'(exports, module2) {
		'use strict';
		var refractorPhp = require_php();
		var refractorJavadoclike = require_javadoclike();
		module2.exports = phpdoc;
		phpdoc.displayName = 'phpdoc';
		phpdoc.aliases = [];
		function phpdoc(Prism) {
			Prism.register(refractorPhp);
			Prism.register(refractorJavadoclike);
			(function (Prism2) {
				var typeExpression = /(?:\b[a-zA-Z]\w*|[|\\[\]])+/.source;
				Prism2.languages.phpdoc = Prism2.languages.extend('javadoclike', {
					parameter: {
						pattern: RegExp(
							'(@(?:global|param|property(?:-read|-write)?|var)\\s+(?:' +
								typeExpression +
								'\\s+)?)\\$\\w+'
						),
						lookbehind: true
					}
				});
				Prism2.languages.insertBefore('phpdoc', 'keyword', {
					'class-name': [
						{
							pattern: RegExp(
								'(@(?:global|package|param|property(?:-read|-write)?|return|subpackage|throws|var)\\s+)' +
									typeExpression
							),
							lookbehind: true,
							inside: {
								keyword:
									/\b(?:array|bool|boolean|callback|double|false|float|int|integer|mixed|null|object|resource|self|string|true|void)\b/,
								punctuation: /[|\\[\]()]/
							}
						}
					]
				});
				Prism2.languages.javadoclike.addSupport('php', Prism2.languages.phpdoc);
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/plsql.js
var require_plsql = __commonJS({
	'node_modules/refractor/lang/plsql.js'(exports, module2) {
		'use strict';
		var refractorSql = require_sql();
		module2.exports = plsql;
		plsql.displayName = 'plsql';
		plsql.aliases = [];
		function plsql(Prism) {
			Prism.register(refractorSql);
			Prism.languages.plsql = Prism.languages.extend('sql', {
				comment: {
					pattern: /\/\*[\s\S]*?\*\/|--.*/,
					greedy: true
				},
				keyword:
					/\b(?:A|ACCESSIBLE|ADD|AGENT|AGGREGATE|ALL|ALTER|AND|ANY|ARRAY|AS|ASC|AT|ATTRIBUTE|AUTHID|AVG|BEGIN|BETWEEN|BFILE_BASE|BINARY|BLOB_BASE|BLOCK|BODY|BOTH|BOUND|BULK|BY|BYTE|C|CALL|CALLING|CASCADE|CASE|CHAR|CHARACTER|CHARSET|CHARSETFORM|CHARSETID|CHAR_BASE|CHECK|CLOB_BASE|CLONE|CLOSE|CLUSTER|CLUSTERS|COLAUTH|COLLECT|COLUMNS|COMMENT|COMMIT|COMMITTED|COMPILED|COMPRESS|CONNECT|CONSTANT|CONSTRUCTOR|CONTEXT|CONTINUE|CONVERT|COUNT|CRASH|CREATE|CREDENTIAL|CURRENT|CURSOR|CUSTOMDATUM|DANGLING|DATA|DATE|DATE_BASE|DAY|DECLARE|DEFAULT|DEFINE|DELETE|DESC|DETERMINISTIC|DIRECTORY|DISTINCT|DOUBLE|DROP|DURATION|ELEMENT|ELSE|ELSIF|EMPTY|END|ESCAPE|EXCEPT|EXCEPTION|EXCEPTIONS|EXCLUSIVE|EXECUTE|EXISTS|EXIT|EXTERNAL|FETCH|FINAL|FIRST|FIXED|FLOAT|FOR|FORALL|FORCE|FROM|FUNCTION|GENERAL|GOTO|GRANT|GROUP|HASH|HAVING|HEAP|HIDDEN|HOUR|IDENTIFIED|IF|IMMEDIATE|IMMUTABLE|IN|INCLUDING|INDEX|INDEXES|INDICATOR|INDICES|INFINITE|INSERT|INSTANTIABLE|INT|INTERFACE|INTERSECT|INTERVAL|INTO|INVALIDATE|IS|ISOLATION|JAVA|LANGUAGE|LARGE|LEADING|LENGTH|LEVEL|LIBRARY|LIKE|LIKE2|LIKE4|LIKEC|LIMIT|LIMITED|LOCAL|LOCK|LONG|LOOP|MAP|MAX|MAXLEN|MEMBER|MERGE|MIN|MINUS|MINUTE|MOD|MODE|MODIFY|MONTH|MULTISET|MUTABLE|NAME|NAN|NATIONAL|NATIVE|NCHAR|NEW|NOCOMPRESS|NOCOPY|NOT|NOWAIT|NULL|NUMBER_BASE|OBJECT|OCICOLL|OCIDATE|OCIDATETIME|OCIDURATION|OCIINTERVAL|OCILOBLOCATOR|OCINUMBER|OCIRAW|OCIREF|OCIREFCURSOR|OCIROWID|OCISTRING|OCITYPE|OF|OLD|ON|ONLY|OPAQUE|OPEN|OPERATOR|OPTION|OR|ORACLE|ORADATA|ORDER|ORGANIZATION|ORLANY|ORLVARY|OTHERS|OUT|OVERLAPS|OVERRIDING|PACKAGE|PARALLEL_ENABLE|PARAMETER|PARAMETERS|PARENT|PARTITION|PASCAL|PERSISTABLE|PIPE|PIPELINED|PLUGGABLE|POLYMORPHIC|PRAGMA|PRECISION|PRIOR|PRIVATE|PROCEDURE|PUBLIC|RAISE|RANGE|RAW|READ|RECORD|REF|REFERENCE|RELIES_ON|REM|REMAINDER|RENAME|RESOURCE|RESULT|RESULT_CACHE|RETURN|RETURNING|REVERSE|REVOKE|ROLLBACK|ROW|SAMPLE|SAVE|SAVEPOINT|SB1|SB2|SB4|SECOND|SEGMENT|SELECT|SELF|SEPARATE|SEQUENCE|SERIALIZABLE|SET|SHARE|SHORT|SIZE|SIZE_T|SOME|SPARSE|SQL|SQLCODE|SQLDATA|SQLNAME|SQLSTATE|STANDARD|START|STATIC|STDDEV|STORED|STRING|STRUCT|STYLE|SUBMULTISET|SUBPARTITION|SUBSTITUTABLE|SUBTYPE|SUM|SYNONYM|TABAUTH|TABLE|TDO|THE|THEN|TIME|TIMESTAMP|TIMEZONE_ABBR|TIMEZONE_HOUR|TIMEZONE_MINUTE|TIMEZONE_REGION|TO|TRAILING|TRANSACTION|TRANSACTIONAL|TRUSTED|TYPE|UB1|UB2|UB4|UNDER|UNION|UNIQUE|UNPLUG|UNSIGNED|UNTRUSTED|UPDATE|USE|USING|VALIST|VALUE|VALUES|VARIABLE|VARIANCE|VARRAY|VARYING|VIEW|VIEWS|VOID|WHEN|WHERE|WHILE|WITH|WORK|WRAPPED|WRITE|YEAR|ZONE)\b/i,
				operator: /:=?|=>|[<>^~!]=|\.\.|\|\||\*\*|[-+*/%<>=@]/
			});
			Prism.languages.insertBefore('plsql', 'operator', {
				label: {
					pattern: /<<\s*\w+\s*>>/,
					alias: 'symbol'
				}
			});
		}
	}
});

// node_modules/refractor/lang/powerquery.js
var require_powerquery = __commonJS({
	'node_modules/refractor/lang/powerquery.js'(exports, module2) {
		'use strict';
		module2.exports = powerquery;
		powerquery.displayName = 'powerquery';
		powerquery.aliases = [];
		function powerquery(Prism) {
			Prism.languages.powerquery = {
				comment: {
					pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
					lookbehind: true,
					greedy: true
				},
				'quoted-identifier': {
					pattern: /#"(?:[^"\r\n]|"")*"(?!")/,
					greedy: true
				},
				string: {
					pattern: /(?:#!)?"(?:[^"\r\n]|"")*"(?!")/,
					greedy: true
				},
				constant: [
					/\bDay\.(?:Friday|Monday|Saturday|Sunday|Thursday|Tuesday|Wednesday)\b/,
					/\bTraceLevel\.(?:Critical|Error|Information|Verbose|Warning)\b/,
					/\bOccurrence\.(?:All|First|Last)\b/,
					/\bOrder\.(?:Ascending|Descending)\b/,
					/\bRoundingMode\.(?:AwayFromZero|Down|ToEven|TowardZero|Up)\b/,
					/\bMissingField\.(?:Error|Ignore|UseNull)\b/,
					/\bQuoteStyle\.(?:Csv|None)\b/,
					/\bJoinKind\.(?:FullOuter|Inner|LeftAnti|LeftOuter|RightAnti|RightOuter)\b/,
					/\bGroupKind\.(?:Global|Local)\b/,
					/\bExtraValues\.(?:Error|Ignore|List)\b/,
					/\bJoinAlgorithm\.(?:Dynamic|LeftHash|LeftIndex|PairwiseHash|RightHash|RightIndex|SortMerge)\b/,
					/\bJoinSide\.(?:Left|Right)\b/,
					/\bPrecision\.(?:Decimal|Double)\b/,
					/\bRelativePosition\.From(?:End|Start)\b/,
					/\bTextEncoding\.(?:Ascii|BigEndianUnicode|Unicode|Utf16|Utf8|Windows)\b/,
					/\b(?:Any|Binary|Date|DateTime|DateTimeZone|Duration|Function|Int16|Int32|Int64|Int8|List|Logical|None|Number|Record|Table|Text|Time)\.Type\b/,
					/\bnull\b/
				],
				boolean: /\b(?:false|true)\b/,
				keyword:
					/\b(?:and|as|each|else|error|if|in|is|let|meta|not|nullable|optional|or|otherwise|section|shared|then|try|type)\b|#(?:binary|date|datetime|datetimezone|duration|infinity|nan|sections|shared|table|time)\b/,
				function: {
					pattern: /(^|[^#\w.])[a-z_][\w.]*(?=\s*\()/i,
					lookbehind: true
				},
				'data-type': {
					pattern:
						/\b(?:any|anynonnull|binary|date|datetime|datetimezone|duration|function|list|logical|none|number|record|table|text|time)\b/,
					alias: 'class-name'
				},
				number: {
					pattern:
						/\b0x[\da-f]+\b|(?:[+-]?(?:\b\d+\.)?\b\d+|[+-]\.\d+|(^|[^.])\B\.\d+)(?:e[+-]?\d+)?\b/i,
					lookbehind: true
				},
				operator: /[-+*\/&?@^]|<(?:=>?|>)?|>=?|=>?|\.\.\.?/,
				punctuation: /[,;\[\](){}]/
			};
			Prism.languages.pq = Prism.languages['powerquery'];
			Prism.languages.mscript = Prism.languages['powerquery'];
		}
	}
});

// node_modules/refractor/lang/powershell.js
var require_powershell = __commonJS({
	'node_modules/refractor/lang/powershell.js'(exports, module2) {
		'use strict';
		module2.exports = powershell;
		powershell.displayName = 'powershell';
		powershell.aliases = [];
		function powershell(Prism) {
			(function (Prism2) {
				var powershell2 = (Prism2.languages.powershell = {
					comment: [
						{
							pattern: /(^|[^`])<#[\s\S]*?#>/,
							lookbehind: true
						},
						{
							pattern: /(^|[^`])#.*/,
							lookbehind: true
						}
					],
					string: [
						{
							pattern: /"(?:`[\s\S]|[^`"])*"/,
							greedy: true,
							inside: null
						},
						{
							pattern: /'(?:[^']|'')*'/,
							greedy: true
						}
					],
					namespace: /\[[a-z](?:\[(?:\[[^\]]*\]|[^\[\]])*\]|[^\[\]])*\]/i,
					boolean: /\$(?:false|true)\b/i,
					variable: /\$\w+\b/,
					function: [
						/\b(?:Add|Approve|Assert|Backup|Block|Checkpoint|Clear|Close|Compare|Complete|Compress|Confirm|Connect|Convert|ConvertFrom|ConvertTo|Copy|Debug|Deny|Disable|Disconnect|Dismount|Edit|Enable|Enter|Exit|Expand|Export|Find|ForEach|Format|Get|Grant|Group|Hide|Import|Initialize|Install|Invoke|Join|Limit|Lock|Measure|Merge|Move|New|Open|Optimize|Out|Ping|Pop|Protect|Publish|Push|Read|Receive|Redo|Register|Remove|Rename|Repair|Request|Reset|Resize|Resolve|Restart|Restore|Resume|Revoke|Save|Search|Select|Send|Set|Show|Skip|Sort|Split|Start|Step|Stop|Submit|Suspend|Switch|Sync|Tee|Test|Trace|Unblock|Undo|Uninstall|Unlock|Unprotect|Unpublish|Unregister|Update|Use|Wait|Watch|Where|Write)-[a-z]+\b/i,
						/\b(?:ac|cat|chdir|clc|cli|clp|clv|compare|copy|cp|cpi|cpp|cvpa|dbp|del|diff|dir|ebp|echo|epal|epcsv|epsn|erase|fc|fl|ft|fw|gal|gbp|gc|gci|gcs|gdr|gi|gl|gm|gp|gps|group|gsv|gu|gv|gwmi|iex|ii|ipal|ipcsv|ipsn|irm|iwmi|iwr|kill|lp|ls|measure|mi|mount|move|mp|mv|nal|ndr|ni|nv|ogv|popd|ps|pushd|pwd|rbp|rd|rdr|ren|ri|rm|rmdir|rni|rnp|rp|rv|rvpa|rwmi|sal|saps|sasv|sbp|sc|select|set|shcm|si|sl|sleep|sls|sort|sp|spps|spsv|start|sv|swmi|tee|trcm|type|write)\b/i
					],
					keyword:
						/\b(?:Begin|Break|Catch|Class|Continue|Data|Define|Do|DynamicParam|Else|ElseIf|End|Exit|Filter|Finally|For|ForEach|From|Function|If|InlineScript|Parallel|Param|Process|Return|Sequence|Switch|Throw|Trap|Try|Until|Using|Var|While|Workflow)\b/i,
					operator: {
						pattern:
							/(^|\W)(?:!|-(?:b?(?:and|x?or)|as|(?:Not)?(?:Contains|In|Like|Match)|eq|ge|gt|is(?:Not)?|Join|le|lt|ne|not|Replace|sh[lr])\b|-[-=]?|\+[+=]?|[*\/%]=?)/i,
						lookbehind: true
					},
					punctuation: /[|{}[\];(),.]/
				});
				powershell2.string[0].inside = {
					function: {
						pattern: /(^|[^`])\$\((?:\$\([^\r\n()]*\)|(?!\$\()[^\r\n)])*\)/,
						lookbehind: true,
						inside: powershell2
					},
					boolean: powershell2.boolean,
					variable: powershell2.variable
				};
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/processing.js
var require_processing = __commonJS({
	'node_modules/refractor/lang/processing.js'(exports, module2) {
		'use strict';
		module2.exports = processing;
		processing.displayName = 'processing';
		processing.aliases = [];
		function processing(Prism) {
			Prism.languages.processing = Prism.languages.extend('clike', {
				keyword:
					/\b(?:break|case|catch|class|continue|default|else|extends|final|for|if|implements|import|new|null|private|public|return|static|super|switch|this|try|void|while)\b/,
				function: /\b\w+(?=\s*\()/,
				operator: /<[<=]?|>[>=]?|&&?|\|\|?|[%?]|[!=+\-*\/]=?/
			});
			Prism.languages.insertBefore('processing', 'number', {
				constant: /\b(?!XML\b)[A-Z][A-Z\d_]+\b/,
				type: {
					pattern: /\b(?:boolean|byte|char|color|double|float|int|[A-Z]\w*)\b/,
					alias: 'class-name'
				}
			});
		}
	}
});

// node_modules/refractor/lang/prolog.js
var require_prolog = __commonJS({
	'node_modules/refractor/lang/prolog.js'(exports, module2) {
		'use strict';
		module2.exports = prolog;
		prolog.displayName = 'prolog';
		prolog.aliases = [];
		function prolog(Prism) {
			Prism.languages.prolog = {
				comment: {
					pattern: /\/\*[\s\S]*?\*\/|%.*/,
					greedy: true
				},
				string: {
					pattern: /(["'])(?:\1\1|\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1(?!\1)/,
					greedy: true
				},
				builtin: /\b(?:fx|fy|xf[xy]?|yfx?)\b/,
				function: /\b[a-z]\w*(?:(?=\()|\/\d+)/,
				number: /\b\d+(?:\.\d*)?/,
				operator: /[:\\=><\-?*@\/;+^|!$.]+|\b(?:is|mod|not|xor)\b/,
				punctuation: /[(){}\[\],]/
			};
		}
	}
});

// node_modules/refractor/lang/promql.js
var require_promql = __commonJS({
	'node_modules/refractor/lang/promql.js'(exports, module2) {
		'use strict';
		module2.exports = promql;
		promql.displayName = 'promql';
		promql.aliases = [];
		function promql(Prism) {
			(function (Prism2) {
				var aggregations = [
					'sum',
					'min',
					'max',
					'avg',
					'group',
					'stddev',
					'stdvar',
					'count',
					'count_values',
					'bottomk',
					'topk',
					'quantile'
				];
				var vectorMatching = ['on', 'ignoring', 'group_right', 'group_left', 'by', 'without'];
				var offsetModifier = ['offset'];
				var keywords = aggregations.concat(vectorMatching, offsetModifier);
				Prism2.languages.promql = {
					comment: {
						pattern: /(^[ \t]*)#.*/m,
						lookbehind: true
					},
					'vector-match': {
						pattern: new RegExp('((?:' + vectorMatching.join('|') + ')\\s*)\\([^)]*\\)'),
						lookbehind: true,
						inside: {
							'label-key': {
								pattern: /\b[^,]+\b/,
								alias: 'attr-name'
							},
							punctuation: /[(),]/
						}
					},
					'context-labels': {
						pattern: /\{[^{}]*\}/,
						inside: {
							'label-key': {
								pattern: /\b[a-z_]\w*(?=\s*(?:=|![=~]))/,
								alias: 'attr-name'
							},
							'label-value': {
								pattern: /(["'`])(?:\\[\s\S]|(?!\1)[^\\])*\1/,
								greedy: true,
								alias: 'attr-value'
							},
							punctuation: /\{|\}|=~?|![=~]|,/
						}
					},
					'context-range': [
						{
							pattern: /\[[\w\s:]+\]/,
							inside: {
								punctuation: /\[|\]|:/,
								'range-duration': {
									pattern: /\b(?:\d+(?:[smhdwy]|ms))+\b/i,
									alias: 'number'
								}
							}
						},
						{
							pattern: /(\boffset\s+)\w+/,
							lookbehind: true,
							inside: {
								'range-duration': {
									pattern: /\b(?:\d+(?:[smhdwy]|ms))+\b/i,
									alias: 'number'
								}
							}
						}
					],
					keyword: new RegExp('\\b(?:' + keywords.join('|') + ')\\b', 'i'),
					function: /\b[a-z_]\w*(?=\s*\()/i,
					number:
						/[-+]?(?:(?:\b\d+(?:\.\d+)?|\B\.\d+)(?:e[-+]?\d+)?\b|\b(?:0x[0-9a-f]+|nan|inf)\b)/i,
					operator: /[\^*/%+-]|==|!=|<=|<|>=|>|\b(?:and|or|unless)\b/i,
					punctuation: /[{};()`,.[\]]/
				};
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/properties.js
var require_properties = __commonJS({
	'node_modules/refractor/lang/properties.js'(exports, module2) {
		'use strict';
		module2.exports = properties2;
		properties2.displayName = 'properties';
		properties2.aliases = [];
		function properties2(Prism) {
			Prism.languages.properties = {
				comment: /^[ \t]*[#!].*$/m,
				'attr-value': {
					pattern:
						/(^[ \t]*(?:\\(?:\r\n|[\s\S])|[^\\\s:=])+(?: *[=:] *(?! )| ))(?:\\(?:\r\n|[\s\S])|[^\\\r\n])+/m,
					lookbehind: true
				},
				'attr-name': /^[ \t]*(?:\\(?:\r\n|[\s\S])|[^\\\s:=])+(?= *[=:]| )/m,
				punctuation: /[=:]/
			};
		}
	}
});

// node_modules/refractor/lang/protobuf.js
var require_protobuf = __commonJS({
	'node_modules/refractor/lang/protobuf.js'(exports, module2) {
		'use strict';
		module2.exports = protobuf;
		protobuf.displayName = 'protobuf';
		protobuf.aliases = [];
		function protobuf(Prism) {
			(function (Prism2) {
				var builtinTypes =
					/\b(?:bool|bytes|double|s?fixed(?:32|64)|float|[su]?int(?:32|64)|string)\b/;
				Prism2.languages.protobuf = Prism2.languages.extend('clike', {
					'class-name': [
						{
							pattern: /(\b(?:enum|extend|message|service)\s+)[A-Za-z_]\w*(?=\s*\{)/,
							lookbehind: true
						},
						{
							pattern:
								/(\b(?:rpc\s+\w+|returns)\s*\(\s*(?:stream\s+)?)\.?[A-Za-z_]\w*(?:\.[A-Za-z_]\w*)*(?=\s*\))/,
							lookbehind: true
						}
					],
					keyword:
						/\b(?:enum|extend|extensions|import|message|oneof|option|optional|package|public|repeated|required|reserved|returns|rpc(?=\s+\w)|service|stream|syntax|to)\b(?!\s*=\s*\d)/,
					function: /\b[a-z_]\w*(?=\s*\()/i
				});
				Prism2.languages.insertBefore('protobuf', 'operator', {
					map: {
						pattern: /\bmap<\s*[\w.]+\s*,\s*[\w.]+\s*>(?=\s+[a-z_]\w*\s*[=;])/i,
						alias: 'class-name',
						inside: {
							punctuation: /[<>.,]/,
							builtin: builtinTypes
						}
					},
					builtin: builtinTypes,
					'positional-class-name': {
						pattern: /(?:\b|\B\.)[a-z_]\w*(?:\.[a-z_]\w*)*(?=\s+[a-z_]\w*\s*[=;])/i,
						alias: 'class-name',
						inside: {
							punctuation: /\./
						}
					},
					annotation: {
						pattern: /(\[\s*)[a-z_]\w*(?=\s*=)/i,
						lookbehind: true
					}
				});
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/psl.js
var require_psl = __commonJS({
	'node_modules/refractor/lang/psl.js'(exports, module2) {
		'use strict';
		module2.exports = psl;
		psl.displayName = 'psl';
		psl.aliases = [];
		function psl(Prism) {
			Prism.languages.psl = {
				comment: {
					pattern: /#.*/,
					greedy: true
				},
				string: {
					pattern: /"(?:\\.|[^\\"])*"/,
					greedy: true,
					inside: {
						symbol: /\\[ntrbA-Z"\\]/
					}
				},
				'heredoc-string': {
					pattern: /<<<([a-zA-Z_]\w*)[\r\n](?:.*[\r\n])*?\1\b/,
					alias: 'string',
					greedy: true
				},
				keyword:
					/\b(?:__multi|__single|case|default|do|else|elsif|exit|export|for|foreach|function|if|last|line|local|next|requires|return|switch|until|while|word)\b/,
				constant:
					/\b(?:ALARM|CHART_ADD_GRAPH|CHART_DELETE_GRAPH|CHART_DESTROY|CHART_LOAD|CHART_PRINT|EOF|OFFLINE|OK|PSL_PROF_LOG|R_CHECK_HORIZ|R_CHECK_VERT|R_CLICKER|R_COLUMN|R_FRAME|R_ICON|R_LABEL|R_LABEL_CENTER|R_LIST_MULTIPLE|R_LIST_MULTIPLE_ND|R_LIST_SINGLE|R_LIST_SINGLE_ND|R_MENU|R_POPUP|R_POPUP_SCROLLED|R_RADIO_HORIZ|R_RADIO_VERT|R_ROW|R_SCALE_HORIZ|R_SCALE_VERT|R_SEP_HORIZ|R_SEP_VERT|R_SPINNER|R_TEXT_FIELD|R_TEXT_FIELD_LABEL|R_TOGGLE|TRIM_LEADING|TRIM_LEADING_AND_TRAILING|TRIM_REDUNDANT|TRIM_TRAILING|VOID|WARN)\b/,
				boolean: /\b(?:FALSE|False|NO|No|TRUE|True|YES|Yes|false|no|true|yes)\b/,
				variable: /\b(?:PslDebug|errno|exit_status)\b/,
				builtin: {
					pattern:
						/\b(?:PslExecute|PslFunctionCall|PslFunctionExists|PslSetOptions|_snmp_debug|acos|add_diary|annotate|annotate_get|ascii_to_ebcdic|asctime|asin|atan|atexit|batch_set|blackout|cat|ceil|chan_exists|change_state|close|code_cvt|cond_signal|cond_wait|console_type|convert_base|convert_date|convert_locale_date|cos|cosh|create|date|dcget_text|destroy|destroy_lock|dget_text|difference|dump_hist|ebcdic_to_ascii|encrypt|event_archive|event_catalog_get|event_check|event_query|event_range_manage|event_range_query|event_report|event_schedule|event_trigger|event_trigger2|execute|exists|exp|fabs|file|floor|fmod|fopen|fseek|ftell|full_discovery|get|get_chan_info|get_ranges|get_text|get_vars|getenv|gethostinfo|getpid|getpname|grep|history|history_get_retention|in_transition|index|int|internal|intersection|is_var|isnumber|join|kill|length|lines|lock|lock_info|log|log10|loge|matchline|msg_check|msg_get_format|msg_get_severity|msg_printf|msg_sprintf|ntharg|nthargf|nthline|nthlinef|num_bytes|num_consoles|pconfig|popen|poplines|pow|print|printf|proc_exists|process|random|read|readln|refresh_parameters|remote_check|remote_close|remote_event_query|remote_event_trigger|remote_file_send|remote_open|remove|replace|rindex|sec_check_priv|sec_store_get|sec_store_set|set|set_alarm_ranges|set_locale|share|sin|sinh|sleep|snmp_agent_config|snmp_agent_start|snmp_agent_stop|snmp_close|snmp_config|snmp_get|snmp_get_next|snmp_h_get|snmp_h_get_next|snmp_h_set|snmp_open|snmp_set|snmp_trap_ignore|snmp_trap_listen|snmp_trap_raise_std_trap|snmp_trap_receive|snmp_trap_register_im|snmp_trap_send|snmp_walk|sopen|sort|splitline|sprintf|sqrt|srandom|str_repeat|strcasecmp|subset|substr|system|tail|tan|tanh|text_domain|time|tmpnam|tolower|toupper|trace_psl_process|trim|union|unique|unlock|unset|va_arg|va_start|write)\b/,
					alias: 'builtin-function'
				},
				'foreach-variable': {
					pattern: /(\bforeach\s+(?:(?:\w+\b|"(?:\\.|[^\\"])*")\s+){0,2})[_a-zA-Z]\w*(?=\s*\()/,
					lookbehind: true,
					greedy: true
				},
				function: /\b[_a-z]\w*\b(?=\s*\()/i,
				number: /\b(?:0x[0-9a-f]+|\d+(?:\.\d+)?)\b/i,
				operator: /--|\+\+|&&=?|\|\|=?|<<=?|>>=?|[=!]~|[-+*/%&|^!=<>]=?|\.|[:?]/,
				punctuation: /[(){}\[\];,]/
			};
		}
	}
});

// node_modules/refractor/lang/pug.js
var require_pug = __commonJS({
	'node_modules/refractor/lang/pug.js'(exports, module2) {
		'use strict';
		module2.exports = pug;
		pug.displayName = 'pug';
		pug.aliases = [];
		function pug(Prism) {
			(function (Prism2) {
				Prism2.languages.pug = {
					comment: {
						pattern: /(^([\t ]*))\/\/.*(?:(?:\r?\n|\r)\2[\t ].+)*/m,
						lookbehind: true
					},
					'multiline-script': {
						pattern:
							/(^([\t ]*)script\b.*\.[\t ]*)(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
						lookbehind: true,
						inside: Prism2.languages.javascript
					},
					filter: {
						pattern: /(^([\t ]*)):.+(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
						lookbehind: true,
						inside: {
							'filter-name': {
								pattern: /^:[\w-]+/,
								alias: 'variable'
							},
							text: /\S[\s\S]*/
						}
					},
					'multiline-plain-text': {
						pattern:
							/(^([\t ]*)[\w\-#.]+\.[\t ]*)(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/m,
						lookbehind: true
					},
					markup: {
						pattern: /(^[\t ]*)<.+/m,
						lookbehind: true,
						inside: Prism2.languages.markup
					},
					doctype: {
						pattern: /((?:^|\n)[\t ]*)doctype(?: .+)?/,
						lookbehind: true
					},
					'flow-control': {
						pattern: /(^[\t ]*)(?:case|default|each|else|if|unless|when|while)\b(?: .+)?/m,
						lookbehind: true,
						inside: {
							each: {
								pattern: /^each .+? in\b/,
								inside: {
									keyword: /\b(?:each|in)\b/,
									punctuation: /,/
								}
							},
							branch: {
								pattern: /^(?:case|default|else|if|unless|when|while)\b/,
								alias: 'keyword'
							},
							rest: Prism2.languages.javascript
						}
					},
					keyword: {
						pattern: /(^[\t ]*)(?:append|block|extends|include|prepend)\b.+/m,
						lookbehind: true
					},
					mixin: [
						{
							pattern: /(^[\t ]*)mixin .+/m,
							lookbehind: true,
							inside: {
								keyword: /^mixin/,
								function: /\w+(?=\s*\(|\s*$)/,
								punctuation: /[(),.]/
							}
						},
						{
							pattern: /(^[\t ]*)\+.+/m,
							lookbehind: true,
							inside: {
								name: {
									pattern: /^\+\w+/,
									alias: 'function'
								},
								rest: Prism2.languages.javascript
							}
						}
					],
					script: {
						pattern: /(^[\t ]*script(?:(?:&[^(]+)?\([^)]+\))*[\t ]).+/m,
						lookbehind: true,
						inside: Prism2.languages.javascript
					},
					'plain-text': {
						pattern: /(^[\t ]*(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?[\t ]).+/m,
						lookbehind: true
					},
					tag: {
						pattern: /(^[\t ]*)(?!-)[\w\-#.]*[\w\-](?:(?:&[^(]+)?\([^)]+\))*\/?:?/m,
						lookbehind: true,
						inside: {
							attributes: [
								{
									pattern: /&[^(]+\([^)]+\)/,
									inside: Prism2.languages.javascript
								},
								{
									pattern: /\([^)]+\)/,
									inside: {
										'attr-value': {
											pattern: /(=\s*(?!\s))(?:\{[^}]*\}|[^,)\r\n]+)/,
											lookbehind: true,
											inside: Prism2.languages.javascript
										},
										'attr-name': /[\w-]+(?=\s*!?=|\s*[,)])/,
										punctuation: /[!=(),]+/
									}
								}
							],
							punctuation: /:/,
							'attr-id': /#[\w\-]+/,
							'attr-class': /\.[\w\-]+/
						}
					},
					code: [
						{
							pattern: /(^[\t ]*(?:-|!?=)).+/m,
							lookbehind: true,
							inside: Prism2.languages.javascript
						}
					],
					punctuation: /[.\-!=|]+/
				};
				var filter_pattern =
					/(^([\t ]*)):<filter_name>(?:(?:\r?\n|\r(?!\n))(?:\2[\t ].+|\s*?(?=\r?\n|\r)))+/.source;
				var filters = [
					{
						filter: 'atpl',
						language: 'twig'
					},
					{
						filter: 'coffee',
						language: 'coffeescript'
					},
					'ejs',
					'handlebars',
					'less',
					'livescript',
					'markdown',
					{
						filter: 'sass',
						language: 'scss'
					},
					'stylus'
				];
				var all_filters = {};
				for (var i2 = 0, l = filters.length; i2 < l; i2++) {
					var filter = filters[i2];
					filter =
						typeof filter === 'string'
							? {
									filter,
									language: filter
							  }
							: filter;
					if (Prism2.languages[filter.language]) {
						all_filters['filter-' + filter.filter] = {
							pattern: RegExp(
								filter_pattern.replace('<filter_name>', function () {
									return filter.filter;
								}),
								'm'
							),
							lookbehind: true,
							inside: {
								'filter-name': {
									pattern: /^:[\w-]+/,
									alias: 'variable'
								},
								text: {
									pattern: /\S[\s\S]*/,
									alias: [filter.language, 'language-' + filter.language],
									inside: Prism2.languages[filter.language]
								}
							}
						};
					}
				}
				Prism2.languages.insertBefore('pug', 'filter', all_filters);
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/puppet.js
var require_puppet = __commonJS({
	'node_modules/refractor/lang/puppet.js'(exports, module2) {
		'use strict';
		module2.exports = puppet;
		puppet.displayName = 'puppet';
		puppet.aliases = [];
		function puppet(Prism) {
			(function (Prism2) {
				Prism2.languages.puppet = {
					heredoc: [
						{
							pattern:
								/(@\("([^"\r\n\/):]+)"(?:\/[nrts$uL]*)?\).*(?:\r?\n|\r))(?:.*(?:\r?\n|\r(?!\n)))*?[ \t]*(?:\|[ \t]*)?(?:-[ \t]*)?\2/,
							lookbehind: true,
							alias: 'string',
							inside: {
								punctuation: /(?=\S).*\S(?= *$)/
							}
						},
						{
							pattern:
								/(@\(([^"\r\n\/):]+)(?:\/[nrts$uL]*)?\).*(?:\r?\n|\r))(?:.*(?:\r?\n|\r(?!\n)))*?[ \t]*(?:\|[ \t]*)?(?:-[ \t]*)?\2/,
							lookbehind: true,
							greedy: true,
							alias: 'string',
							inside: {
								punctuation: /(?=\S).*\S(?= *$)/
							}
						},
						{
							pattern: /@\("?(?:[^"\r\n\/):]+)"?(?:\/[nrts$uL]*)?\)/,
							alias: 'string',
							inside: {
								punctuation: {
									pattern: /(\().+?(?=\))/,
									lookbehind: true
								}
							}
						}
					],
					'multiline-comment': {
						pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
						lookbehind: true,
						greedy: true,
						alias: 'comment'
					},
					regex: {
						pattern:
							/((?:\bnode\s+|[~=\(\[\{,]\s*|[=+]>\s*|^\s*))\/(?:[^\/\\]|\\[\s\S])+\/(?:[imx]+\b|\B)/,
						lookbehind: true,
						greedy: true,
						inside: {
							'extended-regex': {
								pattern: /^\/(?:[^\/\\]|\\[\s\S])+\/[im]*x[im]*$/,
								inside: {
									comment: /#.*/
								}
							}
						}
					},
					comment: {
						pattern: /(^|[^\\])#.*/,
						lookbehind: true,
						greedy: true
					},
					string: {
						pattern:
							/(["'])(?:\$\{(?:[^'"}]|(["'])(?:(?!\2)[^\\]|\\[\s\S])*\2)+\}|\$(?!\{)|(?!\1)[^\\$]|\\[\s\S])*\1/,
						greedy: true,
						inside: {
							'double-quoted': {
								pattern: /^"[\s\S]*"$/,
								inside: {}
							}
						}
					},
					variable: {
						pattern: /\$(?:::)?\w+(?:::\w+)*/,
						inside: {
							punctuation: /::/
						}
					},
					'attr-name': /(?:\b\w+|\*)(?=\s*=>)/,
					function: [
						{
							pattern: /(\.)(?!\d)\w+/,
							lookbehind: true
						},
						/\b(?:contain|debug|err|fail|include|info|notice|realize|require|tag|warning)\b|\b(?!\d)\w+(?=\()/
					],
					number: /\b(?:0x[a-f\d]+|\d+(?:\.\d+)?(?:e-?\d+)?)\b/i,
					boolean: /\b(?:false|true)\b/,
					keyword:
						/\b(?:application|attr|case|class|consumes|default|define|else|elsif|function|if|import|inherits|node|private|produces|type|undef|unless)\b/,
					datatype: {
						pattern:
							/\b(?:Any|Array|Boolean|Callable|Catalogentry|Class|Collection|Data|Default|Enum|Float|Hash|Integer|NotUndef|Numeric|Optional|Pattern|Regexp|Resource|Runtime|Scalar|String|Struct|Tuple|Type|Undef|Variant)\b/,
						alias: 'symbol'
					},
					operator:
						/=[=~>]?|![=~]?|<(?:<\|?|[=~|-])?|>[>=]?|->?|~>|\|>?>?|[*\/%+?]|\b(?:and|in|or)\b/,
					punctuation: /[\[\]{}().,;]|:+/
				};
				var interpolation = [
					{
						pattern: /(^|[^\\])\$\{(?:[^'"{}]|\{[^}]*\}|(["'])(?:(?!\2)[^\\]|\\[\s\S])*\2)+\}/,
						lookbehind: true,
						inside: {
							'short-variable': {
								pattern: /(^\$\{)(?!\w+\()(?:::)?\w+(?:::\w+)*/,
								lookbehind: true,
								alias: 'variable',
								inside: {
									punctuation: /::/
								}
							},
							delimiter: {
								pattern: /^\$/,
								alias: 'variable'
							},
							rest: Prism2.languages.puppet
						}
					},
					{
						pattern: /(^|[^\\])\$(?:::)?\w+(?:::\w+)*/,
						lookbehind: true,
						alias: 'variable',
						inside: {
							punctuation: /::/
						}
					}
				];
				Prism2.languages.puppet['heredoc'][0].inside.interpolation = interpolation;
				Prism2.languages.puppet['string'].inside['double-quoted'].inside.interpolation =
					interpolation;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/pure.js
var require_pure = __commonJS({
	'node_modules/refractor/lang/pure.js'(exports, module2) {
		'use strict';
		module2.exports = pure;
		pure.displayName = 'pure';
		pure.aliases = [];
		function pure(Prism) {
			(function (Prism2) {
				Prism2.languages.pure = {
					comment: [
						{
							pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
							lookbehind: true
						},
						{
							pattern: /(^|[^\\:])\/\/.*/,
							lookbehind: true
						},
						/#!.+/
					],
					'inline-lang': {
						pattern: /%<[\s\S]+?%>/,
						greedy: true,
						inside: {
							lang: {
								pattern: /(^%< *)-\*-.+?-\*-/,
								lookbehind: true,
								alias: 'comment'
							},
							delimiter: {
								pattern: /^%<.*|%>$/,
								alias: 'punctuation'
							}
						}
					},
					string: {
						pattern: /"(?:\\.|[^"\\\r\n])*"/,
						greedy: true
					},
					number: {
						pattern:
							/((?:\.\.)?)(?:\b(?:inf|nan)\b|\b0x[\da-f]+|(?:\b(?:0b)?\d+(?:\.\d+)?|\B\.\d+)(?:e[+-]?\d+)?L?)/i,
						lookbehind: true
					},
					keyword:
						/\b(?:NULL|ans|break|bt|case|catch|cd|clear|const|def|del|dump|else|end|exit|extern|false|force|help|if|infix[lr]?|interface|let|ls|mem|namespace|nonfix|of|otherwise|outfix|override|postfix|prefix|private|public|pwd|quit|run|save|show|stats|then|throw|trace|true|type|underride|using|when|with)\b/,
					function:
						/\b(?:abs|add_(?:addr|constdef|(?:fundef|interface|macdef|typedef)(?:_at)?|vardef)|all|any|applp?|arity|bigintp?|blob(?:_crc|_size|p)?|boolp?|byte_c?string(?:_pointer)?|byte_(?:matrix|pointer)|calloc|cat|catmap|ceil|char[ps]?|check_ptrtag|chr|clear_sentry|clearsym|closurep?|cmatrixp?|cols?|colcat(?:map)?|colmap|colrev|colvector(?:p|seq)?|complex(?:_float_(?:matrix|pointer)|_matrix(?:_view)?|_pointer|p)?|conj|cookedp?|cst|cstring(?:_(?:dup|list|vector))?|curry3?|cyclen?|del_(?:constdef|fundef|interface|macdef|typedef|vardef)|delete|diag(?:mat)?|dim|dmatrixp?|do|double(?:_matrix(?:_view)?|_pointer|p)?|dowith3?|drop|dropwhile|eval(?:cmd)?|exactp|filter|fix|fixity|flip|float(?:_matrix|_pointer)|floor|fold[lr]1?|frac|free|funp?|functionp?|gcd|get(?:_(?:byte|constdef|double|float|fundef|int(?:64)?|interface(?:_typedef)?|long|macdef|pointer|ptrtag|sentry|short|string|typedef|vardef))?|globsym|hash|head|id|im|imatrixp?|index|inexactp|infp|init|insert|int(?:_matrix(?:_view)?|_pointer|p)?|int64_(?:matrix|pointer)|integerp?|iteraten?|iterwhile|join|keys?|lambdap?|last(?:err(?:pos)?)?|lcd|list[2p]?|listmap|make_ptrtag|malloc|map|matcat|matrixp?|max|member|min|nanp|nargs|nmatrixp?|null|numberp?|ord|pack(?:ed)?|pointer(?:_cast|_tag|_type|p)?|pow|pred|ptrtag|put(?:_(?:byte|double|float|int(?:64)?|long|pointer|short|string))?|rationalp?|re|realp?|realloc|recordp?|redim|reduce(?:_with)?|refp?|repeatn?|reverse|rlistp?|round|rows?|rowcat(?:map)?|rowmap|rowrev|rowvector(?:p|seq)?|same|scan[lr]1?|sentry|sgn|short_(?:matrix|pointer)|slice|smatrixp?|sort|split|str|strcat|stream|stride|string(?:_(?:dup|list|vector)|p)?|subdiag(?:mat)?|submat|subseq2?|substr|succ|supdiag(?:mat)?|symbolp?|tail|take|takewhile|thunkp?|transpose|trunc|tuplep?|typep|ubyte|uint(?:64)?|ulong|uncurry3?|unref|unzip3?|update|ushort|vals?|varp?|vector(?:p|seq)?|void|zip3?|zipwith3?)\b/,
					special: {
						pattern: /\b__[a-z]+__\b/i,
						alias: 'builtin'
					},
					operator:
						/(?:[!"#$%&'*+,\-.\/:<=>?@\\^`|~\u00a1-\u00bf\u00d7-\u00f7\u20d0-\u2bff]|\b_+\b)+|\b(?:and|div|mod|not|or)\b/,
					punctuation: /[(){}\[\];,|]/
				};
				var inlineLanguages = [
					'c',
					{
						lang: 'c++',
						alias: 'cpp'
					},
					'fortran'
				];
				var inlineLanguageRe = /%< *-\*- *<lang>\d* *-\*-[\s\S]+?%>/.source;
				inlineLanguages.forEach(function (lang) {
					var alias = lang;
					if (typeof lang !== 'string') {
						alias = lang.alias;
						lang = lang.lang;
					}
					if (Prism2.languages[alias]) {
						var o = {};
						o['inline-lang-' + alias] = {
							pattern: RegExp(
								inlineLanguageRe.replace('<lang>', lang.replace(/([.+*?\/\\(){}\[\]])/g, '\\$1')),
								'i'
							),
							inside: Prism2.util.clone(Prism2.languages.pure['inline-lang'].inside)
						};
						o['inline-lang-' + alias].inside.rest = Prism2.util.clone(Prism2.languages[alias]);
						Prism2.languages.insertBefore('pure', 'inline-lang', o);
					}
				});
				if (Prism2.languages.c) {
					Prism2.languages.pure['inline-lang'].inside.rest = Prism2.util.clone(Prism2.languages.c);
				}
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/purebasic.js
var require_purebasic = __commonJS({
	'node_modules/refractor/lang/purebasic.js'(exports, module2) {
		'use strict';
		module2.exports = purebasic;
		purebasic.displayName = 'purebasic';
		purebasic.aliases = [];
		function purebasic(Prism) {
			Prism.languages.purebasic = Prism.languages.extend('clike', {
				comment: /;.*/,
				keyword:
					/\b(?:align|and|as|break|calldebugger|case|compilercase|compilerdefault|compilerelse|compilerelseif|compilerendif|compilerendselect|compilererror|compilerif|compilerselect|continue|data|datasection|debug|debuglevel|declare|declarec|declarecdll|declaredll|declaremodule|default|define|dim|disableasm|disabledebugger|disableexplicit|else|elseif|enableasm|enabledebugger|enableexplicit|end|enddatasection|enddeclaremodule|endenumeration|endif|endimport|endinterface|endmacro|endmodule|endprocedure|endselect|endstructure|endstructureunion|endwith|enumeration|extends|fakereturn|for|foreach|forever|global|gosub|goto|if|import|importc|includebinary|includefile|includepath|interface|macro|module|newlist|newmap|next|not|or|procedure|procedurec|procedurecdll|proceduredll|procedurereturn|protected|prototype|prototypec|read|redim|repeat|restore|return|runtime|select|shared|static|step|structure|structureunion|swap|threaded|to|until|wend|while|with|xincludefile|xor)\b/i,
				function: /\b\w+(?:\.\w+)?\s*(?=\()/,
				number: /(?:\$[\da-f]+|\b-?(?:\d+(?:\.\d+)?|\.\d+)(?:e[+-]?\d+)?)\b/i,
				operator: /(?:@\*?|\?|\*)\w+|-[>-]?|\+\+?|!=?|<<?=?|>>?=?|==?|&&?|\|?\||[~^%?*/@]/
			});
			Prism.languages.insertBefore('purebasic', 'keyword', {
				tag: /#\w+\$?/,
				asm: {
					pattern: /(^[\t ]*)!.*/m,
					lookbehind: true,
					alias: 'tag',
					inside: {
						comment: /;.*/,
						string: {
							pattern: /(["'`])(?:\\.|(?!\1)[^\\\r\n])*\1/,
							greedy: true
						},
						'label-reference-anonymous': {
							pattern: /(!\s*j[a-z]+\s+)@[fb]/i,
							lookbehind: true,
							alias: 'fasm-label'
						},
						'label-reference-addressed': {
							pattern: /(!\s*j[a-z]+\s+)[A-Z._?$@][\w.?$@~#]*/i,
							lookbehind: true,
							alias: 'fasm-label'
						},
						keyword: [/\b(?:extern|global)\b[^;\r\n]*/i, /\b(?:CPU|DEFAULT|FLOAT)\b.*/],
						function: {
							pattern: /^([\t ]*!\s*)[\da-z]+(?=\s|$)/im,
							lookbehind: true
						},
						'function-inline': {
							pattern: /(:\s*)[\da-z]+(?=\s)/i,
							lookbehind: true,
							alias: 'function'
						},
						label: {
							pattern: /^([\t ]*!\s*)[A-Za-z._?$@][\w.?$@~#]*(?=:)/m,
							lookbehind: true,
							alias: 'fasm-label'
						},
						register:
							/\b(?:st\d|[xyz]mm\d\d?|[cdt]r\d|r\d\d?[bwd]?|[er]?[abcd]x|[abcd][hl]|[er]?(?:bp|di|si|sp)|[cdefgs]s|mm\d+)\b/i,
						number:
							/(?:\b|-|(?=\$))(?:0[hx](?:[\da-f]*\.)?[\da-f]+(?:p[+-]?\d+)?|\d[\da-f]+[hx]|\$\d[\da-f]*|0[oq][0-7]+|[0-7]+[oq]|0[by][01]+|[01]+[by]|0[dt]\d+|(?:\d+(?:\.\d+)?|\.\d+)(?:\.?e[+-]?\d+)?[dt]?)\b/i,
						operator: /[\[\]*+\-/%<>=&|$!,.:]/
					}
				}
			});
			delete Prism.languages.purebasic['class-name'];
			delete Prism.languages.purebasic['boolean'];
			Prism.languages.pbfasm = Prism.languages['purebasic'];
		}
	}
});

// node_modules/refractor/lang/purescript.js
var require_purescript = __commonJS({
	'node_modules/refractor/lang/purescript.js'(exports, module2) {
		'use strict';
		var refractorHaskell = require_haskell();
		module2.exports = purescript;
		purescript.displayName = 'purescript';
		purescript.aliases = ['purs'];
		function purescript(Prism) {
			Prism.register(refractorHaskell);
			Prism.languages.purescript = Prism.languages.extend('haskell', {
				keyword:
					/\b(?:ado|case|class|data|derive|do|else|forall|if|in|infixl|infixr|instance|let|module|newtype|of|primitive|then|type|where)\b|/,
				'import-statement': {
					pattern:
						/(^[\t ]*)import\s+[A-Z][\w']*(?:\.[A-Z][\w']*)*(?:\s+as\s+[A-Z][\w']*(?:\.[A-Z][\w']*)*)?(?:\s+hiding\b)?/m,
					lookbehind: true,
					inside: {
						keyword: /\b(?:as|hiding|import)\b/,
						punctuation: /\./
					}
				},
				builtin:
					/\b(?:absurd|add|ap|append|apply|between|bind|bottom|clamp|compare|comparing|compose|conj|const|degree|discard|disj|div|eq|flap|flip|gcd|identity|ifM|join|lcm|liftA1|liftM1|map|max|mempty|min|mod|mul|negate|not|notEq|one|otherwise|recip|show|sub|top|unit|unless|unlessM|void|when|whenM|zero)\b/,
				operator: [
					Prism.languages.haskell.operator[0],
					Prism.languages.haskell.operator[2],
					/[\xa2-\xa6\xa8\xa9\xac\xae-\xb1\xb4\xb8\xd7\xf7\u02c2-\u02c5\u02d2-\u02df\u02e5-\u02eb\u02ed\u02ef-\u02ff\u0375\u0384\u0385\u03f6\u0482\u058d-\u058f\u0606-\u0608\u060b\u060e\u060f\u06de\u06e9\u06fd\u06fe\u07f6\u07fe\u07ff\u09f2\u09f3\u09fa\u09fb\u0af1\u0b70\u0bf3-\u0bfa\u0c7f\u0d4f\u0d79\u0e3f\u0f01-\u0f03\u0f13\u0f15-\u0f17\u0f1a-\u0f1f\u0f34\u0f36\u0f38\u0fbe-\u0fc5\u0fc7-\u0fcc\u0fce\u0fcf\u0fd5-\u0fd8\u109e\u109f\u1390-\u1399\u166d\u17db\u1940\u19de-\u19ff\u1b61-\u1b6a\u1b74-\u1b7c\u1fbd\u1fbf-\u1fc1\u1fcd-\u1fcf\u1fdd-\u1fdf\u1fed-\u1fef\u1ffd\u1ffe\u2044\u2052\u207a-\u207c\u208a-\u208c\u20a0-\u20bf\u2100\u2101\u2103-\u2106\u2108\u2109\u2114\u2116-\u2118\u211e-\u2123\u2125\u2127\u2129\u212e\u213a\u213b\u2140-\u2144\u214a-\u214d\u214f\u218a\u218b\u2190-\u2307\u230c-\u2328\u232b-\u2426\u2440-\u244a\u249c-\u24e9\u2500-\u2767\u2794-\u27c4\u27c7-\u27e5\u27f0-\u2982\u2999-\u29d7\u29dc-\u29fb\u29fe-\u2b73\u2b76-\u2b95\u2b97-\u2bff\u2ce5-\u2cea\u2e50\u2e51\u2e80-\u2e99\u2e9b-\u2ef3\u2f00-\u2fd5\u2ff0-\u2ffb\u3004\u3012\u3013\u3020\u3036\u3037\u303e\u303f\u309b\u309c\u3190\u3191\u3196-\u319f\u31c0-\u31e3\u3200-\u321e\u322a-\u3247\u3250\u3260-\u327f\u328a-\u32b0\u32c0-\u33ff\u4dc0-\u4dff\ua490-\ua4c6\ua700-\ua716\ua720\ua721\ua789\ua78a\ua828-\ua82b\ua836-\ua839\uaa77-\uaa79\uab5b\uab6a\uab6b\ufb29\ufbb2-\ufbc1\ufdfc\ufdfd\ufe62\ufe64-\ufe66\ufe69\uff04\uff0b\uff1c-\uff1e\uff3e\uff40\uff5c\uff5e\uffe0-\uffe6\uffe8-\uffee\ufffc\ufffd]/
				]
			});
			Prism.languages.purs = Prism.languages.purescript;
		}
	}
});

// node_modules/refractor/lang/python.js
var require_python = __commonJS({
	'node_modules/refractor/lang/python.js'(exports, module2) {
		'use strict';
		module2.exports = python;
		python.displayName = 'python';
		python.aliases = ['py'];
		function python(Prism) {
			Prism.languages.python = {
				comment: {
					pattern: /(^|[^\\])#.*/,
					lookbehind: true,
					greedy: true
				},
				'string-interpolation': {
					pattern: /(?:f|fr|rf)(?:("""|''')[\s\S]*?\1|("|')(?:\\.|(?!\2)[^\\\r\n])*\2)/i,
					greedy: true,
					inside: {
						interpolation: {
							pattern:
								/((?:^|[^{])(?:\{\{)*)\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}]|\{(?!\{)(?:[^{}])+\})+\})+\}/,
							lookbehind: true,
							inside: {
								'format-spec': {
									pattern: /(:)[^:(){}]+(?=\}$)/,
									lookbehind: true
								},
								'conversion-option': {
									pattern: /![sra](?=[:}]$)/,
									alias: 'punctuation'
								},
								rest: null
							}
						},
						string: /[\s\S]+/
					}
				},
				'triple-quoted-string': {
					pattern: /(?:[rub]|br|rb)?("""|''')[\s\S]*?\1/i,
					greedy: true,
					alias: 'string'
				},
				string: {
					pattern: /(?:[rub]|br|rb)?("|')(?:\\.|(?!\1)[^\\\r\n])*\1/i,
					greedy: true
				},
				function: {
					pattern: /((?:^|\s)def[ \t]+)[a-zA-Z_]\w*(?=\s*\()/g,
					lookbehind: true
				},
				'class-name': {
					pattern: /(\bclass\s+)\w+/i,
					lookbehind: true
				},
				decorator: {
					pattern: /(^[\t ]*)@\w+(?:\.\w+)*/m,
					lookbehind: true,
					alias: ['annotation', 'punctuation'],
					inside: {
						punctuation: /\./
					}
				},
				keyword:
					/\b(?:_(?=\s*:)|and|as|assert|async|await|break|case|class|continue|def|del|elif|else|except|exec|finally|for|from|global|if|import|in|is|lambda|match|nonlocal|not|or|pass|print|raise|return|try|while|with|yield)\b/,
				builtin:
					/\b(?:__import__|abs|all|any|apply|ascii|basestring|bin|bool|buffer|bytearray|bytes|callable|chr|classmethod|cmp|coerce|compile|complex|delattr|dict|dir|divmod|enumerate|eval|execfile|file|filter|float|format|frozenset|getattr|globals|hasattr|hash|help|hex|id|input|int|intern|isinstance|issubclass|iter|len|list|locals|long|map|max|memoryview|min|next|object|oct|open|ord|pow|property|range|raw_input|reduce|reload|repr|reversed|round|set|setattr|slice|sorted|staticmethod|str|sum|super|tuple|type|unichr|unicode|vars|xrange|zip)\b/,
				boolean: /\b(?:False|None|True)\b/,
				number:
					/\b0(?:b(?:_?[01])+|o(?:_?[0-7])+|x(?:_?[a-f0-9])+)\b|(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:e[+-]?\d+(?:_\d+)*)?j?(?!\w)/i,
				operator: /[-+%=]=?|!=|:=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
				punctuation: /[{}[\];(),.:]/
			};
			Prism.languages.python['string-interpolation'].inside['interpolation'].inside.rest =
				Prism.languages.python;
			Prism.languages.py = Prism.languages.python;
		}
	}
});

// node_modules/refractor/lang/q.js
var require_q = __commonJS({
	'node_modules/refractor/lang/q.js'(exports, module2) {
		'use strict';
		module2.exports = q;
		q.displayName = 'q';
		q.aliases = [];
		function q(Prism) {
			Prism.languages.q = {
				string: /"(?:\\.|[^"\\\r\n])*"/,
				comment: [
					{
						pattern: /([\t )\]}])\/.*/,
						lookbehind: true,
						greedy: true
					},
					{
						pattern:
							/(^|\r?\n|\r)\/[\t ]*(?:(?:\r?\n|\r)(?:.*(?:\r?\n|\r(?!\n)))*?(?:\\(?=[\t ]*(?:\r?\n|\r))|$)|\S.*)/,
						lookbehind: true,
						greedy: true
					},
					{
						pattern: /^\\[\t ]*(?:\r?\n|\r)[\s\S]+/m,
						greedy: true
					},
					{
						pattern: /^#!.+/m,
						greedy: true
					}
				],
				symbol: /`(?::\S+|[\w.]*)/,
				datetime: {
					pattern:
						/0N[mdzuvt]|0W[dtz]|\d{4}\.\d\d(?:m|\.\d\d(?:T(?:\d\d(?::\d\d(?::\d\d(?:[.:]\d\d\d)?)?)?)?)?[dz]?)|\d\d:\d\d(?::\d\d(?:[.:]\d\d\d)?)?[uvt]?/,
					alias: 'number'
				},
				number:
					/\b(?![01]:)(?:0N[hje]?|0W[hj]?|0[wn]|0x[\da-fA-F]+|\d+(?:\.\d*)?(?:e[+-]?\d+)?[hjfeb]?)/,
				keyword:
					/\\\w+\b|\b(?:abs|acos|aj0?|all|and|any|asc|asin|asof|atan|attr|avgs?|binr?|by|ceiling|cols|cor|cos|count|cov|cross|csv|cut|delete|deltas|desc|dev|differ|distinct|div|do|dsave|ej|enlist|eval|except|exec|exit|exp|fby|fills|first|fkeys|flip|floor|from|get|getenv|group|gtime|hclose|hcount|hdel|hopen|hsym|iasc|identity|idesc|if|ij|in|insert|inter|inv|keys?|last|like|list|ljf?|load|log|lower|lsq|ltime|ltrim|mavg|maxs?|mcount|md5|mdev|med|meta|mins?|mmax|mmin|mmu|mod|msum|neg|next|not|null|or|over|parse|peach|pj|plist|prds?|prev|prior|rand|rank|ratios|raze|read0|read1|reciprocal|reval|reverse|rload|rotate|rsave|rtrim|save|scan|scov|sdev|select|set|setenv|show|signum|sin|sqrt|ssr?|string|sublist|sums?|sv|svar|system|tables|tan|til|trim|txf|type|uj|ungroup|union|update|upper|upsert|value|var|views?|vs|wavg|where|while|within|wj1?|wsum|ww|xasc|xbar|xcols?|xdesc|xexp|xgroup|xkey|xlog|xprev|xrank)\b/,
				adverb: {
					pattern: /['\/\\]:?|\beach\b/,
					alias: 'function'
				},
				verb: {
					pattern: /(?:\B\.\B|\b[01]:|<[=>]?|>=?|[:+\-*%,!?~=|$&#@^]):?|\b_\b:?/,
					alias: 'operator'
				},
				punctuation: /[(){}\[\];.]/
			};
		}
	}
});

// node_modules/refractor/lang/qml.js
var require_qml = __commonJS({
	'node_modules/refractor/lang/qml.js'(exports, module2) {
		'use strict';
		module2.exports = qml;
		qml.displayName = 'qml';
		qml.aliases = [];
		function qml(Prism) {
			(function (Prism2) {
				var jsString = /"(?:\\.|[^\\"\r\n])*"|'(?:\\.|[^\\'\r\n])*'/.source;
				var jsComment = /\/\/.*(?!.)|\/\*(?:[^*]|\*(?!\/))*\*\//.source;
				var jsExpr =
					/(?:[^\\()[\]{}"'/]|<string>|\/(?![*/])|<comment>|\(<expr>*\)|\[<expr>*\]|\{<expr>*\}|\\[\s\S])/.source
						.replace(/<string>/g, function () {
							return jsString;
						})
						.replace(/<comment>/g, function () {
							return jsComment;
						});
				for (var i2 = 0; i2 < 2; i2++) {
					jsExpr = jsExpr.replace(/<expr>/g, function () {
						return jsExpr;
					});
				}
				jsExpr = jsExpr.replace(/<expr>/g, '[^\\s\\S]');
				Prism2.languages.qml = {
					comment: {
						pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
						greedy: true
					},
					'javascript-function': {
						pattern: RegExp(
							/((?:^|;)[ \t]*)function\s+(?!\s)[_$a-zA-Z\xA0-\uFFFF](?:(?!\s)[$\w\xA0-\uFFFF])*\s*\(<js>*\)\s*\{<js>*\}/.source.replace(
								/<js>/g,
								function () {
									return jsExpr;
								}
							),
							'm'
						),
						lookbehind: true,
						greedy: true,
						alias: 'language-javascript',
						inside: Prism2.languages.javascript
					},
					'class-name': {
						pattern: /((?:^|[:;])[ \t]*)(?!\d)\w+(?=[ \t]*\{|[ \t]+on\b)/m,
						lookbehind: true
					},
					property: [
						{
							pattern: /((?:^|[;{])[ \t]*)(?!\d)\w+(?:\.\w+)*(?=[ \t]*:)/m,
							lookbehind: true
						},
						{
							pattern:
								/((?:^|[;{])[ \t]*)property[ \t]+(?!\d)\w+(?:\.\w+)*[ \t]+(?!\d)\w+(?:\.\w+)*(?=[ \t]*:)/m,
							lookbehind: true,
							inside: {
								keyword: /^property/,
								property: /\w+(?:\.\w+)*/
							}
						}
					],
					'javascript-expression': {
						pattern: RegExp(
							/(:[ \t]*)(?![\s;}[])(?:(?!$|[;}])<js>)+/.source.replace(/<js>/g, function () {
								return jsExpr;
							}),
							'm'
						),
						lookbehind: true,
						greedy: true,
						alias: 'language-javascript',
						inside: Prism2.languages.javascript
					},
					string: {
						pattern: /"(?:\\.|[^\\"\r\n])*"/,
						greedy: true
					},
					keyword: /\b(?:as|import|on)\b/,
					punctuation: /[{}[\]:;,]/
				};
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/qore.js
var require_qore = __commonJS({
	'node_modules/refractor/lang/qore.js'(exports, module2) {
		'use strict';
		module2.exports = qore;
		qore.displayName = 'qore';
		qore.aliases = [];
		function qore(Prism) {
			Prism.languages.qore = Prism.languages.extend('clike', {
				comment: {
					pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:\/\/|#).*)/,
					lookbehind: true
				},
				string: {
					pattern: /("|')(?:\\[\s\S]|(?!\1)[^\\])*\1/,
					greedy: true
				},
				keyword:
					/\b(?:abstract|any|assert|binary|bool|boolean|break|byte|case|catch|char|class|code|const|continue|data|default|do|double|else|enum|extends|final|finally|float|for|goto|hash|if|implements|import|inherits|instanceof|int|interface|long|my|native|new|nothing|null|object|our|own|private|reference|rethrow|return|short|soft(?:bool|date|float|int|list|number|string)|static|strictfp|string|sub|super|switch|synchronized|this|throw|throws|transient|try|void|volatile|while)\b/,
				boolean: /\b(?:false|true)\b/i,
				function: /\$?\b(?!\d)\w+(?=\()/,
				number:
					/\b(?:0b[01]+|0x(?:[\da-f]*\.)?[\da-fp\-]+|(?:\d+(?:\.\d+)?|\.\d+)(?:e\d+)?[df]|(?:\d+(?:\.\d+)?|\.\d+))\b/i,
				operator: {
					pattern:
						/(^|[^.])(?:\+[+=]?|-[-=]?|[!=](?:==?|~)?|>>?=?|<(?:=>?|<=?)?|&[&=]?|\|[|=]?|[*\/%^]=?|[~?])/,
					lookbehind: true
				},
				variable: /\$(?!\d)\w+\b/
			});
		}
	}
});

// node_modules/refractor/lang/qsharp.js
var require_qsharp = __commonJS({
	'node_modules/refractor/lang/qsharp.js'(exports, module2) {
		'use strict';
		module2.exports = qsharp;
		qsharp.displayName = 'qsharp';
		qsharp.aliases = ['qs'];
		function qsharp(Prism) {
			(function (Prism2) {
				function replace(pattern, replacements) {
					return pattern.replace(/<<(\d+)>>/g, function (m2, index6) {
						return '(?:' + replacements[+index6] + ')';
					});
				}
				function re(pattern, replacements, flags) {
					return RegExp(replace(pattern, replacements), flags || '');
				}
				function nested(pattern, depthLog2) {
					for (var i2 = 0; i2 < depthLog2; i2++) {
						pattern = pattern.replace(/<<self>>/g, function () {
							return '(?:' + pattern + ')';
						});
					}
					return pattern.replace(/<<self>>/g, '[^\\s\\S]');
				}
				var keywordKinds = {
					type: 'Adj BigInt Bool Ctl Double false Int One Pauli PauliI PauliX PauliY PauliZ Qubit Range Result String true Unit Zero',
					other:
						'Adjoint adjoint apply as auto body borrow borrowing Controlled controlled distribute elif else fail fixup for function if in internal intrinsic invert is let mutable namespace new newtype open operation repeat return self set until use using while within'
				};
				function keywordsToPattern(words) {
					return '\\b(?:' + words.trim().replace(/ /g, '|') + ')\\b';
				}
				var keywords = RegExp(keywordsToPattern(keywordKinds.type + ' ' + keywordKinds.other));
				var identifier = /\b[A-Za-z_]\w*\b/.source;
				var qualifiedName = replace(/<<0>>(?:\s*\.\s*<<0>>)*/.source, [identifier]);
				var typeInside = {
					keyword: keywords,
					punctuation: /[<>()?,.:[\]]/
				};
				var regularString = /"(?:\\.|[^\\"])*"/.source;
				Prism2.languages.qsharp = Prism2.languages.extend('clike', {
					comment: /\/\/.*/,
					string: [
						{
							pattern: re(/(^|[^$\\])<<0>>/.source, [regularString]),
							lookbehind: true,
							greedy: true
						}
					],
					'class-name': [
						{
							pattern: re(/(\b(?:as|open)\s+)<<0>>(?=\s*(?:;|as\b))/.source, [qualifiedName]),
							lookbehind: true,
							inside: typeInside
						},
						{
							pattern: re(/(\bnamespace\s+)<<0>>(?=\s*\{)/.source, [qualifiedName]),
							lookbehind: true,
							inside: typeInside
						}
					],
					keyword: keywords,
					number:
						/(?:\b0(?:x[\da-f]+|b[01]+|o[0-7]+)|(?:\B\.\d+|\b\d+(?:\.\d*)?)(?:e[-+]?\d+)?)l?\b/i,
					operator:
						/\band=|\bor=|\band\b|\bnot\b|\bor\b|<[-=]|[-=]>|>>>=?|<<<=?|\^\^\^=?|\|\|\|=?|&&&=?|w\/=?|~~~|[*\/+\-^=!%]=?/,
					punctuation: /::|[{}[\];(),.:]/
				});
				Prism2.languages.insertBefore('qsharp', 'number', {
					range: {
						pattern: /\.\./,
						alias: 'operator'
					}
				});
				var interpolationExpr = nested(
					replace(/\{(?:[^"{}]|<<0>>|<<self>>)*\}/.source, [regularString]),
					2
				);
				Prism2.languages.insertBefore('qsharp', 'string', {
					'interpolation-string': {
						pattern: re(/\$"(?:\\.|<<0>>|[^\\"{])*"/.source, [interpolationExpr]),
						greedy: true,
						inside: {
							interpolation: {
								pattern: re(/((?:^|[^\\])(?:\\\\)*)<<0>>/.source, [interpolationExpr]),
								lookbehind: true,
								inside: {
									punctuation: /^\{|\}$/,
									expression: {
										pattern: /[\s\S]+/,
										alias: 'language-qsharp',
										inside: Prism2.languages.qsharp
									}
								}
							},
							string: /[\s\S]+/
						}
					}
				});
			})(Prism);
			Prism.languages.qs = Prism.languages.qsharp;
		}
	}
});

// node_modules/refractor/lang/r.js
var require_r = __commonJS({
	'node_modules/refractor/lang/r.js'(exports, module2) {
		'use strict';
		module2.exports = r2;
		r2.displayName = 'r';
		r2.aliases = [];
		function r2(Prism) {
			Prism.languages.r = {
				comment: /#.*/,
				string: {
					pattern: /(['"])(?:\\.|(?!\1)[^\\\r\n])*\1/,
					greedy: true
				},
				'percent-operator': {
					pattern: /%[^%\s]*%/,
					alias: 'operator'
				},
				boolean: /\b(?:FALSE|TRUE)\b/,
				ellipsis: /\.\.(?:\.|\d+)/,
				number: [
					/\b(?:Inf|NaN)\b/,
					/(?:\b0x[\dA-Fa-f]+(?:\.\d*)?|\b\d+(?:\.\d*)?|\B\.\d+)(?:[EePp][+-]?\d+)?[iL]?/
				],
				keyword:
					/\b(?:NA|NA_character_|NA_complex_|NA_integer_|NA_real_|NULL|break|else|for|function|if|in|next|repeat|while)\b/,
				operator: /->?>?|<(?:=|<?-)?|[>=!]=?|::?|&&?|\|\|?|[+*\/^$@~]/,
				punctuation: /[(){}\[\],;]/
			};
		}
	}
});

// node_modules/refractor/lang/racket.js
var require_racket = __commonJS({
	'node_modules/refractor/lang/racket.js'(exports, module2) {
		'use strict';
		var refractorScheme = require_scheme();
		module2.exports = racket;
		racket.displayName = 'racket';
		racket.aliases = ['rkt'];
		function racket(Prism) {
			Prism.register(refractorScheme);
			Prism.languages.racket = Prism.languages.extend('scheme', {
				'lambda-parameter': {
					pattern: /([(\[]lambda\s+[(\[])[^()\[\]'\s]+/,
					lookbehind: true
				}
			});
			Prism.languages.insertBefore('racket', 'string', {
				lang: {
					pattern: /^#lang.+/m,
					greedy: true,
					alias: 'keyword'
				}
			});
			Prism.languages.rkt = Prism.languages.racket;
		}
	}
});

// node_modules/refractor/lang/reason.js
var require_reason = __commonJS({
	'node_modules/refractor/lang/reason.js'(exports, module2) {
		'use strict';
		module2.exports = reason;
		reason.displayName = 'reason';
		reason.aliases = [];
		function reason(Prism) {
			Prism.languages.reason = Prism.languages.extend('clike', {
				string: {
					pattern: /"(?:\\(?:\r\n|[\s\S])|[^\\\r\n"])*"/,
					greedy: true
				},
				'class-name': /\b[A-Z]\w*/,
				keyword:
					/\b(?:and|as|assert|begin|class|constraint|do|done|downto|else|end|exception|external|for|fun|function|functor|if|in|include|inherit|initializer|lazy|let|method|module|mutable|new|nonrec|object|of|open|or|private|rec|sig|struct|switch|then|to|try|type|val|virtual|when|while|with)\b/,
				operator:
					/\.{3}|:[:=]|\|>|->|=(?:==?|>)?|<=?|>=?|[|^?'#!~`]|[+\-*\/]\.?|\b(?:asr|land|lor|lsl|lsr|lxor|mod)\b/
			});
			Prism.languages.insertBefore('reason', 'class-name', {
				char: {
					pattern: /'(?:\\x[\da-f]{2}|\\o[0-3][0-7][0-7]|\\\d{3}|\\.|[^'\\\r\n])'/,
					greedy: true
				},
				constructor: /\b[A-Z]\w*\b(?!\s*\.)/,
				label: {
					pattern: /\b[a-z]\w*(?=::)/,
					alias: 'symbol'
				}
			});
			delete Prism.languages.reason.function;
		}
	}
});

// node_modules/refractor/lang/regex.js
var require_regex = __commonJS({
	'node_modules/refractor/lang/regex.js'(exports, module2) {
		'use strict';
		module2.exports = regex;
		regex.displayName = 'regex';
		regex.aliases = [];
		function regex(Prism) {
			(function (Prism2) {
				var specialEscape = {
					pattern: /\\[\\(){}[\]^$+*?|.]/,
					alias: 'escape'
				};
				var escape2 =
					/\\(?:x[\da-fA-F]{2}|u[\da-fA-F]{4}|u\{[\da-fA-F]+\}|0[0-7]{0,2}|[123][0-7]{2}|c[a-zA-Z]|.)/;
				var charSet = {
					pattern: /\.|\\[wsd]|\\p\{[^{}]+\}/i,
					alias: 'class-name'
				};
				var charSetWithoutDot = {
					pattern: /\\[wsd]|\\p\{[^{}]+\}/i,
					alias: 'class-name'
				};
				var rangeChar = '(?:[^\\\\-]|' + escape2.source + ')';
				var range = RegExp(rangeChar + '-' + rangeChar);
				var groupName = {
					pattern: /(<|')[^<>']+(?=[>']$)/,
					lookbehind: true,
					alias: 'variable'
				};
				Prism2.languages.regex = {
					'char-class': {
						pattern: /((?:^|[^\\])(?:\\\\)*)\[(?:[^\\\]]|\\[\s\S])*\]/,
						lookbehind: true,
						inside: {
							'char-class-negation': {
								pattern: /(^\[)\^/,
								lookbehind: true,
								alias: 'operator'
							},
							'char-class-punctuation': {
								pattern: /^\[|\]$/,
								alias: 'punctuation'
							},
							range: {
								pattern: range,
								inside: {
									escape: escape2,
									'range-punctuation': {
										pattern: /-/,
										alias: 'operator'
									}
								}
							},
							'special-escape': specialEscape,
							'char-set': charSetWithoutDot,
							escape: escape2
						}
					},
					'special-escape': specialEscape,
					'char-set': charSet,
					backreference: [
						{
							pattern: /\\(?![123][0-7]{2})[1-9]/,
							alias: 'keyword'
						},
						{
							pattern: /\\k<[^<>']+>/,
							alias: 'keyword',
							inside: {
								'group-name': groupName
							}
						}
					],
					anchor: {
						pattern: /[$^]|\\[ABbGZz]/,
						alias: 'function'
					},
					escape: escape2,
					group: [
						{
							pattern:
								/\((?:\?(?:<[^<>']+>|'[^<>']+'|[>:]|<?[=!]|[idmnsuxU]+(?:-[idmnsuxU]+)?:?))?/,
							alias: 'punctuation',
							inside: {
								'group-name': groupName
							}
						},
						{
							pattern: /\)/,
							alias: 'punctuation'
						}
					],
					quantifier: {
						pattern: /(?:[+*?]|\{\d+(?:,\d*)?\})[?+]?/,
						alias: 'number'
					},
					alternation: {
						pattern: /\|/,
						alias: 'keyword'
					}
				};
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/rego.js
var require_rego = __commonJS({
	'node_modules/refractor/lang/rego.js'(exports, module2) {
		'use strict';
		module2.exports = rego;
		rego.displayName = 'rego';
		rego.aliases = [];
		function rego(Prism) {
			Prism.languages.rego = {
				comment: /#.*/,
				property: {
					pattern: /(^|[^\\.])(?:"(?:\\.|[^\\"\r\n])*"|`[^`]*`|\b[a-z_]\w*\b)(?=\s*:(?!=))/i,
					lookbehind: true,
					greedy: true
				},
				string: {
					pattern: /(^|[^\\])"(?:\\.|[^\\"\r\n])*"|`[^`]*`/,
					lookbehind: true,
					greedy: true
				},
				keyword: /\b(?:as|default|else|import|not|null|package|set(?=\s*\()|some|with)\b/,
				boolean: /\b(?:false|true)\b/,
				function: {
					pattern: /\b[a-z_]\w*\b(?:\s*\.\s*\b[a-z_]\w*\b)*(?=\s*\()/i,
					inside: {
						namespace: /\b\w+\b(?=\s*\.)/,
						punctuation: /\./
					}
				},
				number: /-?\b\d+(?:\.\d+)?(?:e[+-]?\d+)?\b/i,
				operator: /[-+*/%|&]|[<>:=]=?|!=|\b_\b/,
				punctuation: /[,;.\[\]{}()]/
			};
		}
	}
});

// node_modules/refractor/lang/renpy.js
var require_renpy = __commonJS({
	'node_modules/refractor/lang/renpy.js'(exports, module2) {
		'use strict';
		module2.exports = renpy;
		renpy.displayName = 'renpy';
		renpy.aliases = ['rpy'];
		function renpy(Prism) {
			Prism.languages.renpy = {
				comment: {
					pattern: /(^|[^\\])#.+/,
					lookbehind: true
				},
				string: {
					pattern:
						/("""|''')[\s\S]+?\1|("|')(?:\\.|(?!\2)[^\\])*\2|(?:^#?(?:(?:[0-9a-fA-F]){3}|[0-9a-fA-F]{6})$)/m,
					greedy: true
				},
				function: /\b[a-z_]\w*(?=\()/i,
				property:
					/\b(?:Update|UpdateVersion|action|activate_sound|adv_nvl_transition|after_load_transition|align|alpha|alt|anchor|antialias|area|auto|background|bar_invert|bar_resizing|bar_vertical|black_color|bold|bottom_bar|bottom_gutter|bottom_margin|bottom_padding|box_reverse|box_wrap|can_update|caret|child|color|crop|default_afm_enable|default_afm_time|default_fullscreen|default_text_cps|developer|directory_name|drag_handle|drag_joined|drag_name|drag_raise|draggable|dragged|drop_shadow|drop_shadow_color|droppable|dropped|easein|easeout|edgescroll|end_game_transition|end_splash_transition|enter_replay_transition|enter_sound|enter_transition|enter_yesno_transition|executable_name|exit_replay_transition|exit_sound|exit_transition|exit_yesno_transition|fadein|fadeout|first_indent|first_spacing|fit_first|focus|focus_mask|font|foreground|game_main_transition|get_installed_packages|google_play_key|google_play_salt|ground|has_music|has_sound|has_voice|height|help|hinting|hover|hover_background|hover_color|hover_sound|hovered|hyperlink_functions|idle|idle_color|image_style|include_update|insensitive|insensitive_background|insensitive_color|inside|intra_transition|italic|justify|kerning|keyboard_focus|language|layer_clipping|layers|layout|left_bar|left_gutter|left_margin|left_padding|length|line_leading|line_overlap_split|line_spacing|linear|main_game_transition|main_menu_music|maximum|min_width|minimum|minwidth|modal|mouse|mousewheel|name|narrator_menu|newline_indent|nvl_adv_transition|offset|order_reverse|outlines|overlay_functions|pos|position|prefix|radius|range|rest_indent|right_bar|right_gutter|right_margin|right_padding|rotate|rotate_pad|ruby_style|sample_sound|save_directory|say_attribute_transition|screen_height|screen_width|scrollbars|selected_hover|selected_hover_color|selected_idle|selected_idle_color|selected_insensitive|show_side_image|show_two_window|side_spacing|side_xpos|side_ypos|size|size_group|slow_cps|slow_cps_multiplier|spacing|strikethrough|subpixel|text_align|text_style|text_xpos|text_y_fudge|text_ypos|thumb|thumb_offset|thumb_shadow|thumbnail_height|thumbnail_width|time|top_bar|top_gutter|top_margin|top_padding|translations|underline|unscrollable|update|value|version|version_name|version_tuple|vertical|width|window_hide_transition|window_icon|window_left_padding|window_show_transition|window_title|windows_icon|xadjustment|xalign|xanchor|xanchoraround|xaround|xcenter|xfill|xinitial|xmargin|xmaximum|xminimum|xoffset|xofsset|xpadding|xpos|xsize|xzoom|yadjustment|yalign|yanchor|yanchoraround|yaround|ycenter|yfill|yinitial|ymargin|ymaximum|yminimum|yoffset|ypadding|ypos|ysize|ysizexysize|yzoom|zoom|zorder)\b/,
				tag: /\b(?:bar|block|button|buttoscreenn|drag|draggroup|fixed|frame|grid|[hv]box|hotbar|hotspot|image|imagebutton|imagemap|input|key|label|menu|mm_menu_frame|mousearea|nvl|parallel|screen|self|side|tag|text|textbutton|timer|vbar|viewport|window)\b|\$/,
				keyword:
					/\b(?:None|add|adjustment|alignaround|allow|angle|animation|around|as|assert|behind|box_layout|break|build|cache|call|center|changed|child_size|choice|circles|class|clear|clicked|clipping|clockwise|config|contains|continue|corner1|corner2|counterclockwise|def|default|define|del|delay|disabled|disabled_text|dissolve|elif|else|event|except|exclude|exec|expression|fade|finally|for|from|function|global|gm_root|has|hide|id|if|import|in|init|is|jump|knot|lambda|left|less_rounded|mm_root|movie|music|null|on|onlayer|pass|pause|persistent|play|print|python|queue|raise|random|renpy|repeat|return|right|rounded_window|scene|scope|set|show|slow|slow_abortable|slow_done|sound|stop|store|style|style_group|substitute|suffix|theme|transform|transform_anchor|transpose|try|ui|unhovered|updater|use|voice|while|widget|widget_hover|widget_selected|widget_text|yield)\b/,
				boolean: /\b(?:[Ff]alse|[Tt]rue)\b/,
				number: /(?:\b(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*(?:\.\d*)?)|\B\.\d+)(?:e[+-]?\d+)?j?/i,
				operator: /[-+%=]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]|\b(?:and|at|not|or|with)\b/,
				punctuation: /[{}[\];(),.:]/
			};
			Prism.languages.rpy = Prism.languages.renpy;
		}
	}
});

// node_modules/refractor/lang/rest.js
var require_rest = __commonJS({
	'node_modules/refractor/lang/rest.js'(exports, module2) {
		'use strict';
		module2.exports = rest;
		rest.displayName = 'rest';
		rest.aliases = [];
		function rest(Prism) {
			Prism.languages.rest = {
				table: [
					{
						pattern:
							/(^[\t ]*)(?:\+[=-]+)+\+(?:\r?\n|\r)(?:\1[+|].+[+|](?:\r?\n|\r))+\1(?:\+[=-]+)+\+/m,
						lookbehind: true,
						inside: {
							punctuation: /\||(?:\+[=-]+)+\+/
						}
					},
					{
						pattern:
							/(^[\t ]*)=+ [ =]*=(?:(?:\r?\n|\r)\1.+)+(?:\r?\n|\r)\1=+ [ =]*=(?=(?:\r?\n|\r){2}|\s*$)/m,
						lookbehind: true,
						inside: {
							punctuation: /[=-]+/
						}
					}
				],
				'substitution-def': {
					pattern: /(^[\t ]*\.\. )\|(?:[^|\s](?:[^|]*[^|\s])?)\| [^:]+::/m,
					lookbehind: true,
					inside: {
						substitution: {
							pattern: /^\|(?:[^|\s]|[^|\s][^|]*[^|\s])\|/,
							alias: 'attr-value',
							inside: {
								punctuation: /^\||\|$/
							}
						},
						directive: {
							pattern: /( )(?! )[^:]+::/,
							lookbehind: true,
							alias: 'function',
							inside: {
								punctuation: /::$/
							}
						}
					}
				},
				'link-target': [
					{
						pattern: /(^[\t ]*\.\. )\[[^\]]+\]/m,
						lookbehind: true,
						alias: 'string',
						inside: {
							punctuation: /^\[|\]$/
						}
					},
					{
						pattern: /(^[\t ]*\.\. )_(?:`[^`]+`|(?:[^:\\]|\\.)+):/m,
						lookbehind: true,
						alias: 'string',
						inside: {
							punctuation: /^_|:$/
						}
					}
				],
				directive: {
					pattern: /(^[\t ]*\.\. )[^:]+::/m,
					lookbehind: true,
					alias: 'function',
					inside: {
						punctuation: /::$/
					}
				},
				comment: {
					pattern: /(^[\t ]*\.\.)(?:(?: .+)?(?:(?:\r?\n|\r).+)+| .+)(?=(?:\r?\n|\r){2}|$)/m,
					lookbehind: true
				},
				title: [
					{
						pattern:
							/^(([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2+)(?:\r?\n|\r).+(?:\r?\n|\r)\1$/m,
						inside: {
							punctuation:
								/^[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+|[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+$/,
							important: /.+/
						}
					},
					{
						pattern:
							/(^|(?:\r?\n|\r){2}).+(?:\r?\n|\r)([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2+(?=\r?\n|\r|$)/,
						lookbehind: true,
						inside: {
							punctuation: /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]+$/,
							important: /.+/
						}
					}
				],
				hr: {
					pattern:
						/((?:\r?\n|\r){2})([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\2{3,}(?=(?:\r?\n|\r){2})/,
					lookbehind: true,
					alias: 'punctuation'
				},
				field: {
					pattern: /(^[\t ]*):[^:\r\n]+:(?= )/m,
					lookbehind: true,
					alias: 'attr-name'
				},
				'command-line-option': {
					pattern:
						/(^[\t ]*)(?:[+-][a-z\d]|(?:--|\/)[a-z\d-]+)(?:[ =](?:[a-z][\w-]*|<[^<>]+>))?(?:, (?:[+-][a-z\d]|(?:--|\/)[a-z\d-]+)(?:[ =](?:[a-z][\w-]*|<[^<>]+>))?)*(?=(?:\r?\n|\r)? {2,}\S)/im,
					lookbehind: true,
					alias: 'symbol'
				},
				'literal-block': {
					pattern: /::(?:\r?\n|\r){2}([ \t]+)(?![ \t]).+(?:(?:\r?\n|\r)\1.+)*/,
					inside: {
						'literal-block-punctuation': {
							pattern: /^::/,
							alias: 'punctuation'
						}
					}
				},
				'quoted-literal-block': {
					pattern:
						/::(?:\r?\n|\r){2}([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~]).*(?:(?:\r?\n|\r)\1.*)*/,
					inside: {
						'literal-block-punctuation': {
							pattern: /^(?:::|([!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~])\1*)/m,
							alias: 'punctuation'
						}
					}
				},
				'list-bullet': {
					pattern:
						/(^[\t ]*)(?:[*+\-]|\(?(?:\d+|[a-z]|[ivxdclm]+)\)|(?:\d+|[a-z]|[ivxdclm]+)\.)(?= )/im,
					lookbehind: true,
					alias: 'punctuation'
				},
				'doctest-block': {
					pattern: /(^[\t ]*)>>> .+(?:(?:\r?\n|\r).+)*/m,
					lookbehind: true,
					inside: {
						punctuation: /^>>>/
					}
				},
				inline: [
					{
						pattern:
							/(^|[\s\-:\/'"<(\[{])(?::[^:]+:`.*?`|`.*?`:[^:]+:|(\*\*?|``?|\|)(?!\s)(?:(?!\2).)*\S\2(?=[\s\-.,:;!?\\\/'")\]}]|$))/m,
						lookbehind: true,
						inside: {
							bold: {
								pattern: /(^\*\*).+(?=\*\*$)/,
								lookbehind: true
							},
							italic: {
								pattern: /(^\*).+(?=\*$)/,
								lookbehind: true
							},
							'inline-literal': {
								pattern: /(^``).+(?=``$)/,
								lookbehind: true,
								alias: 'symbol'
							},
							role: {
								pattern: /^:[^:]+:|:[^:]+:$/,
								alias: 'function',
								inside: {
									punctuation: /^:|:$/
								}
							},
							'interpreted-text': {
								pattern: /(^`).+(?=`$)/,
								lookbehind: true,
								alias: 'attr-value'
							},
							substitution: {
								pattern: /(^\|).+(?=\|$)/,
								lookbehind: true,
								alias: 'attr-value'
							},
							punctuation: /\*\*?|``?|\|/
						}
					}
				],
				link: [
					{
						pattern: /\[[^\[\]]+\]_(?=[\s\-.,:;!?\\\/'")\]}]|$)/,
						alias: 'string',
						inside: {
							punctuation: /^\[|\]_$/
						}
					},
					{
						pattern:
							/(?:\b[a-z\d]+(?:[_.:+][a-z\d]+)*_?_|`[^`]+`_?_|_`[^`]+`)(?=[\s\-.,:;!?\\\/'")\]}]|$)/i,
						alias: 'string',
						inside: {
							punctuation: /^_?`|`$|`?_?_$/
						}
					}
				],
				punctuation: {
					pattern: /(^[\t ]*)(?:\|(?= |$)|(?:---?||\.\.|__)(?= )|\.\.$)/m,
					lookbehind: true
				}
			};
		}
	}
});

// node_modules/refractor/lang/rip.js
var require_rip = __commonJS({
	'node_modules/refractor/lang/rip.js'(exports, module2) {
		'use strict';
		module2.exports = rip;
		rip.displayName = 'rip';
		rip.aliases = [];
		function rip(Prism) {
			Prism.languages.rip = {
				comment: {
					pattern: /#.*/,
					greedy: true
				},
				char: {
					pattern: /\B`[^\s`'",.:;#\/\\()<>\[\]{}]\b/,
					greedy: true
				},
				string: {
					pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
					greedy: true
				},
				regex: {
					pattern: /(^|[^/])\/(?!\/)(?:\[[^\n\r\]]*\]|\\.|[^/\\\r\n\[])+\/(?=\s*(?:$|[\r\n,.;})]))/,
					lookbehind: true,
					greedy: true
				},
				keyword: /(?:=>|->)|\b(?:case|catch|class|else|exit|finally|if|raise|return|switch|try)\b/,
				builtin: /@|\bSystem\b/,
				boolean: /\b(?:false|true)\b/,
				date: /\b\d{4}-\d{2}-\d{2}\b/,
				time: /\b\d{2}:\d{2}:\d{2}\b/,
				datetime: /\b\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\b/,
				symbol: /:[^\d\s`'",.:;#\/\\()<>\[\]{}][^\s`'",.:;#\/\\()<>\[\]{}]*/,
				number: /[+-]?\b(?:\d+\.\d+|\d+)\b/,
				punctuation: /(?:\.{2,3})|[`,.:;=\/\\()<>\[\]{}]/,
				reference: /[^\d\s`'",.:;#\/\\()<>\[\]{}][^\s`'",.:;#\/\\()<>\[\]{}]*/
			};
		}
	}
});

// node_modules/refractor/lang/roboconf.js
var require_roboconf = __commonJS({
	'node_modules/refractor/lang/roboconf.js'(exports, module2) {
		'use strict';
		module2.exports = roboconf;
		roboconf.displayName = 'roboconf';
		roboconf.aliases = [];
		function roboconf(Prism) {
			Prism.languages.roboconf = {
				comment: /#.*/,
				keyword: {
					pattern: /(^|\s)(?:(?:external|import)\b|(?:facet|instance of)(?=[ \t]+[\w-]+[ \t]*\{))/,
					lookbehind: true
				},
				component: {
					pattern: /[\w-]+(?=[ \t]*\{)/,
					alias: 'variable'
				},
				property: /[\w.-]+(?=[ \t]*:)/,
				value: {
					pattern: /(=[ \t]*(?![ \t]))[^,;]+/,
					lookbehind: true,
					alias: 'attr-value'
				},
				optional: {
					pattern: /\(optional\)/,
					alias: 'builtin'
				},
				wildcard: {
					pattern: /(\.)\*/,
					lookbehind: true,
					alias: 'operator'
				},
				punctuation: /[{},.;:=]/
			};
		}
	}
});

// node_modules/refractor/lang/robotframework.js
var require_robotframework = __commonJS({
	'node_modules/refractor/lang/robotframework.js'(exports, module2) {
		'use strict';
		module2.exports = robotframework;
		robotframework.displayName = 'robotframework';
		robotframework.aliases = [];
		function robotframework(Prism) {
			(function (Prism2) {
				var comment4 = {
					pattern: /(^[ \t]*| {2}|\t)#.*/m,
					lookbehind: true,
					greedy: true
				};
				var variable = {
					pattern: /((?:^|[^\\])(?:\\{2})*)[$@&%]\{(?:[^{}\r\n]|\{[^{}\r\n]*\})*\}/,
					lookbehind: true,
					inside: {
						punctuation: /^[$@&%]\{|\}$/
					}
				};
				function createSection(name, inside) {
					var extendecInside = {};
					extendecInside['section-header'] = {
						pattern: /^ ?\*{3}.+?\*{3}/,
						alias: 'keyword'
					};
					for (var token in inside) {
						extendecInside[token] = inside[token];
					}
					extendecInside['tag'] = {
						pattern: /([\r\n](?: {2}|\t)[ \t]*)\[[-\w]+\]/,
						lookbehind: true,
						inside: {
							punctuation: /\[|\]/
						}
					};
					extendecInside['variable'] = variable;
					extendecInside['comment'] = comment4;
					return {
						pattern: RegExp(
							/^ ?\*{3}[ \t]*<name>[ \t]*\*{3}(?:.|[\r\n](?!\*{3}))*/.source.replace(
								/<name>/g,
								function () {
									return name;
								}
							),
							'im'
						),
						alias: 'section',
						inside: extendecInside
					};
				}
				var docTag = {
					pattern: /(\[Documentation\](?: {2}|\t)[ \t]*)(?![ \t]|#)(?:.|(?:\r\n?|\n)[ \t]*\.{3})+/,
					lookbehind: true,
					alias: 'string'
				};
				var testNameLike = {
					pattern: /([\r\n] ?)(?!#)(?:\S(?:[ \t]\S)*)+/,
					lookbehind: true,
					alias: 'function',
					inside: {
						variable
					}
				};
				var testPropertyLike = {
					pattern: /([\r\n](?: {2}|\t)[ \t]*)(?!\[|\.{3}|#)(?:\S(?:[ \t]\S)*)+/,
					lookbehind: true,
					inside: {
						variable
					}
				};
				Prism2.languages['robotframework'] = {
					settings: createSection('Settings', {
						documentation: {
							pattern:
								/([\r\n] ?Documentation(?: {2}|\t)[ \t]*)(?![ \t]|#)(?:.|(?:\r\n?|\n)[ \t]*\.{3})+/,
							lookbehind: true,
							alias: 'string'
						},
						property: {
							pattern: /([\r\n] ?)(?!\.{3}|#)(?:\S(?:[ \t]\S)*)+/,
							lookbehind: true
						}
					}),
					variables: createSection('Variables'),
					'test-cases': createSection('Test Cases', {
						'test-name': testNameLike,
						documentation: docTag,
						property: testPropertyLike
					}),
					keywords: createSection('Keywords', {
						'keyword-name': testNameLike,
						documentation: docTag,
						property: testPropertyLike
					}),
					tasks: createSection('Tasks', {
						'task-name': testNameLike,
						documentation: docTag,
						property: testPropertyLike
					}),
					comment: comment4
				};
				Prism2.languages.robot = Prism2.languages['robotframework'];
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/rust.js
var require_rust = __commonJS({
	'node_modules/refractor/lang/rust.js'(exports, module2) {
		'use strict';
		module2.exports = rust;
		rust.displayName = 'rust';
		rust.aliases = [];
		function rust(Prism) {
			(function (Prism2) {
				var multilineComment = /\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|<self>)*\*\//.source;
				for (var i2 = 0; i2 < 2; i2++) {
					multilineComment = multilineComment.replace(/<self>/g, function () {
						return multilineComment;
					});
				}
				multilineComment = multilineComment.replace(/<self>/g, function () {
					return /[^\s\S]/.source;
				});
				Prism2.languages.rust = {
					comment: [
						{
							pattern: RegExp(/(^|[^\\])/.source + multilineComment),
							lookbehind: true,
							greedy: true
						},
						{
							pattern: /(^|[^\\:])\/\/.*/,
							lookbehind: true,
							greedy: true
						}
					],
					string: {
						pattern: /b?"(?:\\[\s\S]|[^\\"])*"|b?r(#*)"(?:[^"]|"(?!\1))*"\1/,
						greedy: true
					},
					char: {
						pattern: /b?'(?:\\(?:x[0-7][\da-fA-F]|u\{(?:[\da-fA-F]_*){1,6}\}|.)|[^\\\r\n\t'])'/,
						greedy: true
					},
					attribute: {
						pattern: /#!?\[(?:[^\[\]"]|"(?:\\[\s\S]|[^\\"])*")*\]/,
						greedy: true,
						alias: 'attr-name',
						inside: {
							string: null
						}
					},
					'closure-params': {
						pattern: /([=(,:]\s*|\bmove\s*)\|[^|]*\||\|[^|]*\|(?=\s*(?:\{|->))/,
						lookbehind: true,
						greedy: true,
						inside: {
							'closure-punctuation': {
								pattern: /^\||\|$/,
								alias: 'punctuation'
							},
							rest: null
						}
					},
					'lifetime-annotation': {
						pattern: /'\w+/,
						alias: 'symbol'
					},
					'fragment-specifier': {
						pattern: /(\$\w+:)[a-z]+/,
						lookbehind: true,
						alias: 'punctuation'
					},
					variable: /\$\w+/,
					'function-definition': {
						pattern: /(\bfn\s+)\w+/,
						lookbehind: true,
						alias: 'function'
					},
					'type-definition': {
						pattern: /(\b(?:enum|struct|trait|type|union)\s+)\w+/,
						lookbehind: true,
						alias: 'class-name'
					},
					'module-declaration': [
						{
							pattern: /(\b(?:crate|mod)\s+)[a-z][a-z_\d]*/,
							lookbehind: true,
							alias: 'namespace'
						},
						{
							pattern:
								/(\b(?:crate|self|super)\s*)::\s*[a-z][a-z_\d]*\b(?:\s*::(?:\s*[a-z][a-z_\d]*\s*::)*)?/,
							lookbehind: true,
							alias: 'namespace',
							inside: {
								punctuation: /::/
							}
						}
					],
					keyword: [
						/\b(?:Self|abstract|as|async|await|become|box|break|const|continue|crate|do|dyn|else|enum|extern|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|override|priv|pub|ref|return|self|static|struct|super|trait|try|type|typeof|union|unsafe|unsized|use|virtual|where|while|yield)\b/,
						/\b(?:bool|char|f(?:32|64)|[ui](?:8|16|32|64|128|size)|str)\b/
					],
					function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())/,
					macro: {
						pattern: /\b\w+!/,
						alias: 'property'
					},
					constant: /\b[A-Z_][A-Z_\d]+\b/,
					'class-name': /\b[A-Z]\w*\b/,
					namespace: {
						pattern: /(?:\b[a-z][a-z_\d]*\s*::\s*)*\b[a-z][a-z_\d]*\s*::(?!\s*<)/,
						inside: {
							punctuation: /::/
						}
					},
					number:
						/\b(?:0x[\dA-Fa-f](?:_?[\dA-Fa-f])*|0o[0-7](?:_?[0-7])*|0b[01](?:_?[01])*|(?:(?:\d(?:_?\d)*)?\.)?\d(?:_?\d)*(?:[Ee][+-]?\d+)?)(?:_?(?:f32|f64|[iu](?:8|16|32|64|size)?))?\b/,
					boolean: /\b(?:false|true)\b/,
					punctuation: /->|\.\.=|\.{1,3}|::|[{}[\];(),:]/,
					operator: /[-+*\/%!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?=?|[@?]/
				};
				Prism2.languages.rust['closure-params'].inside.rest = Prism2.languages.rust;
				Prism2.languages.rust['attribute'].inside['string'] = Prism2.languages.rust['string'];
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/sas.js
var require_sas = __commonJS({
	'node_modules/refractor/lang/sas.js'(exports, module2) {
		'use strict';
		module2.exports = sas;
		sas.displayName = 'sas';
		sas.aliases = [];
		function sas(Prism) {
			(function (Prism2) {
				var stringPattern = /(?:"(?:""|[^"])*"(?!")|'(?:''|[^'])*'(?!'))/.source;
				var number3 = /\b(?:\d[\da-f]*x|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i;
				var numericConstant = {
					pattern: RegExp(stringPattern + '[bx]'),
					alias: 'number'
				};
				var macroVariable = {
					pattern: /&[a-z_]\w*/i
				};
				var macroKeyword = {
					pattern:
						/((?:^|\s|=|\())%(?:ABORT|BY|CMS|COPY|DISPLAY|DO|ELSE|END|EVAL|GLOBAL|GO|GOTO|IF|INC|INCLUDE|INDEX|INPUT|KTRIM|LENGTH|LET|LIST|LOCAL|PUT|QKTRIM|QSCAN|QSUBSTR|QSYSFUNC|QUPCASE|RETURN|RUN|SCAN|SUBSTR|SUPERQ|SYMDEL|SYMEXIST|SYMGLOBL|SYMLOCAL|SYSCALL|SYSEVALF|SYSEXEC|SYSFUNC|SYSGET|SYSRPUT|THEN|TO|TSO|UNQUOTE|UNTIL|UPCASE|WHILE|WINDOW)\b/i,
					lookbehind: true,
					alias: 'keyword'
				};
				var step = {
					pattern: /(^|\s)(?:proc\s+\w+|data(?!=)|quit|run)\b/i,
					alias: 'keyword',
					lookbehind: true
				};
				var comment4 = [
					/\/\*[\s\S]*?\*\//,
					{
						pattern: /(^[ \t]*|;\s*)\*[^;]*;/m,
						lookbehind: true
					}
				];
				var string3 = {
					pattern: RegExp(stringPattern),
					greedy: true
				};
				var punctuation = /[$%@.(){}\[\];,\\]/;
				var func = {
					pattern: /%?\b\w+(?=\()/,
					alias: 'keyword'
				};
				var args = {
					function: func,
					'arg-value': {
						pattern: /(=\s*)[A-Z\.]+/i,
						lookbehind: true
					},
					operator: /=/,
					'macro-variable': macroVariable,
					arg: {
						pattern: /[A-Z]+/i,
						alias: 'keyword'
					},
					number: number3,
					'numeric-constant': numericConstant,
					punctuation,
					string: string3
				};
				var format2 = {
					pattern: /\b(?:format|put)\b=?[\w'$.]+/i,
					inside: {
						keyword: /^(?:format|put)(?==)/i,
						equals: /=/,
						format: {
							pattern: /(?:\w|\$\d)+\.\d?/,
							alias: 'number'
						}
					}
				};
				var altformat = {
					pattern: /\b(?:format|put)\s+[\w']+(?:\s+[$.\w]+)+(?=;)/i,
					inside: {
						keyword: /^(?:format|put)/i,
						format: {
							pattern: /[\w$]+\.\d?/,
							alias: 'number'
						}
					}
				};
				var globalStatements = {
					pattern:
						/((?:^|\s)=?)(?:catname|checkpoint execute_always|dm|endsas|filename|footnote|%include|libname|%list|lock|missing|options|page|resetline|%run|sasfile|skip|sysecho|title\d?)\b/i,
					lookbehind: true,
					alias: 'keyword'
				};
				var submitStatement = {
					pattern: /(^|\s)(?:submit(?:\s+(?:load|norun|parseonly))?|endsubmit)\b/i,
					lookbehind: true,
					alias: 'keyword'
				};
				var actionSets =
					/aStore|accessControl|aggregation|audio|autotune|bayesianNetClassifier|bioMedImage|boolRule|builtins|cardinality|cdm|clustering|conditionalRandomFields|configuration|copula|countreg|dataDiscovery|dataPreprocess|dataSciencePilot|dataStep|decisionTree|deduplication|deepLearn|deepNeural|deepRnn|ds2|ecm|entityRes|espCluster|explainModel|factmac|fastKnn|fcmpact|fedSql|freqTab|gVarCluster|gam|gleam|graphSemiSupLearn|hiddenMarkovModel|hyperGroup|ica|image|iml|kernalPca|langModel|ldaTopic|loadStreams|mbc|mixed|mlTools|modelPublishing|network|neuralNet|nmf|nonParametricBayes|nonlinear|optNetwork|optimization|panel|pca|percentile|phreg|pls|qkb|qlim|quantreg|recommend|regression|reinforcementLearn|robustPca|ruleMining|sampling|sandwich|sccasl|search(?:Analytics)?|sentimentAnalysis|sequence|session(?:Prop)?|severity|simSystem|simple|smartData|sparkEmbeddedProcess|sparseML|spatialreg|spc|stabilityMonitoring|svDataDescription|svm|table|text(?:Filters|Frequency|Mining|Parse|Rule(?:Develop|Score)|Topic|Util)|timeData|transpose|tsInfo|tsReconcile|uniTimeSeries|varReduce/
						.source;
				var casActions = {
					pattern: RegExp(
						/(^|\s)(?:action\s+)?(?:<act>)\.[a-z]+\b[^;]+/.source.replace(/<act>/g, function () {
							return actionSets;
						}),
						'i'
					),
					lookbehind: true,
					inside: {
						keyword: RegExp(
							/(?:<act>)\.[a-z]+\b/.source.replace(/<act>/g, function () {
								return actionSets;
							}),
							'i'
						),
						action: {
							pattern: /(?:action)/i,
							alias: 'keyword'
						},
						comment: comment4,
						function: func,
						'arg-value': args['arg-value'],
						operator: args.operator,
						argument: args.arg,
						number: number3,
						'numeric-constant': numericConstant,
						punctuation,
						string: string3
					}
				};
				var keywords = {
					pattern:
						/((?:^|\s)=?)(?:after|analysis|and|array|barchart|barwidth|begingraph|by|call|cas|cbarline|cfill|class(?:lev)?|close|column|computed?|contains|continue|data(?==)|define|delete|describe|document|do\s+over|do|dol|drop|dul|else|end(?:comp|source)?|entryTitle|eval(?:uate)?|exec(?:ute)?|exit|file(?:name)?|fill(?:attrs)?|flist|fnc|function(?:list)?|global|goto|group(?:by)?|headline|headskip|histogram|if|infile|keep|keylabel|keyword|label|layout|leave|legendlabel|length|libname|loadactionset|merge|midpoints|_?null_|name|noobs|nowd|ods|options|or|otherwise|out(?:put)?|over(?:lay)?|plot|print|put|raise|ranexp|rannor|rbreak|retain|return|select|session|sessref|set|source|statgraph|sum|summarize|table|temp|terminate|then\s+do|then|title\d?|to|var|when|where|xaxisopts|y2axisopts|yaxisopts)\b/i,
					lookbehind: true
				};
				Prism2.languages.sas = {
					datalines: {
						pattern: /^([ \t]*)(?:cards|(?:data)?lines);[\s\S]+?^[ \t]*;/im,
						lookbehind: true,
						alias: 'string',
						inside: {
							keyword: {
								pattern: /^(?:cards|(?:data)?lines)/i
							},
							punctuation: /;/
						}
					},
					'proc-sql': {
						pattern:
							/(^proc\s+(?:fed)?sql(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
						lookbehind: true,
						inside: {
							sql: {
								pattern: RegExp(
									/^[ \t]*(?:select|alter\s+table|(?:create|describe|drop)\s+(?:index|table(?:\s+constraints)?|view)|create\s+unique\s+index|insert\s+into|update)(?:<str>|[^;"'])+;/.source.replace(
										/<str>/g,
										function () {
											return stringPattern;
										}
									),
									'im'
								),
								alias: 'language-sql',
								inside: Prism2.languages.sql
							},
							'global-statements': globalStatements,
							'sql-statements': {
								pattern:
									/(^|\s)(?:disconnect\s+from|begin|commit|exec(?:ute)?|reset|rollback|validate)\b/i,
								lookbehind: true,
								alias: 'keyword'
							},
							number: number3,
							'numeric-constant': numericConstant,
							punctuation,
							string: string3
						}
					},
					'proc-groovy': {
						pattern:
							/(^proc\s+groovy(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
						lookbehind: true,
						inside: {
							comment: comment4,
							groovy: {
								pattern: RegExp(
									/(^[ \t]*submit(?:\s+(?:load|norun|parseonly))?)(?:<str>|[^"'])+?(?=endsubmit;)/.source.replace(
										/<str>/g,
										function () {
											return stringPattern;
										}
									),
									'im'
								),
								lookbehind: true,
								alias: 'language-groovy',
								inside: Prism2.languages.groovy
							},
							keyword: keywords,
							'submit-statement': submitStatement,
							'global-statements': globalStatements,
							number: number3,
							'numeric-constant': numericConstant,
							punctuation,
							string: string3
						}
					},
					'proc-lua': {
						pattern:
							/(^proc\s+lua(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|data|quit|run);|(?![\s\S]))/im,
						lookbehind: true,
						inside: {
							comment: comment4,
							lua: {
								pattern: RegExp(
									/(^[ \t]*submit(?:\s+(?:load|norun|parseonly))?)(?:<str>|[^"'])+?(?=endsubmit;)/.source.replace(
										/<str>/g,
										function () {
											return stringPattern;
										}
									),
									'im'
								),
								lookbehind: true,
								alias: 'language-lua',
								inside: Prism2.languages.lua
							},
							keyword: keywords,
							'submit-statement': submitStatement,
							'global-statements': globalStatements,
							number: number3,
							'numeric-constant': numericConstant,
							punctuation,
							string: string3
						}
					},
					'proc-cas': {
						pattern:
							/(^proc\s+cas(?:\s+[\w|=]+)?;)[\s\S]+?(?=^(?:proc\s+\w+|quit|data);|(?![\s\S]))/im,
						lookbehind: true,
						inside: {
							comment: comment4,
							'statement-var': {
								pattern: /((?:^|\s)=?)saveresult\s[^;]+/im,
								lookbehind: true,
								inside: {
									statement: {
										pattern: /^saveresult\s+\S+/i,
										inside: {
											keyword: /^(?:saveresult)/i
										}
									},
									rest: args
								}
							},
							'cas-actions': casActions,
							statement: {
								pattern: /((?:^|\s)=?)(?:default|(?:un)?set|on|output|upload)[^;]+/im,
								lookbehind: true,
								inside: args
							},
							step,
							keyword: keywords,
							function: func,
							format: format2,
							altformat,
							'global-statements': globalStatements,
							number: number3,
							'numeric-constant': numericConstant,
							punctuation,
							string: string3
						}
					},
					'proc-args': {
						pattern: RegExp(
							/(^proc\s+\w+\s+)(?!\s)(?:[^;"']|<str>)+;/.source.replace(/<str>/g, function () {
								return stringPattern;
							}),
							'im'
						),
						lookbehind: true,
						inside: args
					},
					'macro-keyword': macroKeyword,
					'macro-variable': macroVariable,
					'macro-string-functions': {
						pattern: /((?:^|\s|=))%(?:BQUOTE|NRBQUOTE|NRQUOTE|NRSTR|QUOTE|STR)\(.*?(?:[^%]\))/i,
						lookbehind: true,
						inside: {
							function: {
								pattern: /%(?:BQUOTE|NRBQUOTE|NRQUOTE|NRSTR|QUOTE|STR)/i,
								alias: 'keyword'
							},
							'macro-keyword': macroKeyword,
							'macro-variable': macroVariable,
							'escaped-char': {
								pattern: /%['"()<>=^~;,#]/
							},
							punctuation
						}
					},
					'macro-declaration': {
						pattern: /^%macro[^;]+(?=;)/im,
						inside: {
							keyword: /%macro/i
						}
					},
					'macro-end': {
						pattern: /^%mend[^;]+(?=;)/im,
						inside: {
							keyword: /%mend/i
						}
					},
					macro: {
						pattern: /%_\w+(?=\()/,
						alias: 'keyword'
					},
					input: {
						pattern: /\binput\s[-\w\s/*.$&]+;/i,
						inside: {
							input: {
								alias: 'keyword',
								pattern: /^input/i
							},
							comment: comment4,
							number: number3,
							'numeric-constant': numericConstant
						}
					},
					'options-args': {
						pattern: /(^options)[-'"|/\\<>*+=:()\w\s]*(?=;)/im,
						lookbehind: true,
						inside: args
					},
					'cas-actions': casActions,
					comment: comment4,
					function: func,
					format: format2,
					altformat,
					'numeric-constant': numericConstant,
					datetime: {
						pattern: RegExp(stringPattern + '(?:dt?|t)'),
						alias: 'number'
					},
					string: string3,
					step,
					keyword: keywords,
					'operator-keyword': {
						pattern: /\b(?:eq|ge|gt|in|le|lt|ne|not)\b/i,
						alias: 'operator'
					},
					number: number3,
					operator: /\*\*?|\|\|?|!!?|?|<[>=]?|>[<=]?|[-+\/=&]|[~^]=?/,
					punctuation
				};
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/sass.js
var require_sass = __commonJS({
	'node_modules/refractor/lang/sass.js'(exports, module2) {
		'use strict';
		module2.exports = sass;
		sass.displayName = 'sass';
		sass.aliases = [];
		function sass(Prism) {
			(function (Prism2) {
				Prism2.languages.sass = Prism2.languages.extend('css', {
					comment: {
						pattern: /^([ \t]*)\/[\/*].*(?:(?:\r?\n|\r)\1[ \t].+)*/m,
						lookbehind: true,
						greedy: true
					}
				});
				Prism2.languages.insertBefore('sass', 'atrule', {
					'atrule-line': {
						pattern: /^(?:[ \t]*)[@+=].+/m,
						greedy: true,
						inside: {
							atrule: /(?:@[\w-]+|[+=])/
						}
					}
				});
				delete Prism2.languages.sass.atrule;
				var variable = /\$[-\w]+|#\{\$[-\w]+\}/;
				var operator = [
					/[+*\/%]|[=!]=|<=?|>=?|\b(?:and|not|or)\b/,
					{
						pattern: /(\s)-(?=\s)/,
						lookbehind: true
					}
				];
				Prism2.languages.insertBefore('sass', 'property', {
					'variable-line': {
						pattern: /^[ \t]*\$.+/m,
						greedy: true,
						inside: {
							punctuation: /:/,
							variable,
							operator
						}
					},
					'property-line': {
						pattern: /^[ \t]*(?:[^:\s]+ *:.*|:[^:\s].*)/m,
						greedy: true,
						inside: {
							property: [
								/[^:\s]+(?=\s*:)/,
								{
									pattern: /(:)[^:\s]+/,
									lookbehind: true
								}
							],
							punctuation: /:/,
							variable,
							operator,
							important: Prism2.languages.sass.important
						}
					}
				});
				delete Prism2.languages.sass.property;
				delete Prism2.languages.sass.important;
				Prism2.languages.insertBefore('sass', 'punctuation', {
					selector: {
						pattern:
							/^([ \t]*)\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*(?:,(?:\r?\n|\r)\1[ \t]+\S(?:,[^,\r\n]+|[^,\r\n]*)(?:,[^,\r\n]+)*)*/m,
						lookbehind: true,
						greedy: true
					}
				});
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/scala.js
var require_scala = __commonJS({
	'node_modules/refractor/lang/scala.js'(exports, module2) {
		'use strict';
		var refractorJava = require_java();
		module2.exports = scala;
		scala.displayName = 'scala';
		scala.aliases = [];
		function scala(Prism) {
			Prism.register(refractorJava);
			Prism.languages.scala = Prism.languages.extend('java', {
				'triple-quoted-string': {
					pattern: /"""[\s\S]*?"""/,
					greedy: true,
					alias: 'string'
				},
				string: {
					pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
					greedy: true
				},
				keyword:
					/<-|=>|\b(?:abstract|case|catch|class|def|do|else|extends|final|finally|for|forSome|if|implicit|import|lazy|match|new|null|object|override|package|private|protected|return|sealed|self|super|this|throw|trait|try|type|val|var|while|with|yield)\b/,
				number: /\b0x(?:[\da-f]*\.)?[\da-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e\d+)?[dfl]?/i,
				builtin:
					/\b(?:Any|AnyRef|AnyVal|Boolean|Byte|Char|Double|Float|Int|Long|Nothing|Short|String|Unit)\b/,
				symbol: /'[^\d\s\\]\w*/
			});
			Prism.languages.insertBefore('scala', 'triple-quoted-string', {
				'string-interpolation': {
					pattern:
						/\b[a-z]\w*(?:"""(?:[^$]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*?"""|"(?:[^$"\r\n]|\$(?:[^{]|\{(?:[^{}]|\{[^{}]*\})*\}))*")/i,
					greedy: true,
					inside: {
						id: {
							pattern: /^\w+/,
							greedy: true,
							alias: 'function'
						},
						escape: {
							pattern: /\\\$"|\$[$"]/,
							greedy: true,
							alias: 'symbol'
						},
						interpolation: {
							pattern: /\$(?:\w+|\{(?:[^{}]|\{[^{}]*\})*\})/,
							greedy: true,
							inside: {
								punctuation: /^\$\{?|\}$/,
								expression: {
									pattern: /[\s\S]+/,
									inside: Prism.languages.scala
								}
							}
						},
						string: /[\s\S]+/
					}
				}
			});
			delete Prism.languages.scala['class-name'];
			delete Prism.languages.scala['function'];
		}
	}
});

// node_modules/refractor/lang/scss.js
var require_scss = __commonJS({
	'node_modules/refractor/lang/scss.js'(exports, module2) {
		'use strict';
		module2.exports = scss;
		scss.displayName = 'scss';
		scss.aliases = [];
		function scss(Prism) {
			Prism.languages.scss = Prism.languages.extend('css', {
				comment: {
					pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
					lookbehind: true
				},
				atrule: {
					pattern: /@[\w-](?:\([^()]+\)|[^()\s]|\s+(?!\s))*?(?=\s+[{;])/,
					inside: {
						rule: /@[\w-]+/
					}
				},
				url: /(?:[-a-z]+-)?url(?=\()/i,
				selector: {
					pattern:
						/(?=\S)[^@;{}()]?(?:[^@;{}()\s]|\s+(?!\s)|#\{\$[-\w]+\})+(?=\s*\{(?:\}|\s|[^}][^:{}]*[:{][^}]))/,
					inside: {
						parent: {
							pattern: /&/,
							alias: 'important'
						},
						placeholder: /%[-\w]+/,
						variable: /\$[-\w]+|#\{\$[-\w]+\}/
					}
				},
				property: {
					pattern: /(?:[-\w]|\$[-\w]|#\{\$[-\w]+\})+(?=\s*:)/,
					inside: {
						variable: /\$[-\w]+|#\{\$[-\w]+\}/
					}
				}
			});
			Prism.languages.insertBefore('scss', 'atrule', {
				keyword: [
					/@(?:content|debug|each|else(?: if)?|extend|for|forward|function|if|import|include|mixin|return|use|warn|while)\b/i,
					{
						pattern: /( )(?:from|through)(?= )/,
						lookbehind: true
					}
				]
			});
			Prism.languages.insertBefore('scss', 'important', {
				variable: /\$[-\w]+|#\{\$[-\w]+\}/
			});
			Prism.languages.insertBefore('scss', 'function', {
				'module-modifier': {
					pattern: /\b(?:as|hide|show|with)\b/i,
					alias: 'keyword'
				},
				placeholder: {
					pattern: /%[-\w]+/,
					alias: 'selector'
				},
				statement: {
					pattern: /\B!(?:default|optional)\b/i,
					alias: 'keyword'
				},
				boolean: /\b(?:false|true)\b/,
				null: {
					pattern: /\bnull\b/,
					alias: 'keyword'
				},
				operator: {
					pattern: /(\s)(?:[-+*\/%]|[=!]=|<=?|>=?|and|not|or)(?=\s)/,
					lookbehind: true
				}
			});
			Prism.languages.scss['atrule'].inside.rest = Prism.languages.scss;
		}
	}
});

// node_modules/refractor/lang/shell-session.js
var require_shell_session = __commonJS({
	'node_modules/refractor/lang/shell-session.js'(exports, module2) {
		'use strict';
		var refractorBash = require_bash();
		module2.exports = shellSession;
		shellSession.displayName = 'shellSession';
		shellSession.aliases = [];
		function shellSession(Prism) {
			Prism.register(refractorBash);
			(function (Prism2) {
				var strings = [
					/"(?:\\[\s\S]|\$\([^)]+\)|\$(?!\()|`[^`]+`|[^"\\`$])*"/.source,
					/'[^']*'/.source,
					/\$'(?:[^'\\]|\\[\s\S])*'/.source,
					/<<-?\s*(["']?)(\w+)\1\s[\s\S]*?[\r\n]\2/.source
				].join('|');
				Prism2.languages['shell-session'] = {
					command: {
						pattern: RegExp(
							/^/.source +
								'(?:' +
								(/[^\s@:$#%*!/\\]+@[^\r\n@:$#%*!/\\]+(?::[^\0-\x1F$#%*?"<>:;|]+)?/.source +
									'|' +
									/[/~.][^\0-\x1F$#%*?"<>@:;|]*/.source) +
								')?' +
								/[$#%](?=\s)/.source +
								/(?:[^\\\r\n \t'"<$]|[ \t](?:(?!#)|#.*$)|\\(?:[^\r]|\r\n?)|\$(?!')|<(?!<)|<<str>>)+/.source.replace(
									/<<str>>/g,
									function () {
										return strings;
									}
								),
							'm'
						),
						greedy: true,
						inside: {
							info: {
								pattern: /^[^#$%]+/,
								alias: 'punctuation',
								inside: {
									user: /^[^\s@:$#%*!/\\]+@[^\r\n@:$#%*!/\\]+/,
									punctuation: /:/,
									path: /[\s\S]+/
								}
							},
							bash: {
								pattern: /(^[$#%]\s*)\S[\s\S]*/,
								lookbehind: true,
								alias: 'language-bash',
								inside: Prism2.languages.bash
							},
							'shell-symbol': {
								pattern: /^[$#%]/,
								alias: 'important'
							}
						}
					},
					output: /.(?:.*(?:[\r\n]|.$))*/
				};
				Prism2.languages['sh-session'] = Prism2.languages['shellsession'] =
					Prism2.languages['shell-session'];
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/smali.js
var require_smali = __commonJS({
	'node_modules/refractor/lang/smali.js'(exports, module2) {
		'use strict';
		module2.exports = smali;
		smali.displayName = 'smali';
		smali.aliases = [];
		function smali(Prism) {
			Prism.languages.smali = {
				comment: /#.*/,
				string: {
					pattern: /"(?:[^\r\n\\"]|\\.)*"|'(?:[^\r\n\\']|\\(?:.|u[\da-fA-F]{4}))'/,
					greedy: true
				},
				'class-name': {
					pattern: /(^|[^L])L(?:(?:\w+|`[^`\r\n]*`)\/)*(?:[\w$]+|`[^`\r\n]*`)(?=\s*;)/,
					lookbehind: true,
					inside: {
						'class-name': {
							pattern: /(^L|\/)(?:[\w$]+|`[^`\r\n]*`)$/,
							lookbehind: true
						},
						namespace: {
							pattern: /^(L)(?:(?:\w+|`[^`\r\n]*`)\/)+/,
							lookbehind: true,
							inside: {
								punctuation: /\//
							}
						},
						builtin: /^L/
					}
				},
				builtin: [
					{
						pattern: /([();\[])[BCDFIJSVZ]+/,
						lookbehind: true
					},
					{
						pattern: /([\w$>]:)[BCDFIJSVZ]/,
						lookbehind: true
					}
				],
				keyword: [
					{
						pattern: /(\.end\s+)[\w-]+/,
						lookbehind: true
					},
					{
						pattern: /(^|[^\w.-])\.(?!\d)[\w-]+/,
						lookbehind: true
					},
					{
						pattern:
							/(^|[^\w.-])(?:abstract|annotation|bridge|constructor|enum|final|interface|private|protected|public|runtime|static|synthetic|system|transient)(?![\w.-])/,
						lookbehind: true
					}
				],
				function: {
					pattern: /(^|[^\w.-])(?:\w+|<[\w$-]+>)(?=\()/,
					lookbehind: true
				},
				field: {
					pattern: /[\w$]+(?=:)/,
					alias: 'variable'
				},
				register: {
					pattern: /(^|[^\w.-])[vp]\d(?![\w.-])/,
					lookbehind: true,
					alias: 'variable'
				},
				boolean: {
					pattern: /(^|[^\w.-])(?:false|true)(?![\w.-])/,
					lookbehind: true
				},
				number: {
					pattern:
						/(^|[^/\w.-])-?(?:NAN|INFINITY|0x(?:[\dA-F]+(?:\.[\dA-F]*)?|\.[\dA-F]+)(?:p[+-]?[\dA-F]+)?|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?)[dflst]?(?![\w.-])/i,
					lookbehind: true
				},
				label: {
					pattern: /(:)\w+/,
					lookbehind: true,
					alias: 'property'
				},
				operator: /->|\.\.|[\[=]/,
				punctuation: /[{}(),;:]/
			};
		}
	}
});

// node_modules/refractor/lang/smalltalk.js
var require_smalltalk = __commonJS({
	'node_modules/refractor/lang/smalltalk.js'(exports, module2) {
		'use strict';
		module2.exports = smalltalk;
		smalltalk.displayName = 'smalltalk';
		smalltalk.aliases = [];
		function smalltalk(Prism) {
			Prism.languages.smalltalk = {
				comment: {
					pattern: /"(?:""|[^"])*"/,
					greedy: true
				},
				char: {
					pattern: /\$./,
					greedy: true
				},
				string: {
					pattern: /'(?:''|[^'])*'/,
					greedy: true
				},
				symbol: /#[\da-z]+|#(?:-|([+\/\\*~<>=@%|&?!])\1?)|#(?=\()/i,
				'block-arguments': {
					pattern: /(\[\s*):[^\[|]*\|/,
					lookbehind: true,
					inside: {
						variable: /:[\da-z]+/i,
						punctuation: /\|/
					}
				},
				'temporary-variables': {
					pattern: /\|[^|]+\|/,
					inside: {
						variable: /[\da-z]+/i,
						punctuation: /\|/
					}
				},
				keyword: /\b(?:new|nil|self|super)\b/,
				boolean: /\b(?:false|true)\b/,
				number: [/\d+r-?[\dA-Z]+(?:\.[\dA-Z]+)?(?:e-?\d+)?/, /\b\d+(?:\.\d+)?(?:e-?\d+)?/],
				operator: /[<=]=?|:=|~[~=]|\/\/?|\\\\|>[>=]?|[!^+\-*&|,@]/,
				punctuation: /[.;:?\[\](){}]/
			};
		}
	}
});

// node_modules/refractor/lang/smarty.js
var require_smarty = __commonJS({
	'node_modules/refractor/lang/smarty.js'(exports, module2) {
		'use strict';
		var refractorMarkupTemplating = require_markup_templating();
		module2.exports = smarty;
		smarty.displayName = 'smarty';
		smarty.aliases = [];
		function smarty(Prism) {
			Prism.register(refractorMarkupTemplating);
			(function (Prism2) {
				Prism2.languages.smarty = {
					comment: {
						pattern: /^\{\*[\s\S]*?\*\}/,
						greedy: true
					},
					'embedded-php': {
						pattern: /^\{php\}[\s\S]*?\{\/php\}/,
						greedy: true,
						inside: {
							smarty: {
								pattern: /^\{php\}|\{\/php\}$/,
								inside: null
							},
							php: {
								pattern: /[\s\S]+/,
								alias: 'language-php',
								inside: Prism2.languages.php
							}
						}
					},
					string: [
						{
							pattern: /"(?:\\.|[^"\\\r\n])*"/,
							greedy: true,
							inside: {
								interpolation: {
									pattern: /\{[^{}]*\}|`[^`]*`/,
									inside: {
										'interpolation-punctuation': {
											pattern: /^[{`]|[`}]$/,
											alias: 'punctuation'
										},
										expression: {
											pattern: /[\s\S]+/,
											inside: null
										}
									}
								},
								variable: /\$\w+/
							}
						},
						{
							pattern: /'(?:\\.|[^'\\\r\n])*'/,
							greedy: true
						}
					],
					keyword: {
						pattern: /(^\{\/?)[a-z_]\w*\b(?!\()/i,
						lookbehind: true,
						greedy: true
					},
					delimiter: {
						pattern: /^\{\/?|\}$/,
						greedy: true,
						alias: 'punctuation'
					},
					number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
					variable: [
						/\$(?!\d)\w+/,
						/#(?!\d)\w+#/,
						{
							pattern: /(\.|->|\w\s*=)(?!\d)\w+\b(?!\()/,
							lookbehind: true
						},
						{
							pattern: /(\[)(?!\d)\w+(?=\])/,
							lookbehind: true
						}
					],
					function: {
						pattern: /(\|\s*)@?[a-z_]\w*|\b[a-z_]\w*(?=\()/i,
						lookbehind: true
					},
					'attr-name': /\b[a-z_]\w*(?=\s*=)/i,
					boolean: /\b(?:false|no|off|on|true|yes)\b/,
					punctuation: /[\[\](){}.,:`]|->/,
					operator: [
						/[+\-*\/%]|==?=?|[!<>]=?|&&|\|\|?/,
						/\bis\s+(?:not\s+)?(?:div|even|odd)(?:\s+by)?\b/,
						/\b(?:and|eq|gt?e|gt|lt?e|lt|mod|neq?|not|or)\b/
					]
				};
				Prism2.languages.smarty['embedded-php'].inside.smarty.inside = Prism2.languages.smarty;
				Prism2.languages.smarty.string[0].inside.interpolation.inside.expression.inside =
					Prism2.languages.smarty;
				var string3 = /"(?:\\.|[^"\\\r\n])*"|'(?:\\.|[^'\\\r\n])*'/;
				var smartyPattern = RegExp(
					/\{\*[\s\S]*?\*\}/.source +
						'|' +
						/\{php\}[\s\S]*?\{\/php\}/.source +
						'|' +
						/\{(?:[^{}"']|<str>|\{(?:[^{}"']|<str>|\{(?:[^{}"']|<str>)*\})*\})*\}/.source.replace(
							/<str>/g,
							function () {
								return string3.source;
							}
						),
					'g'
				);
				Prism2.hooks.add('before-tokenize', function (env) {
					var smartyLiteralStart = '{literal}';
					var smartyLiteralEnd = '{/literal}';
					var smartyLiteralMode = false;
					Prism2.languages['markup-templating'].buildPlaceholders(
						env,
						'smarty',
						smartyPattern,
						function (match) {
							if (match === smartyLiteralEnd) {
								smartyLiteralMode = false;
							}
							if (!smartyLiteralMode) {
								if (match === smartyLiteralStart) {
									smartyLiteralMode = true;
								}
								return true;
							}
							return false;
						}
					);
				});
				Prism2.hooks.add('after-tokenize', function (env) {
					Prism2.languages['markup-templating'].tokenizePlaceholders(env, 'smarty');
				});
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/sml.js
var require_sml = __commonJS({
	'node_modules/refractor/lang/sml.js'(exports, module2) {
		'use strict';
		module2.exports = sml;
		sml.displayName = 'sml';
		sml.aliases = ['smlnj'];
		function sml(Prism) {
			(function (Prism2) {
				var keywords =
					/\b(?:abstype|and|andalso|as|case|datatype|do|else|end|eqtype|exception|fn|fun|functor|handle|if|in|include|infix|infixr|let|local|nonfix|of|op|open|orelse|raise|rec|sharing|sig|signature|struct|structure|then|type|val|where|while|with|withtype)\b/i;
				Prism2.languages.sml = {
					comment: /\(\*(?:[^*(]|\*(?!\))|\((?!\*)|\(\*(?:[^*(]|\*(?!\))|\((?!\*))*\*\))*\*\)/,
					string: {
						pattern: /#?"(?:[^"\\]|\\.)*"/,
						greedy: true
					},
					'class-name': [
						{
							pattern: RegExp(
								/((?:^|[^:]):\s*)<TERMINAL>(?:\s*(?:(?:\*|->)\s*<TERMINAL>|,\s*<TERMINAL>(?:(?=<NOT-LAST>)|(?!<NOT-LAST>)\s+<LONG-ID>)))*/.source
									.replace(/<NOT-LAST>/g, function () {
										return /\s*(?:[*,]|->)/.source;
									})
									.replace(/<TERMINAL>/g, function () {
										return /(?:'[\w']*|<LONG-ID>|\((?:[^()]|\([^()]*\))*\)|\{(?:[^{}]|\{[^{}]*\})*\})(?:\s+<LONG-ID>)*/
											.source;
									})
									.replace(/<LONG-ID>/g, function () {
										return /(?!<KEYWORD>)[a-z\d_][\w'.]*/.source;
									})
									.replace(/<KEYWORD>/g, function () {
										return keywords.source;
									}),
								'i'
							),
							lookbehind: true,
							greedy: true,
							inside: null
						},
						{
							pattern:
								/((?:^|[^\w'])(?:datatype|exception|functor|signature|structure|type)\s+)[a-z_][\w'.]*/i,
							lookbehind: true
						}
					],
					function: {
						pattern: /((?:^|[^\w'])fun\s+)[a-z_][\w'.]*/i,
						lookbehind: true
					},
					keyword: keywords,
					variable: {
						pattern: /(^|[^\w'])'[\w']*/,
						lookbehind: true
					},
					number: /~?\b(?:\d+(?:\.\d+)?(?:e~?\d+)?|0x[\da-f]+)\b/i,
					word: {
						pattern: /\b0w(?:\d+|x[\da-f]+)\b/i,
						alias: 'constant'
					},
					boolean: /\b(?:false|true)\b/i,
					operator: /\.\.\.|:[>=:]|=>?|->|[<>]=?|[!+\-*/^#|@~]/,
					punctuation: /[(){}\[\].:,;]/
				};
				Prism2.languages.sml['class-name'][0].inside = Prism2.languages.sml;
				Prism2.languages.smlnj = Prism2.languages.sml;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/solidity.js
var require_solidity = __commonJS({
	'node_modules/refractor/lang/solidity.js'(exports, module2) {
		'use strict';
		module2.exports = solidity;
		solidity.displayName = 'solidity';
		solidity.aliases = ['sol'];
		function solidity(Prism) {
			Prism.languages.solidity = Prism.languages.extend('clike', {
				'class-name': {
					pattern: /(\b(?:contract|enum|interface|library|new|struct|using)\s+)(?!\d)[\w$]+/,
					lookbehind: true
				},
				keyword:
					/\b(?:_|anonymous|as|assembly|assert|break|calldata|case|constant|constructor|continue|contract|default|delete|do|else|emit|enum|event|external|for|from|function|if|import|indexed|inherited|interface|internal|is|let|library|mapping|memory|modifier|new|payable|pragma|private|public|pure|require|returns?|revert|selfdestruct|solidity|storage|struct|suicide|switch|this|throw|using|var|view|while)\b/,
				operator: /=>|->|:=|=:|\*\*|\+\+|--|\|\||&&|<<=?|>>=?|[-+*/%^&|<>!=]=?|[~?]/
			});
			Prism.languages.insertBefore('solidity', 'keyword', {
				builtin:
					/\b(?:address|bool|byte|u?int(?:8|16|24|32|40|48|56|64|72|80|88|96|104|112|120|128|136|144|152|160|168|176|184|192|200|208|216|224|232|240|248|256)?|string|bytes(?:[1-9]|[12]\d|3[0-2])?)\b/
			});
			Prism.languages.insertBefore('solidity', 'number', {
				version: {
					pattern: /([<>]=?|\^)\d+\.\d+\.\d+\b/,
					lookbehind: true,
					alias: 'number'
				}
			});
			Prism.languages.sol = Prism.languages.solidity;
		}
	}
});

// node_modules/refractor/lang/solution-file.js
var require_solution_file = __commonJS({
	'node_modules/refractor/lang/solution-file.js'(exports, module2) {
		'use strict';
		module2.exports = solutionFile;
		solutionFile.displayName = 'solutionFile';
		solutionFile.aliases = [];
		function solutionFile(Prism) {
			(function (Prism2) {
				var guid = {
					pattern: /\{[\da-f]{8}-[\da-f]{4}-[\da-f]{4}-[\da-f]{4}-[\da-f]{12}\}/i,
					alias: 'constant',
					inside: {
						punctuation: /[{}]/
					}
				};
				Prism2.languages['solution-file'] = {
					comment: {
						pattern: /#.*/,
						greedy: true
					},
					string: {
						pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
						greedy: true,
						inside: {
							guid
						}
					},
					object: {
						pattern:
							/^([ \t]*)(?:([A-Z]\w*)\b(?=.*(?:\r\n?|\n)(?:\1[ \t].*(?:\r\n?|\n))*\1End\2(?=[ \t]*$))|End[A-Z]\w*(?=[ \t]*$))/m,
						lookbehind: true,
						greedy: true,
						alias: 'keyword'
					},
					property: {
						pattern: /^([ \t]*)(?!\s)[^\r\n"#=()]*[^\s"#=()](?=\s*=)/m,
						lookbehind: true,
						inside: {
							guid
						}
					},
					guid,
					number: /\b\d+(?:\.\d+)*\b/,
					boolean: /\b(?:FALSE|TRUE)\b/,
					operator: /=/,
					punctuation: /[(),]/
				};
				Prism2.languages['sln'] = Prism2.languages['solution-file'];
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/soy.js
var require_soy = __commonJS({
	'node_modules/refractor/lang/soy.js'(exports, module2) {
		'use strict';
		var refractorMarkupTemplating = require_markup_templating();
		module2.exports = soy;
		soy.displayName = 'soy';
		soy.aliases = [];
		function soy(Prism) {
			Prism.register(refractorMarkupTemplating);
			(function (Prism2) {
				var stringPattern = /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/;
				var numberPattern = /\b\d+(?:\.\d+)?(?:[eE][+-]?\d+)?\b|\b0x[\dA-F]+\b/;
				Prism2.languages.soy = {
					comment: [
						/\/\*[\s\S]*?\*\//,
						{
							pattern: /(\s)\/\/.*/,
							lookbehind: true,
							greedy: true
						}
					],
					'command-arg': {
						pattern:
							/(\{+\/?\s*(?:alias|call|delcall|delpackage|deltemplate|namespace|template)\s+)\.?[\w.]+/,
						lookbehind: true,
						alias: 'string',
						inside: {
							punctuation: /\./
						}
					},
					parameter: {
						pattern: /(\{+\/?\s*@?param\??\s+)\.?[\w.]+/,
						lookbehind: true,
						alias: 'variable'
					},
					keyword: [
						{
							pattern:
								/(\{+\/?[^\S\r\n]*)(?:\\[nrt]|alias|call|case|css|default|delcall|delpackage|deltemplate|else(?:if)?|fallbackmsg|for(?:each)?|if(?:empty)?|lb|let|literal|msg|namespace|nil|@?param\??|rb|sp|switch|template|xid)/,
							lookbehind: true
						},
						/\b(?:any|as|attributes|bool|css|float|html|in|int|js|list|map|null|number|string|uri)\b/
					],
					delimiter: {
						pattern: /^\{+\/?|\/?\}+$/,
						alias: 'punctuation'
					},
					property: /\w+(?==)/,
					variable: {
						pattern: /\$[^\W\d]\w*(?:\??(?:\.\w+|\[[^\]]+\]))*/,
						inside: {
							string: {
								pattern: stringPattern,
								greedy: true
							},
							number: numberPattern,
							punctuation: /[\[\].?]/
						}
					},
					string: {
						pattern: stringPattern,
						greedy: true
					},
					function: [
						/\w+(?=\()/,
						{
							pattern: /(\|[^\S\r\n]*)\w+/,
							lookbehind: true
						}
					],
					boolean: /\b(?:false|true)\b/,
					number: numberPattern,
					operator: /\?:?|<=?|>=?|==?|!=|[+*/%-]|\b(?:and|not|or)\b/,
					punctuation: /[{}()\[\]|.,:]/
				};
				Prism2.hooks.add('before-tokenize', function (env) {
					var soyPattern = /\{\{.+?\}\}|\{.+?\}|\s\/\/.*|\/\*[\s\S]*?\*\//g;
					var soyLitteralStart = '{literal}';
					var soyLitteralEnd = '{/literal}';
					var soyLitteralMode = false;
					Prism2.languages['markup-templating'].buildPlaceholders(
						env,
						'soy',
						soyPattern,
						function (match) {
							if (match === soyLitteralEnd) {
								soyLitteralMode = false;
							}
							if (!soyLitteralMode) {
								if (match === soyLitteralStart) {
									soyLitteralMode = true;
								}
								return true;
							}
							return false;
						}
					);
				});
				Prism2.hooks.add('after-tokenize', function (env) {
					Prism2.languages['markup-templating'].tokenizePlaceholders(env, 'soy');
				});
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/turtle.js
var require_turtle = __commonJS({
	'node_modules/refractor/lang/turtle.js'(exports, module2) {
		'use strict';
		module2.exports = turtle;
		turtle.displayName = 'turtle';
		turtle.aliases = [];
		function turtle(Prism) {
			Prism.languages.turtle = {
				comment: {
					pattern: /#.*/,
					greedy: true
				},
				'multiline-string': {
					pattern: /"""(?:(?:""?)?(?:[^"\\]|\\.))*"""|'''(?:(?:''?)?(?:[^'\\]|\\.))*'''/,
					greedy: true,
					alias: 'string',
					inside: {
						comment: /#.*/
					}
				},
				string: {
					pattern: /"(?:[^\\"\r\n]|\\.)*"|'(?:[^\\'\r\n]|\\.)*'/,
					greedy: true
				},
				url: {
					pattern: /<(?:[^\x00-\x20<>"{}|^`\\]|\\(?:u[\da-fA-F]{4}|U[\da-fA-F]{8}))*>/,
					greedy: true,
					inside: {
						punctuation: /[<>]/
					}
				},
				function: {
					pattern:
						/(?:(?![-.\d\xB7])[-.\w\xB7\xC0-\uFFFD]+)?:(?:(?![-.])(?:[-.:\w\xC0-\uFFFD]|%[\da-f]{2}|\\.)+)?/i,
					inside: {
						'local-name': {
							pattern: /([^:]*:)[\s\S]+/,
							lookbehind: true
						},
						prefix: {
							pattern: /[\s\S]+/,
							inside: {
								punctuation: /:/
							}
						}
					}
				},
				number: /[+-]?\b\d+(?:\.\d*)?(?:e[+-]?\d+)?/i,
				punctuation: /[{}.,;()[\]]|\^\^/,
				boolean: /\b(?:false|true)\b/,
				keyword: [/(?:\ba|@prefix|@base)\b|=/, /\b(?:base|graph|prefix)\b/i],
				tag: {
					pattern: /@[a-z]+(?:-[a-z\d]+)*/i,
					inside: {
						punctuation: /@/
					}
				}
			};
			Prism.languages.trig = Prism.languages['turtle'];
		}
	}
});

// node_modules/refractor/lang/sparql.js
var require_sparql = __commonJS({
	'node_modules/refractor/lang/sparql.js'(exports, module2) {
		'use strict';
		var refractorTurtle = require_turtle();
		module2.exports = sparql;
		sparql.displayName = 'sparql';
		sparql.aliases = ['rq'];
		function sparql(Prism) {
			Prism.register(refractorTurtle);
			Prism.languages.sparql = Prism.languages.extend('turtle', {
				boolean: /\b(?:false|true)\b/i,
				variable: {
					pattern: /[?$]\w+/,
					greedy: true
				}
			});
			Prism.languages.insertBefore('sparql', 'punctuation', {
				keyword: [
					/\b(?:A|ADD|ALL|AS|ASC|ASK|BNODE|BY|CLEAR|CONSTRUCT|COPY|CREATE|DATA|DEFAULT|DELETE|DESC|DESCRIBE|DISTINCT|DROP|EXISTS|FILTER|FROM|GROUP|HAVING|INSERT|INTO|LIMIT|LOAD|MINUS|MOVE|NAMED|NOT|NOW|OFFSET|OPTIONAL|ORDER|RAND|REDUCED|SELECT|SEPARATOR|SERVICE|SILENT|STRUUID|UNION|USING|UUID|VALUES|WHERE)\b/i,
					/\b(?:ABS|AVG|BIND|BOUND|CEIL|COALESCE|CONCAT|CONTAINS|COUNT|DATATYPE|DAY|ENCODE_FOR_URI|FLOOR|GROUP_CONCAT|HOURS|IF|IRI|isBLANK|isIRI|isLITERAL|isNUMERIC|isURI|LANG|LANGMATCHES|LCASE|MAX|MD5|MIN|MINUTES|MONTH|REGEX|REPLACE|ROUND|sameTerm|SAMPLE|SECONDS|SHA1|SHA256|SHA384|SHA512|STR|STRAFTER|STRBEFORE|STRDT|STRENDS|STRLANG|STRLEN|STRSTARTS|SUBSTR|SUM|TIMEZONE|TZ|UCASE|URI|YEAR)\b(?=\s*\()/i,
					/\b(?:BASE|GRAPH|PREFIX)\b/i
				]
			});
			Prism.languages.rq = Prism.languages.sparql;
		}
	}
});

// node_modules/refractor/lang/splunk-spl.js
var require_splunk_spl = __commonJS({
	'node_modules/refractor/lang/splunk-spl.js'(exports, module2) {
		'use strict';
		module2.exports = splunkSpl;
		splunkSpl.displayName = 'splunkSpl';
		splunkSpl.aliases = [];
		function splunkSpl(Prism) {
			Prism.languages['splunk-spl'] = {
				comment: /`comment\("(?:\\.|[^\\"])*"\)`/,
				string: {
					pattern: /"(?:\\.|[^\\"])*"/,
					greedy: true
				},
				keyword:
					/\b(?:abstract|accum|addcoltotals|addinfo|addtotals|analyzefields|anomalies|anomalousvalue|anomalydetection|append|appendcols|appendcsv|appendlookup|appendpipe|arules|associate|audit|autoregress|bin|bucket|bucketdir|chart|cluster|cofilter|collect|concurrency|contingency|convert|correlate|datamodel|dbinspect|dedup|delete|delta|diff|erex|eval|eventcount|eventstats|extract|fieldformat|fields|fieldsummary|filldown|fillnull|findtypes|folderize|foreach|format|from|gauge|gentimes|geom|geomfilter|geostats|head|highlight|history|iconify|input|inputcsv|inputlookup|iplocation|join|kmeans|kv|kvform|loadjob|localize|localop|lookup|makecontinuous|makemv|makeresults|map|mcollect|metadata|metasearch|meventcollect|mstats|multikv|multisearch|mvcombine|mvexpand|nomv|outlier|outputcsv|outputlookup|outputtext|overlap|pivot|predict|rangemap|rare|regex|relevancy|reltime|rename|replace|rest|return|reverse|rex|rtorder|run|savedsearch|script|scrub|search|searchtxn|selfjoin|sendemail|set|setfields|sichart|sirare|sistats|sitimechart|sitop|sort|spath|stats|strcat|streamstats|table|tags|tail|timechart|timewrap|top|transaction|transpose|trendline|tscollect|tstats|typeahead|typelearner|typer|union|uniq|untable|where|x11|xmlkv|xmlunescape|xpath|xyseries)\b/i,
				'operator-word': {
					pattern: /\b(?:and|as|by|not|or|xor)\b/i,
					alias: 'operator'
				},
				function: /\b\w+(?=\s*\()/,
				property: /\b\w+(?=\s*=(?!=))/,
				date: {
					pattern: /\b\d{1,2}\/\d{1,2}\/\d{1,4}(?:(?::\d{1,2}){3})?\b/,
					alias: 'number'
				},
				number: /\b\d+(?:\.\d+)?\b/,
				boolean: /\b(?:f|false|t|true)\b/i,
				operator: /[<>=]=?|[-+*/%|]/,
				punctuation: /[()[\],]/
			};
		}
	}
});

// node_modules/refractor/lang/sqf.js
var require_sqf = __commonJS({
	'node_modules/refractor/lang/sqf.js'(exports, module2) {
		'use strict';
		module2.exports = sqf;
		sqf.displayName = 'sqf';
		sqf.aliases = [];
		function sqf(Prism) {
			Prism.languages.sqf = Prism.languages.extend('clike', {
				string: {
					pattern: /"(?:(?:"")?[^"])*"(?!")|'(?:[^'])*'/,
					greedy: true
				},
				keyword:
					/\b(?:breakOut|breakTo|call|case|catch|default|do|echo|else|execFSM|execVM|exitWith|for|forEach|forEachMember|forEachMemberAgent|forEachMemberTeam|from|goto|if|nil|preprocessFile|preprocessFileLineNumbers|private|scopeName|spawn|step|switch|then|throw|to|try|while|with)\b/i,
				boolean: /\b(?:false|true)\b/i,
				function:
					/\b(?:abs|accTime|acos|action|actionIDs|actionKeys|actionKeysImages|actionKeysNames|actionKeysNamesArray|actionName|actionParams|activateAddons|activatedAddons|activateKey|add3DENConnection|add3DENEventHandler|add3DENLayer|addAction|addBackpack|addBackpackCargo|addBackpackCargoGlobal|addBackpackGlobal|addCamShake|addCuratorAddons|addCuratorCameraArea|addCuratorEditableObjects|addCuratorEditingArea|addCuratorPoints|addEditorObject|addEventHandler|addForce|addForceGeneratorRTD|addGoggles|addGroupIcon|addHandgunItem|addHeadgear|addItem|addItemCargo|addItemCargoGlobal|addItemPool|addItemToBackpack|addItemToUniform|addItemToVest|addLiveStats|addMagazine|addMagazineAmmoCargo|addMagazineCargo|addMagazineCargoGlobal|addMagazineGlobal|addMagazinePool|addMagazines|addMagazineTurret|addMenu|addMenuItem|addMissionEventHandler|addMPEventHandler|addMusicEventHandler|addOwnedMine|addPlayerScores|addPrimaryWeaponItem|addPublicVariableEventHandler|addRating|addResources|addScore|addScoreSide|addSecondaryWeaponItem|addSwitchableUnit|addTeamMember|addToRemainsCollector|addTorque|addUniform|addVehicle|addVest|addWaypoint|addWeapon|addWeaponCargo|addWeaponCargoGlobal|addWeaponGlobal|addWeaponItem|addWeaponPool|addWeaponTurret|admin|agent|agents|AGLToASL|aimedAtTarget|aimPos|airDensityCurveRTD|airDensityRTD|airplaneThrottle|airportSide|AISFinishHeal|alive|all3DENEntities|allAirports|allControls|allCurators|allCutLayers|allDead|allDeadMen|allDisplays|allGroups|allMapMarkers|allMines|allMissionObjects|allow3DMode|allowCrewInImmobile|allowCuratorLogicIgnoreAreas|allowDamage|allowDammage|allowFileOperations|allowFleeing|allowGetIn|allowSprint|allPlayers|allSimpleObjects|allSites|allTurrets|allUnits|allUnitsUAV|allVariables|ammo|ammoOnPylon|animate|animateBay|animateDoor|animatePylon|animateSource|animationNames|animationPhase|animationSourcePhase|animationState|append|apply|armoryPoints|arrayIntersect|asin|ASLToAGL|ASLToATL|assert|assignAsCargo|assignAsCargoIndex|assignAsCommander|assignAsDriver|assignAsGunner|assignAsTurret|assignCurator|assignedCargo|assignedCommander|assignedDriver|assignedGunner|assignedItems|assignedTarget|assignedTeam|assignedVehicle|assignedVehicleRole|assignItem|assignTeam|assignToAirport|atan|atan2|atg|ATLToASL|attachedObject|attachedObjects|attachedTo|attachObject|attachTo|attackEnabled|backpack|backpackCargo|backpackContainer|backpackItems|backpackMagazines|backpackSpaceFor|behaviour|benchmark|binocular|blufor|boundingBox|boundingBoxReal|boundingCenter|briefingName|buildingExit|buildingPos|buldozer_EnableRoadDiag|buldozer_IsEnabledRoadDiag|buldozer_LoadNewRoads|buldozer_reloadOperMap|buttonAction|buttonSetAction|cadetMode|callExtension|camCommand|camCommit|camCommitPrepared|camCommitted|camConstuctionSetParams|camCreate|camDestroy|cameraEffect|cameraEffectEnableHUD|cameraInterest|cameraOn|cameraView|campaignConfigFile|camPreload|camPreloaded|camPrepareBank|camPrepareDir|camPrepareDive|camPrepareFocus|camPrepareFov|camPrepareFovRange|camPreparePos|camPrepareRelPos|camPrepareTarget|camSetBank|camSetDir|camSetDive|camSetFocus|camSetFov|camSetFovRange|camSetPos|camSetRelPos|camSetTarget|camTarget|camUseNVG|canAdd|canAddItemToBackpack|canAddItemToUniform|canAddItemToVest|cancelSimpleTaskDestination|canFire|canMove|canSlingLoad|canStand|canSuspend|canTriggerDynamicSimulation|canUnloadInCombat|canVehicleCargo|captive|captiveNum|cbChecked|cbSetChecked|ceil|channelEnabled|cheatsEnabled|checkAIFeature|checkVisibility|civilian|className|clear3DENAttribute|clear3DENInventory|clearAllItemsFromBackpack|clearBackpackCargo|clearBackpackCargoGlobal|clearForcesRTD|clearGroupIcons|clearItemCargo|clearItemCargoGlobal|clearItemPool|clearMagazineCargo|clearMagazineCargoGlobal|clearMagazinePool|clearOverlay|clearRadio|clearVehicleInit|clearWeaponCargo|clearWeaponCargoGlobal|clearWeaponPool|clientOwner|closeDialog|closeDisplay|closeOverlay|collapseObjectTree|collect3DENHistory|collectiveRTD|combatMode|commandArtilleryFire|commandChat|commander|commandFire|commandFollow|commandFSM|commandGetOut|commandingMenu|commandMove|commandRadio|commandStop|commandSuppressiveFire|commandTarget|commandWatch|comment|commitOverlay|compile|compileFinal|completedFSM|composeText|configClasses|configFile|configHierarchy|configName|configNull|configProperties|configSourceAddonList|configSourceMod|configSourceModList|confirmSensorTarget|connectTerminalToUAV|controlNull|controlsGroupCtrl|copyFromClipboard|copyToClipboard|copyWaypoints|cos|count|countEnemy|countFriendly|countSide|countType|countUnknown|create3DENComposition|create3DENEntity|createAgent|createCenter|createDialog|createDiaryLink|createDiaryRecord|createDiarySubject|createDisplay|createGearDialog|createGroup|createGuardedPoint|createLocation|createMarker|createMarkerLocal|createMenu|createMine|createMissionDisplay|createMPCampaignDisplay|createSimpleObject|createSimpleTask|createSite|createSoundSource|createTask|createTeam|createTrigger|createUnit|createVehicle|createVehicleCrew|createVehicleLocal|crew|ctAddHeader|ctAddRow|ctClear|ctCurSel|ctData|ctFindHeaderRows|ctFindRowHeader|ctHeaderControls|ctHeaderCount|ctRemoveHeaders|ctRemoveRows|ctrlActivate|ctrlAddEventHandler|ctrlAngle|ctrlAutoScrollDelay|ctrlAutoScrollRewind|ctrlAutoScrollSpeed|ctrlChecked|ctrlClassName|ctrlCommit|ctrlCommitted|ctrlCreate|ctrlDelete|ctrlEnable|ctrlEnabled|ctrlFade|ctrlHTMLLoaded|ctrlIDC|ctrlIDD|ctrlMapAnimAdd|ctrlMapAnimClear|ctrlMapAnimCommit|ctrlMapAnimDone|ctrlMapCursor|ctrlMapMouseOver|ctrlMapScale|ctrlMapScreenToWorld|ctrlMapWorldToScreen|ctrlModel|ctrlModelDirAndUp|ctrlModelScale|ctrlParent|ctrlParentControlsGroup|ctrlPosition|ctrlRemoveAllEventHandlers|ctrlRemoveEventHandler|ctrlScale|ctrlSetActiveColor|ctrlSetAngle|ctrlSetAutoScrollDelay|ctrlSetAutoScrollRewind|ctrlSetAutoScrollSpeed|ctrlSetBackgroundColor|ctrlSetChecked|ctrlSetDisabledColor|ctrlSetEventHandler|ctrlSetFade|ctrlSetFocus|ctrlSetFont|ctrlSetFontH1|ctrlSetFontH1B|ctrlSetFontH2|ctrlSetFontH2B|ctrlSetFontH3|ctrlSetFontH3B|ctrlSetFontH4|ctrlSetFontH4B|ctrlSetFontH5|ctrlSetFontH5B|ctrlSetFontH6|ctrlSetFontH6B|ctrlSetFontHeight|ctrlSetFontHeightH1|ctrlSetFontHeightH2|ctrlSetFontHeightH3|ctrlSetFontHeightH4|ctrlSetFontHeightH5|ctrlSetFontHeightH6|ctrlSetFontHeightSecondary|ctrlSetFontP|ctrlSetFontPB|ctrlSetFontSecondary|ctrlSetForegroundColor|ctrlSetModel|ctrlSetModelDirAndUp|ctrlSetModelScale|ctrlSetPixelPrecision|ctrlSetPosition|ctrlSetScale|ctrlSetStructuredText|ctrlSetText|ctrlSetTextColor|ctrlSetTextColorSecondary|ctrlSetTextSecondary|ctrlSetTooltip|ctrlSetTooltipColorBox|ctrlSetTooltipColorShade|ctrlSetTooltipColorText|ctrlShow|ctrlShown|ctrlText|ctrlTextHeight|ctrlTextSecondary|ctrlTextWidth|ctrlType|ctrlVisible|ctRowControls|ctRowCount|ctSetCurSel|ctSetData|ctSetHeaderTemplate|ctSetRowTemplate|ctSetValue|ctValue|curatorAddons|curatorCamera|curatorCameraArea|curatorCameraAreaCeiling|curatorCoef|curatorEditableObjects|curatorEditingArea|curatorEditingAreaType|curatorMouseOver|curatorPoints|curatorRegisteredObjects|curatorSelected|curatorWaypointCost|current3DENOperation|currentChannel|currentCommand|currentMagazine|currentMagazineDetail|currentMagazineDetailTurret|currentMagazineTurret|currentMuzzle|currentNamespace|currentTask|currentTasks|currentThrowable|currentVisionMode|currentWaypoint|currentWeapon|currentWeaponMode|currentWeaponTurret|currentZeroing|cursorObject|cursorTarget|customChat|customRadio|cutFadeOut|cutObj|cutRsc|cutText|damage|date|dateToNumber|daytime|deActivateKey|debriefingText|debugFSM|debugLog|deg|delete3DENEntities|deleteAt|deleteCenter|deleteCollection|deleteEditorObject|deleteGroup|deleteGroupWhenEmpty|deleteIdentity|deleteLocation|deleteMarker|deleteMarkerLocal|deleteRange|deleteResources|deleteSite|deleteStatus|deleteTeam|deleteVehicle|deleteVehicleCrew|deleteWaypoint|detach|detectedMines|diag_activeMissionFSMs|diag_activeScripts|diag_activeSQFScripts|diag_activeSQSScripts|diag_captureFrame|diag_captureFrameToFile|diag_captureSlowFrame|diag_codePerformance|diag_drawMode|diag_dynamicSimulationEnd|diag_enable|diag_enabled|diag_fps|diag_fpsMin|diag_frameNo|diag_lightNewLoad|diag_list|diag_log|diag_logSlowFrame|diag_mergeConfigFile|diag_recordTurretLimits|diag_setLightNew|diag_tickTime|diag_toggle|dialog|diarySubjectExists|didJIP|didJIPOwner|difficulty|difficultyEnabled|difficultyEnabledRTD|difficultyOption|direction|directSay|disableAI|disableCollisionWith|disableConversation|disableDebriefingStats|disableMapIndicators|disableNVGEquipment|disableRemoteSensors|disableSerialization|disableTIEquipment|disableUAVConnectability|disableUserInput|displayAddEventHandler|displayCtrl|displayNull|displayParent|displayRemoveAllEventHandlers|displayRemoveEventHandler|displaySetEventHandler|dissolveTeam|distance|distance2D|distanceSqr|distributionRegion|do3DENAction|doArtilleryFire|doFire|doFollow|doFSM|doGetOut|doMove|doorPhase|doStop|doSuppressiveFire|doTarget|doWatch|drawArrow|drawEllipse|drawIcon|drawIcon3D|drawLine|drawLine3D|drawLink|drawLocation|drawPolygon|drawRectangle|drawTriangle|driver|drop|dynamicSimulationDistance|dynamicSimulationDistanceCoef|dynamicSimulationEnabled|dynamicSimulationSystemEnabled|east|edit3DENMissionAttributes|editObject|editorSetEventHandler|effectiveCommander|emptyPositions|enableAI|enableAIFeature|enableAimPrecision|enableAttack|enableAudioFeature|enableAutoStartUpRTD|enableAutoTrimRTD|enableCamShake|enableCaustics|enableChannel|enableCollisionWith|enableCopilot|enableDebriefingStats|enableDiagLegend|enableDynamicSimulation|enableDynamicSimulationSystem|enableEndDialog|enableEngineArtillery|enableEnvironment|enableFatigue|enableGunLights|enableInfoPanelComponent|enableIRLasers|enableMimics|enablePersonTurret|enableRadio|enableReload|enableRopeAttach|enableSatNormalOnDetail|enableSaving|enableSentences|enableSimulation|enableSimulationGlobal|enableStamina|enableStressDamage|enableTeamSwitch|enableTraffic|enableUAVConnectability|enableUAVWaypoints|enableVehicleCargo|enableVehicleSensor|enableWeaponDisassembly|endl|endLoadingScreen|endMission|engineOn|enginesIsOnRTD|enginesPowerRTD|enginesRpmRTD|enginesTorqueRTD|entities|environmentEnabled|estimatedEndServerTime|estimatedTimeLeft|evalObjectArgument|everyBackpack|everyContainer|exec|execEditorScript|exp|expectedDestination|exportJIPMessages|eyeDirection|eyePos|face|faction|fadeMusic|fadeRadio|fadeSound|fadeSpeech|failMission|fillWeaponsFromPool|find|findCover|findDisplay|findEditorObject|findEmptyPosition|findEmptyPositionReady|findIf|findNearestEnemy|finishMissionInit|finite|fire|fireAtTarget|firstBackpack|flag|flagAnimationPhase|flagOwner|flagSide|flagTexture|fleeing|floor|flyInHeight|flyInHeightASL|fog|fogForecast|fogParams|forceAddUniform|forceAtPositionRTD|forcedMap|forceEnd|forceFlagTexture|forceFollowRoad|forceGeneratorRTD|forceMap|forceRespawn|forceSpeed|forceWalk|forceWeaponFire|forceWeatherChange|forgetTarget|format|formation|formationDirection|formationLeader|formationMembers|formationPosition|formationTask|formatText|formLeader|freeLook|fromEditor|fuel|fullCrew|gearIDCAmmoCount|gearSlotAmmoCount|gearSlotData|get3DENActionState|get3DENAttribute|get3DENCamera|get3DENConnections|get3DENEntity|get3DENEntityID|get3DENGrid|get3DENIconsVisible|get3DENLayerEntities|get3DENLinesVisible|get3DENMissionAttribute|get3DENMouseOver|get3DENSelected|getAimingCoef|getAllEnvSoundControllers|getAllHitPointsDamage|getAllOwnedMines|getAllSoundControllers|getAmmoCargo|getAnimAimPrecision|getAnimSpeedCoef|getArray|getArtilleryAmmo|getArtilleryComputerSettings|getArtilleryETA|getAssignedCuratorLogic|getAssignedCuratorUnit|getBackpackCargo|getBleedingRemaining|getBurningValue|getCameraViewDirection|getCargoIndex|getCenterOfMass|getClientState|getClientStateNumber|getCompatiblePylonMagazines|getConnectedUAV|getContainerMaxLoad|getCursorObjectParams|getCustomAimCoef|getDammage|getDescription|getDir|getDirVisual|getDLCAssetsUsage|getDLCAssetsUsageByName|getDLCs|getDLCUsageTime|getEditorCamera|getEditorMode|getEditorObjectScope|getElevationOffset|getEngineTargetRpmRTD|getEnvSoundController|getFatigue|getFieldManualStartPage|getForcedFlagTexture|getFriend|getFSMVariable|getFuelCargo|getGroupIcon|getGroupIconParams|getGroupIcons|getHideFrom|getHit|getHitIndex|getHitPointDamage|getItemCargo|getMagazineCargo|getMarkerColor|getMarkerPos|getMarkerSize|getMarkerType|getMass|getMissionConfig|getMissionConfigValue|getMissionDLCs|getMissionLayerEntities|getMissionLayers|getModelInfo|getMousePosition|getMusicPlayedTime|getNumber|getObjectArgument|getObjectChildren|getObjectDLC|getObjectMaterials|getObjectProxy|getObjectTextures|getObjectType|getObjectViewDistance|getOxygenRemaining|getPersonUsedDLCs|getPilotCameraDirection|getPilotCameraPosition|getPilotCameraRotation|getPilotCameraTarget|getPlateNumber|getPlayerChannel|getPlayerScores|getPlayerUID|getPlayerUIDOld|getPos|getPosASL|getPosASLVisual|getPosASLW|getPosATL|getPosATLVisual|getPosVisual|getPosWorld|getPylonMagazines|getRelDir|getRelPos|getRemoteSensorsDisabled|getRepairCargo|getResolution|getRotorBrakeRTD|getShadowDistance|getShotParents|getSlingLoad|getSoundController|getSoundControllerResult|getSpeed|getStamina|getStatValue|getSuppression|getTerrainGrid|getTerrainHeightASL|getText|getTotalDLCUsageTime|getTrimOffsetRTD|getUnitLoadout|getUnitTrait|getUserMFDText|getUserMFDValue|getVariable|getVehicleCargo|getWeaponCargo|getWeaponSway|getWingsOrientationRTD|getWingsPositionRTD|getWPPos|glanceAt|globalChat|globalRadio|goggles|group|groupChat|groupFromNetId|groupIconSelectable|groupIconsVisible|groupId|groupOwner|groupRadio|groupSelectedUnits|groupSelectUnit|grpNull|gunner|gusts|halt|handgunItems|handgunMagazine|handgunWeapon|handsHit|hasInterface|hasPilotCamera|hasWeapon|hcAllGroups|hcGroupParams|hcLeader|hcRemoveAllGroups|hcRemoveGroup|hcSelected|hcSelectGroup|hcSetGroup|hcShowBar|hcShownBar|headgear|hideBody|hideObject|hideObjectGlobal|hideSelection|hint|hintC|hintCadet|hintSilent|hmd|hostMission|htmlLoad|HUDMovementLevels|humidity|image|importAllGroups|importance|in|inArea|inAreaArray|incapacitatedState|independent|inflame|inflamed|infoPanel|infoPanelComponentEnabled|infoPanelComponents|infoPanels|inGameUISetEventHandler|inheritsFrom|initAmbientLife|inPolygon|inputAction|inRangeOfArtillery|insertEditorObject|intersect|is3DEN|is3DENMultiplayer|isAbleToBreathe|isAgent|isAimPrecisionEnabled|isArray|isAutoHoverOn|isAutonomous|isAutoStartUpEnabledRTD|isAutotest|isAutoTrimOnRTD|isBleeding|isBurning|isClass|isCollisionLightOn|isCopilotEnabled|isDamageAllowed|isDedicated|isDLCAvailable|isEngineOn|isEqualTo|isEqualType|isEqualTypeAll|isEqualTypeAny|isEqualTypeArray|isEqualTypeParams|isFilePatchingEnabled|isFlashlightOn|isFlatEmpty|isForcedWalk|isFormationLeader|isGroupDeletedWhenEmpty|isHidden|isInRemainsCollector|isInstructorFigureEnabled|isIRLaserOn|isKeyActive|isKindOf|isLaserOn|isLightOn|isLocalized|isManualFire|isMarkedForCollection|isMultiplayer|isMultiplayerSolo|isNil|isNull|isNumber|isObjectHidden|isObjectRTD|isOnRoad|isPipEnabled|isPlayer|isRealTime|isRemoteExecuted|isRemoteExecutedJIP|isServer|isShowing3DIcons|isSimpleObject|isSprintAllowed|isStaminaEnabled|isSteamMission|isStreamFriendlyUIEnabled|isStressDamageEnabled|isText|isTouchingGround|isTurnedOut|isTutHintsEnabled|isUAVConnectable|isUAVConnected|isUIContext|isUniformAllowed|isVehicleCargo|isVehicleRadarOn|isVehicleSensorEnabled|isWalking|isWeaponDeployed|isWeaponRested|itemCargo|items|itemsWithMagazines|join|joinAs|joinAsSilent|joinSilent|joinString|kbAddDatabase|kbAddDatabaseTargets|kbAddTopic|kbHasTopic|kbReact|kbRemoveTopic|kbTell|kbWasSaid|keyImage|keyName|knowsAbout|land|landAt|landResult|language|laserTarget|lbAdd|lbClear|lbColor|lbColorRight|lbCurSel|lbData|lbDelete|lbIsSelected|lbPicture|lbPictureRight|lbSelection|lbSetColor|lbSetColorRight|lbSetCurSel|lbSetData|lbSetPicture|lbSetPictureColor|lbSetPictureColorDisabled|lbSetPictureColorSelected|lbSetPictureRight|lbSetPictureRightColor|lbSetPictureRightColorDisabled|lbSetPictureRightColorSelected|lbSetSelectColor|lbSetSelectColorRight|lbSetSelected|lbSetText|lbSetTextRight|lbSetTooltip|lbSetValue|lbSize|lbSort|lbSortByValue|lbText|lbTextRight|lbValue|leader|leaderboardDeInit|leaderboardGetRows|leaderboardInit|leaderboardRequestRowsFriends|leaderboardRequestRowsGlobal|leaderboardRequestRowsGlobalAroundUser|leaderboardsRequestUploadScore|leaderboardsRequestUploadScoreKeepBest|leaderboardState|leaveVehicle|libraryCredits|libraryDisclaimers|lifeState|lightAttachObject|lightDetachObject|lightIsOn|lightnings|limitSpeed|linearConversion|lineBreak|lineIntersects|lineIntersectsObjs|lineIntersectsSurfaces|lineIntersectsWith|linkItem|list|listObjects|listRemoteTargets|listVehicleSensors|ln|lnbAddArray|lnbAddColumn|lnbAddRow|lnbClear|lnbColor|lnbColorRight|lnbCurSelRow|lnbData|lnbDeleteColumn|lnbDeleteRow|lnbGetColumnsPosition|lnbPicture|lnbPictureRight|lnbSetColor|lnbSetColorRight|lnbSetColumnsPos|lnbSetCurSelRow|lnbSetData|lnbSetPicture|lnbSetPictureColor|lnbSetPictureColorRight|lnbSetPictureColorSelected|lnbSetPictureColorSelectedRight|lnbSetPictureRight|lnbSetText|lnbSetTextRight|lnbSetValue|lnbSize|lnbSort|lnbSortByValue|lnbText|lnbTextRight|lnbValue|load|loadAbs|loadBackpack|loadFile|loadGame|loadIdentity|loadMagazine|loadOverlay|loadStatus|loadUniform|loadVest|local|localize|locationNull|locationPosition|lock|lockCameraTo|lockCargo|lockDriver|locked|lockedCargo|lockedDriver|lockedTurret|lockIdentity|lockTurret|lockWP|log|logEntities|logNetwork|logNetworkTerminate|lookAt|lookAtPos|magazineCargo|magazines|magazinesAllTurrets|magazinesAmmo|magazinesAmmoCargo|magazinesAmmoFull|magazinesDetail|magazinesDetailBackpack|magazinesDetailUniform|magazinesDetailVest|magazinesTurret|magazineTurretAmmo|mapAnimAdd|mapAnimClear|mapAnimCommit|mapAnimDone|mapCenterOnCamera|mapGridPosition|markAsFinishedOnSteam|markerAlpha|markerBrush|markerColor|markerDir|markerPos|markerShape|markerSize|markerText|markerType|max|members|menuAction|menuAdd|menuChecked|menuClear|menuCollapse|menuData|menuDelete|menuEnable|menuEnabled|menuExpand|menuHover|menuPicture|menuSetAction|menuSetCheck|menuSetData|menuSetPicture|menuSetValue|menuShortcut|menuShortcutText|menuSize|menuSort|menuText|menuURL|menuValue|min|mineActive|mineDetectedBy|missionConfigFile|missionDifficulty|missionName|missionNamespace|missionStart|missionVersion|modelToWorld|modelToWorldVisual|modelToWorldVisualWorld|modelToWorldWorld|modParams|moonIntensity|moonPhase|morale|move|move3DENCamera|moveInAny|moveInCargo|moveInCommander|moveInDriver|moveInGunner|moveInTurret|moveObjectToEnd|moveOut|moveTime|moveTo|moveToCompleted|moveToFailed|musicVolume|name|nameSound|nearEntities|nearestBuilding|nearestLocation|nearestLocations|nearestLocationWithDubbing|nearestObject|nearestObjects|nearestTerrainObjects|nearObjects|nearObjectsReady|nearRoads|nearSupplies|nearTargets|needReload|netId|netObjNull|newOverlay|nextMenuItemIndex|nextWeatherChange|nMenuItems|numberOfEnginesRTD|numberToDate|objectCurators|objectFromNetId|objectParent|objNull|objStatus|onBriefingGear|onBriefingGroup|onBriefingNotes|onBriefingPlan|onBriefingTeamSwitch|onCommandModeChanged|onDoubleClick|onEachFrame|onGroupIconClick|onGroupIconOverEnter|onGroupIconOverLeave|onHCGroupSelectionChanged|onMapSingleClick|onPlayerConnected|onPlayerDisconnected|onPreloadFinished|onPreloadStarted|onShowNewObject|onTeamSwitch|openCuratorInterface|openDLCPage|openDSInterface|openMap|openSteamApp|openYoutubeVideo|opfor|orderGetIn|overcast|overcastForecast|owner|param|params|parseNumber|parseSimpleArray|parseText|parsingNamespace|particlesQuality|pi|pickWeaponPool|pitch|pixelGrid|pixelGridBase|pixelGridNoUIScale|pixelH|pixelW|playableSlotsNumber|playableUnits|playAction|playActionNow|player|playerRespawnTime|playerSide|playersNumber|playGesture|playMission|playMove|playMoveNow|playMusic|playScriptedMission|playSound|playSound3D|position|positionCameraToWorld|posScreenToWorld|posWorldToScreen|ppEffectAdjust|ppEffectCommit|ppEffectCommitted|ppEffectCreate|ppEffectDestroy|ppEffectEnable|ppEffectEnabled|ppEffectForceInNVG|precision|preloadCamera|preloadObject|preloadSound|preloadTitleObj|preloadTitleRsc|primaryWeapon|primaryWeaponItems|primaryWeaponMagazine|priority|processDiaryLink|processInitCommands|productVersion|profileName|profileNamespace|profileNameSteam|progressLoadingScreen|progressPosition|progressSetPosition|publicVariable|publicVariableClient|publicVariableServer|pushBack|pushBackUnique|putWeaponPool|queryItemsPool|queryMagazinePool|queryWeaponPool|rad|radioChannelAdd|radioChannelCreate|radioChannelRemove|radioChannelSetCallSign|radioChannelSetLabel|radioVolume|rain|rainbow|random|rank|rankId|rating|rectangular|registeredTasks|registerTask|reload|reloadEnabled|remoteControl|remoteExec|remoteExecCall|remoteExecutedOwner|remove3DENConnection|remove3DENEventHandler|remove3DENLayer|removeAction|removeAll3DENEventHandlers|removeAllActions|removeAllAssignedItems|removeAllContainers|removeAllCuratorAddons|removeAllCuratorCameraAreas|removeAllCuratorEditingAreas|removeAllEventHandlers|removeAllHandgunItems|removeAllItems|removeAllItemsWithMagazines|removeAllMissionEventHandlers|removeAllMPEventHandlers|removeAllMusicEventHandlers|removeAllOwnedMines|removeAllPrimaryWeaponItems|removeAllWeapons|removeBackpack|removeBackpackGlobal|removeCuratorAddons|removeCuratorCameraArea|removeCuratorEditableObjects|removeCuratorEditingArea|removeDrawIcon|removeDrawLinks|removeEventHandler|removeFromRemainsCollector|removeGoggles|removeGroupIcon|removeHandgunItem|removeHeadgear|removeItem|removeItemFromBackpack|removeItemFromUniform|removeItemFromVest|removeItems|removeMagazine|removeMagazineGlobal|removeMagazines|removeMagazinesTurret|removeMagazineTurret|removeMenuItem|removeMissionEventHandler|removeMPEventHandler|removeMusicEventHandler|removeOwnedMine|removePrimaryWeaponItem|removeSecondaryWeaponItem|removeSimpleTask|removeSwitchableUnit|removeTeamMember|removeUniform|removeVest|removeWeapon|removeWeaponAttachmentCargo|removeWeaponCargo|removeWeaponGlobal|removeWeaponTurret|reportRemoteTarget|requiredVersion|resetCamShake|resetSubgroupDirection|resistance|resize|resources|respawnVehicle|restartEditorCamera|reveal|revealMine|reverse|reversedMouseY|roadAt|roadsConnectedTo|roleDescription|ropeAttachedObjects|ropeAttachedTo|ropeAttachEnabled|ropeAttachTo|ropeCreate|ropeCut|ropeDestroy|ropeDetach|ropeEndPosition|ropeLength|ropes|ropeUnwind|ropeUnwound|rotorsForcesRTD|rotorsRpmRTD|round|runInitScript|safeZoneH|safeZoneW|safeZoneWAbs|safeZoneX|safeZoneXAbs|safeZoneY|save3DENInventory|saveGame|saveIdentity|saveJoysticks|saveOverlay|saveProfileNamespace|saveStatus|saveVar|savingEnabled|say|say2D|say3D|score|scoreSide|screenshot|screenToWorld|scriptDone|scriptName|scriptNull|scudState|secondaryWeapon|secondaryWeaponItems|secondaryWeaponMagazine|select|selectBestPlaces|selectDiarySubject|selectedEditorObjects|selectEditorObject|selectionNames|selectionPosition|selectLeader|selectMax|selectMin|selectNoPlayer|selectPlayer|selectRandom|selectRandomWeighted|selectWeapon|selectWeaponTurret|sendAUMessage|sendSimpleCommand|sendTask|sendTaskResult|sendUDPMessage|serverCommand|serverCommandAvailable|serverCommandExecutable|serverName|serverTime|set|set3DENAttribute|set3DENAttributes|set3DENGrid|set3DENIconsVisible|set3DENLayer|set3DENLinesVisible|set3DENLogicType|set3DENMissionAttribute|set3DENMissionAttributes|set3DENModelsVisible|set3DENObjectType|set3DENSelected|setAccTime|setActualCollectiveRTD|setAirplaneThrottle|setAirportSide|setAmmo|setAmmoCargo|setAmmoOnPylon|setAnimSpeedCoef|setAperture|setApertureNew|setArmoryPoints|setAttributes|setAutonomous|setBehaviour|setBleedingRemaining|setBrakesRTD|setCameraInterest|setCamShakeDefParams|setCamShakeParams|setCamUseTI|setCaptive|setCenterOfMass|setCollisionLight|setCombatMode|setCompassOscillation|setConvoySeparation|setCuratorCameraAreaCeiling|setCuratorCoef|setCuratorEditingAreaType|setCuratorWaypointCost|setCurrentChannel|setCurrentTask|setCurrentWaypoint|setCustomAimCoef|setCustomWeightRTD|setDamage|setDammage|setDate|setDebriefingText|setDefaultCamera|setDestination|setDetailMapBlendPars|setDir|setDirection|setDrawIcon|setDriveOnPath|setDropInterval|setDynamicSimulationDistance|setDynamicSimulationDistanceCoef|setEditorMode|setEditorObjectScope|setEffectCondition|setEngineRpmRTD|setFace|setFaceAnimation|setFatigue|setFeatureType|setFlagAnimationPhase|setFlagOwner|setFlagSide|setFlagTexture|setFog|setForceGeneratorRTD|setFormation|setFormationTask|setFormDir|setFriend|setFromEditor|setFSMVariable|setFuel|setFuelCargo|setGroupIcon|setGroupIconParams|setGroupIconsSelectable|setGroupIconsVisible|setGroupId|setGroupIdGlobal|setGroupOwner|setGusts|setHideBehind|setHit|setHitIndex|setHitPointDamage|setHorizonParallaxCoef|setHUDMovementLevels|setIdentity|setImportance|setInfoPanel|setLeader|setLightAmbient|setLightAttenuation|setLightBrightness|setLightColor|setLightDayLight|setLightFlareMaxDistance|setLightFlareSize|setLightIntensity|setLightnings|setLightUseFlare|setLocalWindParams|setMagazineTurretAmmo|setMarkerAlpha|setMarkerAlphaLocal|setMarkerBrush|setMarkerBrushLocal|setMarkerColor|setMarkerColorLocal|setMarkerDir|setMarkerDirLocal|setMarkerPos|setMarkerPosLocal|setMarkerShape|setMarkerShapeLocal|setMarkerSize|setMarkerSizeLocal|setMarkerText|setMarkerTextLocal|setMarkerType|setMarkerTypeLocal|setMass|setMimic|setMousePosition|setMusicEffect|setMusicEventHandler|setName|setNameSound|setObjectArguments|setObjectMaterial|setObjectMaterialGlobal|setObjectProxy|setObjectTexture|setObjectTextureGlobal|setObjectViewDistance|setOvercast|setOwner|setOxygenRemaining|setParticleCircle|setParticleClass|setParticleFire|setParticleParams|setParticleRandom|setPilotCameraDirection|setPilotCameraRotation|setPilotCameraTarget|setPilotLight|setPiPEffect|setPitch|setPlateNumber|setPlayable|setPlayerRespawnTime|setPos|setPosASL|setPosASL2|setPosASLW|setPosATL|setPosition|setPosWorld|setPylonLoadOut|setPylonsPriority|setRadioMsg|setRain|setRainbow|setRandomLip|setRank|setRectangular|setRepairCargo|setRotorBrakeRTD|setShadowDistance|setShotParents|setSide|setSimpleTaskAlwaysVisible|setSimpleTaskCustomData|setSimpleTaskDescription|setSimpleTaskDestination|setSimpleTaskTarget|setSimpleTaskType|setSimulWeatherLayers|setSize|setSkill|setSlingLoad|setSoundEffect|setSpeaker|setSpeech|setSpeedMode|setStamina|setStaminaScheme|setStatValue|setSuppression|setSystemOfUnits|setTargetAge|setTaskMarkerOffset|setTaskResult|setTaskState|setTerrainGrid|setText|setTimeMultiplier|setTitleEffect|setToneMapping|setToneMappingParams|setTrafficDensity|setTrafficDistance|setTrafficGap|setTrafficSpeed|setTriggerActivation|setTriggerArea|setTriggerStatements|setTriggerText|setTriggerTimeout|setTriggerType|setType|setUnconscious|setUnitAbility|setUnitLoadout|setUnitPos|setUnitPosWeak|setUnitRank|setUnitRecoilCoefficient|setUnitTrait|setUnloadInCombat|setUserActionText|setUserMFDText|setUserMFDValue|setVariable|setVectorDir|setVectorDirAndUp|setVectorUp|setVehicleAmmo|setVehicleAmmoDef|setVehicleArmor|setVehicleCargo|setVehicleId|setVehicleInit|setVehicleLock|setVehiclePosition|setVehicleRadar|setVehicleReceiveRemoteTargets|setVehicleReportOwnPosition|setVehicleReportRemoteTargets|setVehicleTIPars|setVehicleVarName|setVelocity|setVelocityModelSpace|setVelocityTransformation|setViewDistance|setVisibleIfTreeCollapsed|setWantedRpmRTD|setWaves|setWaypointBehaviour|setWaypointCombatMode|setWaypointCompletionRadius|setWaypointDescription|setWaypointForceBehaviour|setWaypointFormation|setWaypointHousePosition|setWaypointLoiterRadius|setWaypointLoiterType|setWaypointName|setWaypointPosition|setWaypointScript|setWaypointSpeed|setWaypointStatements|setWaypointTimeout|setWaypointType|setWaypointVisible|setWeaponReloadingTime|setWind|setWindDir|setWindForce|setWindStr|setWingForceScaleRTD|setWPPos|show3DIcons|showChat|showCinemaBorder|showCommandingMenu|showCompass|showCuratorCompass|showGPS|showHUD|showLegend|showMap|shownArtilleryComputer|shownChat|shownCompass|shownCuratorCompass|showNewEditorObject|shownGPS|shownHUD|shownMap|shownPad|shownRadio|shownScoretable|shownUAVFeed|shownWarrant|shownWatch|showPad|showRadio|showScoretable|showSubtitles|showUAVFeed|showWarrant|showWatch|showWaypoint|showWaypoints|side|sideAmbientLife|sideChat|sideEmpty|sideEnemy|sideFriendly|sideLogic|sideRadio|sideUnknown|simpleTasks|simulationEnabled|simulCloudDensity|simulCloudOcclusion|simulInClouds|simulWeatherSync|sin|size|sizeOf|skill|skillFinal|skipTime|sleep|sliderPosition|sliderRange|sliderSetPosition|sliderSetRange|sliderSetSpeed|sliderSpeed|slingLoadAssistantShown|soldierMagazines|someAmmo|sort|soundVolume|speaker|speed|speedMode|splitString|sqrt|squadParams|stance|startLoadingScreen|stop|stopEngineRTD|stopped|str|sunOrMoon|supportInfo|suppressFor|surfaceIsWater|surfaceNormal|surfaceType|swimInDepth|switchableUnits|switchAction|switchCamera|switchGesture|switchLight|switchMove|synchronizedObjects|synchronizedTriggers|synchronizedWaypoints|synchronizeObjectsAdd|synchronizeObjectsRemove|synchronizeTrigger|synchronizeWaypoint|systemChat|systemOfUnits|tan|targetKnowledge|targets|targetsAggregate|targetsQuery|taskAlwaysVisible|taskChildren|taskCompleted|taskCustomData|taskDescription|taskDestination|taskHint|taskMarkerOffset|taskNull|taskParent|taskResult|taskState|taskType|teamMember|teamMemberNull|teamName|teams|teamSwitch|teamSwitchEnabled|teamType|terminate|terrainIntersect|terrainIntersectASL|terrainIntersectAtASL|text|textLog|textLogFormat|tg|time|timeMultiplier|titleCut|titleFadeOut|titleObj|titleRsc|titleText|toArray|toFixed|toLower|toString|toUpper|triggerActivated|triggerActivation|triggerArea|triggerAttachedVehicle|triggerAttachObject|triggerAttachVehicle|triggerDynamicSimulation|triggerStatements|triggerText|triggerTimeout|triggerTimeoutCurrent|triggerType|turretLocal|turretOwner|turretUnit|tvAdd|tvClear|tvCollapse|tvCollapseAll|tvCount|tvCurSel|tvData|tvDelete|tvExpand|tvExpandAll|tvPicture|tvPictureRight|tvSetColor|tvSetCurSel|tvSetData|tvSetPicture|tvSetPictureColor|tvSetPictureColorDisabled|tvSetPictureColorSelected|tvSetPictureRight|tvSetPictureRightColor|tvSetPictureRightColorDisabled|tvSetPictureRightColorSelected|tvSetSelectColor|tvSetText|tvSetTooltip|tvSetValue|tvSort|tvSortByValue|tvText|tvTooltip|tvValue|type|typeName|typeOf|UAVControl|uiNamespace|uiSleep|unassignCurator|unassignItem|unassignTeam|unassignVehicle|underwater|uniform|uniformContainer|uniformItems|uniformMagazines|unitAddons|unitAimPosition|unitAimPositionVisual|unitBackpack|unitIsUAV|unitPos|unitReady|unitRecoilCoefficient|units|unitsBelowHeight|unlinkItem|unlockAchievement|unregisterTask|updateDrawIcon|updateMenuItem|updateObjectTree|useAIOperMapObstructionTest|useAISteeringComponent|useAudioTimeForMoves|userInputDisabled|vectorAdd|vectorCos|vectorCrossProduct|vectorDiff|vectorDir|vectorDirVisual|vectorDistance|vectorDistanceSqr|vectorDotProduct|vectorFromTo|vectorMagnitude|vectorMagnitudeSqr|vectorModelToWorld|vectorModelToWorldVisual|vectorMultiply|vectorNormalized|vectorUp|vectorUpVisual|vectorWorldToModel|vectorWorldToModelVisual|vehicle|vehicleCargoEnabled|vehicleChat|vehicleRadio|vehicleReceiveRemoteTargets|vehicleReportOwnPosition|vehicleReportRemoteTargets|vehicles|vehicleVarName|velocity|velocityModelSpace|verifySignature|vest|vestContainer|vestItems|vestMagazines|viewDistance|visibleCompass|visibleGPS|visibleMap|visiblePosition|visiblePositionASL|visibleScoretable|visibleWatch|waitUntil|waves|waypointAttachedObject|waypointAttachedVehicle|waypointAttachObject|waypointAttachVehicle|waypointBehaviour|waypointCombatMode|waypointCompletionRadius|waypointDescription|waypointForceBehaviour|waypointFormation|waypointHousePosition|waypointLoiterRadius|waypointLoiterType|waypointName|waypointPosition|waypoints|waypointScript|waypointsEnabledUAV|waypointShow|waypointSpeed|waypointStatements|waypointTimeout|waypointTimeoutCurrent|waypointType|waypointVisible|weaponAccessories|weaponAccessoriesCargo|weaponCargo|weaponDirection|weaponInertia|weaponLowered|weapons|weaponsItems|weaponsItemsCargo|weaponState|weaponsTurret|weightRTD|west|WFSideText|wind|windDir|windRTD|windStr|wingsForcesRTD|worldName|worldSize|worldToModel|worldToModelVisual|worldToScreen)\b/i,
				number: /(?:\$|\b0x)[\da-f]+\b|(?:\B\.\d+|\b\d+(?:\.\d+)?)(?:e[+-]?\d+)?\b/i,
				operator: /##|>>|&&|\|\||[!=<>]=?|[-+*/%#^]|\b(?:and|mod|not|or)\b/i,
				'magic-variable': {
					pattern:
						/\b(?:this|thisList|thisTrigger|_exception|_fnc_scriptName|_fnc_scriptNameParent|_forEachIndex|_this|_thisEventHandler|_thisFSM|_thisScript|_x)\b/i,
					alias: 'keyword'
				},
				constant: /\bDIK(?:_[a-z\d]+)+\b/i
			});
			Prism.languages.insertBefore('sqf', 'string', {
				macro: {
					pattern: /(^[ \t]*)#[a-z](?:[^\r\n\\]|\\(?:\r\n|[\s\S]))*/im,
					lookbehind: true,
					greedy: true,
					alias: 'property',
					inside: {
						directive: {
							pattern: /#[a-z]+\b/i,
							alias: 'keyword'
						},
						comment: Prism.languages.sqf.comment
					}
				}
			});
			delete Prism.languages.sqf['class-name'];
		}
	}
});

// node_modules/refractor/lang/squirrel.js
var require_squirrel = __commonJS({
	'node_modules/refractor/lang/squirrel.js'(exports, module2) {
		'use strict';
		module2.exports = squirrel;
		squirrel.displayName = 'squirrel';
		squirrel.aliases = [];
		function squirrel(Prism) {
			Prism.languages.squirrel = Prism.languages.extend('clike', {
				comment: [
					Prism.languages.clike['comment'][0],
					{
						pattern: /(^|[^\\:])(?:\/\/|#).*/,
						lookbehind: true,
						greedy: true
					}
				],
				string: {
					pattern: /(^|[^\\"'@])(?:@"(?:[^"]|"")*"(?!")|"(?:[^\\\r\n"]|\\.)*")/,
					lookbehind: true,
					greedy: true
				},
				'class-name': {
					pattern: /(\b(?:class|enum|extends|instanceof)\s+)\w+(?:\.\w+)*/,
					lookbehind: true,
					inside: {
						punctuation: /\./
					}
				},
				keyword:
					/\b(?:__FILE__|__LINE__|base|break|case|catch|class|clone|const|constructor|continue|default|delete|else|enum|extends|for|foreach|function|if|in|instanceof|local|null|resume|return|static|switch|this|throw|try|typeof|while|yield)\b/,
				number: /\b(?:0x[0-9a-fA-F]+|\d+(?:\.(?:\d+|[eE][+-]?\d+))?)\b/,
				operator: /\+\+|--|<=>|<[-<]|>>>?|&&?|\|\|?|[-+*/%!=<>]=?|[~^]|::?/,
				punctuation: /[(){}\[\],;.]/
			});
			Prism.languages.insertBefore('squirrel', 'string', {
				char: {
					pattern: /(^|[^\\"'])'(?:[^\\']|\\(?:[xuU][0-9a-fA-F]{0,8}|[\s\S]))'/,
					lookbehind: true,
					greedy: true
				}
			});
			Prism.languages.insertBefore('squirrel', 'operator', {
				'attribute-punctuation': {
					pattern: /<\/|\/>/,
					alias: 'important'
				},
				lambda: {
					pattern: /@(?=\()/,
					alias: 'operator'
				}
			});
		}
	}
});

// node_modules/refractor/lang/stan.js
var require_stan = __commonJS({
	'node_modules/refractor/lang/stan.js'(exports, module2) {
		'use strict';
		module2.exports = stan;
		stan.displayName = 'stan';
		stan.aliases = [];
		function stan(Prism) {
			(function (Prism2) {
				var higherOrderFunctions =
					/\b(?:algebra_solver|algebra_solver_newton|integrate_1d|integrate_ode|integrate_ode_bdf|integrate_ode_rk45|map_rect|ode_(?:adams|bdf|ckrk|rk45)(?:_tol)?|ode_adjoint_tol_ctl|reduce_sum|reduce_sum_static)\b/;
				Prism2.languages.stan = {
					comment: /\/\/.*|\/\*[\s\S]*?\*\/|#(?!include).*/,
					string: {
						pattern: /"[\x20\x21\x23-\x5B\x5D-\x7E]*"/,
						greedy: true
					},
					directive: {
						pattern: /^([ \t]*)#include\b.*/m,
						lookbehind: true,
						alias: 'property'
					},
					'function-arg': {
						pattern: RegExp(
							'(' + higherOrderFunctions.source + /\s*\(\s*/.source + ')' + /[a-zA-Z]\w*/.source
						),
						lookbehind: true,
						alias: 'function'
					},
					constraint: {
						pattern: /(\b(?:int|matrix|real|row_vector|vector)\s*)<[^<>]*>/,
						lookbehind: true,
						inside: {
							expression: {
								pattern: /(=\s*)\S(?:\S|\s+(?!\s))*?(?=\s*(?:>$|,\s*\w+\s*=))/,
								lookbehind: true,
								inside: null
							},
							property: /\b[a-z]\w*(?=\s*=)/i,
							operator: /=/,
							punctuation: /^<|>$|,/
						}
					},
					keyword: [
						{
							pattern:
								/\bdata(?=\s*\{)|\b(?:functions|generated|model|parameters|quantities|transformed)\b/,
							alias: 'program-block'
						},
						/\b(?:array|break|cholesky_factor_corr|cholesky_factor_cov|complex|continue|corr_matrix|cov_matrix|data|else|for|if|in|increment_log_prob|int|matrix|ordered|positive_ordered|print|real|reject|return|row_vector|simplex|target|unit_vector|vector|void|while)\b/,
						higherOrderFunctions
					],
					function: /\b[a-z]\w*(?=\s*\()/i,
					number:
						/(?:\b\d+(?:_\d+)*(?:\.(?:\d+(?:_\d+)*)?)?|\B\.\d+(?:_\d+)*)(?:E[+-]?\d+(?:_\d+)*)?i?(?!\w)/i,
					boolean: /\b(?:false|true)\b/,
					operator: /<-|\.[*/]=?|\|\|?|&&|[!=<>+\-*/]=?|['^%~?:]/,
					punctuation: /[()\[\]{},;]/
				};
				Prism2.languages.stan.constraint.inside.expression.inside = Prism2.languages.stan;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/stylus.js
var require_stylus = __commonJS({
	'node_modules/refractor/lang/stylus.js'(exports, module2) {
		'use strict';
		module2.exports = stylus;
		stylus.displayName = 'stylus';
		stylus.aliases = [];
		function stylus(Prism) {
			(function (Prism2) {
				var unit = {
					pattern: /(\b\d+)(?:%|[a-z]+)/,
					lookbehind: true
				};
				var number3 = {
					pattern: /(^|[^\w.-])-?(?:\d+(?:\.\d+)?|\.\d+)/,
					lookbehind: true
				};
				var inside = {
					comment: {
						pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
						lookbehind: true
					},
					url: {
						pattern: /\burl\((["']?).*?\1\)/i,
						greedy: true
					},
					string: {
						pattern: /("|')(?:(?!\1)[^\\\r\n]|\\(?:\r\n|[\s\S]))*\1/,
						greedy: true
					},
					interpolation: null,
					func: null,
					important: /\B!(?:important|optional)\b/i,
					keyword: {
						pattern: /(^|\s+)(?:(?:else|for|if|return|unless)(?=\s|$)|@[\w-]+)/,
						lookbehind: true
					},
					hexcode: /#[\da-f]{3,6}/i,
					color: [
						/\b(?:AliceBlue|AntiqueWhite|Aqua|Aquamarine|Azure|Beige|Bisque|Black|BlanchedAlmond|Blue|BlueViolet|Brown|BurlyWood|CadetBlue|Chartreuse|Chocolate|Coral|CornflowerBlue|Cornsilk|Crimson|Cyan|DarkBlue|DarkCyan|DarkGoldenRod|DarkGr[ae]y|DarkGreen|DarkKhaki|DarkMagenta|DarkOliveGreen|DarkOrange|DarkOrchid|DarkRed|DarkSalmon|DarkSeaGreen|DarkSlateBlue|DarkSlateGr[ae]y|DarkTurquoise|DarkViolet|DeepPink|DeepSkyBlue|DimGr[ae]y|DodgerBlue|FireBrick|FloralWhite|ForestGreen|Fuchsia|Gainsboro|GhostWhite|Gold|GoldenRod|Gr[ae]y|Green|GreenYellow|HoneyDew|HotPink|IndianRed|Indigo|Ivory|Khaki|Lavender|LavenderBlush|LawnGreen|LemonChiffon|LightBlue|LightCoral|LightCyan|LightGoldenRodYellow|LightGr[ae]y|LightGreen|LightPink|LightSalmon|LightSeaGreen|LightSkyBlue|LightSlateGr[ae]y|LightSteelBlue|LightYellow|Lime|LimeGreen|Linen|Magenta|Maroon|MediumAquaMarine|MediumBlue|MediumOrchid|MediumPurple|MediumSeaGreen|MediumSlateBlue|MediumSpringGreen|MediumTurquoise|MediumVioletRed|MidnightBlue|MintCream|MistyRose|Moccasin|NavajoWhite|Navy|OldLace|Olive|OliveDrab|Orange|OrangeRed|Orchid|PaleGoldenRod|PaleGreen|PaleTurquoise|PaleVioletRed|PapayaWhip|PeachPuff|Peru|Pink|Plum|PowderBlue|Purple|Red|RosyBrown|RoyalBlue|SaddleBrown|Salmon|SandyBrown|SeaGreen|SeaShell|Sienna|Silver|SkyBlue|SlateBlue|SlateGr[ae]y|Snow|SpringGreen|SteelBlue|Tan|Teal|Thistle|Tomato|Transparent|Turquoise|Violet|Wheat|White|WhiteSmoke|Yellow|YellowGreen)\b/i,
						{
							pattern:
								/\b(?:hsl|rgb)\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*\)\B|\b(?:hsl|rgb)a\(\s*\d{1,3}\s*,\s*\d{1,3}%?\s*,\s*\d{1,3}%?\s*,\s*(?:0|0?\.\d+|1)\s*\)\B/i,
							inside: {
								unit,
								number: number3,
								function: /[\w-]+(?=\()/,
								punctuation: /[(),]/
							}
						}
					],
					entity: /\\[\da-f]{1,8}/i,
					unit,
					boolean: /\b(?:false|true)\b/,
					operator: [
						/~|[+!\/%<>?=]=?|[-:]=|\*[*=]?|\.{2,3}|&&|\|\||\B-\B|\b(?:and|in|is(?: a| defined| not|nt)?|not|or)\b/
					],
					number: number3,
					punctuation: /[{}()\[\];:,]/
				};
				inside['interpolation'] = {
					pattern: /\{[^\r\n}:]+\}/,
					alias: 'variable',
					inside: {
						delimiter: {
							pattern: /^\{|\}$/,
							alias: 'punctuation'
						},
						rest: inside
					}
				};
				inside['func'] = {
					pattern: /[\w-]+\([^)]*\).*/,
					inside: {
						function: /^[^(]+/,
						rest: inside
					}
				};
				Prism2.languages.stylus = {
					'atrule-declaration': {
						pattern: /(^[ \t]*)@.+/m,
						lookbehind: true,
						inside: {
							atrule: /^@[\w-]+/,
							rest: inside
						}
					},
					'variable-declaration': {
						pattern: /(^[ \t]*)[\w$-]+\s*.?=[ \t]*(?:\{[^{}]*\}|\S.*|$)/m,
						lookbehind: true,
						inside: {
							variable: /^\S+/,
							rest: inside
						}
					},
					statement: {
						pattern: /(^[ \t]*)(?:else|for|if|return|unless)[ \t].+/m,
						lookbehind: true,
						inside: {
							keyword: /^\S+/,
							rest: inside
						}
					},
					'property-declaration': {
						pattern:
							/((?:^|\{)([ \t]*))(?:[\w-]|\{[^}\r\n]+\})+(?:\s*:\s*|[ \t]+)(?!\s)[^{\r\n]*(?:;|[^{\r\n,]$(?!(?:\r?\n|\r)(?:\{|\2[ \t])))/m,
						lookbehind: true,
						inside: {
							property: {
								pattern: /^[^\s:]+/,
								inside: {
									interpolation: inside.interpolation
								}
							},
							rest: inside
						}
					},
					selector: {
						pattern:
							/(^[ \t]*)(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)(?:(?:\r?\n|\r)(?:\1(?:(?=\S)(?:[^{}\r\n:()]|::?[\w-]+(?:\([^)\r\n]*\)|(?![\w-]))|\{[^}\r\n]+\})+)))*(?:,$|\{|(?=(?:\r?\n|\r)(?:\{|\1[ \t])))/m,
						lookbehind: true,
						inside: {
							interpolation: inside.interpolation,
							comment: inside.comment,
							punctuation: /[{},]/
						}
					},
					func: inside.func,
					string: inside.string,
					comment: {
						pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|\/\/.*)/,
						lookbehind: true,
						greedy: true
					},
					interpolation: inside.interpolation,
					punctuation: /[{}()\[\];:.]/
				};
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/swift.js
var require_swift = __commonJS({
	'node_modules/refractor/lang/swift.js'(exports, module2) {
		'use strict';
		module2.exports = swift;
		swift.displayName = 'swift';
		swift.aliases = [];
		function swift(Prism) {
			Prism.languages.swift = {
				comment: {
					pattern:
						/(^|[^\\:])(?:\/\/.*|\/\*(?:[^/*]|\/(?!\*)|\*(?!\/)|\/\*(?:[^*]|\*(?!\/))*\*\/)*\*\/)/,
					lookbehind: true,
					greedy: true
				},
				'string-literal': [
					{
						pattern: RegExp(
							/(^|[^"#])/.source +
								'(?:' +
								/"(?:\\(?:\((?:[^()]|\([^()]*\))*\)|\r\n|[^(])|[^\\\r\n"])*"/.source +
								'|' +
								/"""(?:\\(?:\((?:[^()]|\([^()]*\))*\)|[^(])|[^\\"]|"(?!""))*"""/.source +
								')' +
								/(?!["#])/.source
						),
						lookbehind: true,
						greedy: true,
						inside: {
							interpolation: {
								pattern: /(\\\()(?:[^()]|\([^()]*\))*(?=\))/,
								lookbehind: true,
								inside: null
							},
							'interpolation-punctuation': {
								pattern: /^\)|\\\($/,
								alias: 'punctuation'
							},
							punctuation: /\\(?=[\r\n])/,
							string: /[\s\S]+/
						}
					},
					{
						pattern: RegExp(
							/(^|[^"#])(#+)/.source +
								'(?:' +
								/"(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|\r\n|[^#])|[^\\\r\n])*?"/.source +
								'|' +
								/"""(?:\\(?:#+\((?:[^()]|\([^()]*\))*\)|[^#])|[^\\])*?"""/.source +
								')\\2'
						),
						lookbehind: true,
						greedy: true,
						inside: {
							interpolation: {
								pattern: /(\\#+\()(?:[^()]|\([^()]*\))*(?=\))/,
								lookbehind: true,
								inside: null
							},
							'interpolation-punctuation': {
								pattern: /^\)|\\#+\($/,
								alias: 'punctuation'
							},
							string: /[\s\S]+/
						}
					}
				],
				directive: {
					pattern: RegExp(
						/#/.source +
							'(?:' +
							(/(?:elseif|if)\b/.source +
								'(?:[ 	]*' +
								/(?:![ \t]*)?(?:\b\w+\b(?:[ \t]*\((?:[^()]|\([^()]*\))*\))?|\((?:[^()]|\([^()]*\))*\))(?:[ \t]*(?:&&|\|\|))?/
									.source +
								')+') +
							'|' +
							/(?:else|endif)\b/.source +
							')'
					),
					alias: 'property',
					inside: {
						'directive-name': /^#\w+/,
						boolean: /\b(?:false|true)\b/,
						number: /\b\d+(?:\.\d+)*\b/,
						operator: /!|&&|\|\||[<>]=?/,
						punctuation: /[(),]/
					}
				},
				literal: {
					pattern:
						/#(?:colorLiteral|column|dsohandle|file(?:ID|Literal|Path)?|function|imageLiteral|line)\b/,
					alias: 'constant'
				},
				'other-directive': {
					pattern: /#\w+\b/,
					alias: 'property'
				},
				attribute: {
					pattern: /@\w+/,
					alias: 'atrule'
				},
				'function-definition': {
					pattern: /(\bfunc\s+)\w+/,
					lookbehind: true,
					alias: 'function'
				},
				label: {
					pattern: /\b(break|continue)\s+\w+|\b[a-zA-Z_]\w*(?=\s*:\s*(?:for|repeat|while)\b)/,
					lookbehind: true,
					alias: 'important'
				},
				keyword:
					/\b(?:Any|Protocol|Self|Type|actor|as|assignment|associatedtype|associativity|async|await|break|case|catch|class|continue|convenience|default|defer|deinit|didSet|do|dynamic|else|enum|extension|fallthrough|fileprivate|final|for|func|get|guard|higherThan|if|import|in|indirect|infix|init|inout|internal|is|isolated|lazy|left|let|lowerThan|mutating|none|nonisolated|nonmutating|open|operator|optional|override|postfix|precedencegroup|prefix|private|protocol|public|repeat|required|rethrows|return|right|safe|self|set|some|static|struct|subscript|super|switch|throw|throws|try|typealias|unowned|unsafe|var|weak|where|while|willSet)\b/,
				boolean: /\b(?:false|true)\b/,
				nil: {
					pattern: /\bnil\b/,
					alias: 'constant'
				},
				'short-argument': /\$\d+\b/,
				omit: {
					pattern: /\b_\b/,
					alias: 'keyword'
				},
				number: /\b(?:[\d_]+(?:\.[\de_]+)?|0x[a-f0-9_]+(?:\.[a-f0-9p_]+)?|0b[01_]+|0o[0-7_]+)\b/i,
				'class-name': /\b[A-Z](?:[A-Z_\d]*[a-z]\w*)?\b/,
				function: /\b[a-z_]\w*(?=\s*\()/i,
				constant: /\b(?:[A-Z_]{2,}|k[A-Z][A-Za-z_]+)\b/,
				operator: /[-+*/%=!<>&|^~?]+|\.[.\-+*/%=!<>&|^~?]+/,
				punctuation: /[{}[\]();,.:\\]/
			};
			Prism.languages.swift['string-literal'].forEach(function (rule) {
				rule.inside['interpolation'].inside = Prism.languages.swift;
			});
		}
	}
});

// node_modules/refractor/lang/systemd.js
var require_systemd = __commonJS({
	'node_modules/refractor/lang/systemd.js'(exports, module2) {
		'use strict';
		module2.exports = systemd;
		systemd.displayName = 'systemd';
		systemd.aliases = [];
		function systemd(Prism) {
			(function (Prism2) {
				var comment4 = {
					pattern: /^[;#].*/m,
					greedy: true
				};
				var quotesSource = /"(?:[^\r\n"\\]|\\(?:[^\r]|\r\n?))*"(?!\S)/.source;
				Prism2.languages.systemd = {
					comment: comment4,
					section: {
						pattern: /^\[[^\n\r\[\]]*\](?=[ \t]*$)/m,
						greedy: true,
						inside: {
							punctuation: /^\[|\]$/,
							'section-name': {
								pattern: /[\s\S]+/,
								alias: 'selector'
							}
						}
					},
					key: {
						pattern: /^[^\s=]+(?=[ \t]*=)/m,
						greedy: true,
						alias: 'attr-name'
					},
					value: {
						pattern: RegExp(
							/(=[ \t]*(?!\s))/.source +
								'(?:' +
								quotesSource +
								'|(?=[^"\r\n]))(?:' +
								(/[^\s\\]/.source +
									'|[ 	]+(?:(?![ 	"])|' +
									quotesSource +
									')|' +
									/\\[\r\n]+(?:[#;].*[\r\n]+)*(?![#;])/.source) +
								')*'
						),
						lookbehind: true,
						greedy: true,
						alias: 'attr-value',
						inside: {
							comment: comment4,
							quoted: {
								pattern: RegExp(/(^|\s)/.source + quotesSource),
								lookbehind: true,
								greedy: true
							},
							punctuation: /\\$/m,
							boolean: {
								pattern: /^(?:false|no|off|on|true|yes)$/,
								greedy: true
							}
						}
					},
					punctuation: /=/
				};
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/t4-templating.js
var require_t4_templating = __commonJS({
	'node_modules/refractor/lang/t4-templating.js'(exports, module2) {
		'use strict';
		module2.exports = t4Templating;
		t4Templating.displayName = 't4Templating';
		t4Templating.aliases = [];
		function t4Templating(Prism) {
			(function (Prism2) {
				function createBlock(prefix, inside, contentAlias) {
					return {
						pattern: RegExp('<#' + prefix + '[\\s\\S]*?#>'),
						alias: 'block',
						inside: {
							delimiter: {
								pattern: RegExp('^<#' + prefix + '|#>$'),
								alias: 'important'
							},
							content: {
								pattern: /[\s\S]+/,
								inside,
								alias: contentAlias
							}
						}
					};
				}
				function createT4(insideLang) {
					var grammar = Prism2.languages[insideLang];
					var className = 'language-' + insideLang;
					return {
						block: {
							pattern: /<#[\s\S]+?#>/,
							inside: {
								directive: createBlock('@', {
									'attr-value': {
										pattern: /=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+)/,
										inside: {
											punctuation: /^=|^["']|["']$/
										}
									},
									keyword: /\b\w+(?=\s)/,
									'attr-name': /\b\w+/
								}),
								expression: createBlock('=', grammar, className),
								'class-feature': createBlock('\\+', grammar, className),
								standard: createBlock('', grammar, className)
							}
						}
					};
				}
				Prism2.languages['t4-templating'] = Object.defineProperty({}, 'createT4', {
					value: createT4
				});
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/t4-cs.js
var require_t4_cs = __commonJS({
	'node_modules/refractor/lang/t4-cs.js'(exports, module2) {
		'use strict';
		var refractorT4Templating = require_t4_templating();
		var refractorCsharp = require_csharp();
		module2.exports = t4Cs;
		t4Cs.displayName = 't4Cs';
		t4Cs.aliases = [];
		function t4Cs(Prism) {
			Prism.register(refractorT4Templating);
			Prism.register(refractorCsharp);
			Prism.languages.t4 = Prism.languages['t4-cs'] =
				Prism.languages['t4-templating'].createT4('csharp');
		}
	}
});

// node_modules/refractor/lang/vbnet.js
var require_vbnet = __commonJS({
	'node_modules/refractor/lang/vbnet.js'(exports, module2) {
		'use strict';
		var refractorBasic = require_basic();
		module2.exports = vbnet;
		vbnet.displayName = 'vbnet';
		vbnet.aliases = [];
		function vbnet(Prism) {
			Prism.register(refractorBasic);
			Prism.languages.vbnet = Prism.languages.extend('basic', {
				comment: [
					{
						pattern: /(?:!|REM\b).+/i,
						inside: {
							keyword: /^REM/i
						}
					},
					{
						pattern: /(^|[^\\:])'.*/,
						lookbehind: true,
						greedy: true
					}
				],
				string: {
					pattern: /(^|[^"])"(?:""|[^"])*"(?!")/,
					lookbehind: true,
					greedy: true
				},
				keyword:
					/(?:\b(?:ADDHANDLER|ADDRESSOF|ALIAS|AND|ANDALSO|AS|BEEP|BLOAD|BOOLEAN|BSAVE|BYREF|BYTE|BYVAL|CALL(?: ABSOLUTE)?|CASE|CATCH|CBOOL|CBYTE|CCHAR|CDATE|CDBL|CDEC|CHAIN|CHAR|CHDIR|CINT|CLASS|CLEAR|CLNG|CLOSE|CLS|COBJ|COM|COMMON|CONST|CONTINUE|CSBYTE|CSHORT|CSNG|CSTR|CTYPE|CUINT|CULNG|CUSHORT|DATA|DATE|DECIMAL|DECLARE|DEF(?: FN| SEG|DBL|INT|LNG|SNG|STR)|DEFAULT|DELEGATE|DIM|DIRECTCAST|DO|DOUBLE|ELSE|ELSEIF|END|ENUM|ENVIRON|ERASE|ERROR|EVENT|EXIT|FALSE|FIELD|FILES|FINALLY|FOR(?: EACH)?|FRIEND|FUNCTION|GET|GETTYPE|GETXMLNAMESPACE|GLOBAL|GOSUB|GOTO|HANDLES|IF|IMPLEMENTS|IMPORTS|IN|INHERITS|INPUT|INTEGER|INTERFACE|IOCTL|IS|ISNOT|KEY|KILL|LET|LIB|LIKE|LINE INPUT|LOCATE|LOCK|LONG|LOOP|LSET|ME|MKDIR|MOD|MODULE|MUSTINHERIT|MUSTOVERRIDE|MYBASE|MYCLASS|NAME|NAMESPACE|NARROWING|NEW|NEXT|NOT|NOTHING|NOTINHERITABLE|NOTOVERRIDABLE|OBJECT|OF|OFF|ON(?: COM| ERROR| KEY| TIMER)?|OPEN|OPERATOR|OPTION(?: BASE)?|OPTIONAL|OR|ORELSE|OUT|OVERLOADS|OVERRIDABLE|OVERRIDES|PARAMARRAY|PARTIAL|POKE|PRIVATE|PROPERTY|PROTECTED|PUBLIC|PUT|RAISEEVENT|READ|READONLY|REDIM|REM|REMOVEHANDLER|RESTORE|RESUME|RETURN|RMDIR|RSET|RUN|SBYTE|SELECT(?: CASE)?|SET|SHADOWS|SHARED|SHELL|SHORT|SINGLE|SLEEP|STATIC|STEP|STOP|STRING|STRUCTURE|SUB|SWAP|SYNCLOCK|SYSTEM|THEN|THROW|TIMER|TO|TROFF|TRON|TRUE|TRY|TRYCAST|TYPE|TYPEOF|UINTEGER|ULONG|UNLOCK|UNTIL|USHORT|USING|VIEW PRINT|WAIT|WEND|WHEN|WHILE|WIDENING|WITH|WITHEVENTS|WRITE|WRITEONLY|XOR)|\B(?:#CONST|#ELSE|#ELSEIF|#END|#IF))(?:\$|\b)/i,
				punctuation: /[,;:(){}]/
			});
		}
	}
});

// node_modules/refractor/lang/t4-vb.js
var require_t4_vb = __commonJS({
	'node_modules/refractor/lang/t4-vb.js'(exports, module2) {
		'use strict';
		var refractorT4Templating = require_t4_templating();
		var refractorVbnet = require_vbnet();
		module2.exports = t4Vb;
		t4Vb.displayName = 't4Vb';
		t4Vb.aliases = [];
		function t4Vb(Prism) {
			Prism.register(refractorT4Templating);
			Prism.register(refractorVbnet);
			Prism.languages['t4-vb'] = Prism.languages['t4-templating'].createT4('vbnet');
		}
	}
});

// node_modules/refractor/lang/yaml.js
var require_yaml = __commonJS({
	'node_modules/refractor/lang/yaml.js'(exports, module2) {
		'use strict';
		module2.exports = yaml;
		yaml.displayName = 'yaml';
		yaml.aliases = ['yml'];
		function yaml(Prism) {
			(function (Prism2) {
				var anchorOrAlias = /[*&][^\s[\]{},]+/;
				var tag =
					/!(?:<[\w\-%#;/?:@&=+$,.!~*'()[\]]+>|(?:[a-zA-Z\d-]*!)?[\w\-%#;/?:@&=+$.~*'()]+)?/;
				var properties2 =
					'(?:' +
					tag.source +
					'(?:[ 	]+' +
					anchorOrAlias.source +
					')?|' +
					anchorOrAlias.source +
					'(?:[ 	]+' +
					tag.source +
					')?)';
				var plainKey =
					/(?:[^\s\x00-\x08\x0e-\x1f!"#%&'*,\-:>?@[\]`{|}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]|[?:-]<PLAIN>)(?:[ \t]*(?:(?![#:])<PLAIN>|:<PLAIN>))*/.source.replace(
						/<PLAIN>/g,
						function () {
							return /[^\s\x00-\x08\x0e-\x1f,[\]{}\x7f-\x84\x86-\x9f\ud800-\udfff\ufffe\uffff]/
								.source;
						}
					);
				var string3 = /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'/.source;
				function createValuePattern(value, flags) {
					flags = (flags || '').replace(/m/g, '') + 'm';
					var pattern =
						/([:\-,[{]\s*(?:\s<<prop>>[ \t]+)?)(?:<<value>>)(?=[ \t]*(?:$|,|\]|\}|(?:[\r\n]\s*)?#))/.source
							.replace(/<<prop>>/g, function () {
								return properties2;
							})
							.replace(/<<value>>/g, function () {
								return value;
							});
					return RegExp(pattern, flags);
				}
				Prism2.languages.yaml = {
					scalar: {
						pattern: RegExp(
							/([\-:]\s*(?:\s<<prop>>[ \t]+)?[|>])[ \t]*(?:((?:\r?\n|\r)[ \t]+)\S[^\r\n]*(?:\2[^\r\n]+)*)/.source.replace(
								/<<prop>>/g,
								function () {
									return properties2;
								}
							)
						),
						lookbehind: true,
						alias: 'string'
					},
					comment: /#.*/,
					key: {
						pattern: RegExp(
							/((?:^|[:\-,[{\r\n?])[ \t]*(?:<<prop>>[ \t]+)?)<<key>>(?=\s*:\s)/.source
								.replace(/<<prop>>/g, function () {
									return properties2;
								})
								.replace(/<<key>>/g, function () {
									return '(?:' + plainKey + '|' + string3 + ')';
								})
						),
						lookbehind: true,
						greedy: true,
						alias: 'atrule'
					},
					directive: {
						pattern: /(^[ \t]*)%.+/m,
						lookbehind: true,
						alias: 'important'
					},
					datetime: {
						pattern: createValuePattern(
							/\d{4}-\d\d?-\d\d?(?:[tT]|[ \t]+)\d\d?:\d{2}:\d{2}(?:\.\d*)?(?:[ \t]*(?:Z|[-+]\d\d?(?::\d{2})?))?|\d{4}-\d{2}-\d{2}|\d\d?:\d{2}(?::\d{2}(?:\.\d*)?)?/
								.source
						),
						lookbehind: true,
						alias: 'number'
					},
					boolean: {
						pattern: createValuePattern(/false|true/.source, 'i'),
						lookbehind: true,
						alias: 'important'
					},
					null: {
						pattern: createValuePattern(/null|~/.source, 'i'),
						lookbehind: true,
						alias: 'important'
					},
					string: {
						pattern: createValuePattern(string3),
						lookbehind: true,
						greedy: true
					},
					number: {
						pattern: createValuePattern(
							/[+-]?(?:0x[\da-f]+|0o[0-7]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|\.inf|\.nan)/
								.source,
							'i'
						),
						lookbehind: true
					},
					tag,
					important: anchorOrAlias,
					punctuation: /---|[:[\]{}\-,|>?]|\.\.\./
				};
				Prism2.languages.yml = Prism2.languages.yaml;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/tap.js
var require_tap = __commonJS({
	'node_modules/refractor/lang/tap.js'(exports, module2) {
		'use strict';
		var refractorYaml = require_yaml();
		module2.exports = tap;
		tap.displayName = 'tap';
		tap.aliases = [];
		function tap(Prism) {
			Prism.register(refractorYaml);
			Prism.languages.tap = {
				fail: /not ok[^#{\n\r]*/,
				pass: /ok[^#{\n\r]*/,
				pragma: /pragma [+-][a-z]+/,
				bailout: /bail out!.*/i,
				version: /TAP version \d+/i,
				plan: /\b\d+\.\.\d+(?: +#.*)?/,
				subtest: {
					pattern: /# Subtest(?:: .*)?/,
					greedy: true
				},
				punctuation: /[{}]/,
				directive: /#.*/,
				yamlish: {
					pattern: /(^[ \t]*)---[\s\S]*?[\r\n][ \t]*\.\.\.$/m,
					lookbehind: true,
					inside: Prism.languages.yaml,
					alias: 'language-yaml'
				}
			};
		}
	}
});

// node_modules/refractor/lang/tcl.js
var require_tcl = __commonJS({
	'node_modules/refractor/lang/tcl.js'(exports, module2) {
		'use strict';
		module2.exports = tcl;
		tcl.displayName = 'tcl';
		tcl.aliases = [];
		function tcl(Prism) {
			Prism.languages.tcl = {
				comment: {
					pattern: /(^|[^\\])#.*/,
					lookbehind: true
				},
				string: {
					pattern: /"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*"/,
					greedy: true
				},
				variable: [
					{
						pattern: /(\$)(?:::)?(?:[a-zA-Z0-9]+::)*\w+/,
						lookbehind: true
					},
					{
						pattern: /(\$)\{[^}]+\}/,
						lookbehind: true
					},
					{
						pattern: /(^[\t ]*set[ \t]+)(?:::)?(?:[a-zA-Z0-9]+::)*\w+/m,
						lookbehind: true
					}
				],
				function: {
					pattern: /(^[\t ]*proc[ \t]+)\S+/m,
					lookbehind: true
				},
				builtin: [
					{
						pattern:
							/(^[\t ]*)(?:break|class|continue|error|eval|exit|for|foreach|if|proc|return|switch|while)\b/m,
						lookbehind: true
					},
					/\b(?:else|elseif)\b/
				],
				scope: {
					pattern: /(^[\t ]*)(?:global|upvar|variable)\b/m,
					lookbehind: true,
					alias: 'constant'
				},
				keyword: {
					pattern:
						/(^[\t ]*|\[)(?:Safe_Base|Tcl|after|append|apply|array|auto_(?:execok|import|load|mkindex|qualify|reset)|automkindex_old|bgerror|binary|catch|cd|chan|clock|close|concat|dde|dict|encoding|eof|exec|expr|fblocked|fconfigure|fcopy|file(?:event|name)?|flush|gets|glob|history|http|incr|info|interp|join|lappend|lassign|lindex|linsert|list|llength|load|lrange|lrepeat|lreplace|lreverse|lsearch|lset|lsort|math(?:func|op)|memory|msgcat|namespace|open|package|parray|pid|pkg_mkIndex|platform|puts|pwd|re_syntax|read|refchan|regexp|registry|regsub|rename|scan|seek|set|socket|source|split|string|subst|tcl(?:_endOfWord|_findLibrary|startOf(?:Next|Previous)Word|test|vars|wordBreak(?:After|Before))|tell|time|tm|trace|unknown|unload|unset|update|uplevel|vwait)\b/m,
					lookbehind: true
				},
				operator: /!=?|\*\*?|==|&&?|\|\|?|<[=<]?|>[=>]?|[-+~\/%?^]|\b(?:eq|in|ne|ni)\b/,
				punctuation: /[{}()\[\]]/
			};
		}
	}
});

// node_modules/refractor/lang/textile.js
var require_textile = __commonJS({
	'node_modules/refractor/lang/textile.js'(exports, module2) {
		'use strict';
		module2.exports = textile;
		textile.displayName = 'textile';
		textile.aliases = [];
		function textile(Prism) {
			(function (Prism2) {
				var modifierRegex = /\([^|()\n]+\)|\[[^\]\n]+\]|\{[^}\n]+\}/.source;
				var parenthesesRegex = /\)|\((?![^|()\n]+\))/.source;
				function withModifier(source, flags) {
					return RegExp(
						source
							.replace(/<MOD>/g, function () {
								return '(?:' + modifierRegex + ')';
							})
							.replace(/<PAR>/g, function () {
								return '(?:' + parenthesesRegex + ')';
							}),
						flags || ''
					);
				}
				var modifierTokens = {
					css: {
						pattern: /\{[^{}]+\}/,
						inside: {
							rest: Prism2.languages.css
						}
					},
					'class-id': {
						pattern: /(\()[^()]+(?=\))/,
						lookbehind: true,
						alias: 'attr-value'
					},
					lang: {
						pattern: /(\[)[^\[\]]+(?=\])/,
						lookbehind: true,
						alias: 'attr-value'
					},
					punctuation: /[\\\/]\d+|\S/
				};
				var textile2 = (Prism2.languages.textile = Prism2.languages.extend('markup', {
					phrase: {
						pattern: /(^|\r|\n)\S[\s\S]*?(?=$|\r?\n\r?\n|\r\r)/,
						lookbehind: true,
						inside: {
							'block-tag': {
								pattern: withModifier(/^[a-z]\w*(?:<MOD>|<PAR>|[<>=])*\./.source),
								inside: {
									modifier: {
										pattern: withModifier(/(^[a-z]\w*)(?:<MOD>|<PAR>|[<>=])+(?=\.)/.source),
										lookbehind: true,
										inside: modifierTokens
									},
									tag: /^[a-z]\w*/,
									punctuation: /\.$/
								}
							},
							list: {
								pattern: withModifier(/^[*#]+<MOD>*\s+\S.*/.source, 'm'),
								inside: {
									modifier: {
										pattern: withModifier(/(^[*#]+)<MOD>+/.source),
										lookbehind: true,
										inside: modifierTokens
									},
									punctuation: /^[*#]+/
								}
							},
							table: {
								pattern: withModifier(
									/^(?:(?:<MOD>|<PAR>|[<>=^~])+\.\s*)?(?:\|(?:(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+\.|(?!(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+\.))[^|]*)+\|/
										.source,
									'm'
								),
								inside: {
									modifier: {
										pattern: withModifier(
											/(^|\|(?:\r?\n|\r)?)(?:<MOD>|<PAR>|[<>=^~_]|[\\/]\d+)+(?=\.)/.source
										),
										lookbehind: true,
										inside: modifierTokens
									},
									punctuation: /\||^\./
								}
							},
							inline: {
								pattern: withModifier(
									/(^|[^a-zA-Z\d])(\*\*|__|\?\?|[*_%@+\-^~])<MOD>*.+?\2(?![a-zA-Z\d])/.source
								),
								lookbehind: true,
								inside: {
									bold: {
										pattern: withModifier(/(^(\*\*?)<MOD>*).+?(?=\2)/.source),
										lookbehind: true
									},
									italic: {
										pattern: withModifier(/(^(__?)<MOD>*).+?(?=\2)/.source),
										lookbehind: true
									},
									cite: {
										pattern: withModifier(/(^\?\?<MOD>*).+?(?=\?\?)/.source),
										lookbehind: true,
										alias: 'string'
									},
									code: {
										pattern: withModifier(/(^@<MOD>*).+?(?=@)/.source),
										lookbehind: true,
										alias: 'keyword'
									},
									inserted: {
										pattern: withModifier(/(^\+<MOD>*).+?(?=\+)/.source),
										lookbehind: true
									},
									deleted: {
										pattern: withModifier(/(^-<MOD>*).+?(?=-)/.source),
										lookbehind: true
									},
									span: {
										pattern: withModifier(/(^%<MOD>*).+?(?=%)/.source),
										lookbehind: true
									},
									modifier: {
										pattern: withModifier(/(^\*\*|__|\?\?|[*_%@+\-^~])<MOD>+/.source),
										lookbehind: true,
										inside: modifierTokens
									},
									punctuation: /[*_%?@+\-^~]+/
								}
							},
							'link-ref': {
								pattern: /^\[[^\]]+\]\S+$/m,
								inside: {
									string: {
										pattern: /(^\[)[^\]]+(?=\])/,
										lookbehind: true
									},
									url: {
										pattern: /(^\])\S+$/,
										lookbehind: true
									},
									punctuation: /[\[\]]/
								}
							},
							link: {
								pattern: withModifier(/"<MOD>*[^"]+":.+?(?=[^\w/]?(?:\s|$))/.source),
								inside: {
									text: {
										pattern: withModifier(/(^"<MOD>*)[^"]+(?=")/.source),
										lookbehind: true
									},
									modifier: {
										pattern: withModifier(/(^")<MOD>+/.source),
										lookbehind: true,
										inside: modifierTokens
									},
									url: {
										pattern: /(:).+/,
										lookbehind: true
									},
									punctuation: /[":]/
								}
							},
							image: {
								pattern: withModifier(
									/!(?:<MOD>|<PAR>|[<>=])*(?![<>=])[^!\s()]+(?:\([^)]+\))?!(?::.+?(?=[^\w/]?(?:\s|$)))?/
										.source
								),
								inside: {
									source: {
										pattern: withModifier(
											/(^!(?:<MOD>|<PAR>|[<>=])*)(?![<>=])[^!\s()]+(?:\([^)]+\))?(?=!)/.source
										),
										lookbehind: true,
										alias: 'url'
									},
									modifier: {
										pattern: withModifier(/(^!)(?:<MOD>|<PAR>|[<>=])+/.source),
										lookbehind: true,
										inside: modifierTokens
									},
									url: {
										pattern: /(:).+/,
										lookbehind: true
									},
									punctuation: /[!:]/
								}
							},
							footnote: {
								pattern: /\b\[\d+\]/,
								alias: 'comment',
								inside: {
									punctuation: /\[|\]/
								}
							},
							acronym: {
								pattern: /\b[A-Z\d]+\([^)]+\)/,
								inside: {
									comment: {
										pattern: /(\()[^()]+(?=\))/,
										lookbehind: true
									},
									punctuation: /[()]/
								}
							},
							mark: {
								pattern: /\b\((?:C|R|TM)\)/,
								alias: 'comment',
								inside: {
									punctuation: /[()]/
								}
							}
						}
					}
				}));
				var phraseInside = textile2['phrase'].inside;
				var nestedPatterns = {
					inline: phraseInside['inline'],
					link: phraseInside['link'],
					image: phraseInside['image'],
					footnote: phraseInside['footnote'],
					acronym: phraseInside['acronym'],
					mark: phraseInside['mark']
				};
				textile2.tag.pattern =
					/<\/?(?!\d)[a-z0-9]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/i;
				var phraseInlineInside = phraseInside['inline'].inside;
				phraseInlineInside['bold'].inside = nestedPatterns;
				phraseInlineInside['italic'].inside = nestedPatterns;
				phraseInlineInside['inserted'].inside = nestedPatterns;
				phraseInlineInside['deleted'].inside = nestedPatterns;
				phraseInlineInside['span'].inside = nestedPatterns;
				var phraseTableInside = phraseInside['table'].inside;
				phraseTableInside['inline'] = nestedPatterns['inline'];
				phraseTableInside['link'] = nestedPatterns['link'];
				phraseTableInside['image'] = nestedPatterns['image'];
				phraseTableInside['footnote'] = nestedPatterns['footnote'];
				phraseTableInside['acronym'] = nestedPatterns['acronym'];
				phraseTableInside['mark'] = nestedPatterns['mark'];
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/toml.js
var require_toml = __commonJS({
	'node_modules/refractor/lang/toml.js'(exports, module2) {
		'use strict';
		module2.exports = toml;
		toml.displayName = 'toml';
		toml.aliases = [];
		function toml(Prism) {
			(function (Prism2) {
				var key3 = /(?:[\w-]+|'[^'\n\r]*'|"(?:\\.|[^\\"\r\n])*")/.source;
				function insertKey(pattern) {
					return pattern.replace(/__/g, function () {
						return key3;
					});
				}
				Prism2.languages.toml = {
					comment: {
						pattern: /#.*/,
						greedy: true
					},
					table: {
						pattern: RegExp(
							insertKey(/(^[\t ]*\[\s*(?:\[\s*)?)__(?:\s*\.\s*__)*(?=\s*\])/.source),
							'm'
						),
						lookbehind: true,
						greedy: true,
						alias: 'class-name'
					},
					key: {
						pattern: RegExp(insertKey(/(^[\t ]*|[{,]\s*)__(?:\s*\.\s*__)*(?=\s*=)/.source), 'm'),
						lookbehind: true,
						greedy: true,
						alias: 'property'
					},
					string: {
						pattern: /"""(?:\\[\s\S]|[^\\])*?"""|'''[\s\S]*?'''|'[^'\n\r]*'|"(?:\\.|[^\\"\r\n])*"/,
						greedy: true
					},
					date: [
						{
							pattern:
								/\b\d{4}-\d{2}-\d{2}(?:[T\s]\d{2}:\d{2}:\d{2}(?:\.\d+)?(?:Z|[+-]\d{2}:\d{2})?)?\b/i,
							alias: 'number'
						},
						{
							pattern: /\b\d{2}:\d{2}:\d{2}(?:\.\d+)?\b/,
							alias: 'number'
						}
					],
					number:
						/(?:\b0(?:x[\da-zA-Z]+(?:_[\da-zA-Z]+)*|o[0-7]+(?:_[0-7]+)*|b[10]+(?:_[10]+)*))\b|[-+]?\b\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?(?:[eE][+-]?\d+(?:_\d+)*)?\b|[-+]?\b(?:inf|nan)\b/,
					boolean: /\b(?:false|true)\b/,
					punctuation: /[.,=[\]{}]/
				};
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/tremor.js
var require_tremor = __commonJS({
	'node_modules/refractor/lang/tremor.js'(exports, module2) {
		'use strict';
		module2.exports = tremor;
		tremor.displayName = 'tremor';
		tremor.aliases = [];
		function tremor(Prism) {
			(function (Prism2) {
				Prism2.languages.tremor = {
					comment: {
						pattern: /(^|[^\\])(?:\/\*[\s\S]*?\*\/|(?:--|\/\/|#).*)/,
						lookbehind: true
					},
					'interpolated-string': null,
					extractor: {
						pattern: /\b[a-z_]\w*\|(?:[^\r\n\\|]|\\(?:\r\n|[\s\S]))*\|/i,
						greedy: true,
						inside: {
							regex: {
								pattern: /(^re)\|[\s\S]+/,
								lookbehind: true
							},
							function: /^\w+/,
							value: /\|[\s\S]+/
						}
					},
					identifier: {
						pattern: /`[^`]*`/,
						greedy: true
					},
					function: /\b[a-z_]\w*(?=\s*(?:::\s*<|\())\b/,
					keyword:
						/\b(?:args|as|by|case|config|connect|connector|const|copy|create|default|define|deploy|drop|each|emit|end|erase|event|flow|fn|for|from|group|having|insert|into|intrinsic|let|links|match|merge|mod|move|of|operator|patch|pipeline|recur|script|select|set|sliding|state|stream|to|tumbling|update|use|when|where|window|with)\b/,
					boolean: /\b(?:false|null|true)\b/i,
					number: /\b(?:0b[01_]*|0x[0-9a-fA-F_]*|\d[\d_]*(?:\.\d[\d_]*)?(?:[Ee][+-]?[\d_]+)?)\b/,
					'pattern-punctuation': {
						pattern: /%(?=[({[])/,
						alias: 'punctuation'
					},
					operator:
						/[-+*\/%~!^]=?|=[=>]?|&[&=]?|\|[|=]?|<<?=?|>>?>?=?|(?:absent|and|not|or|present|xor)\b/,
					punctuation: /::|[;\[\]()\{\},.:]/
				};
				var interpolationPattern = /#\{(?:[^"{}]|\{[^{}]*\}|"(?:[^"\\\r\n]|\\(?:\r\n|[\s\S]))*")*\}/
					.source;
				Prism2.languages.tremor['interpolated-string'] = {
					pattern: RegExp(
						/(^|[^\\])/.source +
							'(?:"""(?:' +
							/[^"\\#]|\\[\s\S]|"(?!"")|#(?!\{)/.source +
							'|' +
							interpolationPattern +
							')*"""|"(?:' +
							/[^"\\\r\n#]|\\(?:\r\n|[\s\S])|#(?!\{)/.source +
							'|' +
							interpolationPattern +
							')*")'
					),
					lookbehind: true,
					greedy: true,
					inside: {
						interpolation: {
							pattern: RegExp(interpolationPattern),
							inside: {
								punctuation: /^#\{|\}$/,
								expression: {
									pattern: /[\s\S]+/,
									inside: Prism2.languages.tremor
								}
							}
						},
						string: /[\s\S]+/
					}
				};
				Prism2.languages.troy = Prism2.languages['tremor'];
				Prism2.languages.trickle = Prism2.languages['tremor'];
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/tsx.js
var require_tsx = __commonJS({
	'node_modules/refractor/lang/tsx.js'(exports, module2) {
		'use strict';
		var refractorJsx = require_jsx();
		var refractorTypescript = require_typescript();
		module2.exports = tsx;
		tsx.displayName = 'tsx';
		tsx.aliases = [];
		function tsx(Prism) {
			Prism.register(refractorJsx);
			Prism.register(refractorTypescript);
			(function (Prism2) {
				var typescript = Prism2.util.clone(Prism2.languages.typescript);
				Prism2.languages.tsx = Prism2.languages.extend('jsx', typescript);
				delete Prism2.languages.tsx['parameter'];
				delete Prism2.languages.tsx['literal-property'];
				var tag = Prism2.languages.tsx.tag;
				tag.pattern = RegExp(
					/(^|[^\w$]|(?=<\/))/.source + '(?:' + tag.pattern.source + ')',
					tag.pattern.flags
				);
				tag.lookbehind = true;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/tt2.js
var require_tt2 = __commonJS({
	'node_modules/refractor/lang/tt2.js'(exports, module2) {
		'use strict';
		var refractorMarkupTemplating = require_markup_templating();
		module2.exports = tt2;
		tt2.displayName = 'tt2';
		tt2.aliases = [];
		function tt2(Prism) {
			Prism.register(refractorMarkupTemplating);
			(function (Prism2) {
				Prism2.languages.tt2 = Prism2.languages.extend('clike', {
					comment: /#.*|\[%#[\s\S]*?%\]/,
					keyword:
						/\b(?:BLOCK|CALL|CASE|CATCH|CLEAR|DEBUG|DEFAULT|ELSE|ELSIF|END|FILTER|FINAL|FOREACH|GET|IF|IN|INCLUDE|INSERT|LAST|MACRO|META|NEXT|PERL|PROCESS|RAWPERL|RETURN|SET|STOP|SWITCH|TAGS|THROW|TRY|UNLESS|USE|WHILE|WRAPPER)\b/,
					punctuation: /[[\]{},()]/
				});
				Prism2.languages.insertBefore('tt2', 'number', {
					operator: /=[>=]?|!=?|<=?|>=?|&&|\|\|?|\b(?:and|not|or)\b/,
					variable: {
						pattern: /\b[a-z]\w*(?:\s*\.\s*(?:\d+|\$?[a-z]\w*))*\b/i
					}
				});
				Prism2.languages.insertBefore('tt2', 'keyword', {
					delimiter: {
						pattern: /^(?:\[%|%%)-?|-?%\]$/,
						alias: 'punctuation'
					}
				});
				Prism2.languages.insertBefore('tt2', 'string', {
					'single-quoted-string': {
						pattern: /'[^\\']*(?:\\[\s\S][^\\']*)*'/,
						greedy: true,
						alias: 'string'
					},
					'double-quoted-string': {
						pattern: /"[^\\"]*(?:\\[\s\S][^\\"]*)*"/,
						greedy: true,
						alias: 'string',
						inside: {
							variable: {
								pattern: /\$(?:[a-z]\w*(?:\.(?:\d+|\$?[a-z]\w*))*)/i
							}
						}
					}
				});
				delete Prism2.languages.tt2.string;
				Prism2.hooks.add('before-tokenize', function (env) {
					var tt2Pattern = /\[%[\s\S]+?%\]/g;
					Prism2.languages['markup-templating'].buildPlaceholders(env, 'tt2', tt2Pattern);
				});
				Prism2.hooks.add('after-tokenize', function (env) {
					Prism2.languages['markup-templating'].tokenizePlaceholders(env, 'tt2');
				});
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/twig.js
var require_twig = __commonJS({
	'node_modules/refractor/lang/twig.js'(exports, module2) {
		'use strict';
		var refractorMarkupTemplating = require_markup_templating();
		module2.exports = twig;
		twig.displayName = 'twig';
		twig.aliases = [];
		function twig(Prism) {
			Prism.register(refractorMarkupTemplating);
			Prism.languages.twig = {
				comment: /^\{#[\s\S]*?#\}$/,
				'tag-name': {
					pattern: /(^\{%-?\s*)\w+/,
					lookbehind: true,
					alias: 'keyword'
				},
				delimiter: {
					pattern: /^\{[{%]-?|-?[%}]\}$/,
					alias: 'punctuation'
				},
				string: {
					pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
					inside: {
						punctuation: /^['"]|['"]$/
					}
				},
				keyword: /\b(?:even|if|odd)\b/,
				boolean: /\b(?:false|null|true)\b/,
				number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
				operator: [
					{
						pattern:
							/(\s)(?:and|b-and|b-or|b-xor|ends with|in|is|matches|not|or|same as|starts with)(?=\s)/,
						lookbehind: true
					},
					/[=<>]=?|!=|\*\*?|\/\/?|\?:?|[-+~%|]/
				],
				punctuation: /[()\[\]{}:.,]/
			};
			Prism.hooks.add('before-tokenize', function (env) {
				if (env.language !== 'twig') {
					return;
				}
				var pattern = /\{(?:#[\s\S]*?#|%[\s\S]*?%|\{[\s\S]*?\})\}/g;
				Prism.languages['markup-templating'].buildPlaceholders(env, 'twig', pattern);
			});
			Prism.hooks.add('after-tokenize', function (env) {
				Prism.languages['markup-templating'].tokenizePlaceholders(env, 'twig');
			});
		}
	}
});

// node_modules/refractor/lang/typoscript.js
var require_typoscript = __commonJS({
	'node_modules/refractor/lang/typoscript.js'(exports, module2) {
		'use strict';
		module2.exports = typoscript;
		typoscript.displayName = 'typoscript';
		typoscript.aliases = ['tsconfig'];
		function typoscript(Prism) {
			(function (Prism2) {
				var keywords =
					/\b(?:ACT|ACTIFSUB|CARRAY|CASE|CLEARGIF|COA|COA_INT|CONSTANTS|CONTENT|CUR|EDITPANEL|EFFECT|EXT|FILE|FLUIDTEMPLATE|FORM|FRAME|FRAMESET|GIFBUILDER|GMENU|GMENU_FOLDOUT|GMENU_LAYERS|GP|HMENU|HRULER|HTML|IENV|IFSUB|IMAGE|IMGMENU|IMGMENUITEM|IMGTEXT|IMG_RESOURCE|INCLUDE_TYPOSCRIPT|JSMENU|JSMENUITEM|LLL|LOAD_REGISTER|NO|PAGE|RECORDS|RESTORE_REGISTER|TEMPLATE|TEXT|TMENU|TMENUITEM|TMENU_LAYERS|USER|USER_INT|_GIFBUILDER|global|globalString|globalVar)\b/;
				Prism2.languages.typoscript = {
					comment: [
						{
							pattern: /(^|[^\\])\/\*[\s\S]*?(?:\*\/|$)/,
							lookbehind: true
						},
						{
							pattern: /(^|[^\\:= \t]|(?:^|[^= \t])[ \t]+)\/\/.*/,
							lookbehind: true,
							greedy: true
						},
						{
							pattern: /(^|[^"'])#.*/,
							lookbehind: true,
							greedy: true
						}
					],
					function: [
						{
							pattern: /<INCLUDE_TYPOSCRIPT:\s*source\s*=\s*(?:"[^"\r\n]*"|'[^'\r\n]*')\s*>/,
							inside: {
								string: {
									pattern: /"[^"\r\n]*"|'[^'\r\n]*'/,
									inside: {
										keyword: keywords
									}
								},
								keyword: {
									pattern: /INCLUDE_TYPOSCRIPT/
								}
							}
						},
						{
							pattern: /@import\s*(?:"[^"\r\n]*"|'[^'\r\n]*')/,
							inside: {
								string: /"[^"\r\n]*"|'[^'\r\n]*'/
							}
						}
					],
					string: {
						pattern: /^([^=]*=[< ]?)(?:(?!\]\n).)*/,
						lookbehind: true,
						inside: {
							function: /\{\$.*\}/,
							keyword: keywords,
							number: /^\d+$/,
							punctuation: /[,|:]/
						}
					},
					keyword: keywords,
					number: {
						pattern: /\b\d+\s*[.{=]/,
						inside: {
							operator: /[.{=]/
						}
					},
					tag: {
						pattern: /\.?[-\w\\]+\.?/,
						inside: {
							punctuation: /\./
						}
					},
					punctuation: /[{}[\];(),.:|]/,
					operator: /[<>]=?|[!=]=?=?|--?|\+\+?|&&?|\|\|?|[?*/~^%]/
				};
				Prism2.languages.tsconfig = Prism2.languages.typoscript;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/unrealscript.js
var require_unrealscript = __commonJS({
	'node_modules/refractor/lang/unrealscript.js'(exports, module2) {
		'use strict';
		module2.exports = unrealscript;
		unrealscript.displayName = 'unrealscript';
		unrealscript.aliases = ['uc', 'uscript'];
		function unrealscript(Prism) {
			Prism.languages.unrealscript = {
				comment: /\/\/.*|\/\*[\s\S]*?\*\//,
				string: {
					pattern: /(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
					greedy: true
				},
				category: {
					pattern: /(\b(?:(?:autoexpand|hide|show)categories|var)\s*\()[^()]+(?=\))/,
					lookbehind: true,
					greedy: true,
					alias: 'property'
				},
				metadata: {
					pattern: /(\w\s*)<\s*\w+\s*=[^<>|=\r\n]+(?:\|\s*\w+\s*=[^<>|=\r\n]+)*>/,
					lookbehind: true,
					greedy: true,
					inside: {
						property: /\b\w+(?=\s*=)/,
						operator: /=/,
						punctuation: /[<>|]/
					}
				},
				macro: {
					pattern: /`\w+/,
					alias: 'property'
				},
				'class-name': {
					pattern: /(\b(?:class|enum|extends|interface|state(?:\(\))?|struct|within)\s+)\w+/,
					lookbehind: true
				},
				keyword:
					/\b(?:abstract|actor|array|auto|autoexpandcategories|bool|break|byte|case|class|classgroup|client|coerce|collapsecategories|config|const|continue|default|defaultproperties|delegate|dependson|deprecated|do|dontcollapsecategories|editconst|editinlinenew|else|enum|event|exec|export|extends|final|float|for|forcescriptorder|foreach|function|goto|guid|hidecategories|hidedropdown|if|ignores|implements|inherits|input|int|interface|iterator|latent|local|material|name|native|nativereplication|noexport|nontransient|noteditinlinenew|notplaceable|operator|optional|out|pawn|perobjectconfig|perobjectlocalized|placeable|postoperator|preoperator|private|protected|reliable|replication|return|server|showcategories|simulated|singular|state|static|string|struct|structdefault|structdefaultproperties|switch|texture|transient|travel|unreliable|until|var|vector|while|within)\b/,
				function: /\b[a-z_]\w*(?=\s*\()/i,
				boolean: /\b(?:false|true)\b/,
				number: /\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?/i,
				operator:
					/>>|<<|--|\+\+|\*\*|[-+*/~!=<>$@]=?|&&?|\|\|?|\^\^?|[?:%]|\b(?:ClockwiseFrom|Cross|Dot)\b/,
				punctuation: /[()[\]{};,.]/
			};
			Prism.languages.uc = Prism.languages.uscript = Prism.languages.unrealscript;
		}
	}
});

// node_modules/refractor/lang/uorazor.js
var require_uorazor = __commonJS({
	'node_modules/refractor/lang/uorazor.js'(exports, module2) {
		'use strict';
		module2.exports = uorazor;
		uorazor.displayName = 'uorazor';
		uorazor.aliases = [];
		function uorazor(Prism) {
			Prism.languages.uorazor = {
				'comment-hash': {
					pattern: /#.*/,
					alias: 'comment',
					greedy: true
				},
				'comment-slash': {
					pattern: /\/\/.*/,
					alias: 'comment',
					greedy: true
				},
				string: {
					pattern: /("|')(?:\\.|(?!\1)[^\\\r\n])*\1/,
					inside: {
						punctuation: /^['"]|['"]$/
					},
					greedy: true
				},
				'source-layers': {
					pattern:
						/\b(?:arms|backpack|blue|bracelet|cancel|clear|cloak|criminal|earrings|enemy|facialhair|friend|friendly|gloves|gray|grey|ground|hair|head|innerlegs|innertorso|innocent|lefthand|middletorso|murderer|neck|nonfriendly|onehandedsecondary|outerlegs|outertorso|pants|red|righthand|ring|self|shirt|shoes|talisman|waist)\b/i,
					alias: 'function'
				},
				'source-commands': {
					pattern:
						/\b(?:alliance|attack|cast|clearall|clearignore|clearjournal|clearlist|clearsysmsg|createlist|createtimer|dclick|dclicktype|dclickvar|dress|dressconfig|drop|droprelloc|emote|getlabel|guild|gumpclose|gumpresponse|hotkey|ignore|lasttarget|lift|lifttype|menu|menuresponse|msg|org|organize|organizer|overhead|pause|poplist|potion|promptresponse|pushlist|removelist|removetimer|rename|restock|say|scav|scavenger|script|setability|setlasttarget|setskill|settimer|setvar|sysmsg|target|targetloc|targetrelloc|targettype|undress|unignore|unsetvar|useobject|useonce|useskill|usetype|virtue|wait|waitforgump|waitformenu|waitforprompt|waitforstat|waitforsysmsg|waitfortarget|walk|wfsysmsg|wft|whisper|yell)\b/,
					alias: 'function'
				},
				'tag-name': {
					pattern: /(^\{%-?\s*)\w+/,
					lookbehind: true,
					alias: 'keyword'
				},
				delimiter: {
					pattern: /^\{[{%]-?|-?[%}]\}$/,
					alias: 'punctuation'
				},
				function:
					/\b(?:atlist|close|closest|count|counter|counttype|dead|dex|diffhits|diffmana|diffstam|diffweight|find|findbuff|finddebuff|findlayer|findtype|findtypelist|followers|gumpexists|hidden|hits|hp|hue|human|humanoid|ingump|inlist|insysmessage|insysmsg|int|invul|lhandempty|list|listexists|mana|maxhits|maxhp|maxmana|maxstam|maxweight|monster|mounted|name|next|noto|paralyzed|poisoned|position|prev|previous|queued|rand|random|rhandempty|skill|stam|str|targetexists|timer|timerexists|varexist|warmode|weight)\b/,
				keyword:
					/\b(?:and|as|break|continue|else|elseif|endfor|endif|endwhile|for|if|loop|not|or|replay|stop|while)\b/,
				boolean: /\b(?:false|null|true)\b/,
				number: /\b0x[\dA-Fa-f]+|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:[Ee][-+]?\d+)?/,
				operator: [
					{
						pattern:
							/(\s)(?:and|b-and|b-or|b-xor|ends with|in|is|matches|not|or|same as|starts with)(?=\s)/,
						lookbehind: true
					},
					/[=<>]=?|!=|\*\*?|\/\/?|\?:?|[-+~%|]/
				],
				punctuation: /[()\[\]{}:.,]/
			};
		}
	}
});

// node_modules/refractor/lang/uri.js
var require_uri = __commonJS({
	'node_modules/refractor/lang/uri.js'(exports, module2) {
		'use strict';
		module2.exports = uri;
		uri.displayName = 'uri';
		uri.aliases = ['url'];
		function uri(Prism) {
			Prism.languages.uri = {
				scheme: {
					pattern: /^[a-z][a-z0-9+.-]*:/im,
					greedy: true,
					inside: {
						'scheme-delimiter': /:$/
					}
				},
				fragment: {
					pattern: /#[\w\-.~!$&'()*+,;=%:@/?]*/,
					inside: {
						'fragment-delimiter': /^#/
					}
				},
				query: {
					pattern: /\?[\w\-.~!$&'()*+,;=%:@/?]*/,
					inside: {
						'query-delimiter': {
							pattern: /^\?/,
							greedy: true
						},
						'pair-delimiter': /[&;]/,
						pair: {
							pattern: /^[^=][\s\S]*/,
							inside: {
								key: /^[^=]+/,
								value: {
									pattern: /(^=)[\s\S]+/,
									lookbehind: true
								}
							}
						}
					}
				},
				authority: {
					pattern: RegExp(
						/^\/\//.source +
							/(?:[\w\-.~!$&'()*+,;=%:]*@)?/.source +
							('(?:' +
								/\[(?:[0-9a-fA-F:.]{2,48}|v[0-9a-fA-F]+\.[\w\-.~!$&'()*+,;=]+)\]/.source +
								'|' +
								/[\w\-.~!$&'()*+,;=%]*/.source +
								')') +
							/(?::\d*)?/.source,
						'm'
					),
					inside: {
						'authority-delimiter': /^\/\//,
						'user-info-segment': {
							pattern: /^[\w\-.~!$&'()*+,;=%:]*@/,
							inside: {
								'user-info-delimiter': /@$/,
								'user-info': /^[\w\-.~!$&'()*+,;=%:]+/
							}
						},
						'port-segment': {
							pattern: /:\d*$/,
							inside: {
								'port-delimiter': /^:/,
								port: /^\d+/
							}
						},
						host: {
							pattern: /[\s\S]+/,
							inside: {
								'ip-literal': {
									pattern: /^\[[\s\S]+\]$/,
									inside: {
										'ip-literal-delimiter': /^\[|\]$/,
										'ipv-future': /^v[\s\S]+/,
										'ipv6-address': /^[\s\S]+/
									}
								},
								'ipv4-address': /^(?:(?:[03-9]\d?|[12]\d{0,2})\.){3}(?:[03-9]\d?|[12]\d{0,2})$/
							}
						}
					}
				},
				path: {
					pattern: /^[\w\-.~!$&'()*+,;=%:@/]+/m,
					inside: {
						'path-separator': /\//
					}
				}
			};
			Prism.languages.url = Prism.languages.uri;
		}
	}
});

// node_modules/refractor/lang/v.js
var require_v = __commonJS({
	'node_modules/refractor/lang/v.js'(exports, module2) {
		'use strict';
		module2.exports = v;
		v.displayName = 'v';
		v.aliases = [];
		function v(Prism) {
			(function (Prism2) {
				var interpolationExpr = {
					pattern: /[\s\S]+/,
					inside: null
				};
				Prism2.languages.v = Prism2.languages.extend('clike', {
					string: {
						pattern: /r?(["'])(?:\\(?:\r\n|[\s\S])|(?!\1)[^\\\r\n])*\1/,
						alias: 'quoted-string',
						greedy: true,
						inside: {
							interpolation: {
								pattern:
									/((?:^|[^\\])(?:\\{2})*)\$(?:\{[^{}]*\}|\w+(?:\.\w+(?:\([^\(\)]*\))?|\[[^\[\]]+\])*)/,
								lookbehind: true,
								inside: {
									'interpolation-variable': {
										pattern: /^\$\w[\s\S]*$/,
										alias: 'variable'
									},
									'interpolation-punctuation': {
										pattern: /^\$\{|\}$/,
										alias: 'punctuation'
									},
									'interpolation-expression': interpolationExpr
								}
							}
						}
					},
					'class-name': {
						pattern: /(\b(?:enum|interface|struct|type)\s+)(?:C\.)?\w+/,
						lookbehind: true
					},
					keyword:
						/(?:\b(?:__global|as|asm|assert|atomic|break|chan|const|continue|defer|else|embed|enum|fn|for|go(?:to)?|if|import|in|interface|is|lock|match|module|mut|none|or|pub|return|rlock|select|shared|sizeof|static|struct|type(?:of)?|union|unsafe)|\$(?:else|for|if)|#(?:flag|include))\b/,
					number:
						/\b(?:0x[a-f\d]+(?:_[a-f\d]+)*|0b[01]+(?:_[01]+)*|0o[0-7]+(?:_[0-7]+)*|\d+(?:_\d+)*(?:\.\d+(?:_\d+)*)?)\b/i,
					operator:
						/~|\?|[*\/%^!=]=?|\+[=+]?|-[=-]?|\|[=|]?|&(?:=|&|\^=?)?|>(?:>=?|=)?|<(?:<=?|=|-)?|:=|\.\.\.?/,
					builtin:
						/\b(?:any(?:_float|_int)?|bool|byte(?:ptr)?|charptr|f(?:32|64)|i(?:8|16|64|128|nt)|rune|size_t|string|u(?:16|32|64|128)|voidptr)\b/
				});
				interpolationExpr.inside = Prism2.languages.v;
				Prism2.languages.insertBefore('v', 'string', {
					char: {
						pattern: /`(?:\\`|\\?[^`]{1,2})`/,
						alias: 'rune'
					}
				});
				Prism2.languages.insertBefore('v', 'operator', {
					attribute: {
						pattern:
							/(^[\t ]*)\[(?:deprecated|direct_array_access|flag|inline|live|ref_only|typedef|unsafe_fn|windows_stdcall)\]/m,
						lookbehind: true,
						alias: 'annotation',
						inside: {
							punctuation: /[\[\]]/,
							keyword: /\w+/
						}
					},
					generic: {
						pattern: /<\w+>(?=\s*[\)\{])/,
						inside: {
							punctuation: /[<>]/,
							'class-name': /\w+/
						}
					}
				});
				Prism2.languages.insertBefore('v', 'function', {
					'generic-function': {
						pattern: /\b\w+\s*<\w+>(?=\()/,
						inside: {
							function: /^\w+/,
							generic: {
								pattern: /<\w+>/,
								inside: Prism2.languages.v.generic.inside
							}
						}
					}
				});
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/vala.js
var require_vala = __commonJS({
	'node_modules/refractor/lang/vala.js'(exports, module2) {
		'use strict';
		module2.exports = vala;
		vala.displayName = 'vala';
		vala.aliases = [];
		function vala(Prism) {
			Prism.languages.vala = Prism.languages.extend('clike', {
				'class-name': [
					{
						pattern: /\b[A-Z]\w*(?:\.\w+)*\b(?=(?:\?\s+|\*?\s+\*?)\w)/,
						inside: {
							punctuation: /\./
						}
					},
					{
						pattern: /(\[)[A-Z]\w*(?:\.\w+)*\b/,
						lookbehind: true,
						inside: {
							punctuation: /\./
						}
					},
					{
						pattern: /(\b(?:class|interface)\s+[A-Z]\w*(?:\.\w+)*\s*:\s*)[A-Z]\w*(?:\.\w+)*\b/,
						lookbehind: true,
						inside: {
							punctuation: /\./
						}
					},
					{
						pattern:
							/((?:\b(?:class|enum|interface|new|struct)\s+)|(?:catch\s+\())[A-Z]\w*(?:\.\w+)*\b/,
						lookbehind: true,
						inside: {
							punctuation: /\./
						}
					}
				],
				keyword:
					/\b(?:abstract|as|assert|async|base|bool|break|case|catch|char|class|const|construct|continue|default|delegate|delete|do|double|dynamic|else|ensures|enum|errordomain|extern|finally|float|for|foreach|get|if|in|inline|int|int16|int32|int64|int8|interface|internal|is|lock|long|namespace|new|null|out|override|owned|params|private|protected|public|ref|requires|return|set|short|signal|sizeof|size_t|ssize_t|static|string|struct|switch|this|throw|throws|try|typeof|uchar|uint|uint16|uint32|uint64|uint8|ulong|unichar|unowned|ushort|using|value|var|virtual|void|volatile|weak|while|yield)\b/i,
				function: /\b\w+(?=\s*\()/,
				number: /(?:\b0x[\da-f]+\b|(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:e[+-]?\d+)?)(?:f|u?l?)?/i,
				operator: /\+\+|--|&&|\|\||<<=?|>>=?|=>|->|~|[+\-*\/%&^|=!<>]=?|\?\??|\.\.\./,
				punctuation: /[{}[\];(),.:]/,
				constant: /\b[A-Z0-9_]+\b/
			});
			Prism.languages.insertBefore('vala', 'string', {
				'raw-string': {
					pattern: /"""[\s\S]*?"""/,
					greedy: true,
					alias: 'string'
				},
				'template-string': {
					pattern: /@"[\s\S]*?"/,
					greedy: true,
					inside: {
						interpolation: {
							pattern: /\$(?:\([^)]*\)|[a-zA-Z]\w*)/,
							inside: {
								delimiter: {
									pattern: /^\$\(?|\)$/,
									alias: 'punctuation'
								},
								rest: Prism.languages.vala
							}
						},
						string: /[\s\S]+/
					}
				}
			});
			Prism.languages.insertBefore('vala', 'keyword', {
				regex: {
					pattern:
						/\/(?:\[(?:[^\]\\\r\n]|\\.)*\]|\\.|[^/\\\[\r\n])+\/[imsx]{0,4}(?=\s*(?:$|[\r\n,.;})\]]))/,
					greedy: true,
					inside: {
						'regex-source': {
							pattern: /^(\/)[\s\S]+(?=\/[a-z]*$)/,
							lookbehind: true,
							alias: 'language-regex',
							inside: Prism.languages.regex
						},
						'regex-delimiter': /^\//,
						'regex-flags': /^[a-z]+$/
					}
				}
			});
		}
	}
});

// node_modules/refractor/lang/velocity.js
var require_velocity = __commonJS({
	'node_modules/refractor/lang/velocity.js'(exports, module2) {
		'use strict';
		module2.exports = velocity;
		velocity.displayName = 'velocity';
		velocity.aliases = [];
		function velocity(Prism) {
			(function (Prism2) {
				Prism2.languages.velocity = Prism2.languages.extend('markup', {});
				var velocity2 = {
					variable: {
						pattern:
							/(^|[^\\](?:\\\\)*)\$!?(?:[a-z][\w-]*(?:\([^)]*\))?(?:\.[a-z][\w-]*(?:\([^)]*\))?|\[[^\]]+\])*|\{[^}]+\})/i,
						lookbehind: true,
						inside: {}
					},
					string: {
						pattern: /"[^"]*"|'[^']*'/,
						greedy: true
					},
					number: /\b\d+\b/,
					boolean: /\b(?:false|true)\b/,
					operator: /[=!<>]=?|[+*/%-]|&&|\|\||\.\.|\b(?:eq|g[et]|l[et]|n(?:e|ot))\b/,
					punctuation: /[(){}[\]:,.]/
				};
				velocity2.variable.inside = {
					string: velocity2['string'],
					function: {
						pattern: /([^\w-])[a-z][\w-]*(?=\()/,
						lookbehind: true
					},
					number: velocity2['number'],
					boolean: velocity2['boolean'],
					punctuation: velocity2['punctuation']
				};
				Prism2.languages.insertBefore('velocity', 'comment', {
					unparsed: {
						pattern: /(^|[^\\])#\[\[[\s\S]*?\]\]#/,
						lookbehind: true,
						greedy: true,
						inside: {
							punctuation: /^#\[\[|\]\]#$/
						}
					},
					'velocity-comment': [
						{
							pattern: /(^|[^\\])#\*[\s\S]*?\*#/,
							lookbehind: true,
							greedy: true,
							alias: 'comment'
						},
						{
							pattern: /(^|[^\\])##.*/,
							lookbehind: true,
							greedy: true,
							alias: 'comment'
						}
					],
					directive: {
						pattern:
							/(^|[^\\](?:\\\\)*)#@?(?:[a-z][\w-]*|\{[a-z][\w-]*\})(?:\s*\((?:[^()]|\([^()]*\))*\))?/i,
						lookbehind: true,
						inside: {
							keyword: {
								pattern: /^#@?(?:[a-z][\w-]*|\{[a-z][\w-]*\})|\bin\b/,
								inside: {
									punctuation: /[{}]/
								}
							},
							rest: velocity2
						}
					},
					variable: velocity2['variable']
				});
				Prism2.languages.velocity['tag'].inside['attr-value'].inside.rest =
					Prism2.languages.velocity;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/verilog.js
var require_verilog = __commonJS({
	'node_modules/refractor/lang/verilog.js'(exports, module2) {
		'use strict';
		module2.exports = verilog;
		verilog.displayName = 'verilog';
		verilog.aliases = [];
		function verilog(Prism) {
			Prism.languages.verilog = {
				comment: {
					pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
					greedy: true
				},
				string: {
					pattern: /"(?:\\(?:\r\n|[\s\S])|[^"\\\r\n])*"/,
					greedy: true
				},
				'kernel-function': {
					pattern: /\B\$\w+\b/,
					alias: 'property'
				},
				constant: /\B`\w+\b/,
				function: /\b\w+(?=\()/,
				keyword:
					/\b(?:alias|and|assert|assign|assume|automatic|before|begin|bind|bins|binsof|bit|break|buf|bufif0|bufif1|byte|case|casex|casez|cell|chandle|class|clocking|cmos|config|const|constraint|context|continue|cover|covergroup|coverpoint|cross|deassign|default|defparam|design|disable|dist|do|edge|else|end|endcase|endclass|endclocking|endconfig|endfunction|endgenerate|endgroup|endinterface|endmodule|endpackage|endprimitive|endprogram|endproperty|endsequence|endspecify|endtable|endtask|enum|event|expect|export|extends|extern|final|first_match|for|force|foreach|forever|fork|forkjoin|function|generate|genvar|highz0|highz1|if|iff|ifnone|ignore_bins|illegal_bins|import|incdir|include|initial|inout|input|inside|instance|int|integer|interface|intersect|join|join_any|join_none|large|liblist|library|local|localparam|logic|longint|macromodule|matches|medium|modport|module|nand|negedge|new|nmos|nor|noshowcancelled|not|notif0|notif1|null|or|output|package|packed|parameter|pmos|posedge|primitive|priority|program|property|protected|pull0|pull1|pulldown|pullup|pulsestyle_ondetect|pulsestyle_onevent|pure|rand|randc|randcase|randsequence|rcmos|real|realtime|ref|reg|release|repeat|return|rnmos|rpmos|rtran|rtranif0|rtranif1|scalared|sequence|shortint|shortreal|showcancelled|signed|small|solve|specify|specparam|static|string|strong0|strong1|struct|super|supply0|supply1|table|tagged|task|this|throughout|time|timeprecision|timeunit|tran|tranif0|tranif1|tri|tri0|tri1|triand|trior|trireg|type|typedef|union|unique|unsigned|use|uwire|var|vectored|virtual|void|wait|wait_order|wand|weak0|weak1|while|wildcard|wire|with|within|wor|xnor|xor)\b/,
				important: /\b(?:always|always_comb|always_ff|always_latch)\b(?: *@)?/,
				number: /\B##?\d+|(?:\b\d+)?'[odbh] ?[\da-fzx_?]+|\b(?:\d*[._])?\d+(?:e[-+]?\d+)?/i,
				operator: /[-+{}^~%*\/?=!<>&|]+/,
				punctuation: /[[\];(),.:]/
			};
		}
	}
});

// node_modules/refractor/lang/vhdl.js
var require_vhdl = __commonJS({
	'node_modules/refractor/lang/vhdl.js'(exports, module2) {
		'use strict';
		module2.exports = vhdl;
		vhdl.displayName = 'vhdl';
		vhdl.aliases = [];
		function vhdl(Prism) {
			Prism.languages.vhdl = {
				comment: /--.+/,
				'vhdl-vectors': {
					pattern: /\b[oxb]"[\da-f_]+"|"[01uxzwlh-]+"/i,
					alias: 'number'
				},
				'quoted-function': {
					pattern: /"\S+?"(?=\()/,
					alias: 'function'
				},
				string: /"(?:[^\\"\r\n]|\\(?:\r\n|[\s\S]))*"/,
				constant: /\b(?:library|use)\b/i,
				keyword:
					/\b(?:'active|'ascending|'base|'delayed|'driving|'driving_value|'event|'high|'image|'instance_name|'last_active|'last_event|'last_value|'left|'leftof|'length|'low|'path_name|'pos|'pred|'quiet|'range|'reverse_range|'right|'rightof|'simple_name|'stable|'succ|'transaction|'val|'value|access|after|alias|all|architecture|array|assert|attribute|begin|block|body|buffer|bus|case|component|configuration|constant|disconnect|downto|else|elsif|end|entity|exit|file|for|function|generate|generic|group|guarded|if|impure|in|inertial|inout|is|label|library|linkage|literal|loop|map|new|next|null|of|on|open|others|out|package|port|postponed|procedure|process|pure|range|record|register|reject|report|return|select|severity|shared|signal|subtype|then|to|transport|type|unaffected|units|until|use|variable|wait|when|while|with)\b/i,
				boolean: /\b(?:false|true)\b/i,
				function: /\w+(?=\()/,
				number: /'[01uxzwlh-]'|\b(?:\d+#[\da-f_.]+#|\d[\d_.]*)(?:e[-+]?\d+)?/i,
				operator:
					/[<>]=?|:=|[-+*/&=]|\b(?:abs|and|mod|nand|nor|not|or|rem|rol|ror|sla|sll|sra|srl|xnor|xor)\b/i,
				punctuation: /[{}[\];(),.:]/
			};
		}
	}
});

// node_modules/refractor/lang/vim.js
var require_vim = __commonJS({
	'node_modules/refractor/lang/vim.js'(exports, module2) {
		'use strict';
		module2.exports = vim;
		vim.displayName = 'vim';
		vim.aliases = [];
		function vim(Prism) {
			Prism.languages.vim = {
				string: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\r\n]|'')*'/,
				comment: /".*/,
				function: /\b\w+(?=\()/,
				keyword:
					/\b(?:N|Next|P|Print|X|XMLent|XMLns|ab|abbreviate|abc|abclear|abo|aboveleft|al|all|ar|arga|argadd|argd|argdelete|argdo|arge|argedit|argg|argglobal|argl|arglocal|args|argu|argument|as|ascii|b|bN|bNext|ba|bad|badd|ball|bd|bdelete|be|bel|belowright|bf|bfirst|bl|blast|bm|bmodified|bn|bnext|bo|botright|bp|bprevious|br|brea|break|breaka|breakadd|breakd|breakdel|breakl|breaklist|brewind|bro|browse|bufdo|buffer|buffers|bun|bunload|bw|bwipeout|c|cN|cNext|cNfcNfile|ca|cabbrev|cabc|cabclear|cad|caddb|caddbuffer|caddexpr|caddf|caddfile|cal|call|cat|catch|cb|cbuffer|cc|ccl|cclose|cd|ce|center|cex|cexpr|cf|cfile|cfir|cfirst|cg|cgetb|cgetbuffer|cgete|cgetexpr|cgetfile|change|changes|chd|chdir|che|checkpath|checkt|checktime|cl|cla|clast|clist|clo|close|cmapc|cmapclear|cn|cnew|cnewer|cnext|cnf|cnfile|cnorea|cnoreabbrev|co|col|colder|colo|colorscheme|comc|comclear|comp|compiler|con|conf|confirm|continue|cope|copen|copy|cp|cpf|cpfile|cprevious|cq|cquit|cr|crewind|cu|cuna|cunabbrev|cunmap|cw|cwindow|d|debugg|debuggreedy|delc|delcommand|delete|delf|delfunction|delm|delmarks|di|diffg|diffget|diffoff|diffpatch|diffpu|diffput|diffsplit|diffthis|diffu|diffupdate|dig|digraphs|display|dj|djump|dl|dlist|dr|drop|ds|dsearch|dsp|dsplit|e|earlier|echoe|echoerr|echom|echomsg|echon|edit|el|else|elsei|elseif|em|emenu|en|endf|endfo|endfor|endfun|endfunction|endif|endt|endtry|endw|endwhile|ene|enew|ex|exi|exit|exu|exusage|f|file|files|filetype|fin|fina|finally|find|fini|finish|fir|first|fix|fixdel|fo|fold|foldc|foldclose|foldd|folddoc|folddoclosed|folddoopen|foldo|foldopen|for|fu|fun|function|go|goto|gr|grep|grepa|grepadd|h|ha|hardcopy|help|helpf|helpfind|helpg|helpgrep|helpt|helptags|hid|hide|his|history|ia|iabbrev|iabc|iabclear|if|ij|ijump|il|ilist|imapc|imapclear|in|inorea|inoreabbrev|isearch|isp|isplit|iu|iuna|iunabbrev|iunmap|j|join|ju|jumps|k|kee|keepalt|keepj|keepjumps|keepmarks|l|lN|lNext|lNf|lNfile|la|lad|laddb|laddbuffer|laddexpr|laddf|laddfile|lan|language|last|later|lb|lbuffer|lc|lcd|lch|lchdir|lcl|lclose|left|lefta|leftabove|let|lex|lexpr|lf|lfile|lfir|lfirst|lg|lgetb|lgetbuffer|lgete|lgetexpr|lgetfile|lgr|lgrep|lgrepa|lgrepadd|lh|lhelpgrep|list|ll|lla|llast|lli|llist|lm|lmak|lmake|lmap|lmapc|lmapclear|ln|lne|lnew|lnewer|lnext|lnf|lnfile|lnoremap|lo|loadview|loc|lockmarks|lockv|lockvar|lol|lolder|lop|lopen|lp|lpf|lpfile|lprevious|lr|lrewind|ls|lt|ltag|lu|lunmap|lv|lvimgrep|lvimgrepa|lvimgrepadd|lw|lwindow|m|ma|mak|make|mark|marks|mat|match|menut|menutranslate|mk|mkexrc|mks|mksession|mksp|mkspell|mkv|mkvie|mkview|mkvimrc|mod|mode|move|mz|mzf|mzfile|mzscheme|n|nbkey|new|next|nmapc|nmapclear|noh|nohlsearch|norea|noreabbrev|nu|number|nun|nunmap|o|omapc|omapclear|on|only|open|opt|options|ou|ounmap|p|pc|pclose|pe|ped|pedit|perl|perld|perldo|po|pop|popu|popup|pp|ppop|pre|preserve|prev|previous|print|prof|profd|profdel|profile|promptf|promptfind|promptr|promptrepl|ps|psearch|ptN|ptNext|pta|ptag|ptf|ptfirst|ptj|ptjump|ptl|ptlast|ptn|ptnext|ptp|ptprevious|ptr|ptrewind|pts|ptselect|pu|put|pw|pwd|py|pyf|pyfile|python|q|qa|qall|quit|quita|quitall|r|read|rec|recover|red|redi|redir|redo|redr|redraw|redraws|redrawstatus|reg|registers|res|resize|ret|retab|retu|return|rew|rewind|ri|right|rightb|rightbelow|ru|rub|ruby|rubyd|rubydo|rubyf|rubyfile|runtime|rv|rviminfo|sN|sNext|sa|sal|sall|san|sandbox|sargument|sav|saveas|sb|sbN|sbNext|sba|sball|sbf|sbfirst|sbl|sblast|sbm|sbmodified|sbn|sbnext|sbp|sbprevious|sbr|sbrewind|sbuffer|scrip|scripte|scriptencoding|scriptnames|se|set|setf|setfiletype|setg|setglobal|setl|setlocal|sf|sfind|sfir|sfirst|sh|shell|sign|sil|silent|sim|simalt|sl|sla|slast|sleep|sm|smagic|smap|smapc|smapclear|sme|smenu|sn|snext|sni|sniff|sno|snomagic|snor|snoremap|snoreme|snoremenu|so|sor|sort|source|sp|spe|spelld|spelldump|spellgood|spelli|spellinfo|spellr|spellrepall|spellu|spellundo|spellw|spellwrong|split|spr|sprevious|sre|srewind|st|sta|stag|star|startg|startgreplace|startinsert|startr|startreplace|stj|stjump|stop|stopi|stopinsert|sts|stselect|sun|sunhide|sunm|sunmap|sus|suspend|sv|sview|syncbind|t|tN|tNext|ta|tab|tabN|tabNext|tabc|tabclose|tabd|tabdo|tabe|tabedit|tabf|tabfind|tabfir|tabfirst|tabl|tablast|tabm|tabmove|tabn|tabnew|tabnext|tabo|tabonly|tabp|tabprevious|tabr|tabrewind|tabs|tag|tags|tc|tcl|tcld|tcldo|tclf|tclfile|te|tearoff|tf|tfirst|th|throw|tj|tjump|tl|tlast|tm|tmenu|tn|tnext|to|topleft|tp|tprevious|tr|trewind|try|ts|tselect|tu|tunmenu|u|una|unabbreviate|undo|undoj|undojoin|undol|undolist|unh|unhide|unlet|unlo|unlockvar|unm|unmap|up|update|ve|verb|verbose|version|vert|vertical|vi|vie|view|vim|vimgrep|vimgrepa|vimgrepadd|visual|viu|viusage|vmapc|vmapclear|vne|vnew|vs|vsplit|vu|vunmap|w|wN|wNext|wa|wall|wh|while|win|winc|wincmd|windo|winp|winpos|winsize|wn|wnext|wp|wprevious|wq|wqa|wqall|write|ws|wsverb|wv|wviminfo|x|xa|xall|xit|xm|xmap|xmapc|xmapclear|xme|xmenu|xn|xnoremap|xnoreme|xnoremenu|xu|xunmap|y|yank)\b/,
				builtin:
					/\b(?:acd|ai|akm|aleph|allowrevins|altkeymap|ambiwidth|ambw|anti|antialias|arab|arabic|arabicshape|ari|arshape|autochdir|autocmd|autoindent|autoread|autowrite|autowriteall|aw|awa|background|backspace|backup|backupcopy|backupdir|backupext|backupskip|balloondelay|ballooneval|balloonexpr|bdir|bdlay|beval|bex|bexpr|bg|bh|bin|binary|biosk|bioskey|bk|bkc|bomb|breakat|brk|browsedir|bs|bsdir|bsk|bt|bufhidden|buflisted|buftype|casemap|ccv|cdpath|cedit|cfu|ch|charconvert|ci|cin|cindent|cink|cinkeys|cino|cinoptions|cinw|cinwords|clipboard|cmdheight|cmdwinheight|cmp|cms|columns|com|comments|commentstring|compatible|complete|completefunc|completeopt|consk|conskey|copyindent|cot|cpo|cpoptions|cpt|cscopepathcomp|cscopeprg|cscopequickfix|cscopetag|cscopetagorder|cscopeverbose|cspc|csprg|csqf|cst|csto|csverb|cuc|cul|cursorcolumn|cursorline|cwh|debug|deco|def|define|delcombine|dex|dg|dict|dictionary|diff|diffexpr|diffopt|digraph|dip|dir|directory|dy|ea|ead|eadirection|eb|ed|edcompatible|ef|efm|ei|ek|enc|encoding|endofline|eol|ep|equalalways|equalprg|errorbells|errorfile|errorformat|esckeys|et|eventignore|expandtab|exrc|fcl|fcs|fdc|fde|fdi|fdl|fdls|fdm|fdn|fdo|fdt|fen|fenc|fencs|fex|ff|ffs|fileencoding|fileencodings|fileformat|fileformats|fillchars|fk|fkmap|flp|fml|fmr|foldcolumn|foldenable|foldexpr|foldignore|foldlevel|foldlevelstart|foldmarker|foldmethod|foldminlines|foldnestmax|foldtext|formatexpr|formatlistpat|formatoptions|formatprg|fp|fs|fsync|ft|gcr|gd|gdefault|gfm|gfn|gfs|gfw|ghr|gp|grepformat|grepprg|gtl|gtt|guicursor|guifont|guifontset|guifontwide|guiheadroom|guioptions|guipty|guitablabel|guitabtooltip|helpfile|helpheight|helplang|hf|hh|hi|hidden|highlight|hk|hkmap|hkmapp|hkp|hl|hlg|hls|hlsearch|ic|icon|iconstring|ignorecase|im|imactivatekey|imak|imc|imcmdline|imd|imdisable|imi|iminsert|ims|imsearch|inc|include|includeexpr|incsearch|inde|indentexpr|indentkeys|indk|inex|inf|infercase|insertmode|invacd|invai|invakm|invallowrevins|invaltkeymap|invanti|invantialias|invar|invarab|invarabic|invarabicshape|invari|invarshape|invautochdir|invautoindent|invautoread|invautowrite|invautowriteall|invaw|invawa|invbackup|invballooneval|invbeval|invbin|invbinary|invbiosk|invbioskey|invbk|invbl|invbomb|invbuflisted|invcf|invci|invcin|invcindent|invcompatible|invconfirm|invconsk|invconskey|invcopyindent|invcp|invcscopetag|invcscopeverbose|invcst|invcsverb|invcuc|invcul|invcursorcolumn|invcursorline|invdeco|invdelcombine|invdg|invdiff|invdigraph|invdisable|invea|inveb|inved|invedcompatible|invek|invendofline|inveol|invequalalways|inverrorbells|invesckeys|invet|invex|invexpandtab|invexrc|invfen|invfk|invfkmap|invfoldenable|invgd|invgdefault|invguipty|invhid|invhidden|invhk|invhkmap|invhkmapp|invhkp|invhls|invhlsearch|invic|invicon|invignorecase|invim|invimc|invimcmdline|invimd|invincsearch|invinf|invinfercase|invinsertmode|invis|invjoinspaces|invjs|invlazyredraw|invlbr|invlinebreak|invlisp|invlist|invloadplugins|invlpl|invlz|invma|invmacatsui|invmagic|invmh|invml|invmod|invmodeline|invmodifiable|invmodified|invmore|invmousef|invmousefocus|invmousehide|invnu|invnumber|invodev|invopendevice|invpaste|invpi|invpreserveindent|invpreviewwindow|invprompt|invpvw|invreadonly|invremap|invrestorescreen|invrevins|invri|invrightleft|invrightleftcmd|invrl|invrlc|invro|invrs|invru|invruler|invsb|invsc|invscb|invscrollbind|invscs|invsecure|invsft|invshellslash|invshelltemp|invshiftround|invshortname|invshowcmd|invshowfulltag|invshowmatch|invshowmode|invsi|invsm|invsmartcase|invsmartindent|invsmarttab|invsmd|invsn|invsol|invspell|invsplitbelow|invsplitright|invspr|invsr|invssl|invsta|invstartofline|invstmp|invswapfile|invswf|invta|invtagbsearch|invtagrelative|invtagstack|invtbi|invtbidi|invtbs|invtermbidi|invterse|invtextauto|invtextmode|invtf|invtgst|invtildeop|invtimeout|invtitle|invto|invtop|invtr|invttimeout|invttybuiltin|invttyfast|invtx|invvb|invvisualbell|invwa|invwarn|invwb|invweirdinvert|invwfh|invwfw|invwildmenu|invwinfixheight|invwinfixwidth|invwiv|invwmnu|invwrap|invwrapscan|invwrite|invwriteany|invwritebackup|invws|isf|isfname|isi|isident|isk|iskeyword|isprint|joinspaces|js|key|keymap|keymodel|keywordprg|km|kmp|kp|langmap|langmenu|laststatus|lazyredraw|lbr|lcs|linebreak|lines|linespace|lisp|lispwords|listchars|loadplugins|lpl|lsp|lz|macatsui|magic|makeef|makeprg|matchpairs|matchtime|maxcombine|maxfuncdepth|maxmapdepth|maxmem|maxmempattern|maxmemtot|mco|mef|menuitems|mfd|mh|mis|mkspellmem|ml|mls|mm|mmd|mmp|mmt|modeline|modelines|modifiable|modified|more|mouse|mousef|mousefocus|mousehide|mousem|mousemodel|mouses|mouseshape|mouset|mousetime|mp|mps|msm|mzq|mzquantum|nf|noacd|noai|noakm|noallowrevins|noaltkeymap|noanti|noantialias|noar|noarab|noarabic|noarabicshape|noari|noarshape|noautochdir|noautoindent|noautoread|noautowrite|noautowriteall|noaw|noawa|nobackup|noballooneval|nobeval|nobin|nobinary|nobiosk|nobioskey|nobk|nobl|nobomb|nobuflisted|nocf|noci|nocin|nocindent|nocompatible|noconfirm|noconsk|noconskey|nocopyindent|nocp|nocscopetag|nocscopeverbose|nocst|nocsverb|nocuc|nocul|nocursorcolumn|nocursorline|nodeco|nodelcombine|nodg|nodiff|nodigraph|nodisable|noea|noeb|noed|noedcompatible|noek|noendofline|noeol|noequalalways|noerrorbells|noesckeys|noet|noex|noexpandtab|noexrc|nofen|nofk|nofkmap|nofoldenable|nogd|nogdefault|noguipty|nohid|nohidden|nohk|nohkmap|nohkmapp|nohkp|nohls|noic|noicon|noignorecase|noim|noimc|noimcmdline|noimd|noincsearch|noinf|noinfercase|noinsertmode|nois|nojoinspaces|nojs|nolazyredraw|nolbr|nolinebreak|nolisp|nolist|noloadplugins|nolpl|nolz|noma|nomacatsui|nomagic|nomh|noml|nomod|nomodeline|nomodifiable|nomodified|nomore|nomousef|nomousefocus|nomousehide|nonu|nonumber|noodev|noopendevice|nopaste|nopi|nopreserveindent|nopreviewwindow|noprompt|nopvw|noreadonly|noremap|norestorescreen|norevins|nori|norightleft|norightleftcmd|norl|norlc|noro|nors|noru|noruler|nosb|nosc|noscb|noscrollbind|noscs|nosecure|nosft|noshellslash|noshelltemp|noshiftround|noshortname|noshowcmd|noshowfulltag|noshowmatch|noshowmode|nosi|nosm|nosmartcase|nosmartindent|nosmarttab|nosmd|nosn|nosol|nospell|nosplitbelow|nosplitright|nospr|nosr|nossl|nosta|nostartofline|nostmp|noswapfile|noswf|nota|notagbsearch|notagrelative|notagstack|notbi|notbidi|notbs|notermbidi|noterse|notextauto|notextmode|notf|notgst|notildeop|notimeout|notitle|noto|notop|notr|nottimeout|nottybuiltin|nottyfast|notx|novb|novisualbell|nowa|nowarn|nowb|noweirdinvert|nowfh|nowfw|nowildmenu|nowinfixheight|nowinfixwidth|nowiv|nowmnu|nowrap|nowrapscan|nowrite|nowriteany|nowritebackup|nows|nrformats|numberwidth|nuw|odev|oft|ofu|omnifunc|opendevice|operatorfunc|opfunc|osfiletype|pa|para|paragraphs|paste|pastetoggle|patchexpr|patchmode|path|pdev|penc|pex|pexpr|pfn|ph|pheader|pi|pm|pmbcs|pmbfn|popt|preserveindent|previewheight|previewwindow|printdevice|printencoding|printexpr|printfont|printheader|printmbcharset|printmbfont|printoptions|prompt|pt|pumheight|pvh|pvw|qe|quoteescape|readonly|remap|report|restorescreen|revins|rightleft|rightleftcmd|rl|rlc|ro|rs|rtp|ruf|ruler|rulerformat|runtimepath|sbo|sc|scb|scr|scroll|scrollbind|scrolljump|scrolloff|scrollopt|scs|sect|sections|secure|sel|selection|selectmode|sessionoptions|sft|shcf|shellcmdflag|shellpipe|shellquote|shellredir|shellslash|shelltemp|shelltype|shellxquote|shiftround|shiftwidth|shm|shortmess|shortname|showbreak|showcmd|showfulltag|showmatch|showmode|showtabline|shq|si|sidescroll|sidescrolloff|siso|sj|slm|smartcase|smartindent|smarttab|smc|smd|softtabstop|sol|spc|spell|spellcapcheck|spellfile|spelllang|spellsuggest|spf|spl|splitbelow|splitright|sps|sr|srr|ss|ssl|ssop|stal|startofline|statusline|stl|stmp|su|sua|suffixes|suffixesadd|sw|swapfile|swapsync|swb|swf|switchbuf|sws|sxq|syn|synmaxcol|syntax|t_AB|t_AF|t_AL|t_CS|t_CV|t_Ce|t_Co|t_Cs|t_DL|t_EI|t_F1|t_F2|t_F3|t_F4|t_F5|t_F6|t_F7|t_F8|t_F9|t_IE|t_IS|t_K1|t_K3|t_K4|t_K5|t_K6|t_K7|t_K8|t_K9|t_KA|t_KB|t_KC|t_KD|t_KE|t_KF|t_KG|t_KH|t_KI|t_KJ|t_KK|t_KL|t_RI|t_RV|t_SI|t_Sb|t_Sf|t_WP|t_WS|t_ZH|t_ZR|t_al|t_bc|t_cd|t_ce|t_cl|t_cm|t_cs|t_da|t_db|t_dl|t_fs|t_k1|t_k2|t_k3|t_k4|t_k5|t_k6|t_k7|t_k8|t_k9|t_kB|t_kD|t_kI|t_kN|t_kP|t_kb|t_kd|t_ke|t_kh|t_kl|t_kr|t_ks|t_ku|t_le|t_mb|t_md|t_me|t_mr|t_ms|t_nd|t_op|t_se|t_so|t_sr|t_te|t_ti|t_ts|t_ue|t_us|t_ut|t_vb|t_ve|t_vi|t_vs|t_xs|tabline|tabpagemax|tabstop|tagbsearch|taglength|tagrelative|tagstack|tal|tb|tbi|tbidi|tbis|tbs|tenc|term|termbidi|termencoding|terse|textauto|textmode|textwidth|tgst|thesaurus|tildeop|timeout|timeoutlen|title|titlelen|titleold|titlestring|toolbar|toolbariconsize|top|tpm|tsl|tsr|ttimeout|ttimeoutlen|ttm|tty|ttybuiltin|ttyfast|ttym|ttymouse|ttyscroll|ttytype|tw|tx|uc|ul|undolevels|updatecount|updatetime|ut|vb|vbs|vdir|verbosefile|vfile|viewdir|viewoptions|viminfo|virtualedit|visualbell|vop|wak|warn|wb|wc|wcm|wd|weirdinvert|wfh|wfw|whichwrap|wi|wig|wildchar|wildcharm|wildignore|wildmenu|wildmode|wildoptions|wim|winaltkeys|window|winfixheight|winfixwidth|winheight|winminheight|winminwidth|winwidth|wiv|wiw|wm|wmh|wmnu|wmw|wop|wrap|wrapmargin|wrapscan|writeany|writebackup|writedelay|ww)\b/,
				number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?)\b/i,
				operator: /\|\||&&|[-+.]=?|[=!](?:[=~][#?]?)?|[<>]=?[#?]?|[*\/%?]|\b(?:is(?:not)?)\b/,
				punctuation: /[{}[\](),;:]/
			};
		}
	}
});

// node_modules/refractor/lang/visual-basic.js
var require_visual_basic = __commonJS({
	'node_modules/refractor/lang/visual-basic.js'(exports, module2) {
		'use strict';
		module2.exports = visualBasic;
		visualBasic.displayName = 'visualBasic';
		visualBasic.aliases = [];
		function visualBasic(Prism) {
			Prism.languages['visual-basic'] = {
				comment: {
					pattern: /(?:[']|REM\b)(?:[^\r\n_]|_(?:\r\n?|\n)?)*/i,
					inside: {
						keyword: /^REM/i
					}
				},
				directive: {
					pattern:
						/#(?:Const|Else|ElseIf|End|ExternalChecksum|ExternalSource|If|Region)(?:\b_[ \t]*(?:\r\n?|\n)|.)+/i,
					alias: 'property',
					greedy: true
				},
				string: {
					pattern: /\$?["](?:["]{2}|[^"])*["]C?/i,
					greedy: true
				},
				date: {
					pattern:
						/#[ \t]*(?:\d+([/-])\d+\1\d+(?:[ \t]+(?:\d+[ \t]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[ \t]*(?:AM|PM))?))?|\d+[ \t]*(?:AM|PM)|\d+:\d+(?::\d+)?(?:[ \t]*(?:AM|PM))?)[ \t]*#/i,
					alias: 'number'
				},
				number: /(?:(?:\b\d+(?:\.\d+)?|\.\d+)(?:E[+-]?\d+)?|&[HO][\dA-F]+)(?:[FRD]|U?[ILS])?/i,
				boolean: /\b(?:False|Nothing|True)\b/i,
				keyword:
					/\b(?:AddHandler|AddressOf|Alias|And(?:Also)?|As|Boolean|ByRef|Byte|ByVal|Call|Case|Catch|C(?:Bool|Byte|Char|Date|Dbl|Dec|Int|Lng|Obj|SByte|Short|Sng|Str|Type|UInt|ULng|UShort)|Char|Class|Const|Continue|Currency|Date|Decimal|Declare|Default|Delegate|Dim|DirectCast|Do|Double|Each|Else(?:If)?|End(?:If)?|Enum|Erase|Error|Event|Exit|Finally|For|Friend|Function|Get(?:Type|XMLNamespace)?|Global|GoSub|GoTo|Handles|If|Implements|Imports|In|Inherits|Integer|Interface|Is|IsNot|Let|Lib|Like|Long|Loop|Me|Mod|Module|Must(?:Inherit|Override)|My(?:Base|Class)|Namespace|Narrowing|New|Next|Not(?:Inheritable|Overridable)?|Object|Of|On|Operator|Option(?:al)?|Or(?:Else)?|Out|Overloads|Overridable|Overrides|ParamArray|Partial|Private|Property|Protected|Public|RaiseEvent|ReadOnly|ReDim|RemoveHandler|Resume|Return|SByte|Select|Set|Shadows|Shared|short|Single|Static|Step|Stop|String|Structure|Sub|SyncLock|Then|Throw|To|Try|TryCast|Type|TypeOf|U(?:Integer|Long|Short)|Until|Using|Variant|Wend|When|While|Widening|With(?:Events)?|WriteOnly|Xor)\b/i,
				operator: /[+\-*/\\^<=>&#@$%!]|\b_(?=[ \t]*[\r\n])/,
				punctuation: /[{}().,:?]/
			};
			Prism.languages.vb = Prism.languages['visual-basic'];
			Prism.languages.vba = Prism.languages['visual-basic'];
		}
	}
});

// node_modules/refractor/lang/warpscript.js
var require_warpscript = __commonJS({
	'node_modules/refractor/lang/warpscript.js'(exports, module2) {
		'use strict';
		module2.exports = warpscript;
		warpscript.displayName = 'warpscript';
		warpscript.aliases = [];
		function warpscript(Prism) {
			Prism.languages.warpscript = {
				comment: /#.*|\/\/.*|\/\*[\s\S]*?\*\//,
				string: {
					pattern: /"(?:[^"\\\r\n]|\\.)*"|'(?:[^'\\\r\n]|\\.)*'|<'(?:[^\\']|'(?!>)|\\.)*'>/,
					greedy: true
				},
				variable: /\$\S+/,
				macro: {
					pattern: /@\S+/,
					alias: 'property'
				},
				keyword:
					/\b(?:BREAK|CHECKMACRO|CONTINUE|CUDF|DEFINED|DEFINEDMACRO|EVAL|FAIL|FOR|FOREACH|FORSTEP|IFT|IFTE|MSGFAIL|NRETURN|RETHROW|RETURN|SWITCH|TRY|UDF|UNTIL|WHILE)\b/,
				number: /[+-]?\b(?:NaN|Infinity|\d+(?:\.\d*)?(?:[Ee][+-]?\d+)?|0x[\da-fA-F]+|0b[01]+)\b/,
				boolean: /\b(?:F|T|false|true)\b/,
				punctuation: /<%|%>|[{}[\]()]/,
				operator: /==|&&?|\|\|?|\*\*?|>>>?|<<|[<>!~]=?|[-/%^]|\+!?|\b(?:AND|NOT|OR)\b/
			};
		}
	}
});

// node_modules/refractor/lang/wasm.js
var require_wasm = __commonJS({
	'node_modules/refractor/lang/wasm.js'(exports, module2) {
		'use strict';
		module2.exports = wasm;
		wasm.displayName = 'wasm';
		wasm.aliases = [];
		function wasm(Prism) {
			Prism.languages.wasm = {
				comment: [
					/\(;[\s\S]*?;\)/,
					{
						pattern: /;;.*/,
						greedy: true
					}
				],
				string: {
					pattern: /"(?:\\[\s\S]|[^"\\])*"/,
					greedy: true
				},
				keyword: [
					{
						pattern: /\b(?:align|offset)=/,
						inside: {
							operator: /=/
						}
					},
					{
						pattern:
							/\b(?:(?:f32|f64|i32|i64)(?:\.(?:abs|add|and|ceil|clz|const|convert_[su]\/i(?:32|64)|copysign|ctz|demote\/f64|div(?:_[su])?|eqz?|extend_[su]\/i32|floor|ge(?:_[su])?|gt(?:_[su])?|le(?:_[su])?|load(?:(?:8|16|32)_[su])?|lt(?:_[su])?|max|min|mul|neg?|nearest|or|popcnt|promote\/f32|reinterpret\/[fi](?:32|64)|rem_[su]|rot[lr]|shl|shr_[su]|sqrt|store(?:8|16|32)?|sub|trunc(?:_[su]\/f(?:32|64))?|wrap\/i64|xor))?|memory\.(?:grow|size))\b/,
						inside: {
							punctuation: /\./
						}
					},
					/\b(?:anyfunc|block|br(?:_if|_table)?|call(?:_indirect)?|data|drop|elem|else|end|export|func|get_(?:global|local)|global|if|import|local|loop|memory|module|mut|nop|offset|param|result|return|select|set_(?:global|local)|start|table|tee_local|then|type|unreachable)\b/
				],
				variable: /\$[\w!#$%&'*+\-./:<=>?@\\^`|~]+/,
				number:
					/[+-]?\b(?:\d(?:_?\d)*(?:\.\d(?:_?\d)*)?(?:[eE][+-]?\d(?:_?\d)*)?|0x[\da-fA-F](?:_?[\da-fA-F])*(?:\.[\da-fA-F](?:_?[\da-fA-D])*)?(?:[pP][+-]?\d(?:_?\d)*)?)\b|\binf\b|\bnan(?::0x[\da-fA-F](?:_?[\da-fA-D])*)?\b/,
				punctuation: /[()]/
			};
		}
	}
});

// node_modules/refractor/lang/web-idl.js
var require_web_idl = __commonJS({
	'node_modules/refractor/lang/web-idl.js'(exports, module2) {
		'use strict';
		module2.exports = webIdl;
		webIdl.displayName = 'webIdl';
		webIdl.aliases = [];
		function webIdl(Prism) {
			(function (Prism2) {
				var id = /(?:\B-|\b_|\b)[A-Za-z][\w-]*(?![\w-])/.source;
				var type =
					'(?:' +
					/\b(?:unsigned\s+)?long\s+long(?![\w-])/.source +
					'|' +
					/\b(?:unrestricted|unsigned)\s+[a-z]+(?![\w-])/.source +
					'|' +
					/(?!(?:unrestricted|unsigned)\b)/.source +
					id +
					/(?:\s*<(?:[^<>]|<[^<>]*>)*>)?/.source +
					')' +
					/(?:\s*\?)?/.source;
				var typeInside = {};
				Prism2.languages['web-idl'] = {
					comment: {
						pattern: /\/\/.*|\/\*[\s\S]*?\*\//,
						greedy: true
					},
					string: {
						pattern: /"[^"]*"/,
						greedy: true
					},
					namespace: {
						pattern: RegExp(/(\bnamespace\s+)/.source + id),
						lookbehind: true
					},
					'class-name': [
						{
							pattern: /(^|[^\w-])(?:iterable|maplike|setlike)\s*<(?:[^<>]|<[^<>]*>)*>/,
							lookbehind: true,
							inside: typeInside
						},
						{
							pattern: RegExp(
								/(\b(?:attribute|const|deleter|getter|optional|setter)\s+)/.source + type
							),
							lookbehind: true,
							inside: typeInside
						},
						{
							pattern: RegExp('(' + /\bcallback\s+/.source + id + /\s*=\s*/.source + ')' + type),
							lookbehind: true,
							inside: typeInside
						},
						{
							pattern: RegExp(/(\btypedef\b\s*)/.source + type),
							lookbehind: true,
							inside: typeInside
						},
						{
							pattern: RegExp(
								/(\b(?:callback|dictionary|enum|interface(?:\s+mixin)?)\s+)(?!(?:interface|mixin)\b)/
									.source + id
							),
							lookbehind: true
						},
						{
							pattern: RegExp(/(:\s*)/.source + id),
							lookbehind: true
						},
						RegExp(id + /(?=\s+(?:implements|includes)\b)/.source),
						{
							pattern: RegExp(/(\b(?:implements|includes)\s+)/.source + id),
							lookbehind: true
						},
						{
							pattern: RegExp(
								type + '(?=' + /\s*(?:\.{3}\s*)?/.source + id + /\s*[(),;=]/.source + ')'
							),
							inside: typeInside
						}
					],
					builtin:
						/\b(?:ArrayBuffer|BigInt64Array|BigUint64Array|ByteString|DOMString|DataView|Float32Array|Float64Array|FrozenArray|Int16Array|Int32Array|Int8Array|ObservableArray|Promise|USVString|Uint16Array|Uint32Array|Uint8Array|Uint8ClampedArray)\b/,
					keyword: [
						/\b(?:async|attribute|callback|const|constructor|deleter|dictionary|enum|getter|implements|includes|inherit|interface|mixin|namespace|null|optional|or|partial|readonly|required|setter|static|stringifier|typedef|unrestricted)\b/,
						/\b(?:any|bigint|boolean|byte|double|float|iterable|long|maplike|object|octet|record|sequence|setlike|short|symbol|undefined|unsigned|void)\b/
					],
					boolean: /\b(?:false|true)\b/,
					number: {
						pattern:
							/(^|[^\w-])-?(?:0x[0-9a-f]+|(?:\d+(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?|NaN|Infinity)(?![\w-])/i,
						lookbehind: true
					},
					operator: /\.{3}|[=:?<>-]/,
					punctuation: /[(){}[\].,;]/
				};
				for (var key3 in Prism2.languages['web-idl']) {
					if (key3 !== 'class-name') {
						typeInside[key3] = Prism2.languages['web-idl'][key3];
					}
				}
				Prism2.languages['webidl'] = Prism2.languages['web-idl'];
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/wiki.js
var require_wiki = __commonJS({
	'node_modules/refractor/lang/wiki.js'(exports, module2) {
		'use strict';
		module2.exports = wiki;
		wiki.displayName = 'wiki';
		wiki.aliases = [];
		function wiki(Prism) {
			Prism.languages.wiki = Prism.languages.extend('markup', {
				'block-comment': {
					pattern: /(^|[^\\])\/\*[\s\S]*?\*\//,
					lookbehind: true,
					alias: 'comment'
				},
				heading: {
					pattern: /^(=+)[^=\r\n].*?\1/m,
					inside: {
						punctuation: /^=+|=+$/,
						important: /.+/
					}
				},
				emphasis: {
					pattern: /('{2,5}).+?\1/,
					inside: {
						'bold-italic': {
							pattern: /(''''').+?(?=\1)/,
							lookbehind: true,
							alias: ['bold', 'italic']
						},
						bold: {
							pattern: /(''')[^'](?:.*?[^'])?(?=\1)/,
							lookbehind: true
						},
						italic: {
							pattern: /('')[^'](?:.*?[^'])?(?=\1)/,
							lookbehind: true
						},
						punctuation: /^''+|''+$/
					}
				},
				hr: {
					pattern: /^-{4,}/m,
					alias: 'punctuation'
				},
				url: [
					/ISBN +(?:97[89][ -]?)?(?:\d[ -]?){9}[\dx]\b|(?:PMID|RFC) +\d+/i,
					/\[\[.+?\]\]|\[.+?\]/
				],
				variable: [/__[A-Z]+__/, /\{{3}.+?\}{3}/, /\{\{.+?\}\}/],
				symbol: [/^#redirect/im, /~{3,5}/],
				'table-tag': {
					pattern: /((?:^|[|!])[|!])[^|\r\n]+\|(?!\|)/m,
					lookbehind: true,
					inside: {
						'table-bar': {
							pattern: /\|$/,
							alias: 'punctuation'
						},
						rest: Prism.languages.markup['tag'].inside
					}
				},
				punctuation: /^(?:\{\||\|\}|\|-|[*#:;!|])|\|\||!!/m
			});
			Prism.languages.insertBefore('wiki', 'tag', {
				nowiki: {
					pattern: /<(nowiki|pre|source)\b[^>]*>[\s\S]*?<\/\1>/i,
					inside: {
						tag: {
							pattern: /<(?:nowiki|pre|source)\b[^>]*>|<\/(?:nowiki|pre|source)>/i,
							inside: Prism.languages.markup['tag'].inside
						}
					}
				}
			});
		}
	}
});

// node_modules/refractor/lang/wolfram.js
var require_wolfram = __commonJS({
	'node_modules/refractor/lang/wolfram.js'(exports, module2) {
		'use strict';
		module2.exports = wolfram;
		wolfram.displayName = 'wolfram';
		wolfram.aliases = ['mathematica', 'wl', 'nb'];
		function wolfram(Prism) {
			Prism.languages.wolfram = {
				comment: /\(\*(?:\(\*(?:[^*]|\*(?!\)))*\*\)|(?!\(\*)[\s\S])*?\*\)/,
				string: {
					pattern: /"(?:\\.|[^"\\\r\n])*"/,
					greedy: true
				},
				keyword:
					/\b(?:Abs|AbsArg|Accuracy|Block|Do|For|Function|If|Manipulate|Module|Nest|NestList|None|Return|Switch|Table|Which|While)\b/,
				context: {
					pattern: /\b\w+`+\w*/,
					alias: 'class-name'
				},
				blank: {
					pattern: /\b\w+_\b/,
					alias: 'regex'
				},
				'global-variable': {
					pattern: /\$\w+/,
					alias: 'variable'
				},
				boolean: /\b(?:False|True)\b/,
				number:
					/(?:\b(?=\d)|\B(?=\.))(?:0[bo])?(?:(?:\d|0x[\da-f])[\da-f]*(?:\.\d*)?|\.\d+)(?:e[+-]?\d+)?j?\b/i,
				operator:
					/\/\.|;|=\.|\^=|\^:=|:=|<<|>>|<\||\|>|:>|\|->|->|<-|@@@|@@|@|\/@|=!=|===|==|=|\+|-|\^|\[\/-+%=\]=?|!=|\*\*?=?|\/\/?=?|<[<=>]?|>[=>]?|[&|^~]/,
				punctuation: /[{}[\];(),.:]/
			};
			Prism.languages.mathematica = Prism.languages.wolfram;
			Prism.languages.wl = Prism.languages.wolfram;
			Prism.languages.nb = Prism.languages.wolfram;
		}
	}
});

// node_modules/refractor/lang/wren.js
var require_wren = __commonJS({
	'node_modules/refractor/lang/wren.js'(exports, module2) {
		'use strict';
		module2.exports = wren;
		wren.displayName = 'wren';
		wren.aliases = [];
		function wren(Prism) {
			Prism.languages.wren = {
				comment: [
					{
						pattern:
							/\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*)|\/\*(?:[^*/]|\*(?!\/)|\/(?!\*))*\*\/)*\*\/)*\*\//,
						greedy: true
					},
					{
						pattern: /(^|[^\\:])\/\/.*/,
						lookbehind: true,
						greedy: true
					}
				],
				'triple-quoted-string': {
					pattern: /"""[\s\S]*?"""/,
					greedy: true,
					alias: 'string'
				},
				'string-literal': null,
				hashbang: {
					pattern: /^#!\/.+/,
					greedy: true,
					alias: 'comment'
				},
				attribute: {
					pattern: /#!?[ \t\u3000]*\w+/,
					alias: 'keyword'
				},
				'class-name': [
					{
						pattern: /(\bclass\s+)\w+/,
						lookbehind: true
					},
					/\b[A-Z][a-z\d_]*\b/
				],
				constant: /\b[A-Z][A-Z\d_]*\b/,
				null: {
					pattern: /\bnull\b/,
					alias: 'keyword'
				},
				keyword:
					/\b(?:as|break|class|construct|continue|else|for|foreign|if|import|in|is|return|static|super|this|var|while)\b/,
				boolean: /\b(?:false|true)\b/,
				number: /\b(?:0x[\da-f]+|\d+(?:\.\d+)?(?:e[+-]?\d+)?)\b/i,
				function: /\b[a-z_]\w*(?=\s*[({])/i,
				operator: /<<|>>|[=!<>]=?|&&|\|\||[-+*/%~^&|?:]|\.{2,3}/,
				punctuation: /[\[\](){}.,;]/
			};
			Prism.languages.wren['string-literal'] = {
				pattern:
					/(^|[^\\"])"(?:[^\\"%]|\\[\s\S]|%(?!\()|%\((?:[^()]|\((?:[^()]|\([^)]*\))*\))*\))*"/,
				lookbehind: true,
				greedy: true,
				inside: {
					interpolation: {
						pattern: /((?:^|[^\\])(?:\\{2})*)%\((?:[^()]|\((?:[^()]|\([^)]*\))*\))*\)/,
						lookbehind: true,
						inside: {
							expression: {
								pattern: /^(%\()[\s\S]+(?=\)$)/,
								lookbehind: true,
								inside: Prism.languages.wren
							},
							'interpolation-punctuation': {
								pattern: /^%\(|\)$/,
								alias: 'punctuation'
							}
						}
					},
					string: /[\s\S]+/
				}
			};
		}
	}
});

// node_modules/refractor/lang/xeora.js
var require_xeora = __commonJS({
	'node_modules/refractor/lang/xeora.js'(exports, module2) {
		'use strict';
		module2.exports = xeora;
		xeora.displayName = 'xeora';
		xeora.aliases = ['xeoracube'];
		function xeora(Prism) {
			(function (Prism2) {
				Prism2.languages.xeora = Prism2.languages.extend('markup', {
					constant: {
						pattern: /\$(?:DomainContents|PageRenderDuration)\$/,
						inside: {
							punctuation: {
								pattern: /\$/
							}
						}
					},
					variable: {
						pattern: /\$@?(?:#+|[-+*~=^])?[\w.]+\$/,
						inside: {
							punctuation: {
								pattern: /[$.]/
							},
							operator: {
								pattern: /#+|[-+*~=^@]/
							}
						}
					},
					'function-inline': {
						pattern:
							/\$F:[-\w.]+\?[-\w.]+(?:,(?:(?:@[-#]*\w+\.[\w+.]\.*)*\|)*(?:(?:[\w+]|[-#*.~^]+[\w+]|=\S)(?:[^$=]|=+[^=])*=*|(?:@[-#]*\w+\.[\w+.]\.*)+(?:(?:[\w+]|[-#*~^][-#*.~^]*[\w+]|=\S)(?:[^$=]|=+[^=])*=*)?)?)?\$/,
						inside: {
							variable: {
								pattern: /(?:[,|])@?(?:#+|[-+*~=^])?[\w.]+/,
								inside: {
									punctuation: {
										pattern: /[,.|]/
									},
									operator: {
										pattern: /#+|[-+*~=^@]/
									}
								}
							},
							punctuation: {
								pattern: /\$\w:|[$:?.,|]/
							}
						},
						alias: 'function'
					},
					'function-block': {
						pattern:
							/\$XF:\{[-\w.]+\?[-\w.]+(?:,(?:(?:@[-#]*\w+\.[\w+.]\.*)*\|)*(?:(?:[\w+]|[-#*.~^]+[\w+]|=\S)(?:[^$=]|=+[^=])*=*|(?:@[-#]*\w+\.[\w+.]\.*)+(?:(?:[\w+]|[-#*~^][-#*.~^]*[\w+]|=\S)(?:[^$=]|=+[^=])*=*)?)?)?\}:XF\$/,
						inside: {
							punctuation: {
								pattern: /[$:{}?.,|]/
							}
						},
						alias: 'function'
					},
					'directive-inline': {
						pattern: /\$\w(?:#\d+\+?)?(?:\[[-\w.]+\])?:[-\/\w.]+\$/,
						inside: {
							punctuation: {
								pattern: /\$(?:\w:|C(?:\[|#\d))?|[:{[\]]/,
								inside: {
									tag: {
										pattern: /#\d/
									}
								}
							}
						},
						alias: 'function'
					},
					'directive-block-open': {
						pattern: /\$\w+:\{|\$\w(?:#\d+\+?)?(?:\[[-\w.]+\])?:[-\w.]+:\{(?:![A-Z]+)?/,
						inside: {
							punctuation: {
								pattern: /\$(?:\w:|C(?:\[|#\d))?|[:{[\]]/,
								inside: {
									tag: {
										pattern: /#\d/
									}
								}
							},
							attribute: {
								pattern: /![A-Z]+$/,
								inside: {
									punctuation: {
										pattern: /!/
									}
								},
								alias: 'keyword'
							}
						},
						alias: 'function'
					},
					'directive-block-separator': {
						pattern: /\}:[-\w.]+:\{/,
						inside: {
							punctuation: {
								pattern: /[:{}]/
							}
						},
						alias: 'function'
					},
					'directive-block-close': {
						pattern: /\}:[-\w.]+\$/,
						inside: {
							punctuation: {
								pattern: /[:{}$]/
							}
						},
						alias: 'function'
					}
				});
				Prism2.languages.insertBefore(
					'inside',
					'punctuation',
					{
						variable: Prism2.languages.xeora['function-inline'].inside['variable']
					},
					Prism2.languages.xeora['function-block']
				);
				Prism2.languages.xeoracube = Prism2.languages.xeora;
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/xml-doc.js
var require_xml_doc = __commonJS({
	'node_modules/refractor/lang/xml-doc.js'(exports, module2) {
		'use strict';
		module2.exports = xmlDoc;
		xmlDoc.displayName = 'xmlDoc';
		xmlDoc.aliases = [];
		function xmlDoc(Prism) {
			(function (Prism2) {
				function insertDocComment(lang, docComment) {
					if (Prism2.languages[lang]) {
						Prism2.languages.insertBefore(lang, 'comment', {
							'doc-comment': docComment
						});
					}
				}
				var tag = Prism2.languages.markup.tag;
				var slashDocComment = {
					pattern: /\/\/\/.*/,
					greedy: true,
					alias: 'comment',
					inside: {
						tag
					}
				};
				var tickDocComment = {
					pattern: /'''.*/,
					greedy: true,
					alias: 'comment',
					inside: {
						tag
					}
				};
				insertDocComment('csharp', slashDocComment);
				insertDocComment('fsharp', slashDocComment);
				insertDocComment('vbnet', tickDocComment);
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/xojo.js
var require_xojo = __commonJS({
	'node_modules/refractor/lang/xojo.js'(exports, module2) {
		'use strict';
		module2.exports = xojo;
		xojo.displayName = 'xojo';
		xojo.aliases = [];
		function xojo(Prism) {
			Prism.languages.xojo = {
				comment: {
					pattern: /(?:'|\/\/|Rem\b).+/i,
					greedy: true
				},
				string: {
					pattern: /"(?:""|[^"])*"/,
					greedy: true
				},
				number: [/(?:\b\d+(?:\.\d*)?|\B\.\d+)(?:E[+-]?\d+)?/i, /&[bchou][a-z\d]+/i],
				directive: {
					pattern: /#(?:Else|ElseIf|Endif|If|Pragma)\b/i,
					alias: 'property'
				},
				keyword:
					/\b(?:AddHandler|App|Array|As(?:signs)?|Auto|Boolean|Break|By(?:Ref|Val)|Byte|Call|Case|Catch|CFStringRef|CGFloat|Class|Color|Const|Continue|CString|Currency|CurrentMethodName|Declare|Delegate|Dim|Do(?:uble|wnTo)?|Each|Else(?:If)?|End|Enumeration|Event|Exception|Exit|Extends|False|Finally|For|Function|Get|GetTypeInfo|Global|GOTO|If|Implements|In|Inherits|Int(?:8|16|32|64|eger|erface)?|Lib|Loop|Me|Module|Next|Nil|Object|Optional|OSType|ParamArray|Private|Property|Protected|PString|Ptr|Raise(?:Event)?|ReDim|RemoveHandler|Return|Select(?:or)?|Self|Set|Shared|Short|Single|Soft|Static|Step|String|Sub|Super|Text|Then|To|True|Try|Ubound|UInt(?:8|16|32|64|eger)?|Until|Using|Var(?:iant)?|Wend|While|WindowPtr|WString)\b/i,
				operator:
					/<[=>]?|>=?|[+\-*\/\\^=]|\b(?:AddressOf|And|Ctype|IsA?|Mod|New|Not|Or|WeakAddressOf|Xor)\b/i,
				punctuation: /[.,;:()]/
			};
		}
	}
});

// node_modules/refractor/lang/xquery.js
var require_xquery = __commonJS({
	'node_modules/refractor/lang/xquery.js'(exports, module2) {
		'use strict';
		module2.exports = xquery;
		xquery.displayName = 'xquery';
		xquery.aliases = [];
		function xquery(Prism) {
			(function (Prism2) {
				Prism2.languages.xquery = Prism2.languages.extend('markup', {
					'xquery-comment': {
						pattern: /\(:[\s\S]*?:\)/,
						greedy: true,
						alias: 'comment'
					},
					string: {
						pattern: /(["'])(?:\1\1|(?!\1)[\s\S])*\1/,
						greedy: true
					},
					extension: {
						pattern: /\(#.+?#\)/,
						alias: 'symbol'
					},
					variable: /\$[-\w:]+/,
					axis: {
						pattern:
							/(^|[^-])(?:ancestor(?:-or-self)?|attribute|child|descendant(?:-or-self)?|following(?:-sibling)?|parent|preceding(?:-sibling)?|self)(?=::)/,
						lookbehind: true,
						alias: 'operator'
					},
					'keyword-operator': {
						pattern:
							/(^|[^:-])\b(?:and|castable as|div|eq|except|ge|gt|idiv|instance of|intersect|is|le|lt|mod|ne|or|union)\b(?=$|[^:-])/,
						lookbehind: true,
						alias: 'operator'
					},
					keyword: {
						pattern:
							/(^|[^:-])\b(?:as|ascending|at|base-uri|boundary-space|case|cast as|collation|construction|copy-namespaces|declare|default|descending|else|empty (?:greatest|least)|encoding|every|external|for|function|if|import|in|inherit|lax|let|map|module|namespace|no-inherit|no-preserve|option|order(?: by|ed|ing)?|preserve|return|satisfies|schema|some|stable|strict|strip|then|to|treat as|typeswitch|unordered|validate|variable|version|where|xquery)\b(?=$|[^:-])/,
						lookbehind: true
					},
					function: /[\w-]+(?::[\w-]+)*(?=\s*\()/,
					'xquery-element': {
						pattern: /(element\s+)[\w-]+(?::[\w-]+)*/,
						lookbehind: true,
						alias: 'tag'
					},
					'xquery-attribute': {
						pattern: /(attribute\s+)[\w-]+(?::[\w-]+)*/,
						lookbehind: true,
						alias: 'attr-name'
					},
					builtin: {
						pattern:
							/(^|[^:-])\b(?:attribute|comment|document|element|processing-instruction|text|xs:(?:ENTITIES|ENTITY|ID|IDREFS?|NCName|NMTOKENS?|NOTATION|Name|QName|anyAtomicType|anyType|anyURI|base64Binary|boolean|byte|date|dateTime|dayTimeDuration|decimal|double|duration|float|gDay|gMonth|gMonthDay|gYear|gYearMonth|hexBinary|int|integer|language|long|negativeInteger|nonNegativeInteger|nonPositiveInteger|normalizedString|positiveInteger|short|string|time|token|unsigned(?:Byte|Int|Long|Short)|untyped(?:Atomic)?|yearMonthDuration))\b(?=$|[^:-])/,
						lookbehind: true
					},
					number: /\b\d+(?:\.\d+)?(?:E[+-]?\d+)?/,
					operator: [
						/[+*=?|@]|\.\.?|:=|!=|<[=<]?|>[=>]?/,
						{
							pattern: /(\s)-(?=\s)/,
							lookbehind: true
						}
					],
					punctuation: /[[\](){},;:/]/
				});
				Prism2.languages.xquery.tag.pattern =
					/<\/?(?!\d)[^\s>\/=$<%]+(?:\s+[^\s>\/=]+(?:=(?:("|')(?:\\[\s\S]|\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}|(?!\1)[^\\])*\1|[^\s'">=]+))?)*\s*\/?>/;
				Prism2.languages.xquery['tag'].inside['attr-value'].pattern =
					/=(?:("|')(?:\\[\s\S]|\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}|(?!\1)[^\\])*\1|[^\s'">=]+)/;
				Prism2.languages.xquery['tag'].inside['attr-value'].inside['punctuation'] = /^="|"$/;
				Prism2.languages.xquery['tag'].inside['attr-value'].inside['expression'] = {
					pattern: /\{(?!\{)(?:\{(?:\{[^{}]*\}|[^{}])*\}|[^{}])+\}/,
					inside: Prism2.languages.xquery,
					alias: 'language-xquery'
				};
				var stringifyToken = function (token) {
					if (typeof token === 'string') {
						return token;
					}
					if (typeof token.content === 'string') {
						return token.content;
					}
					return token.content.map(stringifyToken).join('');
				};
				var walkTokens = function (tokens) {
					var openedTags = [];
					for (var i2 = 0; i2 < tokens.length; i2++) {
						var token = tokens[i2];
						var notTagNorBrace = false;
						if (typeof token !== 'string') {
							if (token.type === 'tag' && token.content[0] && token.content[0].type === 'tag') {
								if (token.content[0].content[0].content === '</') {
									if (
										openedTags.length > 0 &&
										openedTags[openedTags.length - 1].tagName ===
											stringifyToken(token.content[0].content[1])
									) {
										openedTags.pop();
									}
								} else {
									if (token.content[token.content.length - 1].content === '/>') {
									} else {
										openedTags.push({
											tagName: stringifyToken(token.content[0].content[1]),
											openedBraces: 0
										});
									}
								}
							} else if (
								openedTags.length > 0 &&
								token.type === 'punctuation' &&
								token.content === '{' &&
								(!tokens[i2 + 1] ||
									tokens[i2 + 1].type !== 'punctuation' ||
									tokens[i2 + 1].content !== '{') &&
								(!tokens[i2 - 1] ||
									tokens[i2 - 1].type !== 'plain-text' ||
									tokens[i2 - 1].content !== '{')
							) {
								openedTags[openedTags.length - 1].openedBraces++;
							} else if (
								openedTags.length > 0 &&
								openedTags[openedTags.length - 1].openedBraces > 0 &&
								token.type === 'punctuation' &&
								token.content === '}'
							) {
								openedTags[openedTags.length - 1].openedBraces--;
							} else if (token.type !== 'comment') {
								notTagNorBrace = true;
							}
						}
						if (notTagNorBrace || typeof token === 'string') {
							if (openedTags.length > 0 && openedTags[openedTags.length - 1].openedBraces === 0) {
								var plainText = stringifyToken(token);
								if (
									i2 < tokens.length - 1 &&
									(typeof tokens[i2 + 1] === 'string' || tokens[i2 + 1].type === 'plain-text')
								) {
									plainText += stringifyToken(tokens[i2 + 1]);
									tokens.splice(i2 + 1, 1);
								}
								if (
									i2 > 0 &&
									(typeof tokens[i2 - 1] === 'string' || tokens[i2 - 1].type === 'plain-text')
								) {
									plainText = stringifyToken(tokens[i2 - 1]) + plainText;
									tokens.splice(i2 - 1, 1);
									i2--;
								}
								if (/^\s+$/.test(plainText)) {
									tokens[i2] = plainText;
								} else {
									tokens[i2] = new Prism2.Token('plain-text', plainText, null, plainText);
								}
							}
						}
						if (token.content && typeof token.content !== 'string') {
							walkTokens(token.content);
						}
					}
				};
				Prism2.hooks.add('after-tokenize', function (env) {
					if (env.language !== 'xquery') {
						return;
					}
					walkTokens(env.tokens);
				});
			})(Prism);
		}
	}
});

// node_modules/refractor/lang/yang.js
var require_yang = __commonJS({
	'node_modules/refractor/lang/yang.js'(exports, module2) {
		'use strict';
		module2.exports = yang;
		yang.displayName = 'yang';
		yang.aliases = [];
		function yang(Prism) {
			Prism.languages.yang = {
				comment: /\/\*[\s\S]*?\*\/|\/\/.*/,
				string: {
					pattern: /"(?:[^\\"]|\\.)*"|'[^']*'/,
					greedy: true
				},
				keyword: {
					pattern: /(^|[{};\r\n][ \t]*)[a-z_][\w.-]*/i,
					lookbehind: true
				},
				namespace: {
					pattern: /(\s)[a-z_][\w.-]*(?=:)/i,
					lookbehind: true
				},
				boolean: /\b(?:false|true)\b/,
				operator: /\+/,
				punctuation: /[{};:]/
			};
		}
	}
});

// node_modules/refractor/lang/zig.js
var require_zig = __commonJS({
	'node_modules/refractor/lang/zig.js'(exports, module2) {
		'use strict';
		module2.exports = zig;
		zig.displayName = 'zig';
		zig.aliases = [];
		function zig(Prism) {
			(function (Prism2) {
				function literal(str) {
					return function () {
						return str;
					};
				}
				var keyword =
					/\b(?:align|allowzero|and|anyframe|anytype|asm|async|await|break|cancel|catch|comptime|const|continue|defer|else|enum|errdefer|error|export|extern|fn|for|if|inline|linksection|nakedcc|noalias|nosuspend|null|or|orelse|packed|promise|pub|resume|return|stdcallcc|struct|suspend|switch|test|threadlocal|try|undefined|union|unreachable|usingnamespace|var|volatile|while)\b/;
				var IDENTIFIER = '\\b(?!' + keyword.source + ')(?!\\d)\\w+\\b';
				var ALIGN = /align\s*\((?:[^()]|\([^()]*\))*\)/.source;
				var PREFIX_TYPE_OP =
					/(?:\?|\bpromise->|(?:\[[^[\]]*\]|\*(?!\*)|\*\*)(?:\s*<ALIGN>|\s*const\b|\s*volatile\b|\s*allowzero\b)*)/.source.replace(
						/<ALIGN>/g,
						literal(ALIGN)
					);
				var SUFFIX_EXPR = /(?:\bpromise\b|(?:\berror\.)?<ID>(?:\.<ID>)*(?!\s+<ID>))/.source.replace(
					/<ID>/g,
					literal(IDENTIFIER)
				);
				var TYPE = '(?!\\s)(?:!?\\s*(?:' + PREFIX_TYPE_OP + '\\s*)*' + SUFFIX_EXPR + ')+';
				Prism2.languages.zig = {
					comment: [
						{
							pattern: /\/\/[/!].*/,
							alias: 'doc-comment'
						},
						/\/{2}.*/
					],
					string: [
						{
							pattern: /(^|[^\\@])c?"(?:[^"\\\r\n]|\\.)*"/,
							lookbehind: true,
							greedy: true
						},
						{
							pattern: /([\r\n])([ \t]+c?\\{2}).*(?:(?:\r\n?|\n)\2.*)*/,
							lookbehind: true,
							greedy: true
						}
					],
					char: {
						pattern:
							/(^|[^\\])'(?:[^'\\\r\n]|[\uD800-\uDFFF]{2}|\\(?:.|x[a-fA-F\d]{2}|u\{[a-fA-F\d]{1,6}\}))'/,
						lookbehind: true,
						greedy: true
					},
					builtin: /\B@(?!\d)\w+(?=\s*\()/,
					label: {
						pattern: /(\b(?:break|continue)\s*:\s*)\w+\b|\b(?!\d)\w+\b(?=\s*:\s*(?:\{|while\b))/,
						lookbehind: true
					},
					'class-name': [
						/\b(?!\d)\w+(?=\s*=\s*(?:(?:extern|packed)\s+)?(?:enum|struct|union)\s*[({])/,
						{
							pattern: RegExp(
								/(:\s*)<TYPE>(?=\s*(?:<ALIGN>\s*)?[=;,)])|<TYPE>(?=\s*(?:<ALIGN>\s*)?\{)/.source
									.replace(/<TYPE>/g, literal(TYPE))
									.replace(/<ALIGN>/g, literal(ALIGN))
							),
							lookbehind: true,
							inside: null
						},
						{
							pattern: RegExp(
								/(\)\s*)<TYPE>(?=\s*(?:<ALIGN>\s*)?;)/.source
									.replace(/<TYPE>/g, literal(TYPE))
									.replace(/<ALIGN>/g, literal(ALIGN))
							),
							lookbehind: true,
							inside: null
						}
					],
					'builtin-type': {
						pattern:
							/\b(?:anyerror|bool|c_u?(?:int|long|longlong|short)|c_longdouble|c_void|comptime_(?:float|int)|f(?:16|32|64|128)|[iu](?:8|16|32|64|128|size)|noreturn|type|void)\b/,
						alias: 'keyword'
					},
					keyword,
					function: /\b(?!\d)\w+(?=\s*\()/,
					number:
						/\b(?:0b[01]+|0o[0-7]+|0x[a-fA-F\d]+(?:\.[a-fA-F\d]*)?(?:[pP][+-]?[a-fA-F\d]+)?|\d+(?:\.\d*)?(?:[eE][+-]?\d+)?)\b/,
					boolean: /\b(?:false|true)\b/,
					operator: /\.[*?]|\.{2,3}|[-=]>|\*\*|\+\+|\|\||(?:<<|>>|[-+*]%|[-+*/%^&|<>!=])=?|[?~]/,
					punctuation: /[.:,;(){}[\]]/
				};
				Prism2.languages.zig['class-name'].forEach(function (obj) {
					if (obj.inside === null) {
						obj.inside = Prism2.languages.zig;
					}
				});
			})(Prism);
		}
	}
});

// node_modules/refractor/index.js
var require_refractor = __commonJS({
	'node_modules/refractor/index.js'(exports, module2) {
		'use strict';
		var refractor = require_core2();
		module2.exports = refractor;
		refractor.register(require_abap());
		refractor.register(require_abnf());
		refractor.register(require_actionscript());
		refractor.register(require_ada());
		refractor.register(require_agda());
		refractor.register(require_al());
		refractor.register(require_antlr4());
		refractor.register(require_apacheconf());
		refractor.register(require_apex());
		refractor.register(require_apl());
		refractor.register(require_applescript());
		refractor.register(require_aql());
		refractor.register(require_arduino());
		refractor.register(require_arff());
		refractor.register(require_asciidoc());
		refractor.register(require_asm6502());
		refractor.register(require_asmatmel());
		refractor.register(require_aspnet());
		refractor.register(require_autohotkey());
		refractor.register(require_autoit());
		refractor.register(require_avisynth());
		refractor.register(require_avro_idl());
		refractor.register(require_bash());
		refractor.register(require_basic());
		refractor.register(require_batch());
		refractor.register(require_bbcode());
		refractor.register(require_bicep());
		refractor.register(require_birb());
		refractor.register(require_bison());
		refractor.register(require_bnf());
		refractor.register(require_brainfuck());
		refractor.register(require_brightscript());
		refractor.register(require_bro());
		refractor.register(require_bsl());
		refractor.register(require_c());
		refractor.register(require_cfscript());
		refractor.register(require_chaiscript());
		refractor.register(require_cil());
		refractor.register(require_clojure());
		refractor.register(require_cmake());
		refractor.register(require_cobol());
		refractor.register(require_coffeescript());
		refractor.register(require_concurnas());
		refractor.register(require_coq());
		refractor.register(require_cpp());
		refractor.register(require_crystal());
		refractor.register(require_csharp());
		refractor.register(require_cshtml());
		refractor.register(require_csp());
		refractor.register(require_css_extras());
		refractor.register(require_csv());
		refractor.register(require_cypher());
		refractor.register(require_d());
		refractor.register(require_dart());
		refractor.register(require_dataweave());
		refractor.register(require_dax());
		refractor.register(require_dhall());
		refractor.register(require_diff());
		refractor.register(require_django());
		refractor.register(require_dns_zone_file());
		refractor.register(require_docker());
		refractor.register(require_dot());
		refractor.register(require_ebnf());
		refractor.register(require_editorconfig());
		refractor.register(require_eiffel());
		refractor.register(require_ejs());
		refractor.register(require_elixir());
		refractor.register(require_elm());
		refractor.register(require_erb());
		refractor.register(require_erlang());
		refractor.register(require_etlua());
		refractor.register(require_excel_formula());
		refractor.register(require_factor());
		refractor.register(require_false());
		refractor.register(require_firestore_security_rules());
		refractor.register(require_flow());
		refractor.register(require_fortran());
		refractor.register(require_fsharp());
		refractor.register(require_ftl());
		refractor.register(require_gap());
		refractor.register(require_gcode());
		refractor.register(require_gdscript());
		refractor.register(require_gedcom());
		refractor.register(require_gherkin());
		refractor.register(require_git());
		refractor.register(require_glsl());
		refractor.register(require_gml());
		refractor.register(require_gn());
		refractor.register(require_go_module());
		refractor.register(require_go());
		refractor.register(require_graphql());
		refractor.register(require_groovy());
		refractor.register(require_haml());
		refractor.register(require_handlebars());
		refractor.register(require_haskell());
		refractor.register(require_haxe());
		refractor.register(require_hcl());
		refractor.register(require_hlsl());
		refractor.register(require_hoon());
		refractor.register(require_hpkp());
		refractor.register(require_hsts());
		refractor.register(require_http());
		refractor.register(require_ichigojam());
		refractor.register(require_icon());
		refractor.register(require_icu_message_format());
		refractor.register(require_idris());
		refractor.register(require_iecst());
		refractor.register(require_ignore());
		refractor.register(require_inform7());
		refractor.register(require_ini());
		refractor.register(require_io());
		refractor.register(require_j());
		refractor.register(require_java());
		refractor.register(require_javadoc());
		refractor.register(require_javadoclike());
		refractor.register(require_javastacktrace());
		refractor.register(require_jexl());
		refractor.register(require_jolie());
		refractor.register(require_jq());
		refractor.register(require_js_extras());
		refractor.register(require_js_templates());
		refractor.register(require_jsdoc());
		refractor.register(require_json2());
		refractor.register(require_json5());
		refractor.register(require_jsonp());
		refractor.register(require_jsstacktrace());
		refractor.register(require_jsx());
		refractor.register(require_julia());
		refractor.register(require_keepalived());
		refractor.register(require_keyman());
		refractor.register(require_kotlin());
		refractor.register(require_kumir());
		refractor.register(require_kusto());
		refractor.register(require_latex());
		refractor.register(require_latte());
		refractor.register(require_less());
		refractor.register(require_lilypond());
		refractor.register(require_liquid());
		refractor.register(require_lisp());
		refractor.register(require_livescript());
		refractor.register(require_llvm());
		refractor.register(require_log());
		refractor.register(require_lolcode());
		refractor.register(require_lua());
		refractor.register(require_magma());
		refractor.register(require_makefile());
		refractor.register(require_markdown());
		refractor.register(require_markup_templating());
		refractor.register(require_matlab());
		refractor.register(require_maxscript());
		refractor.register(require_mel());
		refractor.register(require_mermaid());
		refractor.register(require_mizar());
		refractor.register(require_mongodb());
		refractor.register(require_monkey());
		refractor.register(require_moonscript());
		refractor.register(require_n1ql());
		refractor.register(require_n4js());
		refractor.register(require_nand2tetris_hdl());
		refractor.register(require_naniscript());
		refractor.register(require_nasm());
		refractor.register(require_neon());
		refractor.register(require_nevod());
		refractor.register(require_nginx());
		refractor.register(require_nim());
		refractor.register(require_nix());
		refractor.register(require_nsis());
		refractor.register(require_objectivec());
		refractor.register(require_ocaml());
		refractor.register(require_opencl());
		refractor.register(require_openqasm());
		refractor.register(require_oz());
		refractor.register(require_parigp());
		refractor.register(require_parser2());
		refractor.register(require_pascal());
		refractor.register(require_pascaligo());
		refractor.register(require_pcaxis());
		refractor.register(require_peoplecode());
		refractor.register(require_perl());
		refractor.register(require_php_extras());
		refractor.register(require_php());
		refractor.register(require_phpdoc());
		refractor.register(require_plsql());
		refractor.register(require_powerquery());
		refractor.register(require_powershell());
		refractor.register(require_processing());
		refractor.register(require_prolog());
		refractor.register(require_promql());
		refractor.register(require_properties());
		refractor.register(require_protobuf());
		refractor.register(require_psl());
		refractor.register(require_pug());
		refractor.register(require_puppet());
		refractor.register(require_pure());
		refractor.register(require_purebasic());
		refractor.register(require_purescript());
		refractor.register(require_python());
		refractor.register(require_q());
		refractor.register(require_qml());
		refractor.register(require_qore());
		refractor.register(require_qsharp());
		refractor.register(require_r());
		refractor.register(require_racket());
		refractor.register(require_reason());
		refractor.register(require_regex());
		refractor.register(require_rego());
		refractor.register(require_renpy());
		refractor.register(require_rest());
		refractor.register(require_rip());
		refractor.register(require_roboconf());
		refractor.register(require_robotframework());
		refractor.register(require_ruby());
		refractor.register(require_rust());
		refractor.register(require_sas());
		refractor.register(require_sass());
		refractor.register(require_scala());
		refractor.register(require_scheme());
		refractor.register(require_scss());
		refractor.register(require_shell_session());
		refractor.register(require_smali());
		refractor.register(require_smalltalk());
		refractor.register(require_smarty());
		refractor.register(require_sml());
		refractor.register(require_solidity());
		refractor.register(require_solution_file());
		refractor.register(require_soy());
		refractor.register(require_sparql());
		refractor.register(require_splunk_spl());
		refractor.register(require_sqf());
		refractor.register(require_sql());
		refractor.register(require_squirrel());
		refractor.register(require_stan());
		refractor.register(require_stylus());
		refractor.register(require_swift());
		refractor.register(require_systemd());
		refractor.register(require_t4_cs());
		refractor.register(require_t4_templating());
		refractor.register(require_t4_vb());
		refractor.register(require_tap());
		refractor.register(require_tcl());
		refractor.register(require_textile());
		refractor.register(require_toml());
		refractor.register(require_tremor());
		refractor.register(require_tsx());
		refractor.register(require_tt2());
		refractor.register(require_turtle());
		refractor.register(require_twig());
		refractor.register(require_typescript());
		refractor.register(require_typoscript());
		refractor.register(require_unrealscript());
		refractor.register(require_uorazor());
		refractor.register(require_uri());
		refractor.register(require_v());
		refractor.register(require_vala());
		refractor.register(require_vbnet());
		refractor.register(require_velocity());
		refractor.register(require_verilog());
		refractor.register(require_vhdl());
		refractor.register(require_vim());
		refractor.register(require_visual_basic());
		refractor.register(require_warpscript());
		refractor.register(require_wasm());
		refractor.register(require_web_idl());
		refractor.register(require_wiki());
		refractor.register(require_wolfram());
		refractor.register(require_wren());
		refractor.register(require_xeora());
		refractor.register(require_xml_doc());
		refractor.register(require_xojo());
		refractor.register(require_xquery());
		refractor.register(require_yaml());
		refractor.register(require_yang());
		refractor.register(require_zig());
	}
});

// node_modules/@mapbox/rehype-prism/index.js
var require_rehype_prism = __commonJS({
	'node_modules/@mapbox/rehype-prism/index.js'(exports, module2) {
		'use strict';
		var visit4 = require_unist_util_visit();
		var nodeToString = require_hast_util_to_string();
		var refractor = require_refractor();
		module2.exports = (options) => {
			options = options || {};
			if (options.alias) {
				refractor.alias(options.alias);
			}
			return (tree) => {
				visit4(tree, 'element', visitor);
			};
			function visitor(node, index6, parent) {
				if (!parent || parent.tagName !== 'pre' || node.tagName !== 'code') {
					return;
				}
				const lang = getLanguage(node);
				if (lang === null) {
					return;
				}
				let result;
				try {
					parent.properties.className = (parent.properties.className || []).concat(
						'language-' + lang
					);
					result = refractor.highlight(nodeToString(node), lang);
				} catch (err) {
					if (options.ignoreMissing && /Unknown language/.test(err.message)) {
						return;
					}
					throw err;
				}
				node.children = result;
			}
		};
		function getLanguage(node) {
			const className = node.properties.className || [];
			for (const classListItem of className) {
				if (classListItem.slice(0, 9) === 'language-') {
					return classListItem.slice(9).toLowerCase();
				}
			}
			return null;
		}
	}
});

// .svelte-kit/output/server/chunks/handle-markdown-be769235.js
function importMarkdowns(markdownPath) {
	let fileNames = import_glob.default.sync(`${markdownPath}*.md`);
	return fileNames.map((path) => convertMarkdown(path));
}
function convertMarkdown(path) {
	let file2 = import_fs.default.readFileSync(path, 'utf8');
	let { attributes, body: body4 } = (0, import_front_matter.default)(file2);
	let result = remark().use(remarkHtml).processSync(body4).contents;
	result = rehype().use(import_rehype_prism.default).processSync(result).contents;
	return { path, attributes, html: result || body4 };
}
function convertToPostPreview(object) {
	const url = object.path.replace('.md', '').replace('src/', '');
	return { ...(object == null ? void 0 : object.attributes), url };
}
var import_fs, import_glob, import_front_matter, import_rehype_prism;
var init_handle_markdown_be769235 = __esm({
	'.svelte-kit/output/server/chunks/handle-markdown-be769235.js'() {
		import_fs = __toESM(require('fs'), 1);
		import_glob = __toESM(require_glob(), 1);
		import_front_matter = __toESM(require_front_matter(), 1);
		init_remark();
		init_remark_html();
		init_rehype();
		import_rehype_prism = __toESM(require_rehype_prism(), 1);
	}
});

// .svelte-kit/output/server/entries/endpoints/post.json.js
var post_json_exports = {};
__export(post_json_exports, {
	get: () => get
});
async function get() {
	let posts = postFiles.map((file2) => convertToPostPreview(file2));
	if (posts) {
		let body4 = JSON.stringify(posts);
		return { body: body4 };
	}
	return {
		status: 404
	};
}
var import_glob2, import_front_matter2, import_rehype_prism2, postFiles;
var init_post_json = __esm({
	'.svelte-kit/output/server/entries/endpoints/post.json.js'() {
		init_handle_markdown_be769235();
		import_glob2 = __toESM(require_glob(), 1);
		import_front_matter2 = __toESM(require_front_matter(), 1);
		import_rehype_prism2 = __toESM(require_rehype_prism(), 1);
		postFiles = importMarkdowns('src/posts/');
	}
});

// .svelte-kit/output/server/entries/endpoints/posts/_slug_.json.js
var slug_json_exports = {};
__export(slug_json_exports, {
	get: () => get2
});
async function get2({ params }) {
	const { slug } = params;
	const post = convertMarkdown(`src/posts/${slug}.md`);
	let body4 = JSON.stringify(post);
	return { body: body4 };
}
var import_glob3, import_front_matter3, import_rehype_prism3;
var init_slug_json = __esm({
	'.svelte-kit/output/server/entries/endpoints/posts/_slug_.json.js'() {
		init_handle_markdown_be769235();
		import_glob3 = __toESM(require_glob(), 1);
		import_front_matter3 = __toESM(require_front_matter(), 1);
		import_rehype_prism3 = __toESM(require_rehype_prism(), 1);
	}
});

// .svelte-kit/vercel-tmp/serverless.js
var serverless_exports = {};
__export(serverless_exports, {
	default: () => serverless_default
});
module.exports = __toCommonJS(serverless_exports);

// node_modules/@sveltejs/kit/dist/node/polyfills.js
var import_assert = __toESM(require('assert'), 1);
var import_net = __toESM(require('net'), 1);
var import_http = __toESM(require('http'), 1);
var import_stream = __toESM(require('stream'), 1);
var import_buffer = __toESM(require('buffer'), 1);
var import_util = __toESM(require('util'), 1);
var import_web = __toESM(require('stream/web'), 1);
var import_perf_hooks = __toESM(require('perf_hooks'), 1);
var import_types = __toESM(require('util/types'), 1);
var import_events = __toESM(require('events'), 1);
var import_tls = __toESM(require('tls'), 1);
init_commonjsHelpers();
var import_async_hooks = __toESM(require('async_hooks'), 1);
var import_zlib = __toESM(require('zlib'), 1);
var import_crypto = require('crypto');
var symbols$1 = {
	kClose: Symbol('close'),
	kDestroy: Symbol('destroy'),
	kDispatch: Symbol('dispatch'),
	kUrl: Symbol('url'),
	kWriting: Symbol('writing'),
	kResuming: Symbol('resuming'),
	kQueue: Symbol('queue'),
	kConnect: Symbol('connect'),
	kConnecting: Symbol('connecting'),
	kHeadersList: Symbol('headers list'),
	kKeepAliveDefaultTimeout: Symbol('default keep alive timeout'),
	kKeepAliveMaxTimeout: Symbol('max keep alive timeout'),
	kKeepAliveTimeoutThreshold: Symbol('keep alive timeout threshold'),
	kKeepAliveTimeoutValue: Symbol('keep alive timeout'),
	kKeepAlive: Symbol('keep alive'),
	kHeadersTimeout: Symbol('headers timeout'),
	kBodyTimeout: Symbol('body timeout'),
	kServerName: Symbol('server name'),
	kHost: Symbol('host'),
	kNoRef: Symbol('no ref'),
	kBodyUsed: Symbol('used'),
	kRunning: Symbol('running'),
	kBlocking: Symbol('blocking'),
	kPending: Symbol('pending'),
	kSize: Symbol('size'),
	kBusy: Symbol('busy'),
	kQueued: Symbol('queued'),
	kFree: Symbol('free'),
	kConnected: Symbol('connected'),
	kClosed: Symbol('closed'),
	kNeedDrain: Symbol('need drain'),
	kReset: Symbol('reset'),
	kDestroyed: Symbol('destroyed'),
	kMaxHeadersSize: Symbol('max headers size'),
	kRunningIdx: Symbol('running index'),
	kPendingIdx: Symbol('pending index'),
	kError: Symbol('error'),
	kClients: Symbol('clients'),
	kClient: Symbol('client'),
	kParser: Symbol('parser'),
	kOnDestroyed: Symbol('destroy callbacks'),
	kPipelining: Symbol('pipelinig'),
	kSocket: Symbol('socket'),
	kHostHeader: Symbol('host header'),
	kConnector: Symbol('connector'),
	kStrictContentLength: Symbol('strict content length'),
	kMaxRedirections: Symbol('maxRedirections'),
	kMaxRequests: Symbol('maxRequestsPerClient'),
	kProxy: Symbol('proxy agent options'),
	kCounter: Symbol('socket request counter')
};
var AbortError$2 = class extends Error {
	constructor() {
		super('The operation was aborted');
		this.code = 'ABORT_ERR';
		this.name = 'AbortError';
	}
};
var UndiciError = class extends Error {
	constructor(message) {
		super(message);
		this.name = 'UndiciError';
		this.code = 'UND_ERR';
	}
};
var ConnectTimeoutError$1 = class extends UndiciError {
	constructor(message) {
		super(message);
		Error.captureStackTrace(this, ConnectTimeoutError$1);
		this.name = 'ConnectTimeoutError';
		this.message = message || 'Connect Timeout Error';
		this.code = 'UND_ERR_CONNECT_TIMEOUT';
	}
};
var HeadersTimeoutError$1 = class extends UndiciError {
	constructor(message) {
		super(message);
		Error.captureStackTrace(this, HeadersTimeoutError$1);
		this.name = 'HeadersTimeoutError';
		this.message = message || 'Headers Timeout Error';
		this.code = 'UND_ERR_HEADERS_TIMEOUT';
	}
};
var HeadersOverflowError$1 = class extends UndiciError {
	constructor(message) {
		super(message);
		Error.captureStackTrace(this, HeadersOverflowError$1);
		this.name = 'HeadersOverflowError';
		this.message = message || 'Headers Overflow Error';
		this.code = 'UND_ERR_HEADERS_OVERFLOW';
	}
};
var BodyTimeoutError$1 = class extends UndiciError {
	constructor(message) {
		super(message);
		Error.captureStackTrace(this, BodyTimeoutError$1);
		this.name = 'BodyTimeoutError';
		this.message = message || 'Body Timeout Error';
		this.code = 'UND_ERR_BODY_TIMEOUT';
	}
};
var ResponseStatusCodeError$1 = class extends UndiciError {
	constructor(message, statusCode, headers2) {
		super(message);
		Error.captureStackTrace(this, ResponseStatusCodeError$1);
		this.name = 'ResponseStatusCodeError';
		this.message = message || 'Response Status Code Error';
		this.code = 'UND_ERR_RESPONSE_STATUS_CODE';
		this.status = statusCode;
		this.statusCode = statusCode;
		this.headers = headers2;
	}
};
var InvalidArgumentError$f = class extends UndiciError {
	constructor(message) {
		super(message);
		Error.captureStackTrace(this, InvalidArgumentError$f);
		this.name = 'InvalidArgumentError';
		this.message = message || 'Invalid Argument Error';
		this.code = 'UND_ERR_INVALID_ARG';
	}
};
var InvalidReturnValueError$2 = class extends UndiciError {
	constructor(message) {
		super(message);
		Error.captureStackTrace(this, InvalidReturnValueError$2);
		this.name = 'InvalidReturnValueError';
		this.message = message || 'Invalid Return Value Error';
		this.code = 'UND_ERR_INVALID_RETURN_VALUE';
	}
};
var RequestAbortedError$8 = class extends UndiciError {
	constructor(message) {
		super(message);
		Error.captureStackTrace(this, RequestAbortedError$8);
		this.name = 'AbortError';
		this.message = message || 'Request aborted';
		this.code = 'UND_ERR_ABORTED';
	}
};
var InformationalError$1 = class extends UndiciError {
	constructor(message) {
		super(message);
		Error.captureStackTrace(this, InformationalError$1);
		this.name = 'InformationalError';
		this.message = message || 'Request information';
		this.code = 'UND_ERR_INFO';
	}
};
var RequestContentLengthMismatchError$1 = class extends UndiciError {
	constructor(message) {
		super(message);
		Error.captureStackTrace(this, RequestContentLengthMismatchError$1);
		this.name = 'RequestContentLengthMismatchError';
		this.message = message || 'Request body length does not match content-length header';
		this.code = 'UND_ERR_REQ_CONTENT_LENGTH_MISMATCH';
	}
};
var ResponseContentLengthMismatchError$1 = class extends UndiciError {
	constructor(message) {
		super(message);
		Error.captureStackTrace(this, ResponseContentLengthMismatchError$1);
		this.name = 'ResponseContentLengthMismatchError';
		this.message = message || 'Response body length does not match content-length header';
		this.code = 'UND_ERR_RES_CONTENT_LENGTH_MISMATCH';
	}
};
var ClientDestroyedError$1 = class extends UndiciError {
	constructor(message) {
		super(message);
		Error.captureStackTrace(this, ClientDestroyedError$1);
		this.name = 'ClientDestroyedError';
		this.message = message || 'The client is destroyed';
		this.code = 'UND_ERR_DESTROYED';
	}
};
var ClientClosedError$1 = class extends UndiciError {
	constructor(message) {
		super(message);
		Error.captureStackTrace(this, ClientClosedError$1);
		this.name = 'ClientClosedError';
		this.message = message || 'The client is closed';
		this.code = 'UND_ERR_CLOSED';
	}
};
var SocketError$3 = class extends UndiciError {
	constructor(message, socket) {
		super(message);
		Error.captureStackTrace(this, SocketError$3);
		this.name = 'SocketError';
		this.message = message || 'Socket error';
		this.code = 'UND_ERR_SOCKET';
		this.socket = socket;
	}
};
var NotSupportedError$3 = class extends UndiciError {
	constructor(message) {
		super(message);
		Error.captureStackTrace(this, NotSupportedError$3);
		this.name = 'NotSupportedError';
		this.message = message || 'Not supported error';
		this.code = 'UND_ERR_NOT_SUPPORTED';
	}
};
var BalancedPoolMissingUpstreamError = class extends UndiciError {
	constructor(message) {
		super(message);
		Error.captureStackTrace(this, NotSupportedError$3);
		this.name = 'MissingUpstreamError';
		this.message = message || 'No upstream has been added to the BalancedPool';
		this.code = 'UND_ERR_BPL_MISSING_UPSTREAM';
	}
};
var HTTPParserError$1 = class extends Error {
	constructor(message, code3, data2) {
		super(message);
		Error.captureStackTrace(this, HTTPParserError$1);
		this.name = 'HTTPParserError';
		this.code = code3 ? `HPE_${code3}` : void 0;
		this.data = data2 ? data2.toString() : void 0;
	}
};
var errors$1 = {
	AbortError: AbortError$2,
	HTTPParserError: HTTPParserError$1,
	UndiciError,
	HeadersTimeoutError: HeadersTimeoutError$1,
	HeadersOverflowError: HeadersOverflowError$1,
	BodyTimeoutError: BodyTimeoutError$1,
	RequestContentLengthMismatchError: RequestContentLengthMismatchError$1,
	ConnectTimeoutError: ConnectTimeoutError$1,
	ResponseStatusCodeError: ResponseStatusCodeError$1,
	InvalidArgumentError: InvalidArgumentError$f,
	InvalidReturnValueError: InvalidReturnValueError$2,
	RequestAbortedError: RequestAbortedError$8,
	ClientDestroyedError: ClientDestroyedError$1,
	ClientClosedError: ClientClosedError$1,
	InformationalError: InformationalError$1,
	SocketError: SocketError$3,
	NotSupportedError: NotSupportedError$3,
	ResponseContentLengthMismatchError: ResponseContentLengthMismatchError$1,
	BalancedPoolMissingUpstreamError
};
var assert$d = import_assert.default;
var { kDestroyed: kDestroyed$1, kBodyUsed: kBodyUsed$2 } = symbols$1;
var { IncomingMessage } = import_http.default;
var stream$1 = import_stream.default;
var net$2 = import_net.default;
var { InvalidArgumentError: InvalidArgumentError$e } = errors$1;
var { Blob: Blob$4 } = import_buffer.default;
var nodeUtil = import_util.default;
function nop() {}
function isStream(obj) {
	return obj && typeof obj.pipe === 'function';
}
function isBlobLike$4(object) {
	return (
		(Blob$4 && object instanceof Blob$4) ||
		(object &&
			typeof object === 'object' &&
			(typeof object.stream === 'function' || typeof object.arrayBuffer === 'function') &&
			/^(Blob|File)$/.test(object[Symbol.toStringTag]))
	);
}
function isObject(val) {
	return val !== null && typeof val === 'object';
}
function encode(val) {
	return encodeURIComponent(val);
}
function buildURL(url, queryParams) {
	if (url.includes('?') || url.includes('#')) {
		throw new Error('Query params cannot be passed when url already contains "?" or "#".');
	}
	if (!isObject(queryParams)) {
		throw new Error('Query params must be an object');
	}
	const parts = [];
	for (let [key3, val] of Object.entries(queryParams)) {
		if (val === null || typeof val === 'undefined') {
			continue;
		}
		if (!Array.isArray(val)) {
			val = [val];
		}
		for (const v of val) {
			if (isObject(v)) {
				throw new Error(
					'Passing object as a query param is not supported, please serialize to string up-front'
				);
			}
			parts.push(encode(key3) + '=' + encode(v));
		}
	}
	const serializedParams = parts.join('&');
	if (serializedParams) {
		url += '?' + serializedParams;
	}
	return url;
}
function parseURL(url) {
	if (typeof url === 'string') {
		url = new URL(url);
	}
	if (!url || typeof url !== 'object') {
		throw new InvalidArgumentError$e('invalid url');
	}
	if (url.port != null && url.port !== '' && !Number.isFinite(parseInt(url.port))) {
		throw new InvalidArgumentError$e('invalid port');
	}
	if (url.path != null && typeof url.path !== 'string') {
		throw new InvalidArgumentError$e('invalid path');
	}
	if (url.pathname != null && typeof url.pathname !== 'string') {
		throw new InvalidArgumentError$e('invalid pathname');
	}
	if (url.hostname != null && typeof url.hostname !== 'string') {
		throw new InvalidArgumentError$e('invalid hostname');
	}
	if (url.origin != null && typeof url.origin !== 'string') {
		throw new InvalidArgumentError$e('invalid origin');
	}
	if (!/^https?:/.test(url.origin || url.protocol)) {
		throw new InvalidArgumentError$e('invalid protocol');
	}
	if (!(url instanceof URL)) {
		const port = url.port != null ? url.port : url.protocol === 'https:' ? 443 : 80;
		const origin = url.origin != null ? url.origin : `${url.protocol}//${url.hostname}:${port}`;
		const path = url.path != null ? url.path : `${url.pathname || ''}${url.search || ''}`;
		url = new URL(path, origin);
	}
	return url;
}
function parseOrigin(url) {
	url = parseURL(url);
	if (url.pathname !== '/' || url.search || url.hash) {
		throw new InvalidArgumentError$e('invalid url');
	}
	return url;
}
function getHostname(host) {
	if (host[0] === '[') {
		const idx2 = host.indexOf(']');
		assert$d(idx2 !== -1);
		return host.substr(1, idx2 - 1);
	}
	const idx = host.indexOf(':');
	if (idx === -1) return host;
	return host.substr(0, idx);
}
function getServerName(host) {
	if (!host) {
		return null;
	}
	assert$d.strictEqual(typeof host, 'string');
	const servername = getHostname(host);
	if (net$2.isIP(servername)) {
		return '';
	}
	return servername;
}
function deepClone(obj) {
	return JSON.parse(JSON.stringify(obj));
}
function isAsyncIterable(obj) {
	return !!(obj != null && typeof obj[Symbol.asyncIterator] === 'function');
}
function isIterable(obj) {
	return !!(
		obj != null &&
		(typeof obj[Symbol.iterator] === 'function' || typeof obj[Symbol.asyncIterator] === 'function')
	);
}
function bodyLength(body4) {
	if (body4 == null) {
		return 0;
	} else if (isStream(body4)) {
		const state = body4._readableState;
		return state && state.ended === true && Number.isFinite(state.length) ? state.length : null;
	} else if (isBlobLike$4(body4)) {
		return body4.size != null ? body4.size : null;
	} else if (isBuffer(body4)) {
		return body4.byteLength;
	}
	return null;
}
function isDestroyed(stream2) {
	return !stream2 || !!(stream2.destroyed || stream2[kDestroyed$1]);
}
function isReadableAborted(stream2) {
	const state = stream2 && stream2._readableState;
	return isDestroyed(stream2) && state && !state.endEmitted;
}
function destroy(stream2, err) {
	if (!isStream(stream2) || isDestroyed(stream2)) {
		return;
	}
	if (typeof stream2.destroy === 'function') {
		if (Object.getPrototypeOf(stream2).constructor === IncomingMessage) {
			stream2.socket = null;
		}
		stream2.destroy(err);
	} else if (err) {
		process.nextTick(
			(stream3, err2) => {
				stream3.emit('error', err2);
			},
			stream2,
			err
		);
	}
	if (stream2.destroyed !== true) {
		stream2[kDestroyed$1] = true;
	}
}
var KEEPALIVE_TIMEOUT_EXPR = /timeout=(\d+)/;
function parseKeepAliveTimeout(val) {
	const m2 = val.toString().match(KEEPALIVE_TIMEOUT_EXPR);
	return m2 ? parseInt(m2[1], 10) * 1e3 : null;
}
function parseHeaders(headers2, obj = {}) {
	for (let i2 = 0; i2 < headers2.length; i2 += 2) {
		const key3 = headers2[i2].toString().toLowerCase();
		let val = obj[key3];
		if (!val) {
			obj[key3] = headers2[i2 + 1].toString();
		} else {
			if (!Array.isArray(val)) {
				val = [val];
				obj[key3] = val;
			}
			val.push(headers2[i2 + 1].toString());
		}
	}
	return obj;
}
function parseRawHeaders(headers2) {
	return headers2.map((header) => header.toString());
}
function isBuffer(buffer2) {
	return buffer2 instanceof Uint8Array || Buffer.isBuffer(buffer2);
}
function validateHandler(handler, method, upgrade2) {
	if (!handler || typeof handler !== 'object') {
		throw new InvalidArgumentError$e('handler must be an object');
	}
	if (typeof handler.onConnect !== 'function') {
		throw new InvalidArgumentError$e('invalid onConnect method');
	}
	if (typeof handler.onError !== 'function') {
		throw new InvalidArgumentError$e('invalid onError method');
	}
	if (typeof handler.onBodySent !== 'function' && handler.onBodySent !== void 0) {
		throw new InvalidArgumentError$e('invalid onBodySent method');
	}
	if (upgrade2 || method === 'CONNECT') {
		if (typeof handler.onUpgrade !== 'function') {
			throw new InvalidArgumentError$e('invalid onUpgrade method');
		}
	} else {
		if (typeof handler.onHeaders !== 'function') {
			throw new InvalidArgumentError$e('invalid onHeaders method');
		}
		if (typeof handler.onData !== 'function') {
			throw new InvalidArgumentError$e('invalid onData method');
		}
		if (typeof handler.onComplete !== 'function') {
			throw new InvalidArgumentError$e('invalid onComplete method');
		}
	}
}
function isDisturbed(body4) {
	return !!(
		body4 &&
		(stream$1.isDisturbed
			? stream$1.isDisturbed(body4) || body4[kBodyUsed$2]
			: body4[kBodyUsed$2] ||
			  body4.readableDidRead ||
			  (body4._readableState && body4._readableState.dataEmitted) ||
			  isReadableAborted(body4))
	);
}
function isErrored$2(body4) {
	return !!(
		body4 &&
		(stream$1.isErrored
			? stream$1.isErrored(body4)
			: /state: 'errored'/.test(nodeUtil.inspect(body4)))
	);
}
function isReadable$1(body4) {
	return !!(
		body4 &&
		(stream$1.isReadable
			? stream$1.isReadable(body4)
			: /state: 'readable'/.test(nodeUtil.inspect(body4)))
	);
}
function getSocketInfo(socket) {
	return {
		localAddress: socket.localAddress,
		localPort: socket.localPort,
		remoteAddress: socket.remoteAddress,
		remotePort: socket.remotePort,
		remoteFamily: socket.remoteFamily,
		timeout: socket.timeout,
		bytesWritten: socket.bytesWritten,
		bytesRead: socket.bytesRead
	};
}
var ReadableStream$2;
function ReadableStreamFrom$3(iterable) {
	if (!ReadableStream$2) {
		ReadableStream$2 = import_web.default.ReadableStream;
	}
	if (ReadableStream$2.from) {
		return ReadableStream$2.from(iterable);
	}
	let iterator;
	return new ReadableStream$2(
		{
			async start() {
				iterator = iterable[Symbol.asyncIterator]();
			},
			async pull(controller) {
				const { done, value } = await iterator.next();
				if (done) {
					queueMicrotask(() => {
						controller.close();
					});
				} else {
					const buf = Buffer.isBuffer(value) ? value : Buffer.from(value);
					controller.enqueue(new Uint8Array(buf));
				}
				return controller.desiredSize > 0;
			},
			async cancel(reason) {
				await iterator.return();
			}
		},
		0
	);
}
function isFormDataLike(chunk) {
	return chunk && chunk.constructor && chunk.constructor.name === 'FormData';
}
var kEnumerableProperty$3 = /* @__PURE__ */ Object.create(null);
kEnumerableProperty$3.enumerable = true;
var util$h = {
	kEnumerableProperty: kEnumerableProperty$3,
	nop,
	isDisturbed,
	isErrored: isErrored$2,
	isReadable: isReadable$1,
	toUSVString: nodeUtil.toUSVString || ((val) => `${val}`),
	isReadableAborted,
	isBlobLike: isBlobLike$4,
	parseOrigin,
	parseURL,
	getServerName,
	isStream,
	isIterable,
	isAsyncIterable,
	isDestroyed,
	parseRawHeaders,
	parseHeaders,
	parseKeepAliveTimeout,
	destroy,
	bodyLength,
	deepClone,
	ReadableStreamFrom: ReadableStreamFrom$3,
	isBuffer,
	validateHandler,
	getSocketInfo,
	isFormDataLike,
	buildURL
};
var corsSafeListedMethods$1 = ['GET', 'HEAD', 'POST'];
var nullBodyStatus$2 = [101, 204, 205, 304];
var redirectStatus$3 = [301, 302, 303, 307, 308];
var referrerPolicy$1 = [
	'',
	'no-referrer',
	'no-referrer-when-downgrade',
	'same-origin',
	'origin',
	'strict-origin',
	'origin-when-cross-origin',
	'strict-origin-when-cross-origin',
	'unsafe-url'
];
var requestRedirect$1 = ['follow', 'manual', 'error'];
var safeMethods$1 = ['GET', 'HEAD', 'OPTIONS', 'TRACE'];
var requestMode$1 = ['navigate', 'same-origin', 'no-cors', 'cors'];
var requestCredentials$1 = ['omit', 'same-origin', 'include'];
var requestCache$1 = ['default', 'no-store', 'reload', 'no-cache', 'force-cache', 'only-if-cached'];
var requestBodyHeader$1 = [
	'content-encoding',
	'content-language',
	'content-location',
	'content-type'
];
var forbiddenMethods$1 = ['CONNECT', 'TRACE', 'TRACK'];
var subresource$1 = [
	'audio',
	'audioworklet',
	'font',
	'image',
	'manifest',
	'paintworklet',
	'script',
	'style',
	'track',
	'video',
	'xslt',
	''
];
var constants$2 = {
	subresource: subresource$1,
	forbiddenMethods: forbiddenMethods$1,
	requestBodyHeader: requestBodyHeader$1,
	referrerPolicy: referrerPolicy$1,
	requestRedirect: requestRedirect$1,
	requestMode: requestMode$1,
	requestCredentials: requestCredentials$1,
	requestCache: requestCache$1,
	redirectStatus: redirectStatus$3,
	corsSafeListedMethods: corsSafeListedMethods$1,
	nullBodyStatus: nullBodyStatus$2,
	safeMethods: safeMethods$1
};
var symbols = {
	kUrl: Symbol('url'),
	kHeaders: Symbol('headers'),
	kSignal: Symbol('signal'),
	kState: Symbol('state'),
	kGuard: Symbol('guard'),
	kRealm: Symbol('realm')
};
var { Blob: Blob$3 } = import_buffer.default;
var { kState: kState$5 } = symbols;
var File$2 = class extends Blob$3 {
	constructor(fileBits, fileName, options = {}) {
		const n = fileName;
		const t2 = options.type;
		const d = options.lastModified ?? Date.now();
		super(fileBits, { type: t2 });
		this[kState$5] = {
			name: n,
			lastModified: d
		};
	}
	get name() {
		if (!(this instanceof File$2)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kState$5].name;
	}
	get lastModified() {
		if (!(this instanceof File$2)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kState$5].lastModified;
	}
	get [Symbol.toStringTag]() {
		return this.constructor.name;
	}
};
var FileLike$1 = class {
	constructor(blobLike, fileName, options = {}) {
		const n = fileName;
		const t2 = options.type;
		const d = options.lastModified ?? Date.now();
		this[kState$5] = {
			blobLike,
			name: n,
			type: t2,
			lastModified: d
		};
	}
	stream(...args) {
		if (!(this instanceof FileLike$1)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kState$5].blobLike.stream(...args);
	}
	arrayBuffer(...args) {
		if (!(this instanceof FileLike$1)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kState$5].blobLike.arrayBuffer(...args);
	}
	slice(...args) {
		if (!(this instanceof FileLike$1)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kState$5].blobLike.slice(...args);
	}
	text(...args) {
		if (!(this instanceof FileLike$1)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kState$5].blobLike.text(...args);
	}
	get size() {
		if (!(this instanceof FileLike$1)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kState$5].blobLike.size;
	}
	get type() {
		if (!(this instanceof FileLike$1)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kState$5].blobLike.type;
	}
	get name() {
		if (!(this instanceof FileLike$1)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kState$5].name;
	}
	get lastModified() {
		if (!(this instanceof FileLike$1)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kState$5].lastModified;
	}
	get [Symbol.toStringTag]() {
		return 'File';
	}
};
var file = { File: globalThis.File ?? File$2, FileLike: FileLike$1 };
var { redirectStatus: redirectStatus$2 } = constants$2;
var { performance } = import_perf_hooks.default;
var {
	isBlobLike: isBlobLike$3,
	toUSVString: toUSVString$5,
	ReadableStreamFrom: ReadableStreamFrom$2
} = util$h;
var assert$c = import_assert.default;
var File$1;
var badPorts = [
	'1',
	'7',
	'9',
	'11',
	'13',
	'15',
	'17',
	'19',
	'20',
	'21',
	'22',
	'23',
	'25',
	'37',
	'42',
	'43',
	'53',
	'69',
	'77',
	'79',
	'87',
	'95',
	'101',
	'102',
	'103',
	'104',
	'109',
	'110',
	'111',
	'113',
	'115',
	'117',
	'119',
	'123',
	'135',
	'137',
	'139',
	'143',
	'161',
	'179',
	'389',
	'427',
	'465',
	'512',
	'513',
	'514',
	'515',
	'526',
	'530',
	'531',
	'532',
	'540',
	'548',
	'554',
	'556',
	'563',
	'587',
	'601',
	'636',
	'989',
	'990',
	'993',
	'995',
	'1719',
	'1720',
	'1723',
	'2049',
	'3659',
	'4045',
	'5060',
	'5061',
	'6000',
	'6566',
	'6665',
	'6666',
	'6667',
	'6668',
	'6669',
	'6697',
	'10080'
];
function responseURL$1(response2) {
	const urlList = response2.urlList;
	const length = urlList.length;
	return length === 0 ? null : urlList[length - 1].toString();
}
function responseLocationURL$1(response2, requestFragment) {
	if (!redirectStatus$2.includes(response2.status)) {
		return null;
	}
	let location2 = response2.headersList.get('location');
	location2 = location2 ? new URL(location2, responseURL$1(response2)) : null;
	if (location2 && !location2.hash) {
		location2.hash = requestFragment;
	}
	return location2;
}
function requestCurrentURL$1(request2) {
	return request2.urlList[request2.urlList.length - 1];
}
function requestBadPort$1(request2) {
	const url = requestCurrentURL$1(request2);
	if (/^https?:/.test(url.protocol) && badPorts.includes(url.port)) {
		return 'blocked';
	}
	return 'allowed';
}
function isFileLike$1(object) {
	if (!File$1) {
		File$1 = file.File;
	}
	return (
		object instanceof File$1 ||
		(object &&
			(typeof object.stream === 'function' || typeof object.arrayBuffer === 'function') &&
			/^(File)$/.test(object[Symbol.toStringTag]))
	);
}
function isValidReasonPhrase$1(statusText) {
	for (let i2 = 0; i2 < statusText.length; ++i2) {
		const c = statusText.charCodeAt(i2);
		if (!(c === 9 || (c >= 32 && c <= 126) || (c >= 128 && c <= 255))) {
			return false;
		}
	}
	return true;
}
function isTokenChar(c) {
	return !(
		c >= 127 ||
		c <= 32 ||
		c === '(' ||
		c === ')' ||
		c === '<' ||
		c === '>' ||
		c === '@' ||
		c === ',' ||
		c === ';' ||
		c === ':' ||
		c === '\\' ||
		c === '"' ||
		c === '/' ||
		c === '[' ||
		c === ']' ||
		c === '?' ||
		c === '=' ||
		c === '{' ||
		c === '}'
	);
}
function isValidHTTPToken$1(characters2) {
	if (!characters2 || typeof characters2 !== 'string') {
		return false;
	}
	for (let i2 = 0; i2 < characters2.length; ++i2) {
		const c = characters2.charCodeAt(i2);
		if (c > 127 || !isTokenChar(c)) {
			return false;
		}
	}
	return true;
}
function setRequestReferrerPolicyOnRedirect$1(request2, actualResponse) {}
function crossOriginResourcePolicyCheck$1() {
	return 'allowed';
}
function corsCheck$1() {
	return 'success';
}
function TAOCheck$1() {
	return 'success';
}
function appendFetchMetadata$1(httpRequest) {
	let header = null;
	header = httpRequest.mode;
	httpRequest.headersList.set('sec-fetch-mode', header);
}
function appendRequestOriginHeader$1(request2) {
	let serializedOrigin = request2.origin;
	if (request2.responseTainting === 'cors' || request2.mode === 'websocket') {
		if (serializedOrigin) {
			request2.headersList.append('Origin', serializedOrigin);
		}
	} else if (request2.method !== 'GET' && request2.method !== 'HEAD') {
		switch (request2.referrerPolicy) {
			case 'no-referrer':
				serializedOrigin = null;
				break;
			case 'no-referrer-when-downgrade':
			case 'strict-origin':
			case 'strict-origin-when-cross-origin':
				if (/^https:/.test(request2.origin) && !/^https:/.test(requestCurrentURL$1(request2))) {
					serializedOrigin = null;
				}
				break;
			case 'same-origin':
				if (!sameOrigin$2(request2, requestCurrentURL$1(request2))) {
					serializedOrigin = null;
				}
				break;
		}
		if (serializedOrigin) {
			request2.headersList.append('Origin', serializedOrigin);
		}
	}
}
function coarsenedSharedCurrentTime$1(crossOriginIsolatedCapability) {
	return performance.now();
}
function createOpaqueTimingInfo$1(timingInfo) {
	return {
		startTime: timingInfo.startTime ?? 0,
		redirectStartTime: 0,
		redirectEndTime: 0,
		postRedirectStartTime: timingInfo.startTime ?? 0,
		finalServiceWorkerStartTime: 0,
		finalNetworkResponseStartTime: 0,
		finalNetworkRequestStartTime: 0,
		endTime: 0,
		encodedBodySize: 0,
		decodedBodySize: 0,
		finalConnectionTimingInfo: null
	};
}
function makePolicyContainer$1() {
	return {};
}
function clonePolicyContainer$1() {
	return {};
}
function determineRequestsReferrer$1(request2) {
	return 'no-referrer';
}
function matchRequestIntegrity$1(request2, bytes) {
	return false;
}
function tryUpgradeRequestToAPotentiallyTrustworthyURL$1(request2) {}
function sameOrigin$2(A2, B) {
	if (A2.protocol === B.protocol && A2.hostname === B.hostname && A2.port === B.port) {
		return true;
	}
	return false;
}
function createDeferredPromise$1() {
	let res;
	let rej;
	const promise = new Promise((resolve2, reject) => {
		res = resolve2;
		rej = reject;
	});
	return { promise, resolve: res, reject: rej };
}
function isAborted$2(fetchParams) {
	return fetchParams.controller.state === 'aborted';
}
function isCancelled$2(fetchParams) {
	return (
		fetchParams.controller.state === 'aborted' || fetchParams.controller.state === 'terminated'
	);
}
function normalizeMethod$1(method) {
	return /^(DELETE|GET|HEAD|OPTIONS|POST|PUT)$/i.test(method) ? method.toUpperCase() : method;
}
function serializeJavascriptValueToJSONString$1(value) {
	const result = JSON.stringify(value);
	if (result === void 0) {
		throw new TypeError('Value is not JSON serializable');
	}
	assert$c(typeof result === 'string');
	return result;
}
var util$g = {
	isAborted: isAborted$2,
	isCancelled: isCancelled$2,
	createDeferredPromise: createDeferredPromise$1,
	ReadableStreamFrom: ReadableStreamFrom$2,
	toUSVString: toUSVString$5,
	tryUpgradeRequestToAPotentiallyTrustworthyURL: tryUpgradeRequestToAPotentiallyTrustworthyURL$1,
	coarsenedSharedCurrentTime: coarsenedSharedCurrentTime$1,
	matchRequestIntegrity: matchRequestIntegrity$1,
	determineRequestsReferrer: determineRequestsReferrer$1,
	makePolicyContainer: makePolicyContainer$1,
	clonePolicyContainer: clonePolicyContainer$1,
	appendFetchMetadata: appendFetchMetadata$1,
	appendRequestOriginHeader: appendRequestOriginHeader$1,
	TAOCheck: TAOCheck$1,
	corsCheck: corsCheck$1,
	crossOriginResourcePolicyCheck: crossOriginResourcePolicyCheck$1,
	createOpaqueTimingInfo: createOpaqueTimingInfo$1,
	setRequestReferrerPolicyOnRedirect: setRequestReferrerPolicyOnRedirect$1,
	isValidHTTPToken: isValidHTTPToken$1,
	requestBadPort: requestBadPort$1,
	requestCurrentURL: requestCurrentURL$1,
	responseURL: responseURL$1,
	responseLocationURL: responseLocationURL$1,
	isBlobLike: isBlobLike$3,
	isFileLike: isFileLike$1,
	isValidReasonPhrase: isValidReasonPhrase$1,
	sameOrigin: sameOrigin$2,
	normalizeMethod: normalizeMethod$1,
	serializeJavascriptValueToJSONString: serializeJavascriptValueToJSONString$1
};
var { isBlobLike: isBlobLike$2, isFileLike, toUSVString: toUSVString$4 } = util$g;
var { kState: kState$4 } = symbols;
var { File, FileLike } = file;
var { Blob: Blob$2 } = import_buffer.default;
var _FormData$1 = class {
	constructor(...args) {
		if (args.length > 0 && !(args[0]?.constructor?.name === 'HTMLFormElement')) {
			throw new TypeError(
				"Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'"
			);
		}
		this[kState$4] = [];
	}
	append(...args) {
		if (!(this instanceof _FormData$1)) {
			throw new TypeError('Illegal invocation');
		}
		if (args.length < 2) {
			throw new TypeError(
				`Failed to execute 'append' on 'FormData': 2 arguments required, but only ${args.length} present.`
			);
		}
		if (args.length === 3 && !isBlobLike$2(args[1])) {
			throw new TypeError(
				"Failed to execute 'append' on 'FormData': parameter 2 is not of type 'Blob'"
			);
		}
		const name = toUSVString$4(args[0]);
		const filename = args.length === 3 ? toUSVString$4(args[2]) : void 0;
		const value = isBlobLike$2(args[1]) ? args[1] : toUSVString$4(args[1]);
		const entry5 = makeEntry(name, value, filename);
		this[kState$4].push(entry5);
	}
	delete(...args) {
		if (!(this instanceof _FormData$1)) {
			throw new TypeError('Illegal invocation');
		}
		if (args.length < 1) {
			throw new TypeError(
				`Failed to execute 'delete' on 'FormData': 1 arguments required, but only ${args.length} present.`
			);
		}
		const name = toUSVString$4(args[0]);
		const next = [];
		for (const entry5 of this[kState$4]) {
			if (entry5.name !== name) {
				next.push(entry5);
			}
		}
		this[kState$4] = next;
	}
	get(...args) {
		if (!(this instanceof _FormData$1)) {
			throw new TypeError('Illegal invocation');
		}
		if (args.length < 1) {
			throw new TypeError(
				`Failed to execute 'get' on 'FormData': 1 arguments required, but only ${args.length} present.`
			);
		}
		const name = toUSVString$4(args[0]);
		const idx = this[kState$4].findIndex((entry5) => entry5.name === name);
		if (idx === -1) {
			return null;
		}
		return this[kState$4][idx].value;
	}
	getAll(...args) {
		if (!(this instanceof _FormData$1)) {
			throw new TypeError('Illegal invocation');
		}
		if (args.length < 1) {
			throw new TypeError(
				`Failed to execute 'getAll' on 'FormData': 1 arguments required, but only ${args.length} present.`
			);
		}
		const name = toUSVString$4(args[0]);
		return this[kState$4].filter((entry5) => entry5.name === name).map((entry5) => entry5.value);
	}
	has(...args) {
		if (!(this instanceof _FormData$1)) {
			throw new TypeError('Illegal invocation');
		}
		if (args.length < 1) {
			throw new TypeError(
				`Failed to execute 'has' on 'FormData': 1 arguments required, but only ${args.length} present.`
			);
		}
		const name = toUSVString$4(args[0]);
		return this[kState$4].findIndex((entry5) => entry5.name === name) !== -1;
	}
	set(...args) {
		if (!(this instanceof _FormData$1)) {
			throw new TypeError('Illegal invocation');
		}
		if (args.length < 2) {
			throw new TypeError(
				`Failed to execute 'set' on 'FormData': 2 arguments required, but only ${args.length} present.`
			);
		}
		if (args.length === 3 && !isBlobLike$2(args[1])) {
			throw new TypeError(
				"Failed to execute 'set' on 'FormData': parameter 2 is not of type 'Blob'"
			);
		}
		const name = toUSVString$4(args[0]);
		const filename = args.length === 3 ? toUSVString$4(args[2]) : void 0;
		const value = isBlobLike$2(args[1]) ? args[1] : toUSVString$4(args[1]);
		const entry5 = makeEntry(name, value, filename);
		const idx = this[kState$4].findIndex((entry6) => entry6.name === name);
		if (idx !== -1) {
			this[kState$4] = [
				...this[kState$4].slice(0, idx),
				entry5,
				...this[kState$4].slice(idx + 1).filter((entry6) => entry6.name !== name)
			];
		} else {
			this[kState$4].push(entry5);
		}
	}
	get [Symbol.toStringTag]() {
		return this.constructor.name;
	}
	*entries() {
		if (!(this instanceof _FormData$1)) {
			throw new TypeError('Illegal invocation');
		}
		for (const pair of this) {
			yield pair;
		}
	}
	*keys() {
		if (!(this instanceof _FormData$1)) {
			throw new TypeError('Illegal invocation');
		}
		for (const [key3] of this) {
			yield key3;
		}
	}
	*values() {
		if (!(this instanceof _FormData$1)) {
			throw new TypeError('Illegal invocation');
		}
		for (const [, value] of this) {
			yield value;
		}
	}
	*[Symbol.iterator]() {
		for (const { name, value } of this[kState$4]) {
			yield [name, value];
		}
	}
};
var FormData$1 = _FormData$1;
__publicField(FormData$1, 'name', 'FormData');
function makeEntry(name, value, filename) {
	const entry5 = {
		name: null,
		value: null
	};
	entry5.name = name;
	if (isBlobLike$2(value) && !isFileLike(value)) {
		value =
			value instanceof Blob$2
				? new File([value], 'blob', value)
				: new FileLike(value, 'blob', value);
	}
	if (isFileLike(value) && filename != null) {
		value =
			value instanceof File
				? new File([value], filename, value)
				: new FileLike(value, filename, value);
	}
	entry5.value = value;
	return entry5;
}
var formdata = { FormData: FormData$1 };
var util$f = util$h;
var {
	ReadableStreamFrom: ReadableStreamFrom$1,
	toUSVString: toUSVString$3,
	isBlobLike: isBlobLike$1
} = util$g;
var { FormData } = formdata;
var { kState: kState$3 } = symbols;
var { Blob: Blob$1 } = import_buffer.default;
var { kBodyUsed: kBodyUsed$1 } = symbols$1;
var assert$b = import_assert.default;
var { NotSupportedError: NotSupportedError$2 } = errors$1;
var { isErrored: isErrored$1 } = util$h;
var { isUint8Array } = import_types.default;
var ReadableStream$1;
async function* blobGen(blob) {
	if (blob.stream) {
		yield* blob.stream();
	} else {
		yield await blob.arrayBuffer();
	}
}
function extractBody$4(object, keepalive = false) {
	if (!ReadableStream$1) {
		ReadableStream$1 = import_web.default.ReadableStream;
	}
	let stream2 = null;
	let action = null;
	let source = null;
	let length = null;
	let contentType = null;
	if (object == null);
	else if (object instanceof URLSearchParams) {
		source = object.toString();
		contentType = 'application/x-www-form-urlencoded;charset=UTF-8';
	} else if (object instanceof ArrayBuffer || ArrayBuffer.isView(object)) {
		if (object instanceof DataView) {
			object = object.buffer;
		}
		source = new Uint8Array(object);
	} else if (util$f.isFormDataLike(object)) {
		const boundary = '----formdata-undici-' + Math.random();
		const prefix = `--${boundary}\r
Content-Disposition: form-data`;
		const escape2 = (str) => str.replace(/\n/g, '%0A').replace(/\r/g, '%0D').replace(/"/g, '%22');
		const normalizeLinefeeds = (value) => value.replace(/\r?\n|\r/g, '\r\n');
		action = async function* (object2) {
			const enc = new TextEncoder();
			for (const [name, value] of object2) {
				if (typeof value === 'string') {
					yield enc.encode(
						prefix +
							`; name="${escape2(normalizeLinefeeds(name))}"\r
\r
${normalizeLinefeeds(value)}\r
`
					);
				} else {
					yield enc.encode(
						prefix +
							`; name="${escape2(normalizeLinefeeds(name))}"` +
							(value.name ? `; filename="${escape2(value.name)}"` : '') +
							`\r
Content-Type: ${value.type || 'application/octet-stream'}\r
\r
`
					);
					yield* blobGen(value);
					yield enc.encode('\r\n');
				}
			}
			yield enc.encode(`--${boundary}--`);
		};
		source = object;
		contentType = 'multipart/form-data; boundary=' + boundary;
	} else if (isBlobLike$1(object)) {
		action = blobGen;
		source = object;
		length = object.size;
		if (object.type) {
			contentType = object.type;
		}
	} else if (typeof object[Symbol.asyncIterator] === 'function') {
		if (keepalive) {
			throw new TypeError('keepalive');
		}
		if (util$f.isDisturbed(object) || object.locked) {
			throw new TypeError('Response body object should not be disturbed or locked');
		}
		stream2 = object instanceof ReadableStream$1 ? object : ReadableStreamFrom$1(object);
	} else {
		source = toUSVString$3(object);
		contentType = 'text/plain;charset=UTF-8';
	}
	if (typeof source === 'string' || util$f.isBuffer(source)) {
		length = Buffer.byteLength(source);
	}
	if (action != null) {
		let iterator;
		stream2 = new ReadableStream$1({
			async start() {
				iterator = action(object)[Symbol.asyncIterator]();
			},
			async pull(controller) {
				const { value, done } = await iterator.next();
				if (done) {
					queueMicrotask(() => {
						controller.close();
					});
				} else {
					if (!isErrored$1(stream2)) {
						controller.enqueue(new Uint8Array(value));
					}
				}
				return controller.desiredSize > 0;
			},
			async cancel(reason) {
				await iterator.return();
			}
		});
	} else if (!stream2) {
		stream2 = new ReadableStream$1({
			async pull(controller) {
				controller.enqueue(typeof source === 'string' ? new TextEncoder().encode(source) : source);
				queueMicrotask(() => {
					controller.close();
				});
			}
		});
	}
	const body4 = { stream: stream2, source, length };
	return [body4, contentType];
}
function safelyExtractBody$1(object, keepalive = false) {
	if (!ReadableStream$1) {
		ReadableStream$1 = import_web.default.ReadableStream;
	}
	if (object instanceof ReadableStream$1) {
		assert$b(!util$f.isDisturbed(object), 'disturbed');
		assert$b(!object.locked, 'locked');
	}
	return extractBody$4(object, keepalive);
}
function cloneBody$2(body4) {
	const [out1, out2] = body4.stream.tee();
	body4.stream = out1;
	return {
		stream: out2,
		length: body4.length,
		source: body4.source
	};
}
var methods = {
	async blob() {
		const chunks = [];
		if (this[kState$3].body) {
			if (isUint8Array(this[kState$3].body)) {
				chunks.push(this[kState$3].body);
			} else {
				const stream2 = this[kState$3].body.stream;
				if (util$f.isDisturbed(stream2)) {
					throw new TypeError('disturbed');
				}
				if (stream2.locked) {
					throw new TypeError('locked');
				}
				stream2[kBodyUsed$1] = true;
				for await (const chunk of stream2) {
					chunks.push(chunk);
				}
			}
		}
		return new Blob$1(chunks, { type: this.headers.get('Content-Type') || '' });
	},
	async arrayBuffer() {
		const blob = await this.blob();
		return await blob.arrayBuffer();
	},
	async text() {
		const blob = await this.blob();
		return toUSVString$3(await blob.text());
	},
	async json() {
		return JSON.parse(await this.text());
	},
	async formData() {
		const contentType = this.headers.get('Content-Type');
		if (/multipart\/form-data/.test(contentType)) {
			throw new NotSupportedError$2('multipart/form-data not supported');
		} else if (/application\/x-www-form-urlencoded/.test(contentType)) {
			let entries;
			try {
				entries = new URLSearchParams(await this.text());
			} catch (err) {
				throw Object.assign(new TypeError(), { cause: err });
			}
			const formData = new FormData();
			for (const [name, value] of entries) {
				formData.append(name, value);
			}
			return formData;
		} else {
			throw new TypeError();
		}
	}
};
var properties = {
	body: {
		enumerable: true,
		get() {
			return this[kState$3].body ? this[kState$3].body.stream : null;
		}
	},
	bodyUsed: {
		enumerable: true,
		get() {
			return !!this[kState$3].body && util$f.isDisturbed(this[kState$3].body.stream);
		}
	}
};
function mixinBody$2(prototype) {
	Object.assign(prototype, methods);
	Object.defineProperties(prototype, properties);
}
var body = {
	extractBody: extractBody$4,
	safelyExtractBody: safelyExtractBody$1,
	cloneBody: cloneBody$2,
	mixinBody: mixinBody$2
};
var { InvalidArgumentError: InvalidArgumentError$d, NotSupportedError: NotSupportedError$1 } =
	errors$1;
var assert$a = import_assert.default;
var util$e = util$h;
var kHandler = Symbol('handler');
var channels$1 = {};
var extractBody$3;
var nodeVersion$1 = process.versions.node.split('.');
var nodeMajor$1 = Number(nodeVersion$1[0]);
var nodeMinor$1 = Number(nodeVersion$1[1]);
try {
	const diagnosticsChannel = require('diagnostics_channel');
	channels$1.create = diagnosticsChannel.channel('undici:request:create');
	channels$1.bodySent = diagnosticsChannel.channel('undici:request:bodySent');
	channels$1.headers = diagnosticsChannel.channel('undici:request:headers');
	channels$1.trailers = diagnosticsChannel.channel('undici:request:trailers');
	channels$1.error = diagnosticsChannel.channel('undici:request:error');
} catch {
	channels$1.create = { hasSubscribers: false };
	channels$1.bodySent = { hasSubscribers: false };
	channels$1.headers = { hasSubscribers: false };
	channels$1.trailers = { hasSubscribers: false };
	channels$1.error = { hasSubscribers: false };
}
var Request$4 = class {
	constructor(
		origin,
		{
			path,
			method,
			body: body$1,
			headers: headers2,
			query,
			idempotent,
			blocking,
			upgrade: upgrade2,
			headersTimeout,
			bodyTimeout,
			throwOnError
		},
		handler
	) {
		if (typeof path !== 'string') {
			throw new InvalidArgumentError$d('path must be a string');
		} else if (path[0] !== '/' && !(path.startsWith('http://') || path.startsWith('https://'))) {
			throw new InvalidArgumentError$d('path must be an absolute URL or start with a slash');
		}
		if (typeof method !== 'string') {
			throw new InvalidArgumentError$d('method must be a string');
		}
		if (upgrade2 && typeof upgrade2 !== 'string') {
			throw new InvalidArgumentError$d('upgrade must be a string');
		}
		if (headersTimeout != null && (!Number.isFinite(headersTimeout) || headersTimeout < 0)) {
			throw new InvalidArgumentError$d('invalid headersTimeout');
		}
		if (bodyTimeout != null && (!Number.isFinite(bodyTimeout) || bodyTimeout < 0)) {
			throw new InvalidArgumentError$d('invalid bodyTimeout');
		}
		this.headersTimeout = headersTimeout;
		this.bodyTimeout = bodyTimeout;
		this.throwOnError = throwOnError === true;
		this.method = method;
		if (body$1 == null) {
			this.body = null;
		} else if (util$e.isStream(body$1)) {
			this.body = body$1;
		} else if (body$1 instanceof DataView) {
			this.body = body$1.buffer.byteLength ? Buffer.from(body$1.buffer) : null;
		} else if (body$1 instanceof ArrayBuffer || ArrayBuffer.isView(body$1)) {
			this.body = body$1.byteLength ? Buffer.from(body$1) : null;
		} else if (util$e.isBuffer(body$1)) {
			this.body = body$1.byteLength ? body$1 : null;
		} else if (typeof body$1 === 'string') {
			this.body = body$1.length ? Buffer.from(body$1) : null;
		} else if (
			util$e.isFormDataLike(body$1) ||
			util$e.isIterable(body$1) ||
			util$e.isBlobLike(body$1)
		) {
			this.body = body$1;
		} else {
			throw new InvalidArgumentError$d(
				'body must be a string, a Buffer, a Readable stream, an iterable, or an async iterable'
			);
		}
		this.completed = false;
		this.aborted = false;
		this.upgrade = upgrade2 || null;
		this.path = query ? util$e.buildURL(path, query) : path;
		this.origin = origin;
		this.idempotent = idempotent == null ? method === 'HEAD' || method === 'GET' : idempotent;
		this.blocking = blocking == null ? false : blocking;
		this.host = null;
		this.contentLength = null;
		this.contentType = null;
		this.headers = '';
		if (Array.isArray(headers2)) {
			if (headers2.length % 2 !== 0) {
				throw new InvalidArgumentError$d('headers array must be even');
			}
			for (let i2 = 0; i2 < headers2.length; i2 += 2) {
				processHeader(this, headers2[i2], headers2[i2 + 1]);
			}
		} else if (headers2 && typeof headers2 === 'object') {
			const keys2 = Object.keys(headers2);
			for (let i2 = 0; i2 < keys2.length; i2++) {
				const key3 = keys2[i2];
				processHeader(this, key3, headers2[key3]);
			}
		} else if (headers2 != null) {
			throw new InvalidArgumentError$d('headers must be an object or an array');
		}
		if (util$e.isFormDataLike(this.body)) {
			if (nodeMajor$1 < 16 || (nodeMajor$1 === 16 && nodeMinor$1 < 5)) {
				throw new InvalidArgumentError$d(
					'Form-Data bodies are only supported in node v16.5 and newer.'
				);
			}
			if (!extractBody$3) {
				extractBody$3 = body.extractBody;
			}
			const [bodyStream, contentType] = extractBody$3(body$1);
			if (this.contentType == null) {
				this.contentType = contentType;
				this.headers += `content-type: ${contentType}\r
`;
			}
			this.body = bodyStream.stream;
		} else if (util$e.isBlobLike(body$1) && this.contentType == null && body$1.type) {
			this.contentType = body$1.type;
			this.headers += `content-type: ${body$1.type}\r
`;
		}
		util$e.validateHandler(handler, method, upgrade2);
		this.servername = util$e.getServerName(this.host);
		this[kHandler] = handler;
		if (channels$1.create.hasSubscribers) {
			channels$1.create.publish({ request: this });
		}
	}
	onBodySent(chunk) {
		if (this[kHandler].onBodySent) {
			try {
				this[kHandler].onBodySent(chunk);
			} catch (err) {
				this.onError(err);
			}
		}
	}
	onRequestSent() {
		if (channels$1.bodySent.hasSubscribers) {
			channels$1.bodySent.publish({ request: this });
		}
	}
	onConnect(abort2) {
		assert$a(!this.aborted);
		assert$a(!this.completed);
		return this[kHandler].onConnect(abort2);
	}
	onHeaders(statusCode, headers2, resume2, statusText) {
		assert$a(!this.aborted);
		assert$a(!this.completed);
		if (channels$1.headers.hasSubscribers) {
			channels$1.headers.publish({
				request: this,
				response: { statusCode, headers: headers2, statusText }
			});
		}
		return this[kHandler].onHeaders(statusCode, headers2, resume2, statusText);
	}
	onData(chunk) {
		assert$a(!this.aborted);
		assert$a(!this.completed);
		return this[kHandler].onData(chunk);
	}
	onUpgrade(statusCode, headers2, socket) {
		assert$a(!this.aborted);
		assert$a(!this.completed);
		return this[kHandler].onUpgrade(statusCode, headers2, socket);
	}
	onComplete(trailers) {
		assert$a(!this.aborted);
		this.completed = true;
		if (channels$1.trailers.hasSubscribers) {
			channels$1.trailers.publish({ request: this, trailers });
		}
		return this[kHandler].onComplete(trailers);
	}
	onError(error2) {
		if (channels$1.error.hasSubscribers) {
			channels$1.error.publish({ request: this, error: error2 });
		}
		if (this.aborted) {
			return;
		}
		this.aborted = true;
		return this[kHandler].onError(error2);
	}
	addHeader(key3, value) {
		processHeader(this, key3, value);
		return this;
	}
};
function processHeader(request2, key3, val) {
	if (val && typeof val === 'object') {
		throw new InvalidArgumentError$d(`invalid ${key3} header`);
	} else if (val === void 0) {
		return;
	}
	if (request2.host === null && key3.length === 4 && key3.toLowerCase() === 'host') {
		request2.host = val;
	} else if (
		request2.contentLength === null &&
		key3.length === 14 &&
		key3.toLowerCase() === 'content-length'
	) {
		request2.contentLength = parseInt(val, 10);
		if (!Number.isFinite(request2.contentLength)) {
			throw new InvalidArgumentError$d('invalid content-length header');
		}
	} else if (
		request2.contentType === null &&
		key3.length === 12 &&
		key3.toLowerCase() === 'content-type'
	) {
		request2.contentType = val;
		request2.headers += `${key3}: ${val}\r
`;
	} else if (key3.length === 17 && key3.toLowerCase() === 'transfer-encoding') {
		throw new InvalidArgumentError$d('invalid transfer-encoding header');
	} else if (key3.length === 10 && key3.toLowerCase() === 'connection') {
		throw new InvalidArgumentError$d('invalid connection header');
	} else if (key3.length === 10 && key3.toLowerCase() === 'keep-alive') {
		throw new InvalidArgumentError$d('invalid keep-alive header');
	} else if (key3.length === 7 && key3.toLowerCase() === 'upgrade') {
		throw new InvalidArgumentError$d('invalid upgrade header');
	} else if (key3.length === 6 && key3.toLowerCase() === 'expect') {
		throw new NotSupportedError$1('expect header not supported');
	} else {
		request2.headers += `${key3}: ${val}\r
`;
	}
}
var request$2 = Request$4;
var EventEmitter = import_events.default;
var Dispatcher$2 = class extends EventEmitter {
	dispatch() {
		throw new Error('not implemented');
	}
	close() {
		throw new Error('not implemented');
	}
	destroy() {
		throw new Error('not implemented');
	}
};
var dispatcher = Dispatcher$2;
var Dispatcher$1 = dispatcher;
var {
	ClientDestroyedError,
	ClientClosedError,
	InvalidArgumentError: InvalidArgumentError$c
} = errors$1;
var { kDestroy: kDestroy$3, kClose: kClose$3, kDispatch: kDispatch$3 } = symbols$1;
var kDestroyed = Symbol('destroyed');
var kClosed = Symbol('closed');
var kOnDestroyed = Symbol('onDestroyed');
var kOnClosed = Symbol('onClosed');
var DispatcherBase$3 = class extends Dispatcher$1 {
	constructor() {
		super();
		this[kDestroyed] = false;
		this[kOnDestroyed] = [];
		this[kClosed] = false;
		this[kOnClosed] = [];
	}
	get destroyed() {
		return this[kDestroyed];
	}
	get closed() {
		return this[kClosed];
	}
	close(callback) {
		if (callback === void 0) {
			return new Promise((resolve2, reject) => {
				this.close((err, data2) => {
					return err ? reject(err) : resolve2(data2);
				});
			});
		}
		if (typeof callback !== 'function') {
			throw new InvalidArgumentError$c('invalid callback');
		}
		if (this[kDestroyed]) {
			queueMicrotask(() => callback(new ClientDestroyedError(), null));
			return;
		}
		if (this[kClosed]) {
			if (this[kOnClosed]) {
				this[kOnClosed].push(callback);
			} else {
				queueMicrotask(() => callback(null, null));
			}
			return;
		}
		this[kClosed] = true;
		this[kOnClosed].push(callback);
		const onClosed = () => {
			const callbacks = this[kOnClosed];
			this[kOnClosed] = null;
			for (let i2 = 0; i2 < callbacks.length; i2++) {
				callbacks[i2](null, null);
			}
		};
		this[kClose$3]()
			.then(() => this.destroy())
			.then(() => {
				queueMicrotask(onClosed);
			});
	}
	destroy(err, callback) {
		if (typeof err === 'function') {
			callback = err;
			err = null;
		}
		if (callback === void 0) {
			return new Promise((resolve2, reject) => {
				this.destroy(err, (err2, data2) => {
					return err2 ? reject(err2) : resolve2(data2);
				});
			});
		}
		if (typeof callback !== 'function') {
			throw new InvalidArgumentError$c('invalid callback');
		}
		if (this[kDestroyed]) {
			if (this[kOnDestroyed]) {
				this[kOnDestroyed].push(callback);
			} else {
				queueMicrotask(() => callback(null, null));
			}
			return;
		}
		if (!err) {
			err = new ClientDestroyedError();
		}
		this[kDestroyed] = true;
		this[kOnDestroyed].push(callback);
		const onDestroyed = () => {
			const callbacks = this[kOnDestroyed];
			this[kOnDestroyed] = null;
			for (let i2 = 0; i2 < callbacks.length; i2++) {
				callbacks[i2](null, null);
			}
		};
		this[kDestroy$3](err).then(() => {
			queueMicrotask(onDestroyed);
		});
	}
	dispatch(opts, handler) {
		if (!handler || typeof handler !== 'object') {
			throw new InvalidArgumentError$c('handler must be an object');
		}
		try {
			if (!opts || typeof opts !== 'object') {
				throw new InvalidArgumentError$c('opts must be an object.');
			}
			if (this[kDestroyed]) {
				throw new ClientDestroyedError();
			}
			if (this[kClosed]) {
				throw new ClientClosedError();
			}
			return this[kDispatch$3](opts, handler);
		} catch (err) {
			if (typeof handler.onError !== 'function') {
				throw new InvalidArgumentError$c('invalid onError method');
			}
			handler.onError(err);
			return false;
		}
	}
};
var dispatcherBase = DispatcherBase$3;
var util$d = util$h;
var { kBodyUsed } = symbols$1;
var assert$9 = import_assert.default;
var { InvalidArgumentError: InvalidArgumentError$b } = errors$1;
var EE$1 = import_events.default;
var redirectableStatusCodes = [300, 301, 302, 303, 307, 308];
var kBody$1 = Symbol('body');
var BodyAsyncIterable = class {
	constructor(body4) {
		this[kBody$1] = body4;
		this[kBodyUsed] = false;
	}
	async *[Symbol.asyncIterator]() {
		assert$9(!this[kBodyUsed], 'disturbed');
		this[kBodyUsed] = true;
		yield* this[kBody$1];
	}
};
var RedirectHandler$2 = class {
	constructor(dispatcher2, maxRedirections, opts, handler) {
		if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
			throw new InvalidArgumentError$b('maxRedirections must be a positive number');
		}
		util$d.validateHandler(handler, opts.method, opts.upgrade);
		this.dispatcher = dispatcher2;
		this.location = null;
		this.abort = null;
		this.opts = { ...opts, maxRedirections: 0 };
		this.maxRedirections = maxRedirections;
		this.handler = handler;
		this.history = [];
		if (util$d.isStream(this.opts.body)) {
			if (util$d.bodyLength(this.opts.body) === 0) {
				this.opts.body.on('data', function () {
					assert$9(false);
				});
			}
			if (typeof this.opts.body.readableDidRead !== 'boolean') {
				this.opts.body[kBodyUsed] = false;
				EE$1.prototype.on.call(this.opts.body, 'data', function () {
					this[kBodyUsed] = true;
				});
			}
		} else if (this.opts.body && typeof this.opts.body.pipeTo === 'function') {
			this.opts.body = new BodyAsyncIterable(this.opts.body);
		} else if (
			this.opts.body &&
			typeof this.opts.body !== 'string' &&
			!ArrayBuffer.isView(this.opts.body) &&
			util$d.isIterable(this.opts.body)
		) {
			this.opts.body = new BodyAsyncIterable(this.opts.body);
		}
	}
	onConnect(abort2) {
		this.abort = abort2;
		this.handler.onConnect(abort2, { history: this.history });
	}
	onUpgrade(statusCode, headers2, socket) {
		this.handler.onUpgrade(statusCode, headers2, socket);
	}
	onError(error2) {
		this.handler.onError(error2);
	}
	onHeaders(statusCode, headers2, resume2, statusText) {
		this.location =
			this.history.length >= this.maxRedirections || util$d.isDisturbed(this.opts.body)
				? null
				: parseLocation(statusCode, headers2);
		if (this.opts.origin) {
			this.history.push(new URL(this.opts.path, this.opts.origin));
		}
		if (!this.location) {
			return this.handler.onHeaders(statusCode, headers2, resume2, statusText);
		}
		const {
			origin,
			pathname,
			search: search3
		} = util$d.parseURL(new URL(this.location, this.opts.origin));
		const path = search3 ? `${pathname}${search3}` : pathname;
		this.opts.headers = cleanRequestHeaders(
			this.opts.headers,
			statusCode === 303,
			this.opts.origin !== origin
		);
		this.opts.path = path;
		this.opts.origin = origin;
		this.opts.maxRedirections = 0;
		if (statusCode === 303 && this.opts.method !== 'HEAD') {
			this.opts.method = 'GET';
			this.opts.body = null;
		}
	}
	onData(chunk) {
		if (this.location);
		else {
			return this.handler.onData(chunk);
		}
	}
	onComplete(trailers) {
		if (this.location) {
			this.location = null;
			this.abort = null;
			this.dispatcher.dispatch(this.opts, this);
		} else {
			this.handler.onComplete(trailers);
		}
	}
	onBodySent(chunk) {
		if (this.handler.onBodySent) {
			this.handler.onBodySent(chunk);
		}
	}
};
function parseLocation(statusCode, headers2) {
	if (redirectableStatusCodes.indexOf(statusCode) === -1) {
		return null;
	}
	for (let i2 = 0; i2 < headers2.length; i2 += 2) {
		if (headers2[i2].toString().toLowerCase() === 'location') {
			return headers2[i2 + 1];
		}
	}
}
function shouldRemoveHeader(header, removeContent, unknownOrigin) {
	return (
		(header.length === 4 && header.toString().toLowerCase() === 'host') ||
		(removeContent && header.toString().toLowerCase().indexOf('content-') === 0) ||
		(unknownOrigin && header.length === 13 && header.toString().toLowerCase() === 'authorization')
	);
}
function cleanRequestHeaders(headers2, removeContent, unknownOrigin) {
	const ret = [];
	if (Array.isArray(headers2)) {
		for (let i2 = 0; i2 < headers2.length; i2 += 2) {
			if (!shouldRemoveHeader(headers2[i2], removeContent, unknownOrigin)) {
				ret.push(headers2[i2], headers2[i2 + 1]);
			}
		}
	} else if (headers2 && typeof headers2 === 'object') {
		for (const key3 of Object.keys(headers2)) {
			if (!shouldRemoveHeader(key3, removeContent, unknownOrigin)) {
				ret.push(key3, headers2[key3]);
			}
		}
	} else {
		assert$9(headers2 == null, 'headers must be an object or an array');
	}
	return ret;
}
var redirect = RedirectHandler$2;
var net$1 = import_net.default;
var assert$8 = import_assert.default;
var util$c = util$h;
var { InvalidArgumentError: InvalidArgumentError$a, ConnectTimeoutError } = errors$1;
var tls;
function buildConnector$2({ maxCachedSessions, socketPath, timeout, ...opts }) {
	if (
		maxCachedSessions != null &&
		(!Number.isInteger(maxCachedSessions) || maxCachedSessions < 0)
	) {
		throw new InvalidArgumentError$a('maxCachedSessions must be a positive integer or zero');
	}
	const options = { path: socketPath, ...opts };
	const sessionCache = /* @__PURE__ */ new Map();
	timeout = timeout == null ? 1e4 : timeout;
	maxCachedSessions = maxCachedSessions == null ? 100 : maxCachedSessions;
	return function connect2({ hostname, host, protocol, port, servername }, callback) {
		let socket;
		if (protocol === 'https:') {
			if (!tls) {
				tls = import_tls.default;
			}
			servername = servername || options.servername || util$c.getServerName(host) || null;
			const sessionKey = servername || hostname;
			const session = sessionCache.get(sessionKey) || null;
			assert$8(sessionKey);
			socket = tls.connect({
				highWaterMark: 16384,
				...options,
				servername,
				session,
				port: port || 443,
				host: hostname
			});
			socket
				.on('session', function (session2) {
					if (maxCachedSessions === 0) {
						return;
					}
					if (sessionCache.size >= maxCachedSessions) {
						const { value: oldestKey } = sessionCache.keys().next();
						sessionCache.delete(oldestKey);
					}
					sessionCache.set(sessionKey, session2);
				})
				.on('error', function (err) {
					if (sessionKey && err.code !== 'UND_ERR_INFO') {
						sessionCache.delete(sessionKey);
					}
				});
		} else {
			socket = net$1.connect({
				highWaterMark: 64 * 1024,
				...options,
				port: port || 80,
				host: hostname
			});
		}
		const timeoutId = timeout ? setTimeout(onConnectTimeout, timeout, socket) : null;
		socket
			.setNoDelay(true)
			.once(protocol === 'https:' ? 'secureConnect' : 'connect', function () {
				clearTimeout(timeoutId);
				if (callback) {
					const cb = callback;
					callback = null;
					cb(null, this);
				}
			})
			.on('error', function (err) {
				clearTimeout(timeoutId);
				if (callback) {
					const cb = callback;
					callback = null;
					cb(err);
				}
			});
		return socket;
	};
}
function onConnectTimeout(socket) {
	util$c.destroy(socket, new ConnectTimeoutError());
}
var connect$2 = buildConnector$2;
var constants$1 = {};
var utils = {};
Object.defineProperty(utils, '__esModule', { value: true });
utils.enumToMap = void 0;
function enumToMap(obj) {
	const res = {};
	Object.keys(obj).forEach((key3) => {
		const value = obj[key3];
		if (typeof value === 'number') {
			res[key3] = value;
		}
	});
	return res;
}
utils.enumToMap = enumToMap;
(function (exports) {
	Object.defineProperty(exports, '__esModule', { value: true });
	exports.SPECIAL_HEADERS =
		exports.HEADER_STATE =
		exports.MINOR =
		exports.MAJOR =
		exports.CONNECTION_TOKEN_CHARS =
		exports.HEADER_CHARS =
		exports.TOKEN =
		exports.STRICT_TOKEN =
		exports.HEX =
		exports.URL_CHAR =
		exports.STRICT_URL_CHAR =
		exports.USERINFO_CHARS =
		exports.MARK =
		exports.ALPHANUM =
		exports.NUM =
		exports.HEX_MAP =
		exports.NUM_MAP =
		exports.ALPHA =
		exports.FINISH =
		exports.H_METHOD_MAP =
		exports.METHOD_MAP =
		exports.METHODS_RTSP =
		exports.METHODS_ICE =
		exports.METHODS_HTTP =
		exports.METHODS =
		exports.LENIENT_FLAGS =
		exports.FLAGS =
		exports.TYPE =
		exports.ERROR =
			void 0;
	const utils_1 = utils;
	(function (ERROR) {
		ERROR[(ERROR['OK'] = 0)] = 'OK';
		ERROR[(ERROR['INTERNAL'] = 1)] = 'INTERNAL';
		ERROR[(ERROR['STRICT'] = 2)] = 'STRICT';
		ERROR[(ERROR['LF_EXPECTED'] = 3)] = 'LF_EXPECTED';
		ERROR[(ERROR['UNEXPECTED_CONTENT_LENGTH'] = 4)] = 'UNEXPECTED_CONTENT_LENGTH';
		ERROR[(ERROR['CLOSED_CONNECTION'] = 5)] = 'CLOSED_CONNECTION';
		ERROR[(ERROR['INVALID_METHOD'] = 6)] = 'INVALID_METHOD';
		ERROR[(ERROR['INVALID_URL'] = 7)] = 'INVALID_URL';
		ERROR[(ERROR['INVALID_CONSTANT'] = 8)] = 'INVALID_CONSTANT';
		ERROR[(ERROR['INVALID_VERSION'] = 9)] = 'INVALID_VERSION';
		ERROR[(ERROR['INVALID_HEADER_TOKEN'] = 10)] = 'INVALID_HEADER_TOKEN';
		ERROR[(ERROR['INVALID_CONTENT_LENGTH'] = 11)] = 'INVALID_CONTENT_LENGTH';
		ERROR[(ERROR['INVALID_CHUNK_SIZE'] = 12)] = 'INVALID_CHUNK_SIZE';
		ERROR[(ERROR['INVALID_STATUS'] = 13)] = 'INVALID_STATUS';
		ERROR[(ERROR['INVALID_EOF_STATE'] = 14)] = 'INVALID_EOF_STATE';
		ERROR[(ERROR['INVALID_TRANSFER_ENCODING'] = 15)] = 'INVALID_TRANSFER_ENCODING';
		ERROR[(ERROR['CB_MESSAGE_BEGIN'] = 16)] = 'CB_MESSAGE_BEGIN';
		ERROR[(ERROR['CB_HEADERS_COMPLETE'] = 17)] = 'CB_HEADERS_COMPLETE';
		ERROR[(ERROR['CB_MESSAGE_COMPLETE'] = 18)] = 'CB_MESSAGE_COMPLETE';
		ERROR[(ERROR['CB_CHUNK_HEADER'] = 19)] = 'CB_CHUNK_HEADER';
		ERROR[(ERROR['CB_CHUNK_COMPLETE'] = 20)] = 'CB_CHUNK_COMPLETE';
		ERROR[(ERROR['PAUSED'] = 21)] = 'PAUSED';
		ERROR[(ERROR['PAUSED_UPGRADE'] = 22)] = 'PAUSED_UPGRADE';
		ERROR[(ERROR['PAUSED_H2_UPGRADE'] = 23)] = 'PAUSED_H2_UPGRADE';
		ERROR[(ERROR['USER'] = 24)] = 'USER';
	})(exports.ERROR || (exports.ERROR = {}));
	(function (TYPE) {
		TYPE[(TYPE['BOTH'] = 0)] = 'BOTH';
		TYPE[(TYPE['REQUEST'] = 1)] = 'REQUEST';
		TYPE[(TYPE['RESPONSE'] = 2)] = 'RESPONSE';
	})(exports.TYPE || (exports.TYPE = {}));
	(function (FLAGS) {
		FLAGS[(FLAGS['CONNECTION_KEEP_ALIVE'] = 1)] = 'CONNECTION_KEEP_ALIVE';
		FLAGS[(FLAGS['CONNECTION_CLOSE'] = 2)] = 'CONNECTION_CLOSE';
		FLAGS[(FLAGS['CONNECTION_UPGRADE'] = 4)] = 'CONNECTION_UPGRADE';
		FLAGS[(FLAGS['CHUNKED'] = 8)] = 'CHUNKED';
		FLAGS[(FLAGS['UPGRADE'] = 16)] = 'UPGRADE';
		FLAGS[(FLAGS['CONTENT_LENGTH'] = 32)] = 'CONTENT_LENGTH';
		FLAGS[(FLAGS['SKIPBODY'] = 64)] = 'SKIPBODY';
		FLAGS[(FLAGS['TRAILING'] = 128)] = 'TRAILING';
		FLAGS[(FLAGS['TRANSFER_ENCODING'] = 512)] = 'TRANSFER_ENCODING';
	})(exports.FLAGS || (exports.FLAGS = {}));
	(function (LENIENT_FLAGS) {
		LENIENT_FLAGS[(LENIENT_FLAGS['HEADERS'] = 1)] = 'HEADERS';
		LENIENT_FLAGS[(LENIENT_FLAGS['CHUNKED_LENGTH'] = 2)] = 'CHUNKED_LENGTH';
		LENIENT_FLAGS[(LENIENT_FLAGS['KEEP_ALIVE'] = 4)] = 'KEEP_ALIVE';
	})(exports.LENIENT_FLAGS || (exports.LENIENT_FLAGS = {}));
	var METHODS;
	(function (METHODS2) {
		METHODS2[(METHODS2['DELETE'] = 0)] = 'DELETE';
		METHODS2[(METHODS2['GET'] = 1)] = 'GET';
		METHODS2[(METHODS2['HEAD'] = 2)] = 'HEAD';
		METHODS2[(METHODS2['POST'] = 3)] = 'POST';
		METHODS2[(METHODS2['PUT'] = 4)] = 'PUT';
		METHODS2[(METHODS2['CONNECT'] = 5)] = 'CONNECT';
		METHODS2[(METHODS2['OPTIONS'] = 6)] = 'OPTIONS';
		METHODS2[(METHODS2['TRACE'] = 7)] = 'TRACE';
		METHODS2[(METHODS2['COPY'] = 8)] = 'COPY';
		METHODS2[(METHODS2['LOCK'] = 9)] = 'LOCK';
		METHODS2[(METHODS2['MKCOL'] = 10)] = 'MKCOL';
		METHODS2[(METHODS2['MOVE'] = 11)] = 'MOVE';
		METHODS2[(METHODS2['PROPFIND'] = 12)] = 'PROPFIND';
		METHODS2[(METHODS2['PROPPATCH'] = 13)] = 'PROPPATCH';
		METHODS2[(METHODS2['SEARCH'] = 14)] = 'SEARCH';
		METHODS2[(METHODS2['UNLOCK'] = 15)] = 'UNLOCK';
		METHODS2[(METHODS2['BIND'] = 16)] = 'BIND';
		METHODS2[(METHODS2['REBIND'] = 17)] = 'REBIND';
		METHODS2[(METHODS2['UNBIND'] = 18)] = 'UNBIND';
		METHODS2[(METHODS2['ACL'] = 19)] = 'ACL';
		METHODS2[(METHODS2['REPORT'] = 20)] = 'REPORT';
		METHODS2[(METHODS2['MKACTIVITY'] = 21)] = 'MKACTIVITY';
		METHODS2[(METHODS2['CHECKOUT'] = 22)] = 'CHECKOUT';
		METHODS2[(METHODS2['MERGE'] = 23)] = 'MERGE';
		METHODS2[(METHODS2['M-SEARCH'] = 24)] = 'M-SEARCH';
		METHODS2[(METHODS2['NOTIFY'] = 25)] = 'NOTIFY';
		METHODS2[(METHODS2['SUBSCRIBE'] = 26)] = 'SUBSCRIBE';
		METHODS2[(METHODS2['UNSUBSCRIBE'] = 27)] = 'UNSUBSCRIBE';
		METHODS2[(METHODS2['PATCH'] = 28)] = 'PATCH';
		METHODS2[(METHODS2['PURGE'] = 29)] = 'PURGE';
		METHODS2[(METHODS2['MKCALENDAR'] = 30)] = 'MKCALENDAR';
		METHODS2[(METHODS2['LINK'] = 31)] = 'LINK';
		METHODS2[(METHODS2['UNLINK'] = 32)] = 'UNLINK';
		METHODS2[(METHODS2['SOURCE'] = 33)] = 'SOURCE';
		METHODS2[(METHODS2['PRI'] = 34)] = 'PRI';
		METHODS2[(METHODS2['DESCRIBE'] = 35)] = 'DESCRIBE';
		METHODS2[(METHODS2['ANNOUNCE'] = 36)] = 'ANNOUNCE';
		METHODS2[(METHODS2['SETUP'] = 37)] = 'SETUP';
		METHODS2[(METHODS2['PLAY'] = 38)] = 'PLAY';
		METHODS2[(METHODS2['PAUSE'] = 39)] = 'PAUSE';
		METHODS2[(METHODS2['TEARDOWN'] = 40)] = 'TEARDOWN';
		METHODS2[(METHODS2['GET_PARAMETER'] = 41)] = 'GET_PARAMETER';
		METHODS2[(METHODS2['SET_PARAMETER'] = 42)] = 'SET_PARAMETER';
		METHODS2[(METHODS2['REDIRECT'] = 43)] = 'REDIRECT';
		METHODS2[(METHODS2['RECORD'] = 44)] = 'RECORD';
		METHODS2[(METHODS2['FLUSH'] = 45)] = 'FLUSH';
	})((METHODS = exports.METHODS || (exports.METHODS = {})));
	exports.METHODS_HTTP = [
		METHODS.DELETE,
		METHODS.GET,
		METHODS.HEAD,
		METHODS.POST,
		METHODS.PUT,
		METHODS.CONNECT,
		METHODS.OPTIONS,
		METHODS.TRACE,
		METHODS.COPY,
		METHODS.LOCK,
		METHODS.MKCOL,
		METHODS.MOVE,
		METHODS.PROPFIND,
		METHODS.PROPPATCH,
		METHODS.SEARCH,
		METHODS.UNLOCK,
		METHODS.BIND,
		METHODS.REBIND,
		METHODS.UNBIND,
		METHODS.ACL,
		METHODS.REPORT,
		METHODS.MKACTIVITY,
		METHODS.CHECKOUT,
		METHODS.MERGE,
		METHODS['M-SEARCH'],
		METHODS.NOTIFY,
		METHODS.SUBSCRIBE,
		METHODS.UNSUBSCRIBE,
		METHODS.PATCH,
		METHODS.PURGE,
		METHODS.MKCALENDAR,
		METHODS.LINK,
		METHODS.UNLINK,
		METHODS.PRI,
		METHODS.SOURCE
	];
	exports.METHODS_ICE = [METHODS.SOURCE];
	exports.METHODS_RTSP = [
		METHODS.OPTIONS,
		METHODS.DESCRIBE,
		METHODS.ANNOUNCE,
		METHODS.SETUP,
		METHODS.PLAY,
		METHODS.PAUSE,
		METHODS.TEARDOWN,
		METHODS.GET_PARAMETER,
		METHODS.SET_PARAMETER,
		METHODS.REDIRECT,
		METHODS.RECORD,
		METHODS.FLUSH,
		METHODS.GET,
		METHODS.POST
	];
	exports.METHOD_MAP = utils_1.enumToMap(METHODS);
	exports.H_METHOD_MAP = {};
	Object.keys(exports.METHOD_MAP).forEach((key3) => {
		if (/^H/.test(key3)) {
			exports.H_METHOD_MAP[key3] = exports.METHOD_MAP[key3];
		}
	});
	(function (FINISH) {
		FINISH[(FINISH['SAFE'] = 0)] = 'SAFE';
		FINISH[(FINISH['SAFE_WITH_CB'] = 1)] = 'SAFE_WITH_CB';
		FINISH[(FINISH['UNSAFE'] = 2)] = 'UNSAFE';
	})(exports.FINISH || (exports.FINISH = {}));
	exports.ALPHA = [];
	for (let i2 = 'A'.charCodeAt(0); i2 <= 'Z'.charCodeAt(0); i2++) {
		exports.ALPHA.push(String.fromCharCode(i2));
		exports.ALPHA.push(String.fromCharCode(i2 + 32));
	}
	exports.NUM_MAP = {
		0: 0,
		1: 1,
		2: 2,
		3: 3,
		4: 4,
		5: 5,
		6: 6,
		7: 7,
		8: 8,
		9: 9
	};
	exports.HEX_MAP = {
		0: 0,
		1: 1,
		2: 2,
		3: 3,
		4: 4,
		5: 5,
		6: 6,
		7: 7,
		8: 8,
		9: 9,
		A: 10,
		B: 11,
		C: 12,
		D: 13,
		E: 14,
		F: 15,
		a: 10,
		b: 11,
		c: 12,
		d: 13,
		e: 14,
		f: 15
	};
	exports.NUM = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9'];
	exports.ALPHANUM = exports.ALPHA.concat(exports.NUM);
	exports.MARK = ['-', '_', '.', '!', '~', '*', "'", '(', ')'];
	exports.USERINFO_CHARS = exports.ALPHANUM.concat(exports.MARK).concat([
		'%',
		';',
		':',
		'&',
		'=',
		'+',
		'$',
		','
	]);
	exports.STRICT_URL_CHAR = [
		'!',
		'"',
		'$',
		'%',
		'&',
		"'",
		'(',
		')',
		'*',
		'+',
		',',
		'-',
		'.',
		'/',
		':',
		';',
		'<',
		'=',
		'>',
		'@',
		'[',
		'\\',
		']',
		'^',
		'_',
		'`',
		'{',
		'|',
		'}',
		'~'
	].concat(exports.ALPHANUM);
	exports.URL_CHAR = exports.STRICT_URL_CHAR.concat(['	', '\f']);
	for (let i2 = 128; i2 <= 255; i2++) {
		exports.URL_CHAR.push(i2);
	}
	exports.HEX = exports.NUM.concat(['a', 'b', 'c', 'd', 'e', 'f', 'A', 'B', 'C', 'D', 'E', 'F']);
	exports.STRICT_TOKEN = [
		'!',
		'#',
		'$',
		'%',
		'&',
		"'",
		'*',
		'+',
		'-',
		'.',
		'^',
		'_',
		'`',
		'|',
		'~'
	].concat(exports.ALPHANUM);
	exports.TOKEN = exports.STRICT_TOKEN.concat([' ']);
	exports.HEADER_CHARS = ['	'];
	for (let i2 = 32; i2 <= 255; i2++) {
		if (i2 !== 127) {
			exports.HEADER_CHARS.push(i2);
		}
	}
	exports.CONNECTION_TOKEN_CHARS = exports.HEADER_CHARS.filter((c) => c !== 44);
	exports.MAJOR = exports.NUM_MAP;
	exports.MINOR = exports.MAJOR;
	var HEADER_STATE;
	(function (HEADER_STATE2) {
		HEADER_STATE2[(HEADER_STATE2['GENERAL'] = 0)] = 'GENERAL';
		HEADER_STATE2[(HEADER_STATE2['CONNECTION'] = 1)] = 'CONNECTION';
		HEADER_STATE2[(HEADER_STATE2['CONTENT_LENGTH'] = 2)] = 'CONTENT_LENGTH';
		HEADER_STATE2[(HEADER_STATE2['TRANSFER_ENCODING'] = 3)] = 'TRANSFER_ENCODING';
		HEADER_STATE2[(HEADER_STATE2['UPGRADE'] = 4)] = 'UPGRADE';
		HEADER_STATE2[(HEADER_STATE2['CONNECTION_KEEP_ALIVE'] = 5)] = 'CONNECTION_KEEP_ALIVE';
		HEADER_STATE2[(HEADER_STATE2['CONNECTION_CLOSE'] = 6)] = 'CONNECTION_CLOSE';
		HEADER_STATE2[(HEADER_STATE2['CONNECTION_UPGRADE'] = 7)] = 'CONNECTION_UPGRADE';
		HEADER_STATE2[(HEADER_STATE2['TRANSFER_ENCODING_CHUNKED'] = 8)] = 'TRANSFER_ENCODING_CHUNKED';
	})((HEADER_STATE = exports.HEADER_STATE || (exports.HEADER_STATE = {})));
	exports.SPECIAL_HEADERS = {
		connection: HEADER_STATE.CONNECTION,
		'content-length': HEADER_STATE.CONTENT_LENGTH,
		'proxy-connection': HEADER_STATE.CONNECTION,
		'transfer-encoding': HEADER_STATE.TRANSFER_ENCODING,
		upgrade: HEADER_STATE.UPGRADE
	};
})(constants$1);
var llhttp_wasm =
	'AGFzbQEAAAABMAhgAX8Bf2ADf39/AX9gBH9/f38Bf2AAAGADf39/AGABfwBgAn9/AGAGf39/f39/AALLAQgDZW52GHdhc21fb25faGVhZGVyc19jb21wbGV0ZQACA2VudhV3YXNtX29uX21lc3NhZ2VfYmVnaW4AAANlbnYLd2FzbV9vbl91cmwAAQNlbnYOd2FzbV9vbl9zdGF0dXMAAQNlbnYUd2FzbV9vbl9oZWFkZXJfZmllbGQAAQNlbnYUd2FzbV9vbl9oZWFkZXJfdmFsdWUAAQNlbnYMd2FzbV9vbl9ib2R5AAEDZW52GHdhc21fb25fbWVzc2FnZV9jb21wbGV0ZQAAAzk4AwMEAAAFAAAAAAAABQEFAAUFBQAABgAAAAYGAQEBAQEBAQEBAQEBAQEBAQABAAABAQcAAAUFAAMEBQFwAQ4OBQMBAAIGCAF/AUGgtwQLB/UEHwZtZW1vcnkCAAtfaW5pdGlhbGl6ZQAJGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBAAtsbGh0dHBfaW5pdAAKGGxsaHR0cF9zaG91bGRfa2VlcF9hbGl2ZQA1DGxsaHR0cF9hbGxvYwAMBm1hbGxvYwA6C2xsaHR0cF9mcmVlAA0EZnJlZQA8D2xsaHR0cF9nZXRfdHlwZQAOFWxsaHR0cF9nZXRfaHR0cF9tYWpvcgAPFWxsaHR0cF9nZXRfaHR0cF9taW5vcgAQEWxsaHR0cF9nZXRfbWV0aG9kABEWbGxodHRwX2dldF9zdGF0dXNfY29kZQASEmxsaHR0cF9nZXRfdXBncmFkZQATDGxsaHR0cF9yZXNldAAUDmxsaHR0cF9leGVjdXRlABUUbGxodHRwX3NldHRpbmdzX2luaXQAFg1sbGh0dHBfZmluaXNoABcMbGxodHRwX3BhdXNlABgNbGxodHRwX3Jlc3VtZQAZG2xsaHR0cF9yZXN1bWVfYWZ0ZXJfdXBncmFkZQAaEGxsaHR0cF9nZXRfZXJybm8AGxdsbGh0dHBfZ2V0X2Vycm9yX3JlYXNvbgAcF2xsaHR0cF9zZXRfZXJyb3JfcmVhc29uAB0UbGxodHRwX2dldF9lcnJvcl9wb3MAHhFsbGh0dHBfZXJybm9fbmFtZQAfEmxsaHR0cF9tZXRob2RfbmFtZQAgGmxsaHR0cF9zZXRfbGVuaWVudF9oZWFkZXJzACEhbGxodHRwX3NldF9sZW5pZW50X2NodW5rZWRfbGVuZ3RoACIYbGxodHRwX21lc3NhZ2VfbmVlZHNfZW9mADMJEwEAQQELDQECAwQFCwYHLiooJCYK56QCOAIACwgAEIiAgIAACxkAIAAQtoCAgAAaIAAgAjYCNCAAIAE6ACgLHAAgACAALwEyIAAtAC4gABC1gICAABCAgICAAAspAQF/QTgQuoCAgAAiARC2gICAABogAUGAiICAADYCNCABIAA6ACggAQsKACAAELyAgIAACwcAIAAtACgLBwAgAC0AKgsHACAALQArCwcAIAAtACkLBwAgAC8BMgsHACAALQAuC0UBBH8gACgCGCEBIAAtAC0hAiAALQAoIQMgACgCNCEEIAAQtoCAgAAaIAAgBDYCNCAAIAM6ACggACACOgAtIAAgATYCGAsRACAAIAEgASACahC3gICAAAtFACAAQgA3AgAgAEEwakIANwIAIABBKGpCADcCACAAQSBqQgA3AgAgAEEYakIANwIAIABBEGpCADcCACAAQQhqQgA3AgALZwEBf0EAIQECQCAAKAIMDQACQAJAAkACQCAALQAvDgMBAAMCCyAAKAI0IgFFDQAgASgCHCIBRQ0AIAAgARGAgICAAAAiAQ0DC0EADwsQv4CAgAAACyAAQa+RgIAANgIQQQ4hAQsgAQseAAJAIAAoAgwNACAAQbSTgIAANgIQIABBFTYCDAsLFgACQCAAKAIMQRVHDQAgAEEANgIMCwsWAAJAIAAoAgxBFkcNACAAQQA2AgwLCwcAIAAoAgwLBwAgACgCEAsJACAAIAE2AhALBwAgACgCFAsiAAJAIABBGUkNABC/gICAAAALIABBAnRB6JqAgABqKAIACyIAAkAgAEEuSQ0AEL+AgIAAAAsgAEECdEHMm4CAAGooAgALFgAgACAALQAtQf4BcSABQQBHcjoALQsZACAAIAAtAC1B/QFxIAFBAEdBAXRyOgAtCy4BAn9BACEDAkAgACgCNCIERQ0AIAQoAgAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI0IgRFDQAgBCgCBCIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQZyOgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIoIgRFDQAgACAEEYCAgIAAACEDCyADC0kBAn9BACEDAkAgACgCNCIERQ0AIAQoAggiBEUNACAAIAEgAiABayAEEYGAgIAAACIDQX9HDQAgAEHSioCAADYCEEEYIQMLIAMLLgECf0EAIQMCQCAAKAI0IgRFDQAgBCgCLCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIMIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABBjZOAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCNCIERQ0AIAQoAjAiBEUNACAAIAQRgICAgAAAIQMLIAMLSQECf0EAIQMCQCAAKAI0IgRFDQAgBCgCECIERQ0AIAAgASACIAFrIAQRgYCAgAAAIgNBf0cNACAAQcOQgIAANgIQQRghAwsgAwsuAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAI0IgRFDQAgACAEEYCAgIAAACEDCyADCy4BAn9BACEDAkAgACgCNCIERQ0AIAQoAhQiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI0IgRFDQAgBCgCHCIERQ0AIAAgBBGAgICAAAAhAwsgAwtJAQJ/QQAhAwJAIAAoAjQiBEUNACAEKAIYIgRFDQAgACABIAIgAWsgBBGBgICAAAAiA0F/Rw0AIABB0oiAgAA2AhBBGCEDCyADCy4BAn9BACEDAkAgACgCNCIERQ0AIAQoAiAiBEUNACAAIAQRgICAgAAAIQMLIAMLLgECf0EAIQMCQCAAKAI0IgRFDQAgBCgCJCIERQ0AIAAgBBGAgICAAAAhAwsgAwtFAQF/AkACQCAALwEwQRRxQRRHDQBBASEDIAAtAChBAUYNASAALwEyQeUARiEDDAELIAAtAClBBUYhAwsgACADOgAuQQAL9AEBA39BASEDAkAgAC8BMCIEQQhxDQAgACkDIEIAUiEDCwJAAkAgAC0ALkUNAEEBIQUgAC0AKUEFRg0BQQEhBSAEQcAAcUUgA3FBAUcNAQtBACEFIARBwABxDQBBAiEFIARBCHENAAJAIARBgARxRQ0AAkAgAC0AKEEBRw0AQQUhBSAALQAtQQJxRQ0CC0EEDwsCQCAEQSBxDQACQCAALQAoQQFGDQAgAC8BMiIAQZx/akHkAEkNACAAQcwBRg0AIABBsAJGDQBBBCEFIARBiARxQYAERg0CIARBKHFFDQILQQAPC0EAQQMgACkDIFAbIQULIAULXQECf0EAIQECQCAALQAoQQFGDQAgAC8BMiICQZx/akHkAEkNACACQcwBRg0AIAJBsAJGDQAgAC8BMCIAQcAAcQ0AQQEhASAAQYgEcUGABEYNACAAQShxRSEBCyABC6IBAQN/AkACQAJAIAAtACpFDQAgAC0AK0UNAEEAIQMgAC8BMCIEQQJxRQ0BDAILQQAhAyAALwEwIgRBAXFFDQELQQEhAyAALQAoQQFGDQAgAC8BMiIFQZx/akHkAEkNACAFQcwBRg0AIAVBsAJGDQAgBEHAAHENAEEAIQMgBEGIBHFBgARGDQAgBEEocUEARyEDCyAAQQA7ATAgAEEAOgAvIAMLlAEBAn8CQAJAAkAgAC0AKkUNACAALQArRQ0AQQAhASAALwEwIgJBAnFFDQEMAgtBACEBIAAvATAiAkEBcUUNAQtBASEBIAAtAChBAUYNACAALwEyIgBBnH9qQeQASQ0AIABBzAFGDQAgAEGwAkYNACACQcAAcQ0AQQAhASACQYgEcUGABEYNACACQShxQQBHIQELIAELTwAgAEEYakIANwMAIABCADcDACAAQTBqQgA3AwAgAEEoakIANwMAIABBIGpCADcDACAAQRBqQgA3AwAgAEEIakIANwMAIABBuAE2AhxBAAt7AQF/AkAgACgCDCIDDQACQCAAKAIERQ0AIAAgATYCBAsCQCAAIAEgAhC4gICAACIDDQAgACgCDA8LIAAgAzYCHEEAIQMgACgCBCIBRQ0AIAAgASACIAAoAggRgYCAgAAAIgFFDQAgACACNgIUIAAgATYCDCABIQMLIAML8soBAxl/A34FfyOAgICAAEEQayIDJICAgIAAIAEhBCABIQUgASEGIAEhByABIQggASEJIAEhCiABIQsgASEMIAEhDSABIQ4gASEPIAEhECABIREgASESIAEhEyABIRQgASEVIAEhFiABIRcgASEYIAEhGSABIRoCQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAAoAhwiG0F/ag64AbUBAbQBAgMEBQYHCAkKCwwNDg8QuwG6ARESE7MBFBUWFxgZGhscHR4fICGyAbEBIiMkJSYnKCkqKywtLi8wMTIzNDU2Nzg5OrYBOzw9Pj9AQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVpbXF1eX2BhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ent8fX5/gAGBAYIBgwGEAYUBhgGHAYgBiQGKAYsBjAGNAY4BjwGQAZEBkgGTAZQBlQGWAZcBmAGZAZoBmwGcAZ0BngGfAaABoQGiAaMBpAGlAaYBpwGoAakBqgGrAawBrQGuAa8BALcBC0EAIRsMrwELQRAhGwyuAQtBDyEbDK0BC0ERIRsMrAELQRIhGwyrAQtBFSEbDKoBC0EWIRsMqQELQRchGwyoAQtBGCEbDKcBC0EZIRsMpgELQQghGwylAQtBGiEbDKQBC0EbIRsMowELQRQhGwyiAQtBEyEbDKEBC0EcIRsMoAELQR0hGwyfAQtBHiEbDJ4BC0EfIRsMnQELQaoBIRsMnAELQasBIRsMmwELQSEhGwyaAQtBIiEbDJkBC0EjIRsMmAELQSQhGwyXAQtBJSEbDJYBC0GtASEbDJUBC0EmIRsMlAELQSohGwyTAQtBDiEbDJIBC0EnIRsMkQELQSghGwyQAQtBKSEbDI8BC0EuIRsMjgELQSshGwyNAQtBrgEhGwyMAQtBDSEbDIsBC0EMIRsMigELQS8hGwyJAQtBCyEbDIgBC0EsIRsMhwELQS0hGwyGAQtBCiEbDIUBC0ExIRsMhAELQTAhGwyDAQtBCSEbDIIBC0EgIRsMgQELQTIhGwyAAQtBMyEbDH8LQTQhGwx+C0E1IRsMfQtBNiEbDHwLQTchGwx7C0E4IRsMegtBOSEbDHkLQTohGwx4C0GsASEbDHcLQTshGwx2C0E8IRsMdQtBPSEbDHQLQT4hGwxzC0E/IRsMcgtBwAAhGwxxC0HBACEbDHALQcIAIRsMbwtBwwAhGwxuC0HEACEbDG0LQQchGwxsC0HFACEbDGsLQQYhGwxqC0HGACEbDGkLQQUhGwxoC0HHACEbDGcLQQQhGwxmC0HIACEbDGULQckAIRsMZAtBygAhGwxjC0HLACEbDGILQQMhGwxhC0HMACEbDGALQc0AIRsMXwtBzgAhGwxeC0HQACEbDF0LQc8AIRsMXAtB0QAhGwxbC0HSACEbDFoLQQIhGwxZC0HTACEbDFgLQdQAIRsMVwtB1QAhGwxWC0HWACEbDFULQdcAIRsMVAtB2AAhGwxTC0HZACEbDFILQdoAIRsMUQtB2wAhGwxQC0HcACEbDE8LQd0AIRsMTgtB3gAhGwxNC0HfACEbDEwLQeAAIRsMSwtB4QAhGwxKC0HiACEbDEkLQeMAIRsMSAtB5AAhGwxHC0HlACEbDEYLQeYAIRsMRQtB5wAhGwxEC0HoACEbDEMLQekAIRsMQgtB6gAhGwxBC0HrACEbDEALQewAIRsMPwtB7QAhGww+C0HuACEbDD0LQe8AIRsMPAtB8AAhGww7C0HxACEbDDoLQfIAIRsMOQtB8wAhGww4C0H0ACEbDDcLQfUAIRsMNgtB9gAhGww1C0H3ACEbDDQLQfgAIRsMMwtB+QAhGwwyC0H6ACEbDDELQfsAIRsMMAtB/AAhGwwvC0H9ACEbDC4LQf4AIRsMLQtB/wAhGwwsC0GAASEbDCsLQYEBIRsMKgtBggEhGwwpC0GDASEbDCgLQYQBIRsMJwtBhQEhGwwmC0GGASEbDCULQYcBIRsMJAtBiAEhGwwjC0GJASEbDCILQYoBIRsMIQtBiwEhGwwgC0GMASEbDB8LQY0BIRsMHgtBjgEhGwwdC0GPASEbDBwLQZABIRsMGwtBkQEhGwwaC0GSASEbDBkLQZMBIRsMGAtBlAEhGwwXC0GVASEbDBYLQZYBIRsMFQtBlwEhGwwUC0GYASEbDBMLQZkBIRsMEgtBnQEhGwwRC0GaASEbDBALQQEhGwwPC0GbASEbDA4LQZwBIRsMDQtBngEhGwwMC0GgASEbDAsLQZ8BIRsMCgtBoQEhGwwJC0GiASEbDAgLQaMBIRsMBwtBpAEhGwwGC0GlASEbDAULQaYBIRsMBAtBpwEhGwwDC0GoASEbDAILQakBIRsMAQtBrwEhGwsDQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgGw6wAQABAgMEBQYHCAkKCwwNDg8QERITFBUWFxgZGx0fICEkJSYnKCkqKy0uLzAxNzg6Oz5BQ0RFRkdISUpLTE1OT1BRUlNUVVdZW15fYGJkZWZnaGlqbW5vcHFyc3R1dnd4eXp7fH1+f4ABgQGCAYMBhAGFAYYBhwGIAYkBigGLAYwBjQGOAY8BkAGRAZIBkwGUAZUBlgGXAZgBmQGaAZsBnAGdAZ4BnwGgAaEBogGjAaQBpQGmAacBqAGpAaoBqwGsAa0BrgGvAbABsQGyAbMBtAG2AbcBuAG5AboBuwG8Ab0BvgG/AcABwQHCAcMBxAHcAeIB4wHnAfYBwwLDAgsgASIEIAJHDcQBQbgBIRsMkgMLIAEiGyACRw2zAUGoASEbDJEDCyABIgEgAkcNaUHeACEbDJADCyABIgEgAkcNX0HWACEbDI8DCyABIgEgAkcNWEHRACEbDI4DCyABIgEgAkcNVEHPACEbDI0DCyABIgEgAkcNUUHNACEbDIwDCyABIgEgAkcNTkHLACEbDIsDCyABIgEgAkcNEUEMIRsMigMLIAEiASACRw01QTQhGwyJAwsgASIBIAJHDTFBMSEbDIgDCyABIhogAkcNKEEuIRsMhwMLIAEiASACRw0mQSwhGwyGAwsgASIBIAJHDSRBKyEbDIUDCyABIgEgAkcNHUEiIRsMhAMLIAAtAC5BAUYN/AIMyAELIAAgASIBIAIQtICAgABBAUcNtQEMtgELIAAgASIBIAIQrYCAgAAiGw22ASABIQEMtgILAkAgASIBIAJHDQBBBiEbDIEDCyAAIAFBAWoiASACELCAgIAAIhsNtwEgASEBDA8LIABCADcDIEEUIRsM9AILIAEiGyACRw0JQQ8hGwz+AgsCQCABIgEgAkYNACABQQFqIQFBEiEbDPMCC0EHIRsM/QILIABCACAAKQMgIhwgAiABIhtrrSIdfSIeIB4gHFYbNwMgIBwgHVYiH0UNtAFBCCEbDPwCCwJAIAEiASACRg0AIABBiYCAgAA2AgggACABNgIEIAEhAUEWIRsM8QILQQkhGwz7AgsgASEBIAApAyBQDbMBIAEhAQyzAgsCQCABIgEgAkcNAEELIRsM+gILIAAgAUEBaiIBIAIQr4CAgAAiGw2zASABIQEMswILA0ACQCABLQAAQZCdgIAAai0AACIbQQFGDQAgG0ECRw21ASABQQFqIQEMAwsgAUEBaiIBIAJHDQALQQwhGwz4AgsCQCABIgEgAkcNAEENIRsM+AILAkACQCABLQAAIhtBc2oOFAG3AbcBtwG3AbcBtwG3AbcBtwG3AbcBtwG3AbcBtwG3AbcBtwEAtQELIAFBAWohAQy1AQsgAUEBaiEBC0EZIRsM6wILAkAgASIbIAJHDQBBDiEbDPYCC0IAIRwgGyEBAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQCAbLQAAQVBqDjfJAcgBAAECAwQFBgfEAsQCxALEAsQCxALEAggJCgsMDcQCxALEAsQCxALEAsQCxALEAsQCxALEAsQCxALEAsQCxALEAsQCxALEAsQCxALEAsQCxAIODxAREhPEAgtCAiEcDMgBC0IDIRwMxwELQgQhHAzGAQtCBSEcDMUBC0IGIRwMxAELQgchHAzDAQtCCCEcDMIBC0IJIRwMwQELQgohHAzAAQtCCyEcDL8BC0IMIRwMvgELQg0hHAy9AQtCDiEcDLwBC0IPIRwMuwELQgohHAy6AQtCCyEcDLkBC0IMIRwMuAELQg0hHAy3AQtCDiEcDLYBC0IPIRwMtQELQgAhHAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgGy0AAEFQag43yAHHAQABAgMEBQYHyQHJAckByQHJAckByQEICQoLDA3JAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAckByQHJAckBDg8QERITyQELQgIhHAzHAQtCAyEcDMYBC0IEIRwMxQELQgUhHAzEAQtCBiEcDMMBC0IHIRwMwgELQgghHAzBAQtCCSEcDMABC0IKIRwMvwELQgshHAy+AQtCDCEcDL0BC0INIRwMvAELQg4hHAy7AQtCDyEcDLoBC0IKIRwMuQELQgshHAy4AQtCDCEcDLcBC0INIRwMtgELQg4hHAy1AQtCDyEcDLQBCyAAQgAgACkDICIcIAIgASIba60iHX0iHiAeIBxWGzcDICAcIB1WIh9FDbUBQREhGwzzAgsCQCABIgEgAkYNACAAQYmAgIAANgIIIAAgATYCBCABIQFBHCEbDOgCC0ESIRsM8gILIAAgASIbIAIQsoCAgABBf2oOBacBAKgCAbQBtQELQRMhGwzlAgsgAEEBOgAvIBshAQzuAgsgASIBIAJHDbUBQRYhGwzuAgsgASIYIAJHDRpBNSEbDO0CCwJAIAEiASACRw0AQRohGwztAgsgAEEANgIEIABBioCAgAA2AgggACABIAEQqoCAgAAiGw23ASABIQEMugELAkAgASIbIAJHDQBBGyEbDOwCCwJAIBstAAAiAUEgRw0AIBtBAWohAQwbCyABQQlHDbcBIBtBAWohAQwaCwJAIAEiASACRg0AIAFBAWohAQwVC0EcIRsM6gILAkAgASIbIAJHDQBBHSEbDOoCCwJAIBstAAAiAUEJRw0AIBshAQzWAgsgAUEgRw22ASAbIQEM1QILAkAgASIBIAJHDQBBHiEbDOkCCyABLQAAQQpHDbkBIAFBAWohAQymAgsCQCABIhkgAkcNAEEgIRsM6AILIBktAABBdmoOBLwBugG6AbkBugELA0ACQCABLQAAIhtBIEYNAAJAIBtBdmoOBADDAcMBAMEBCyABIQEMyQELIAFBAWoiASACRw0AC0EiIRsM5gILQSMhGyABIiAgAkYN5QIgAiAgayAAKAIAIiFqISIgICEjICEhAQJAA0AgIy0AACIfQSByIB8gH0G/f2pB/wFxQRpJG0H/AXEgAUGQn4CAAGotAABHDQEgAUEDRg3WAiABQQFqIQEgI0EBaiIjIAJHDQALIAAgIjYCAAzmAgsgAEEANgIAICMhAQzAAQtBJCEbIAEiICACRg3kAiACICBrIAAoAgAiIWohIiAgISMgISEBAkADQCAjLQAAIh9BIHIgHyAfQb9/akH/AXFBGkkbQf8BcSABQZSfgIAAai0AAEcNASABQQhGDcIBIAFBAWohASAjQQFqIiMgAkcNAAsgACAiNgIADOUCCyAAQQA2AgAgIyEBDL8BC0ElIRsgASIgIAJGDeMCIAIgIGsgACgCACIhaiEiICAhIyAhIQECQANAICMtAAAiH0EgciAfIB9Bv39qQf8BcUEaSRtB/wFxIAFB8KWAgABqLQAARw0BIAFBBUYNwgEgAUEBaiEBICNBAWoiIyACRw0ACyAAICI2AgAM5AILIABBADYCACAjIQEMvgELAkAgASIBIAJGDQADQAJAIAEtAABBoKGAgABqLQAAIhtBAUYNACAbQQJGDQsgASEBDMYBCyABQQFqIgEgAkcNAAtBISEbDOMCC0EhIRsM4gILAkAgASIBIAJGDQADQAJAIAEtAAAiG0EgRg0AIBtBdmoOBMIBwwHDAcIBwwELIAFBAWoiASACRw0AC0EpIRsM4gILQSkhGwzhAgsDQAJAIAEtAAAiG0EgRg0AIBtBdmoOBMIBBATCAQQLIAFBAWoiASACRw0AC0ErIRsM4AILA0ACQCABLQAAIhtBIEYNACAbQQlHDQQLIAFBAWoiASACRw0AC0EsIRsM3wILA0ACQCAaLQAAQaChgIAAai0AACIBQQFGDQAgAUECRw3HASAaQQFqIQEMlAILIBpBAWoiGiACRw0AC0EuIRsM3gILIAEhAQzCAQsgASEBDMEBC0EvIRsgASIjIAJGDdsCIAIgI2sgACgCACIgaiEhICMhHyAgIQEDQCAfLQAAQSByIAFBoKOAgABqLQAARw3OAiABQQZGDc0CIAFBAWohASAfQQFqIh8gAkcNAAsgACAhNgIADNsCCwJAIAEiGiACRw0AQTAhGwzbAgsgAEGKgICAADYCCCAAIBo2AgQgGiEBIAAtACxBf2oOBLMBvAG+AcABmgILIAFBAWohAQyyAQsCQCABIgEgAkYNAANAAkAgAS0AACIbQSByIBsgG0G/f2pB/wFxQRpJG0H/AXEiG0EJRg0AIBtBIEYNAAJAAkACQAJAIBtBnX9qDhMAAwMDAwMDAwEDAwMDAwMDAwMCAwsgAUEBaiEBQSchGwzTAgsgAUEBaiEBQSghGwzSAgsgAUEBaiEBQSkhGwzRAgsgASEBDLYBCyABQQFqIgEgAkcNAAtBJiEbDNkCC0EmIRsM2AILAkAgASIBIAJGDQADQAJAIAEtAABBoJ+AgABqLQAAQQFGDQAgASEBDLsBCyABQQFqIgEgAkcNAAtBLSEbDNgCC0EtIRsM1wILAkADQAJAIAEtAABBd2oOGAACxALEAsYCxALEAsQCxALEAsQCxALEAsQCxALEAsQCxALEAsQCxALEAsQCAMQCCyABQQFqIgEgAkcNAAtBMSEbDNcCCyABQQFqIQELQSIhGwzKAgsgASIBIAJHDb0BQTMhGwzUAgsDQAJAIAEtAABBsKOAgABqLQAAQQFGDQAgASEBDJYCCyABQQFqIgEgAkcNAAtBNCEbDNMCCyAYLQAAIhtBIEYNmgEgG0E6Rw3GAiAAKAIEIQEgAEEANgIEIAAgASAYEKiAgIAAIgENugEgGEEBaiEBDLwBCyAAIAEgAhCpgICAABoLQQohGwzFAgtBNiEbIAEiIyACRg3PAiACICNrIAAoAgAiIGohISAjIRggICEBAkADQCAYLQAAIh9BIHIgHyAfQb9/akH/AXFBGkkbQf8BcSABQbClgIAAai0AAEcNxAIgAUEFRg0BIAFBAWohASAYQQFqIhggAkcNAAsgACAhNgIADNACCyAAQQA2AgAgAEEBOgAsICMgIGtBBmohAQy9AgtBNyEbIAEiIyACRg3OAiACICNrIAAoAgAiIGohISAjIRggICEBAkADQCAYLQAAIh9BIHIgHyAfQb9/akH/AXFBGkkbQf8BcSABQbalgIAAai0AAEcNwwIgAUEJRg0BIAFBAWohASAYQQFqIhggAkcNAAsgACAhNgIADM8CCyAAQQA2AgAgAEECOgAsICMgIGtBCmohAQy8AgsCQCABIhggAkcNAEE4IRsMzgILAkACQCAYLQAAIgFBIHIgASABQb9/akH/AXFBGkkbQf8BcUGSf2oOBwDDAsMCwwLDAsMCAcMCCyAYQQFqIQFBMiEbDMMCCyAYQQFqIQFBMyEbDMICC0E5IRsgASIjIAJGDcwCIAIgI2sgACgCACIgaiEhICMhGCAgIQEDQCAYLQAAIh9BIHIgHyAfQb9/akH/AXFBGkkbQf8BcSABQcClgIAAai0AAEcNwAIgAUEBRg23AiABQQFqIQEgGEEBaiIYIAJHDQALIAAgITYCAAzMAgtBOiEbIAEiIyACRg3LAiACICNrIAAoAgAiIGohISAjIRggICEBAkADQCAYLQAAIh9BIHIgHyAfQb9/akH/AXFBGkkbQf8BcSABQcKlgIAAai0AAEcNwAIgAUEORg0BIAFBAWohASAYQQFqIhggAkcNAAsgACAhNgIADMwCCyAAQQA2AgAgAEEBOgAsICMgIGtBD2ohAQy5AgtBOyEbIAEiIyACRg3KAiACICNrIAAoAgAiIGohISAjIRggICEBAkADQCAYLQAAIh9BIHIgHyAfQb9/akH/AXFBGkkbQf8BcSABQeClgIAAai0AAEcNvwIgAUEPRg0BIAFBAWohASAYQQFqIhggAkcNAAsgACAhNgIADMsCCyAAQQA2AgAgAEEDOgAsICMgIGtBEGohAQy4AgtBPCEbIAEiIyACRg3JAiACICNrIAAoAgAiIGohISAjIRggICEBAkADQCAYLQAAIh9BIHIgHyAfQb9/akH/AXFBGkkbQf8BcSABQfClgIAAai0AAEcNvgIgAUEFRg0BIAFBAWohASAYQQFqIhggAkcNAAsgACAhNgIADMoCCyAAQQA2AgAgAEEEOgAsICMgIGtBBmohAQy3AgsCQCABIhggAkcNAEE9IRsMyQILAkACQAJAAkAgGC0AACIBQSByIAEgAUG/f2pB/wFxQRpJG0H/AXFBnX9qDhMAwALAAsACwALAAsACwALAAsACwALAAsACAcACwALAAgIDwAILIBhBAWohAUE1IRsMwAILIBhBAWohAUE2IRsMvwILIBhBAWohAUE3IRsMvgILIBhBAWohAUE4IRsMvQILAkAgASIBIAJGDQAgAEGLgICAADYCCCAAIAE2AgQgASEBQTkhGwy9AgtBPiEbDMcCCyABIgEgAkcNswFBwAAhGwzGAgtBwQAhGyABIiMgAkYNxQIgAiAjayAAKAIAIiBqISEgIyEfICAhAQJAA0AgHy0AACABQfalgIAAai0AAEcNuAEgAUEBRg0BIAFBAWohASAfQQFqIh8gAkcNAAsgACAhNgIADMYCCyAAQQA2AgAgIyAga0ECaiEBDLMBCwJAIAEiASACRw0AQcMAIRsMxQILIAEtAABBCkcNtwEgAUEBaiEBDLMBCwJAIAEiASACRw0AQcQAIRsMxAILAkACQCABLQAAQXZqDgQBuAG4AQC4AQsgAUEBaiEBQT0hGwy5AgsgAUEBaiEBDLIBCwJAIAEiASACRw0AQcUAIRsMwwILQQAhGwJAAkACQAJAAkACQAJAAkAgAS0AAEFQag4KvwG+AQABAgMEBQYHwAELQQIhGwy+AQtBAyEbDL0BC0EEIRsMvAELQQUhGwy7AQtBBiEbDLoBC0EHIRsMuQELQQghGwy4AQtBCSEbDLcBCwJAIAEiASACRw0AQcYAIRsMwgILIAEtAABBLkcNuAEgAUEBaiEBDIYCCwJAIAEiASACRw0AQccAIRsMwQILQQAhGwJAAkACQAJAAkACQAJAAkAgAS0AAEFQag4KwQHAAQABAgMEBQYHwgELQQIhGwzAAQtBAyEbDL8BC0EEIRsMvgELQQUhGwy9AQtBBiEbDLwBC0EHIRsMuwELQQghGwy6AQtBCSEbDLkBC0HIACEbIAEiIyACRg2/AiACICNrIAAoAgAiIGohISAjIQEgICEfA0AgAS0AACAfQYKmgIAAai0AAEcNvAEgH0EDRg27ASAfQQFqIR8gAUEBaiIBIAJHDQALIAAgITYCAAy/AgtByQAhGyABIiMgAkYNvgIgAiAjayAAKAIAIiBqISEgIyEBICAhHwNAIAEtAAAgH0GGpoCAAGotAABHDbsBIB9BAkYNvQEgH0EBaiEfIAFBAWoiASACRw0ACyAAICE2AgAMvgILQcoAIRsgASIjIAJGDb0CIAIgI2sgACgCACIgaiEhICMhASAgIR8DQCABLQAAIB9BiaaAgABqLQAARw26ASAfQQNGDb0BIB9BAWohHyABQQFqIgEgAkcNAAsgACAhNgIADL0CCwNAAkAgAS0AACIbQSBGDQACQAJAAkAgG0G4f2oOCwABvgG+Ab4BvgG+Ab4BvgG+AQK+AQsgAUEBaiEBQcIAIRsMtQILIAFBAWohAUHDACEbDLQCCyABQQFqIQFBxAAhGwyzAgsgAUEBaiIBIAJHDQALQcsAIRsMvAILAkAgASIBIAJGDQAgACABQQFqIgEgAhClgICAABogASEBQQchGwyxAgtBzAAhGwy7AgsDQAJAIAEtAABBkKaAgABqLQAAIhtBAUYNACAbQX5qDgO9Ab4BvwHAAQsgAUEBaiIBIAJHDQALQc0AIRsMugILAkAgASIBIAJGDQAgAUEBaiEBDAMLQc4AIRsMuQILA0ACQCABLQAAQZCogIAAai0AACIbQQFGDQACQCAbQX5qDgTAAcEBwgEAwwELIAEhAUHGACEbDK8CCyABQQFqIgEgAkcNAAtBzwAhGwy4AgsCQCABIgEgAkcNAEHQACEbDLgCCwJAIAEtAAAiG0F2ag4aqAHDAcMBqgHDAcMBwwHDAcMBwwHDAcMBwwHDAcMBwwHDAcMBwwHDAcMBwwG4AcMBwwEAwQELIAFBAWohAQtBBiEbDKsCCwNAAkAgAS0AAEGQqoCAAGotAABBAUYNACABIQEMgAILIAFBAWoiASACRw0AC0HRACEbDLUCCwJAIAEiASACRg0AIAFBAWohAQwDC0HSACEbDLQCCwJAIAEiASACRw0AQdMAIRsMtAILIAFBAWohAQwBCwJAIAEiASACRw0AQdQAIRsMswILIAFBAWohAQtBBCEbDKYCCwJAIAEiHyACRw0AQdUAIRsMsQILIB8hAQJAAkACQCAfLQAAQZCsgIAAai0AAEF/ag4HwgHDAcQBAP4BAQLFAQsgH0EBaiEBDAoLIB9BAWohAQy7AQtBACEbIABBADYCHCAAQfGOgIAANgIQIABBBzYCDCAAIB9BAWo2AhQMsAILAkADQAJAIAEtAABBkKyAgABqLQAAIhtBBEYNAAJAAkAgG0F/ag4HwAHBAcIBxwEABAHHAQsgASEBQckAIRsMqAILIAFBAWohAUHLACEbDKcCCyABQQFqIgEgAkcNAAtB1gAhGwywAgsgAUEBaiEBDLkBCwJAIAEiHyACRw0AQdcAIRsMrwILIB8tAABBL0cNwgEgH0EBaiEBDAYLAkAgASIfIAJHDQBB2AAhGwyuAgsCQCAfLQAAIgFBL0cNACAfQQFqIQFBzAAhGwyjAgsgAUF2aiIEQRZLDcEBQQEgBHRBiYCAAnFFDcEBDJYCCwJAIAEiASACRg0AIAFBAWohAUHNACEbDKICC0HZACEbDKwCCwJAIAEiHyACRw0AQdsAIRsMrAILIB8hAQJAIB8tAABBkLCAgABqLQAAQX9qDgOVAvYBAMIBC0HQACEbDKACCwJAIAEiHyACRg0AA0ACQCAfLQAAQZCugIAAai0AACIBQQNGDQACQCABQX9qDgKXAgDDAQsgHyEBQc4AIRsMogILIB9BAWoiHyACRw0AC0HaACEbDKsCC0HaACEbDKoCCwJAIAEiASACRg0AIABBjICAgAA2AgggACABNgIEIAEhAUHPACEbDJ8CC0HcACEbDKkCCwJAIAEiASACRw0AQd0AIRsMqQILIABBjICAgAA2AgggACABNgIEIAEhAQtBAyEbDJwCCwNAIAEtAABBIEcNjwIgAUEBaiIBIAJHDQALQd4AIRsMpgILAkAgASIBIAJHDQBB3wAhGwymAgsgAS0AAEEgRw28ASABQQFqIQEM2AELAkAgASIEIAJHDQBB4AAhGwylAgsgBC0AAEHMAEcNvwEgBEEBaiEBQRMhGwy9AQtB4QAhGyABIh8gAkYNowIgAiAfayAAKAIAIiNqISAgHyEEICMhAQNAIAQtAAAgAUGQsoCAAGotAABHDb4BIAFBBUYNvAEgAUEBaiEBIARBAWoiBCACRw0ACyAAICA2AgAMowILAkAgASIEIAJHDQBB4gAhGwyjAgsCQAJAIAQtAABBvX9qDgwAvwG/Ab8BvwG/Ab8BvwG/Ab8BvwEBvwELIARBAWohAUHUACEbDJgCCyAEQQFqIQFB1QAhGwyXAgtB4wAhGyABIh8gAkYNoQIgAiAfayAAKAIAIiNqISAgHyEEICMhAQJAA0AgBC0AACABQY2zgIAAai0AAEcNvQEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAgNgIADKICCyAAQQA2AgAgHyAja0EDaiEBQRAhGwy6AQtB5AAhGyABIh8gAkYNoAIgAiAfayAAKAIAIiNqISAgHyEEICMhAQJAA0AgBC0AACABQZaygIAAai0AAEcNvAEgAUEFRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAgNgIADKECCyAAQQA2AgAgHyAja0EGaiEBQRYhGwy5AQtB5QAhGyABIh8gAkYNnwIgAiAfayAAKAIAIiNqISAgHyEEICMhAQJAA0AgBC0AACABQZyygIAAai0AAEcNuwEgAUEDRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAgNgIADKACCyAAQQA2AgAgHyAja0EEaiEBQQUhGwy4AQsCQCABIgQgAkcNAEHmACEbDJ8CCyAELQAAQdkARw25ASAEQQFqIQFBCCEbDLcBCwJAIAEiBCACRw0AQecAIRsMngILAkACQCAELQAAQbJ/ag4DALoBAboBCyAEQQFqIQFB2QAhGwyTAgsgBEEBaiEBQdoAIRsMkgILAkAgASIEIAJHDQBB6AAhGwydAgsCQAJAIAQtAABBuH9qDggAuQG5AbkBuQG5AbkBAbkBCyAEQQFqIQFB2AAhGwySAgsgBEEBaiEBQdsAIRsMkQILQekAIRsgASIfIAJGDZsCIAIgH2sgACgCACIjaiEgIB8hBCAjIQECQANAIAQtAAAgAUGgsoCAAGotAABHDbcBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgIDYCAAycAgtBACEbIABBADYCACAfICNrQQNqIQEMtAELQeoAIRsgASIfIAJGDZoCIAIgH2sgACgCACIjaiEgIB8hBCAjIQECQANAIAQtAAAgAUGjsoCAAGotAABHDbYBIAFBBEYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgIDYCAAybAgsgAEEANgIAIB8gI2tBBWohAUEjIRsMswELAkAgASIEIAJHDQBB6wAhGwyaAgsCQAJAIAQtAABBtH9qDggAtgG2AbYBtgG2AbYBAbYBCyAEQQFqIQFB3QAhGwyPAgsgBEEBaiEBQd4AIRsMjgILAkAgASIEIAJHDQBB7AAhGwyZAgsgBC0AAEHFAEcNswEgBEEBaiEBDOQBC0HtACEbIAEiHyACRg2XAiACIB9rIAAoAgAiI2ohICAfIQQgIyEBAkADQCAELQAAIAFBqLKAgABqLQAARw2zASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAICA2AgAMmAILIABBADYCACAfICNrQQRqIQFBLSEbDLABC0HuACEbIAEiHyACRg2WAiACIB9rIAAoAgAiI2ohICAfIQQgIyEBAkADQCAELQAAIAFB8LKAgABqLQAARw2yASABQQhGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAICA2AgAMlwILIABBADYCACAfICNrQQlqIQFBKSEbDK8BCwJAIAEiASACRw0AQe8AIRsMlgILQQEhGyABLQAAQd8ARw2uASABQQFqIQEM4gELQfAAIRsgASIfIAJGDZQCIAIgH2sgACgCACIjaiEgIB8hBCAjIQEDQCAELQAAIAFBrLKAgABqLQAARw2vASABQQFGDfoBIAFBAWohASAEQQFqIgQgAkcNAAsgACAgNgIADJQCC0HxACEbIAEiHyACRg2TAiACIB9rIAAoAgAiI2ohICAfIQQgIyEBAkADQCAELQAAIAFBrrKAgABqLQAARw2vASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAICA2AgAMlAILIABBADYCACAfICNrQQNqIQFBAiEbDKwBC0HyACEbIAEiHyACRg2SAiACIB9rIAAoAgAiI2ohICAfIQQgIyEBAkADQCAELQAAIAFBkLOAgABqLQAARw2uASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAICA2AgAMkwILIABBADYCACAfICNrQQJqIQFBHyEbDKsBC0HzACEbIAEiHyACRg2RAiACIB9rIAAoAgAiI2ohICAfIQQgIyEBAkADQCAELQAAIAFBkrOAgABqLQAARw2tASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAICA2AgAMkgILIABBADYCACAfICNrQQJqIQFBCSEbDKoBCwJAIAEiBCACRw0AQfQAIRsMkQILAkACQCAELQAAQbd/ag4HAK0BrQGtAa0BrQEBrQELIARBAWohAUHmACEbDIYCCyAEQQFqIQFB5wAhGwyFAgsCQCABIhsgAkcNAEH1ACEbDJACCyACIBtrIAAoAgAiH2ohIyAbIQQgHyEBAkADQCAELQAAIAFBsbKAgABqLQAARw2rASABQQVGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAICM2AgBB9QAhGwyQAgsgAEEANgIAIBsgH2tBBmohAUEYIRsMqAELAkAgASIbIAJHDQBB9gAhGwyPAgsgAiAbayAAKAIAIh9qISMgGyEEIB8hAQJAA0AgBC0AACABQbeygIAAai0AAEcNqgEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAjNgIAQfYAIRsMjwILIABBADYCACAbIB9rQQNqIQFBFyEbDKcBCwJAIAEiGyACRw0AQfcAIRsMjgILIAIgG2sgACgCACIfaiEjIBshBCAfIQECQANAIAQtAAAgAUG6soCAAGotAABHDakBIAFBBkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgIzYCAEH3ACEbDI4CCyAAQQA2AgAgGyAfa0EHaiEBQRUhGwymAQsCQCABIhsgAkcNAEH4ACEbDI0CCyACIBtrIAAoAgAiH2ohIyAbIQQgHyEBAkADQCAELQAAIAFBwbKAgABqLQAARw2oASABQQVGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAICM2AgBB+AAhGwyNAgsgAEEANgIAIBsgH2tBBmohAUEeIRsMpQELAkAgASIEIAJHDQBB+QAhGwyMAgsgBC0AAEHMAEcNpgEgBEEBaiEBQQohGwykAQsCQCABIgQgAkcNAEH6ACEbDIsCCwJAAkAgBC0AAEG/f2oODwCnAacBpwGnAacBpwGnAacBpwGnAacBpwGnAQGnAQsgBEEBaiEBQewAIRsMgAILIARBAWohAUHtACEbDP8BCwJAIAEiBCACRw0AQfsAIRsMigILAkACQCAELQAAQb9/ag4DAKYBAaYBCyAEQQFqIQFB6wAhGwz/AQsgBEEBaiEBQe4AIRsM/gELAkAgASIbIAJHDQBB/AAhGwyJAgsgAiAbayAAKAIAIh9qISMgGyEEIB8hAQJAA0AgBC0AACABQceygIAAai0AAEcNpAEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAjNgIAQfwAIRsMiQILIABBADYCACAbIB9rQQJqIQFBCyEbDKEBCwJAIAEiBCACRw0AQf0AIRsMiAILAkACQAJAAkAgBC0AAEFTag4jAKYBpgGmAaYBpgGmAaYBpgGmAaYBpgGmAaYBpgGmAaYBpgGmAaYBpgGmAaYBpgEBpgGmAaYBpgGmAQKmAaYBpgEDpgELIARBAWohAUHpACEbDP8BCyAEQQFqIQFB6gAhGwz+AQsgBEEBaiEBQe8AIRsM/QELIARBAWohAUHwACEbDPwBCwJAIAEiGyACRw0AQf4AIRsMhwILIAIgG2sgACgCACIfaiEjIBshBCAfIQECQANAIAQtAAAgAUHJsoCAAGotAABHDaIBIAFBBEYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgIzYCAEH+ACEbDIcCCyAAQQA2AgAgGyAfa0EFaiEBQRkhGwyfAQsCQCABIh8gAkcNAEH/ACEbDIYCCyACIB9rIAAoAgAiI2ohGyAfIQQgIyEBAkADQCAELQAAIAFBzrKAgABqLQAARw2hASABQQVGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIBs2AgBB/wAhGwyGAgsgAEEANgIAQQYhGyAfICNrQQZqIQEMngELAkAgASIbIAJHDQBBgAEhGwyFAgsgAiAbayAAKAIAIh9qISMgGyEEIB8hAQJAA0AgBC0AACABQdSygIAAai0AAEcNoAEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAjNgIAQYABIRsMhQILIABBADYCACAbIB9rQQJqIQFBHCEbDJ0BCwJAIAEiGyACRw0AQYEBIRsMhAILIAIgG2sgACgCACIfaiEjIBshBCAfIQECQANAIAQtAAAgAUHWsoCAAGotAABHDZ8BIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgIzYCAEGBASEbDIQCCyAAQQA2AgAgGyAfa0ECaiEBQSchGwycAQsCQCABIgQgAkcNAEGCASEbDIMCCwJAAkAgBC0AAEGsf2oOAgABnwELIARBAWohAUH0ACEbDPgBCyAEQQFqIQFB9QAhGwz3AQsCQCABIhsgAkcNAEGDASEbDIICCyACIBtrIAAoAgAiH2ohIyAbIQQgHyEBAkADQCAELQAAIAFB2LKAgABqLQAARw2dASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAICM2AgBBgwEhGwyCAgsgAEEANgIAIBsgH2tBAmohAUEmIRsMmgELAkAgASIbIAJHDQBBhAEhGwyBAgsgAiAbayAAKAIAIh9qISMgGyEEIB8hAQJAA0AgBC0AACABQdqygIAAai0AAEcNnAEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAjNgIAQYQBIRsMgQILIABBADYCACAbIB9rQQJqIQFBAyEbDJkBCwJAIAEiGyACRw0AQYUBIRsMgAILIAIgG2sgACgCACIfaiEjIBshBCAfIQECQANAIAQtAAAgAUGNs4CAAGotAABHDZsBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgIzYCAEGFASEbDIACCyAAQQA2AgAgGyAfa0EDaiEBQQwhGwyYAQsCQCABIhsgAkcNAEGGASEbDP8BCyACIBtrIAAoAgAiH2ohIyAbIQQgHyEBAkADQCAELQAAIAFB3LKAgABqLQAARw2aASABQQNGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAICM2AgBBhgEhGwz/AQsgAEEANgIAIBsgH2tBBGohAUENIRsMlwELAkAgASIEIAJHDQBBhwEhGwz+AQsCQAJAIAQtAABBun9qDgsAmgGaAZoBmgGaAZoBmgGaAZoBAZoBCyAEQQFqIQFB+QAhGwzzAQsgBEEBaiEBQfoAIRsM8gELAkAgASIEIAJHDQBBiAEhGwz9AQsgBC0AAEHQAEcNlwEgBEEBaiEBDMoBCwJAIAEiBCACRw0AQYkBIRsM/AELAkACQCAELQAAQbd/ag4HAZgBmAGYAZgBmAEAmAELIARBAWohAUH8ACEbDPEBCyAEQQFqIQFBIiEbDJQBCwJAIAEiGyACRw0AQYoBIRsM+wELIAIgG2sgACgCACIfaiEjIBshBCAfIQECQANAIAQtAAAgAUHgsoCAAGotAABHDZYBIAFBAUYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgIzYCAEGKASEbDPsBCyAAQQA2AgAgGyAfa0ECaiEBQR0hGwyTAQsCQCABIgQgAkcNAEGLASEbDPoBCwJAAkAgBC0AAEGuf2oOAwCWAQGWAQsgBEEBaiEBQf4AIRsM7wELIARBAWohAUEEIRsMkgELAkAgASIEIAJHDQBBjAEhGwz5AQsCQAJAAkACQAJAIAQtAABBv39qDhUAmAGYAZgBmAGYAZgBmAGYAZgBmAEBmAGYAQKYAZgBA5gBmAEEmAELIARBAWohAUH2ACEbDPEBCyAEQQFqIQFB9wAhGwzwAQsgBEEBaiEBQfgAIRsM7wELIARBAWohAUH9ACEbDO4BCyAEQQFqIQFB/wAhGwztAQsCQCABIhsgAkcNAEGNASEbDPgBCyACIBtrIAAoAgAiH2ohIyAbIQQgHyEBAkADQCAELQAAIAFBjbOAgABqLQAARw2TASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAICM2AgBBjQEhGwz4AQsgAEEANgIAIBsgH2tBA2ohAUERIRsMkAELAkAgASIbIAJHDQBBjgEhGwz3AQsgAiAbayAAKAIAIh9qISMgGyEEIB8hAQJAA0AgBC0AACABQeKygIAAai0AAEcNkgEgAUECRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAjNgIAQY4BIRsM9wELIABBADYCACAbIB9rQQNqIQFBLCEbDI8BCwJAIAEiGyACRw0AQY8BIRsM9gELIAIgG2sgACgCACIfaiEjIBshBCAfIQECQANAIAQtAAAgAUHlsoCAAGotAABHDZEBIAFBBEYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgIzYCAEGPASEbDPYBCyAAQQA2AgAgGyAfa0EFaiEBQSshGwyOAQsCQCABIhsgAkcNAEGQASEbDPUBCyACIBtrIAAoAgAiH2ohIyAbIQQgHyEBAkADQCAELQAAIAFB6rKAgABqLQAARw2QASABQQJGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAICM2AgBBkAEhGwz1AQsgAEEANgIAIBsgH2tBA2ohAUEUIRsMjQELAkAgBCACRw0AQZEBIRsM9AELAkACQAJAAkAgBC0AAEG+f2oODwABApIBkgGSAZIBkgGSAZIBkgGSAZIBkgEDkgELIARBAWohAUGBASEbDOsBCyAEQQFqIQFBggEhGwzqAQsgBEEBaiEBQYMBIRsM6QELIARBAWohAUGEASEbDOgBCwJAIAQgAkcNAEGSASEbDPMBCyAELQAAQcUARw2NASAEQQFqIQQMwQELAkAgBSACRw0AQZMBIRsM8gELIAIgBWsgACgCACIbaiEfIAUhBCAbIQECQANAIAQtAAAgAUHtsoCAAGotAABHDY0BIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgHzYCAEGTASEbDPIBCyAAQQA2AgAgBSAba0EDaiEBQQ4hGwyKAQsCQCAEIAJHDQBBlAEhGwzxAQsgBC0AAEHQAEcNiwEgBEEBaiEBQSUhGwyJAQsCQCAGIAJHDQBBlQEhGwzwAQsgAiAGayAAKAIAIhtqIR8gBiEEIBshAQJAA0AgBC0AACABQfCygIAAai0AAEcNiwEgAUEIRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAfNgIAQZUBIRsM8AELIABBADYCACAGIBtrQQlqIQFBKiEbDIgBCwJAIAQgAkcNAEGWASEbDO8BCwJAAkAgBC0AAEGrf2oOCwCLAYsBiwGLAYsBiwGLAYsBiwEBiwELIARBAWohBEGIASEbDOQBCyAEQQFqIQZBiQEhGwzjAQsCQCAEIAJHDQBBlwEhGwzuAQsCQAJAIAQtAABBv39qDhQAigGKAYoBigGKAYoBigGKAYoBigGKAYoBigGKAYoBigGKAYoBAYoBCyAEQQFqIQVBhwEhGwzjAQsgBEEBaiEEQYoBIRsM4gELAkAgByACRw0AQZgBIRsM7QELIAIgB2sgACgCACIbaiEfIAchBCAbIQECQANAIAQtAAAgAUH5soCAAGotAABHDYgBIAFBA0YNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgHzYCAEGYASEbDO0BCyAAQQA2AgAgByAba0EEaiEBQSEhGwyFAQsCQCAIIAJHDQBBmQEhGwzsAQsgAiAIayAAKAIAIhtqIR8gCCEEIBshAQJAA0AgBC0AACABQf2ygIAAai0AAEcNhwEgAUEGRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAfNgIAQZkBIRsM7AELIABBADYCACAIIBtrQQdqIQFBGiEbDIQBCwJAIAQgAkcNAEGaASEbDOsBCwJAAkACQCAELQAAQbt/ag4RAIgBiAGIAYgBiAGIAYgBiAGIAQGIAYgBiAGIAYgBAogBCyAEQQFqIQRBiwEhGwzhAQsgBEEBaiEHQYwBIRsM4AELIARBAWohCEGNASEbDN8BCwJAIAkgAkcNAEGbASEbDOoBCyACIAlrIAAoAgAiG2ohHyAJIQQgGyEBAkADQCAELQAAIAFBhLOAgABqLQAARw2FASABQQVGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIB82AgBBmwEhGwzqAQsgAEEANgIAIAkgG2tBBmohAUEoIRsMggELAkAgCiACRw0AQZwBIRsM6QELIAIgCmsgACgCACIbaiEfIAohBCAbIQECQANAIAQtAAAgAUGKs4CAAGotAABHDYQBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgHzYCAEGcASEbDOkBCyAAQQA2AgAgCiAba0EDaiEBQQchGwyBAQsCQCAEIAJHDQBBnQEhGwzoAQsCQAJAIAQtAABBu39qDg4AhAGEAYQBhAGEAYQBhAGEAYQBhAGEAYQBAYQBCyAEQQFqIQlBjwEhGwzdAQsgBEEBaiEKQZABIRsM3AELAkAgCyACRw0AQZ4BIRsM5wELIAIgC2sgACgCACIbaiEfIAshBCAbIQECQANAIAQtAAAgAUGNs4CAAGotAABHDYIBIAFBAkYNASABQQFqIQEgBEEBaiIEIAJHDQALIAAgHzYCAEGeASEbDOcBCyAAQQA2AgAgCyAba0EDaiEBQRIhGwx/CwJAIAwgAkcNAEGfASEbDOYBCyACIAxrIAAoAgAiG2ohHyAMIQQgGyEBAkADQCAELQAAIAFBkLOAgABqLQAARw2BASABQQFGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIB82AgBBnwEhGwzmAQsgAEEANgIAIAwgG2tBAmohAUEgIRsMfgsCQCANIAJHDQBBoAEhGwzlAQsgAiANayAAKAIAIhtqIR8gDSEEIBshAQJAA0AgBC0AACABQZKzgIAAai0AAEcNgAEgAUEBRg0BIAFBAWohASAEQQFqIgQgAkcNAAsgACAfNgIAQaABIRsM5QELIABBADYCACANIBtrQQJqIQFBDyEbDH0LAkAgBCACRw0AQaEBIRsM5AELAkACQCAELQAAQbd/ag4HAIABgAGAAYABgAEBgAELIARBAWohDEGTASEbDNkBCyAEQQFqIQ1BlAEhGwzYAQsCQCAOIAJHDQBBogEhGwzjAQsgAiAOayAAKAIAIhtqIR8gDiEEIBshAQJAA0AgBC0AACABQZSzgIAAai0AAEcNfiABQQdGDQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIB82AgBBogEhGwzjAQsgAEEANgIAIA4gG2tBCGohAUEbIRsMewsCQCAEIAJHDQBBowEhGwziAQsCQAJAAkAgBC0AAEG+f2oOEgB/f39/f39/f38Bf39/f39/An8LIARBAWohC0GSASEbDNgBCyAEQQFqIQRBlQEhGwzXAQsgBEEBaiEOQZYBIRsM1gELAkAgBCACRw0AQaQBIRsM4QELIAQtAABBzgBHDXsgBEEBaiEEDLABCwJAIAQgAkcNAEGlASEbDOABCwJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAAkACQAJAIAQtAABBv39qDhUAAQIDigEEBQaKAYoBigEHCAkKC4oBDA0OD4oBCyAEQQFqIQFB1gAhGwzjAQsgBEEBaiEBQdcAIRsM4gELIARBAWohAUHcACEbDOEBCyAEQQFqIQFB4AAhGwzgAQsgBEEBaiEBQeEAIRsM3wELIARBAWohAUHkACEbDN4BCyAEQQFqIQFB5QAhGwzdAQsgBEEBaiEBQegAIRsM3AELIARBAWohAUHxACEbDNsBCyAEQQFqIQFB8gAhGwzaAQsgBEEBaiEBQfMAIRsM2QELIARBAWohAUGAASEbDNgBCyAEQQFqIQRBhgEhGwzXAQsgBEEBaiEEQY4BIRsM1gELIARBAWohBEGRASEbDNUBCyAEQQFqIQRBmAEhGwzUAQsCQCAQIAJHDQBBpwEhGwzfAQsgEEEBaiEPDHsLA0ACQCAbLQAAQXZqDgR7AAB+AAsgG0EBaiIbIAJHDQALQagBIRsM3QELAkAgESACRg0AIABBjYCAgAA2AgggACARNgIEIBEhAUEBIRsM0gELQakBIRsM3AELAkAgESACRw0AQaoBIRsM3AELAkACQCARLQAAQXZqDgQBsQGxAQCxAQsgEUEBaiEQDHwLIBFBAWohDwx4CyAAIA8gAhCngICAABogDyEBDEkLAkAgESACRw0AQasBIRsM2gELAkACQCARLQAAQXZqDhcBfX0BfX19fX19fX19fX19fX19fX19AH0LIBFBAWohEQtBnAEhGwzOAQsCQCASIAJHDQBBrQEhGwzZAQsgEi0AAEEgRw17IABBADsBMiASQQFqIQFBoAEhGwzNAQsgASEjAkADQCAjIhEgAkYNASARLQAAQVBqQf8BcSIbQQpPDa4BAkAgAC8BMiIfQZkzSw0AIAAgH0EKbCIfOwEyIBtB//8DcyAfQf7/A3FJDQAgEUEBaiEjIAAgHyAbaiIbOwEyIBtB//8DcUHoB0kNAQsLQQAhGyAAQQA2AhwgAEGdiYCAADYCECAAQQ02AgwgACARQQFqNgIUDNgBC0GsASEbDNcBCwJAIBMgAkcNAEGuASEbDNcBC0EAIRsCQAJAAkACQAJAAkACQAJAIBMtAABBUGoOCoMBggEAAQIDBAUGB4QBC0ECIRsMggELQQMhGwyBAQtBBCEbDIABC0EFIRsMfwtBBiEbDH4LQQchGwx9C0EIIRsMfAtBCSEbDHsLAkAgFCACRw0AQa8BIRsM1gELIBQtAABBLkcNfCAUQQFqIRMMrAELAkAgFSACRw0AQbABIRsM1QELQQAhGwJAAkACQAJAAkACQAJAAkAgFS0AAEFQag4KhQGEAQABAgMEBQYHhgELQQIhGwyEAQtBAyEbDIMBC0EEIRsMggELQQUhGwyBAQtBBiEbDIABC0EHIRsMfwtBCCEbDH4LQQkhGwx9CwJAIAQgAkcNAEGxASEbDNQBCyACIARrIAAoAgAiH2ohIyAEIRUgHyEbA0AgFS0AACAbQZyzgIAAai0AAEcNfyAbQQRGDbcBIBtBAWohGyAVQQFqIhUgAkcNAAsgACAjNgIAQbEBIRsM0wELAkAgFiACRw0AQbIBIRsM0wELIAIgFmsgACgCACIbaiEfIBYhBCAbIQEDQCAELQAAIAFBobOAgABqLQAARw1/IAFBAUYNuQEgAUEBaiEBIARBAWoiBCACRw0ACyAAIB82AgBBsgEhGwzSAQsCQCAXIAJHDQBBswEhGwzSAQsgAiAXayAAKAIAIhVqIR8gFyEEIBUhGwNAIAQtAAAgG0Gjs4CAAGotAABHDX4gG0ECRg2AASAbQQFqIRsgBEEBaiIEIAJHDQALIAAgHzYCAEGzASEbDNEBCwJAIAQgAkcNAEG0ASEbDNEBCwJAAkAgBC0AAEG7f2oOEAB/f39/f39/f39/f39/fwF/CyAEQQFqIRZBpQEhGwzGAQsgBEEBaiEXQaYBIRsMxQELAkAgBCACRw0AQbUBIRsM0AELIAQtAABByABHDXwgBEEBaiEEDKgBCwJAIAQgAkcNAEG2ASEbDM8BCyAELQAAQcgARg2oASAAQQE6ACgMnwELA0ACQCAELQAAQXZqDgQAfn4AfgsgBEEBaiIEIAJHDQALQbgBIRsMzQELIABBADoALyAALQAtQQRxRQ3GAQsgAEEAOgAvIAEhAQx9CyAbQRVGDawBIABBADYCHCAAIAE2AhQgAEGrjICAADYCECAAQRI2AgxBACEbDMoBCwJAIAAgGyACEK2AgIAAIgQNACAbIQEMwwELAkAgBEEVRw0AIABBAzYCHCAAIBs2AhQgAEGGkoCAADYCECAAQRU2AgxBACEbDMoBCyAAQQA2AhwgACAbNgIUIABBq4yAgAA2AhAgAEESNgIMQQAhGwzJAQsgG0EVRg2oASAAQQA2AhwgACABNgIUIABBiIyAgAA2AhAgAEEUNgIMQQAhGwzIAQsgACgCBCEjIABBADYCBCAbIBynaiIgIQEgACAjIBsgICAfGyIbEK6AgIAAIh9FDX8gAEEHNgIcIAAgGzYCFCAAIB82AgxBACEbDMcBCyAAIAAvATBBgAFyOwEwIAEhAQw1CyAbQRVGDaQBIABBADYCHCAAIAE2AhQgAEHFi4CAADYCECAAQRM2AgxBACEbDMUBCyAAQQA2AhwgACABNgIUIABBi4uAgAA2AhAgAEECNgIMQQAhGwzEAQsgG0E7Rw0BIAFBAWohAQtBCCEbDLcBC0EAIRsgAEEANgIcIAAgATYCFCAAQaOQgIAANgIQIABBDDYCDAzBAQtCASEcCyAbQQFqIQECQCAAKQMgIh1C//////////8PVg0AIAAgHUIEhiAchDcDICABIQEMfAsgAEEANgIcIAAgATYCFCAAQYmJgIAANgIQIABBDDYCDEEAIRsMvwELIABBADYCHCAAIBs2AhQgAEGjkICAADYCECAAQQw2AgxBACEbDL4BCyAAKAIEISMgAEEANgIEIBsgHKdqIiAhASAAICMgGyAgIB8bIhsQroCAgAAiH0UNcyAAQQU2AhwgACAbNgIUIAAgHzYCDEEAIRsMvQELIABBADYCHCAAIBs2AhQgAEGNlICAADYCECAAQQ82AgxBACEbDLwBCyAAIBsgAhCtgICAACIBDQEgGyEBC0EQIRsMrwELAkAgAUEVRw0AIABBAjYCHCAAIBs2AhQgAEGGkoCAADYCECAAQRU2AgxBACEbDLoBCyAAQQA2AhwgACAbNgIUIABBq4yAgAA2AhAgAEESNgIMQQAhGwy5AQsgAUEBaiEbAkAgAC8BMCIBQYABcUUNAAJAIAAgGyACELCAgIAAIgENACAbIQEMcAsgAUEVRw2aASAAQQU2AhwgACAbNgIUIABB7pGAgAA2AhAgAEEVNgIMQQAhGwy5AQsCQCABQaAEcUGgBEcNACAALQAtQQJxDQAgAEEANgIcIAAgGzYCFCAAQeyPgIAANgIQIABBBDYCDEEAIRsMuQELIAAgGyACELGAgIAAGiAbIQECQAJAAkACQAJAIAAgGyACEKyAgIAADhYCAQAEBAQEBAQEBAQEBAQEBAQEBAQDBAsgAEEBOgAuCyAAIAAvATBBwAByOwEwIBshAQtBHiEbDK8BCyAAQRU2AhwgACAbNgIUIABBkZGAgAA2AhAgAEEVNgIMQQAhGwy5AQsgAEEANgIcIAAgGzYCFCAAQbGLgIAANgIQIABBETYCDEEAIRsMuAELIAAtAC1BAXFFDQFBqgEhGwysAQsCQCAYIAJGDQADQAJAIBgtAABBIEYNACAYIQEMpwELIBhBAWoiGCACRw0AC0EXIRsMtwELQRchGwy2AQsgACgCBCEEIABBADYCBCAAIAQgGBCogICAACIERQ2TASAAQRg2AhwgACAENgIMIAAgGEEBajYCFEEAIRsMtQELIABBGTYCHCAAIAE2AhQgACAbNgIMQQAhGwy0AQsgGyEBQQEhHwJAAkACQAJAAkACQAJAIAAtACxBfmoOBwYFBQMBAgAFCyAAIAAvATBBCHI7ATAMAwtBAiEfDAELQQQhHwsgAEEBOgAsIAAgAC8BMCAfcjsBMAsgGyEBC0EhIRsMqQELIABBADYCHCAAIBs2AhQgAEGBj4CAADYCECAAQQs2AgxBACEbDLMBCyAbIQFBASEfAkACQAJAAkACQCAALQAsQXtqDgQCAAEDBQtBAiEfDAELQQQhHwsgAEEBOgAsIAAgAC8BMCAfcjsBMAwBCyAAIAAvATBBCHI7ATALIBshAQtBqwEhGwymAQsgACABIAIQq4CAgAAaDB8LAkAgASIbIAJGDQAgGyEBAkACQCAbLQAAQXZqDgQBb28AbwsgG0EBaiEBC0EfIRsMpQELQT8hGwyvAQsgAEEANgIcIAAgATYCFCAAQeqQgIAANgIQIABBAzYCDEEAIRsMrgELIAAoAgQhASAAQQA2AgQCQCAAIAEgGRCqgICAACIBDQAgGUEBaiEBDG0LIABBHjYCHCAAIAE2AgwgACAZQQFqNgIUQQAhGwytAQsgAC0ALUEBcUUNA0GtASEbDKEBCwJAIBkgAkcNAEEfIRsMrAELA0ACQCAZLQAAQXZqDgQCAAADAAsgGUEBaiIZIAJHDQALQR8hGwyrAQsgACgCBCEBIABBADYCBAJAIAAgASAZEKqAgIAAIgENACAZIQEMagsgAEEeNgIcIAAgGTYCFCAAIAE2AgxBACEbDKoBCyAAKAIEIQEgAEEANgIEAkAgACABIBkQqoCAgAAiAQ0AIBlBAWohAQxpCyAAQR42AhwgACABNgIMIAAgGUEBajYCFEEAIRsMqQELIABBADYCHCAAIBk2AhQgAEHujICAADYCECAAQQo2AgxBACEbDKgBCyAbQSxHDQEgAUEBaiEbQQEhAQJAAkACQAJAAkAgAC0ALEF7ag4EAwECBAALIBshAQwEC0ECIQEMAQtBBCEBCyAAQQE6ACwgACAALwEwIAFyOwEwIBshAQwBCyAAIAAvATBBCHI7ATAgGyEBC0EuIRsMmwELIABBADoALCABIQELQSohGwyZAQsgAEEANgIAICAgIWtBCWohAUEFIRsMkwELIABBADYCACAgICFrQQZqIQFBByEbDJIBCyAAIAAvATBBIHI7ATAgASEBDAILIAAoAgQhBCAAQQA2AgQCQCAAIAQgARCqgICAACIEDQAgASEBDJcBCyAAQSg2AhwgACABNgIUIAAgBDYCDEEAIRsMoAELIABBCDoALCABIQELQSYhGwyTAQsgAC0AMEEgcQ15Qa4BIRsMkgELAkAgGiACRg0AAkADQAJAIBotAABBUGoiAUH/AXFBCkkNACAaIQFBKyEbDJUBCyAAKQMgIhxCmbPmzJmz5swZVg0BIAAgHEIKfiIcNwMgIBwgAa0iHUJ/hUKAfoRWDQEgACAcIB1C/wGDfDcDICAaQQFqIhogAkcNAAtBKiEbDJ4BCyAAKAIEIQQgAEEANgIEIAAgBCAaQQFqIgEQqoCAgAAiBA16IAEhAQyUAQtBKiEbDJwBCyAAIAAvATBB9/sDcUGABHI7ATAgGiEBC0EsIRsMjwELIAAgAC8BMEEQcjsBMAsgAEEAOgAsIBohAQxYCyAAQTI2AhwgACABNgIMIAAgGEEBajYCFEEAIRsMlwELIAEtAABBOkcNAiAAKAIEIRsgAEEANgIEIAAgGyABEKiAgIAAIhsNASABQQFqIQELQTEhGwyKAQsgAEEyNgIcIAAgGzYCDCAAIAFBAWo2AhRBACEbDJQBCyAAQQA2AhwgACABNgIUIABBh46AgAA2AhAgAEEKNgIMQQAhGwyTAQsgAUEBaiEBCyAAQYASOwEqIAAgASACEKWAgIAAGiABIQELQawBIRsMhQELIAAoAgQhGyAAQQA2AgQCQCAAIBsgARCkgICAACIbDQAgASEBDFILIABBwAA2AhwgACABNgIUIAAgGzYCDEEAIRsMjwELIABBADYCHCAAIB82AhQgAEGVmICAADYCECAAQQc2AgwgAEEANgIAQQAhGwyOAQsgACgCBCEbIABBADYCBAJAIAAgGyABEKSAgIAAIhsNACABIQEMUQsgAEHBADYCHCAAIAE2AhQgACAbNgIMQQAhGwyNAQtBACEbIABBADYCHCAAIAE2AhQgAEHrjYCAADYCECAAQQk2AgwMjAELQQEhGwsgACAbOgArIAFBAWohASAALQApQSJGDYUBDE4LIABBADYCHCAAIAE2AhQgAEGijYCAADYCECAAQQk2AgxBACEbDIkBCyAAQQA2AhwgACABNgIUIABBxYqAgAA2AhAgAEEJNgIMQQAhGwyIAQtBASEbCyAAIBs6ACogAUEBaiEBDEwLIABBADYCHCAAIAE2AhQgAEG4jYCAADYCECAAQQk2AgxBACEbDIUBCyAAQQA2AgAgIyAga0EEaiEBAkAgAC0AKUEjTw0AIAEhAQxMCyAAQQA2AhwgACABNgIUIABBr4mAgAA2AhAgAEEINgIMQQAhGwyEAQsgAEEANgIAC0EAIRsgAEEANgIcIAAgATYCFCAAQdmagIAANgIQIABBCDYCDAyCAQsgAEEANgIAICMgIGtBA2ohAQJAIAAtAClBIUcNACABIQEMSQsgAEEANgIcIAAgATYCFCAAQfeJgIAANgIQIABBCDYCDEEAIRsMgQELIABBADYCACAjICBrQQRqIQECQCAALQApIhtBXWpBC08NACABIQEMSAsCQCAbQQZLDQBBASAbdEHKAHFFDQAgASEBDEgLQQAhGyAAQQA2AhwgACABNgIUIABB04mAgAA2AhAgAEEINgIMDIABCyAAKAIEIRsgAEEANgIEAkAgACAbIAEQpICAgAAiGw0AIAEhAQxICyAAQcwANgIcIAAgATYCFCAAIBs2AgxBACEbDH8LIAAoAgQhGyAAQQA2AgQCQCAAIBsgARCkgICAACIbDQAgASEBDEELIABBwAA2AhwgACABNgIUIAAgGzYCDEEAIRsMfgsgACgCBCEbIABBADYCBAJAIAAgGyABEKSAgIAAIhsNACABIQEMQQsgAEHBADYCHCAAIAE2AhQgACAbNgIMQQAhGwx9CyAAKAIEIRsgAEEANgIEAkAgACAbIAEQpICAgAAiGw0AIAEhAQxFCyAAQcwANgIcIAAgATYCFCAAIBs2AgxBACEbDHwLIABBADYCHCAAIAE2AhQgAEGiioCAADYCECAAQQc2AgxBACEbDHsLIAAoAgQhGyAAQQA2AgQCQCAAIBsgARCkgICAACIbDQAgASEBDD0LIABBwAA2AhwgACABNgIUIAAgGzYCDEEAIRsMegsgACgCBCEbIABBADYCBAJAIAAgGyABEKSAgIAAIhsNACABIQEMPQsgAEHBADYCHCAAIAE2AhQgACAbNgIMQQAhGwx5CyAAKAIEIRsgAEEANgIEAkAgACAbIAEQpICAgAAiGw0AIAEhAQxBCyAAQcwANgIcIAAgATYCFCAAIBs2AgxBACEbDHgLIABBADYCHCAAIAE2AhQgAEG4iICAADYCECAAQQc2AgxBACEbDHcLIBtBP0cNASABQQFqIQELQQUhGwxqC0EAIRsgAEEANgIcIAAgATYCFCAAQdOPgIAANgIQIABBBzYCDAx0CyAAKAIEIRsgAEEANgIEAkAgACAbIAEQpICAgAAiGw0AIAEhAQw2CyAAQcAANgIcIAAgATYCFCAAIBs2AgxBACEbDHMLIAAoAgQhGyAAQQA2AgQCQCAAIBsgARCkgICAACIbDQAgASEBDDYLIABBwQA2AhwgACABNgIUIAAgGzYCDEEAIRsMcgsgACgCBCEbIABBADYCBAJAIAAgGyABEKSAgIAAIhsNACABIQEMOgsgAEHMADYCHCAAIAE2AhQgACAbNgIMQQAhGwxxCyAAKAIEIQEgAEEANgIEAkAgACABIB8QpICAgAAiAQ0AIB8hAQwzCyAAQcAANgIcIAAgHzYCFCAAIAE2AgxBACEbDHALIAAoAgQhASAAQQA2AgQCQCAAIAEgHxCkgICAACIBDQAgHyEBDDMLIABBwQA2AhwgACAfNgIUIAAgATYCDEEAIRsMbwsgACgCBCEBIABBADYCBAJAIAAgASAfEKSAgIAAIgENACAfIQEMNwsgAEHMADYCHCAAIB82AhQgACABNgIMQQAhGwxuCyAAQQA2AhwgACAfNgIUIABB0IyAgAA2AhAgAEEHNgIMQQAhGwxtCyAAQQA2AhwgACABNgIUIABB0IyAgAA2AhAgAEEHNgIMQQAhGwxsC0EAIRsgAEEANgIcIAAgHzYCFCAAQe+TgIAANgIQIABBBzYCDAxrCyAAQQA2AhwgACAfNgIUIABB75OAgAA2AhAgAEEHNgIMQQAhGwxqCyAAQQA2AhwgACAfNgIUIABB1I6AgAA2AhAgAEEHNgIMQQAhGwxpCyAAQQA2AhwgACABNgIUIABB8ZKAgAA2AhAgAEEGNgIMQQAhGwxoCyAAQQA2AgAgHyAja0EGaiEBQSQhGwsgACAbOgApIAEhAQxNCyAAQQA2AgALQQAhGyAAQQA2AhwgACAENgIUIABB1JOAgAA2AhAgAEEGNgIMDGQLIAAoAgQhDyAAQQA2AgQgACAPIBsQpoCAgAAiDw0BIBtBAWohDwtBnQEhGwxXCyAAQaYBNgIcIAAgDzYCDCAAIBtBAWo2AhRBACEbDGELIAAoAgQhECAAQQA2AgQgACAQIBsQpoCAgAAiEA0BIBtBAWohEAtBmgEhGwxUCyAAQacBNgIcIAAgEDYCDCAAIBtBAWo2AhRBACEbDF4LIABBADYCHCAAIBE2AhQgAEHzioCAADYCECAAQQ02AgxBACEbDF0LIABBADYCHCAAIBI2AhQgAEHOjYCAADYCECAAQQk2AgxBACEbDFwLQQEhGwsgACAbOgArIBNBAWohEgwwCyAAQQA2AhwgACATNgIUIABBoo2AgAA2AhAgAEEJNgIMQQAhGwxZCyAAQQA2AhwgACAUNgIUIABBxYqAgAA2AhAgAEEJNgIMQQAhGwxYC0EBIRsLIAAgGzoAKiAVQQFqIRQMLgsgAEEANgIcIAAgFTYCFCAAQbiNgIAANgIQIABBCTYCDEEAIRsMVQsgAEEANgIcIAAgFTYCFCAAQdmagIAANgIQIABBCDYCDCAAQQA2AgBBACEbDFQLIABBADYCAAtBACEbIABBADYCHCAAIAQ2AhQgAEG7k4CAADYCECAAQQg2AgwMUgsgAEECOgAoIABBADYCACAXIBVrQQNqIRUMNQsgAEECOgAvIAAgBCACEKOAgIAAIhsNAUGvASEbDEULIAAtAChBf2oOAiAiIQsgG0EVRw0pIABBtwE2AhwgACAENgIUIABB15GAgAA2AhAgAEEVNgIMQQAhGwxOC0EAIRsMQgtBAiEbDEELQQwhGwxAC0EPIRsMPwtBESEbDD4LQR0hGww9C0EVIRsMPAtBFyEbDDsLQRghGww6C0EaIRsMOQtBGyEbDDgLQTohGww3C0EkIRsMNgtBJSEbDDULQS8hGww0C0EwIRsMMwtBOyEbDDILQTwhGwwxC0E+IRsMMAtBPyEbDC8LQcAAIRsMLgtBwQAhGwwtC0HFACEbDCwLQccAIRsMKwtByAAhGwwqC0HKACEbDCkLQd8AIRsMKAtB4gAhGwwnC0H7ACEbDCYLQYUBIRsMJQtBlwEhGwwkC0GZASEbDCMLQakBIRsMIgtBpAEhGwwhC0GbASEbDCALQZ4BIRsMHwtBnwEhGwweC0GhASEbDB0LQaIBIRsMHAtBpwEhGwwbC0GoASEbDBoLIABBADYCHCAAIAQ2AhQgAEHmi4CAADYCECAAQRA2AgxBACEbDCQLIABBADYCHCAAIBo2AhQgAEG6j4CAADYCECAAQQQ2AgxBACEbDCMLIABBJzYCHCAAIAE2AhQgACAENgIMQQAhGwwiCyAYQQFqIQEMGQsgAEEKNgIcIAAgATYCFCAAQcGRgIAANgIQIABBFTYCDEEAIRsMIAsgAEEQNgIcIAAgATYCFCAAQe6RgIAANgIQIABBFTYCDEEAIRsMHwsgAEEANgIcIAAgGzYCFCAAQYiMgIAANgIQIABBFDYCDEEAIRsMHgsgAEEENgIcIAAgATYCFCAAQYaSgIAANgIQIABBFTYCDEEAIRsMHQsgAEEANgIAIAQgH2tBBWohFQtBowEhGwwQCyAAQQA2AgAgHyAja0ECaiEBQeMAIRsMDwsgAEEANgIAIABBgQQ7ASggFiAba0ECaiEBC0HTACEbDA0LIAEhAQJAIAAtAClBBUcNAEHSACEbDA0LQdEAIRsMDAtBACEbIABBADYCHCAAQbqOgIAANgIQIABBBzYCDCAAIB9BAWo2AhQMFgsgAEEANgIAICMgIGtBAmohAUE0IRsMCgsgASEBC0EtIRsMCAsgAUEBaiEBQSMhGwwHC0EgIRsMBgsgAEEANgIAICAgIWtBBGohAUEGIRsLIAAgGzoALCABIQFBDiEbDAQLIABBADYCACAjICBrQQdqIQFBDSEbDAMLIABBADYCACAfIQFBCyEbDAILIABBADYCAAsgAEEAOgAsIBghAUEJIRsMAAsLQQAhGyAAQQA2AhwgACABNgIUIABBlo+AgAA2AhAgAEELNgIMDAkLQQAhGyAAQQA2AhwgACABNgIUIABB8YiAgAA2AhAgAEELNgIMDAgLQQAhGyAAQQA2AhwgACABNgIUIABBiI2AgAA2AhAgAEEKNgIMDAcLIABBAjYCHCAAIAE2AhQgAEGgkoCAADYCECAAQRY2AgxBACEbDAYLQQEhGwwFC0HCACEbIAEiBCACRg0EIANBCGogACAEIAJB+KWAgABBChC5gICAACADKAIMIQQgAygCCA4DAQQCAAsQv4CAgAAACyAAQQA2AhwgAEG5koCAADYCECAAQRc2AgwgACAEQQFqNgIUQQAhGwwCCyAAQQA2AhwgACAENgIUIABBzpKAgAA2AhAgAEEJNgIMQQAhGwwBCwJAIAEiBCACRw0AQRQhGwwBCyAAQYmAgIAANgIIIAAgBDYCBEETIRsLIANBEGokgICAgAAgGwuvAQECfyABKAIAIQYCQAJAIAIgA0YNACAEIAZqIQQgBiADaiACayEHIAIgBkF/cyAFaiIGaiEFA0ACQCACLQAAIAQtAABGDQBBAiEEDAMLAkAgBg0AQQAhBCAFIQIMAwsgBkF/aiEGIARBAWohBCACQQFqIgIgA0cNAAsgByEGIAMhAgsgAEEBNgIAIAEgBjYCACAAIAI2AgQPCyABQQA2AgAgACAENgIAIAAgAjYCBAsKACAAELuAgIAAC5U3AQt/I4CAgIAAQRBrIgEkgICAgAACQEEAKALAs4CAAA0AQQAQvoCAgABBoLeEgABrIgJB2QBJDQBBACEDAkBBACgCgLeAgAAiBA0AQQBCfzcCjLeAgABBAEKAgISAgIDAADcChLeAgABBACABQQhqQXBxQdiq1aoFcyIENgKAt4CAAEEAQQA2ApS3gIAAQQBBADYC5LaAgAALQQAgAjYC7LaAgABBAEGgt4SAADYC6LaAgABBAEGgt4SAADYCuLOAgABBACAENgLMs4CAAEEAQX82AsizgIAAA0AgA0Hks4CAAGogA0HYs4CAAGoiBDYCACAEIANB0LOAgABqIgU2AgAgA0Hcs4CAAGogBTYCACADQeyzgIAAaiADQeCzgIAAaiIFNgIAIAUgBDYCACADQfSzgIAAaiADQeizgIAAaiIENgIAIAQgBTYCACADQfCzgIAAaiAENgIAIANBIGoiA0GAAkcNAAtBoLeEgABBeEGgt4SAAGtBD3FBAEGgt4SAAEEIakEPcRsiA2oiBEEEaiACIANrQUhqIgNBAXI2AgBBAEEAKAKQt4CAADYCxLOAgABBACAENgLAs4CAAEEAIAM2ArSzgIAAIAJBoLeEgABqQUxqQTg2AgALAkACQAJAAkACQAJAAkACQAJAAkACQAJAIABB7AFLDQACQEEAKAKos4CAACIGQRAgAEETakFwcSAAQQtJGyICQQN2IgR2IgNBA3FFDQAgA0EBcSAEckEBcyIFQQN0IgBB2LOAgABqKAIAIgRBCGohAwJAAkAgBCgCCCICIABB0LOAgABqIgBHDQBBACAGQX4gBXdxNgKos4CAAAwBCyAAIAI2AgggAiAANgIMCyAEIAVBA3QiBUEDcjYCBCAEIAVqQQRqIgQgBCgCAEEBcjYCAAwMCyACQQAoArCzgIAAIgdNDQECQCADRQ0AAkACQCADIAR0QQIgBHQiA0EAIANrcnEiA0EAIANrcUF/aiIDIANBDHZBEHEiA3YiBEEFdkEIcSIFIANyIAQgBXYiA0ECdkEEcSIEciADIAR2IgNBAXZBAnEiBHIgAyAEdiIDQQF2QQFxIgRyIAMgBHZqIgVBA3QiAEHYs4CAAGooAgAiBCgCCCIDIABB0LOAgABqIgBHDQBBACAGQX4gBXdxIgY2AqizgIAADAELIAAgAzYCCCADIAA2AgwLIARBCGohAyAEIAJBA3I2AgQgBCAFQQN0IgVqIAUgAmsiBTYCACAEIAJqIgAgBUEBcjYCBAJAIAdFDQAgB0EDdiIIQQN0QdCzgIAAaiECQQAoAryzgIAAIQQCQAJAIAZBASAIdCIIcQ0AQQAgBiAIcjYCqLOAgAAgAiEIDAELIAIoAgghCAsgCCAENgIMIAIgBDYCCCAEIAI2AgwgBCAINgIIC0EAIAA2AryzgIAAQQAgBTYCsLOAgAAMDAtBACgCrLOAgAAiCUUNASAJQQAgCWtxQX9qIgMgA0EMdkEQcSIDdiIEQQV2QQhxIgUgA3IgBCAFdiIDQQJ2QQRxIgRyIAMgBHYiA0EBdkECcSIEciADIAR2IgNBAXZBAXEiBHIgAyAEdmpBAnRB2LWAgABqKAIAIgAoAgRBeHEgAmshBCAAIQUCQANAAkAgBSgCECIDDQAgBUEUaigCACIDRQ0CCyADKAIEQXhxIAJrIgUgBCAFIARJIgUbIQQgAyAAIAUbIQAgAyEFDAALCyAAKAIYIQoCQCAAKAIMIgggAEYNAEEAKAK4s4CAACAAKAIIIgNLGiAIIAM2AgggAyAINgIMDAsLAkAgAEEUaiIFKAIAIgMNACAAKAIQIgNFDQMgAEEQaiEFCwNAIAUhCyADIghBFGoiBSgCACIDDQAgCEEQaiEFIAgoAhAiAw0ACyALQQA2AgAMCgtBfyECIABBv39LDQAgAEETaiIDQXBxIQJBACgCrLOAgAAiB0UNAEEAIQsCQCACQYACSQ0AQR8hCyACQf///wdLDQAgA0EIdiIDIANBgP4/akEQdkEIcSIDdCIEIARBgOAfakEQdkEEcSIEdCIFIAVBgIAPakEQdkECcSIFdEEPdiADIARyIAVyayIDQQF0IAIgA0EVanZBAXFyQRxqIQsLQQAgAmshBAJAAkACQAJAIAtBAnRB2LWAgABqKAIAIgUNAEEAIQNBACEIDAELQQAhAyACQQBBGSALQQF2ayALQR9GG3QhAEEAIQgDQAJAIAUoAgRBeHEgAmsiBiAETw0AIAYhBCAFIQggBg0AQQAhBCAFIQggBSEDDAMLIAMgBUEUaigCACIGIAYgBSAAQR12QQRxakEQaigCACIFRhsgAyAGGyEDIABBAXQhACAFDQALCwJAIAMgCHINAEEAIQhBAiALdCIDQQAgA2tyIAdxIgNFDQMgA0EAIANrcUF/aiIDIANBDHZBEHEiA3YiBUEFdkEIcSIAIANyIAUgAHYiA0ECdkEEcSIFciADIAV2IgNBAXZBAnEiBXIgAyAFdiIDQQF2QQFxIgVyIAMgBXZqQQJ0Qdi1gIAAaigCACEDCyADRQ0BCwNAIAMoAgRBeHEgAmsiBiAESSEAAkAgAygCECIFDQAgA0EUaigCACEFCyAGIAQgABshBCADIAggABshCCAFIQMgBQ0ACwsgCEUNACAEQQAoArCzgIAAIAJrTw0AIAgoAhghCwJAIAgoAgwiACAIRg0AQQAoArizgIAAIAgoAggiA0saIAAgAzYCCCADIAA2AgwMCQsCQCAIQRRqIgUoAgAiAw0AIAgoAhAiA0UNAyAIQRBqIQULA0AgBSEGIAMiAEEUaiIFKAIAIgMNACAAQRBqIQUgACgCECIDDQALIAZBADYCAAwICwJAQQAoArCzgIAAIgMgAkkNAEEAKAK8s4CAACEEAkACQCADIAJrIgVBEEkNACAEIAJqIgAgBUEBcjYCBEEAIAU2ArCzgIAAQQAgADYCvLOAgAAgBCADaiAFNgIAIAQgAkEDcjYCBAwBCyAEIANBA3I2AgQgAyAEakEEaiIDIAMoAgBBAXI2AgBBAEEANgK8s4CAAEEAQQA2ArCzgIAACyAEQQhqIQMMCgsCQEEAKAK0s4CAACIAIAJNDQBBACgCwLOAgAAiAyACaiIEIAAgAmsiBUEBcjYCBEEAIAU2ArSzgIAAQQAgBDYCwLOAgAAgAyACQQNyNgIEIANBCGohAwwKCwJAAkBBACgCgLeAgABFDQBBACgCiLeAgAAhBAwBC0EAQn83Aoy3gIAAQQBCgICEgICAwAA3AoS3gIAAQQAgAUEMakFwcUHYqtWqBXM2AoC3gIAAQQBBADYClLeAgABBAEEANgLktoCAAEGAgAQhBAtBACEDAkAgBCACQccAaiIHaiIGQQAgBGsiC3EiCCACSw0AQQBBMDYCmLeAgAAMCgsCQEEAKALgtoCAACIDRQ0AAkBBACgC2LaAgAAiBCAIaiIFIARNDQAgBSADTQ0BC0EAIQNBAEEwNgKYt4CAAAwKC0EALQDktoCAAEEEcQ0EAkACQAJAQQAoAsCzgIAAIgRFDQBB6LaAgAAhAwNAAkAgAygCACIFIARLDQAgBSADKAIEaiAESw0DCyADKAIIIgMNAAsLQQAQvoCAgAAiAEF/Rg0FIAghBgJAQQAoAoS3gIAAIgNBf2oiBCAAcUUNACAIIABrIAQgAGpBACADa3FqIQYLIAYgAk0NBSAGQf7///8HSw0FAkBBACgC4LaAgAAiA0UNAEEAKALYtoCAACIEIAZqIgUgBE0NBiAFIANLDQYLIAYQvoCAgAAiAyAARw0BDAcLIAYgAGsgC3EiBkH+////B0sNBCAGEL6AgIAAIgAgAygCACADKAIEakYNAyAAIQMLAkAgA0F/Rg0AIAJByABqIAZNDQACQCAHIAZrQQAoAoi3gIAAIgRqQQAgBGtxIgRB/v///wdNDQAgAyEADAcLAkAgBBC+gICAAEF/Rg0AIAQgBmohBiADIQAMBwtBACAGaxC+gICAABoMBAsgAyEAIANBf0cNBQwDC0EAIQgMBwtBACEADAULIABBf0cNAgtBAEEAKALktoCAAEEEcjYC5LaAgAALIAhB/v///wdLDQEgCBC+gICAACEAQQAQvoCAgAAhAyAAQX9GDQEgA0F/Rg0BIAAgA08NASADIABrIgYgAkE4ak0NAQtBAEEAKALYtoCAACAGaiIDNgLYtoCAAAJAIANBACgC3LaAgABNDQBBACADNgLctoCAAAsCQAJAAkACQEEAKALAs4CAACIERQ0AQei2gIAAIQMDQCAAIAMoAgAiBSADKAIEIghqRg0CIAMoAggiAw0ADAMLCwJAAkBBACgCuLOAgAAiA0UNACAAIANPDQELQQAgADYCuLOAgAALQQAhA0EAIAY2Auy2gIAAQQAgADYC6LaAgABBAEF/NgLIs4CAAEEAQQAoAoC3gIAANgLMs4CAAEEAQQA2AvS2gIAAA0AgA0Hks4CAAGogA0HYs4CAAGoiBDYCACAEIANB0LOAgABqIgU2AgAgA0Hcs4CAAGogBTYCACADQeyzgIAAaiADQeCzgIAAaiIFNgIAIAUgBDYCACADQfSzgIAAaiADQeizgIAAaiIENgIAIAQgBTYCACADQfCzgIAAaiAENgIAIANBIGoiA0GAAkcNAAsgAEF4IABrQQ9xQQAgAEEIakEPcRsiA2oiBCAGIANrQUhqIgNBAXI2AgRBAEEAKAKQt4CAADYCxLOAgABBACAENgLAs4CAAEEAIAM2ArSzgIAAIAYgAGpBTGpBODYCAAwCCyADLQAMQQhxDQAgBSAESw0AIAAgBE0NACAEQXggBGtBD3FBACAEQQhqQQ9xGyIFaiIAQQAoArSzgIAAIAZqIgsgBWsiBUEBcjYCBCADIAggBmo2AgRBAEEAKAKQt4CAADYCxLOAgABBACAFNgK0s4CAAEEAIAA2AsCzgIAAIAsgBGpBBGpBODYCAAwBCwJAIABBACgCuLOAgAAiC08NAEEAIAA2ArizgIAAIAAhCwsgACAGaiEIQei2gIAAIQMCQAJAAkACQAJAAkACQANAIAMoAgAgCEYNASADKAIIIgMNAAwCCwsgAy0ADEEIcUUNAQtB6LaAgAAhAwNAAkAgAygCACIFIARLDQAgBSADKAIEaiIFIARLDQMLIAMoAgghAwwACwsgAyAANgIAIAMgAygCBCAGajYCBCAAQXggAGtBD3FBACAAQQhqQQ9xG2oiBiACQQNyNgIEIAhBeCAIa0EPcUEAIAhBCGpBD3EbaiIIIAYgAmoiAmshBQJAIAQgCEcNAEEAIAI2AsCzgIAAQQBBACgCtLOAgAAgBWoiAzYCtLOAgAAgAiADQQFyNgIEDAMLAkBBACgCvLOAgAAgCEcNAEEAIAI2AryzgIAAQQBBACgCsLOAgAAgBWoiAzYCsLOAgAAgAiADQQFyNgIEIAIgA2ogAzYCAAwDCwJAIAgoAgQiA0EDcUEBRw0AIANBeHEhBwJAAkAgA0H/AUsNACAIKAIIIgQgA0EDdiILQQN0QdCzgIAAaiIARhoCQCAIKAIMIgMgBEcNAEEAQQAoAqizgIAAQX4gC3dxNgKos4CAAAwCCyADIABGGiADIAQ2AgggBCADNgIMDAELIAgoAhghCQJAAkAgCCgCDCIAIAhGDQAgCyAIKAIIIgNLGiAAIAM2AgggAyAANgIMDAELAkAgCEEUaiIDKAIAIgQNACAIQRBqIgMoAgAiBA0AQQAhAAwBCwNAIAMhCyAEIgBBFGoiAygCACIEDQAgAEEQaiEDIAAoAhAiBA0ACyALQQA2AgALIAlFDQACQAJAIAgoAhwiBEECdEHYtYCAAGoiAygCACAIRw0AIAMgADYCACAADQFBAEEAKAKss4CAAEF+IAR3cTYCrLOAgAAMAgsgCUEQQRQgCSgCECAIRhtqIAA2AgAgAEUNAQsgACAJNgIYAkAgCCgCECIDRQ0AIAAgAzYCECADIAA2AhgLIAgoAhQiA0UNACAAQRRqIAM2AgAgAyAANgIYCyAHIAVqIQUgCCAHaiEICyAIIAgoAgRBfnE2AgQgAiAFaiAFNgIAIAIgBUEBcjYCBAJAIAVB/wFLDQAgBUEDdiIEQQN0QdCzgIAAaiEDAkACQEEAKAKos4CAACIFQQEgBHQiBHENAEEAIAUgBHI2AqizgIAAIAMhBAwBCyADKAIIIQQLIAQgAjYCDCADIAI2AgggAiADNgIMIAIgBDYCCAwDC0EfIQMCQCAFQf///wdLDQAgBUEIdiIDIANBgP4/akEQdkEIcSIDdCIEIARBgOAfakEQdkEEcSIEdCIAIABBgIAPakEQdkECcSIAdEEPdiADIARyIAByayIDQQF0IAUgA0EVanZBAXFyQRxqIQMLIAIgAzYCHCACQgA3AhAgA0ECdEHYtYCAAGohBAJAQQAoAqyzgIAAIgBBASADdCIIcQ0AIAQgAjYCAEEAIAAgCHI2AqyzgIAAIAIgBDYCGCACIAI2AgggAiACNgIMDAMLIAVBAEEZIANBAXZrIANBH0YbdCEDIAQoAgAhAANAIAAiBCgCBEF4cSAFRg0CIANBHXYhACADQQF0IQMgBCAAQQRxakEQaiIIKAIAIgANAAsgCCACNgIAIAIgBDYCGCACIAI2AgwgAiACNgIIDAILIABBeCAAa0EPcUEAIABBCGpBD3EbIgNqIgsgBiADa0FIaiIDQQFyNgIEIAhBTGpBODYCACAEIAVBNyAFa0EPcUEAIAVBSWpBD3EbakFBaiIIIAggBEEQakkbIghBIzYCBEEAQQAoApC3gIAANgLEs4CAAEEAIAs2AsCzgIAAQQAgAzYCtLOAgAAgCEEQakEAKQLwtoCAADcCACAIQQApAui2gIAANwIIQQAgCEEIajYC8LaAgABBACAGNgLstoCAAEEAIAA2Aui2gIAAQQBBADYC9LaAgAAgCEEkaiEDA0AgA0EHNgIAIAUgA0EEaiIDSw0ACyAIIARGDQMgCCAIKAIEQX5xNgIEIAggCCAEayIGNgIAIAQgBkEBcjYCBAJAIAZB/wFLDQAgBkEDdiIFQQN0QdCzgIAAaiEDAkACQEEAKAKos4CAACIAQQEgBXQiBXENAEEAIAAgBXI2AqizgIAAIAMhBQwBCyADKAIIIQULIAUgBDYCDCADIAQ2AgggBCADNgIMIAQgBTYCCAwEC0EfIQMCQCAGQf///wdLDQAgBkEIdiIDIANBgP4/akEQdkEIcSIDdCIFIAVBgOAfakEQdkEEcSIFdCIAIABBgIAPakEQdkECcSIAdEEPdiADIAVyIAByayIDQQF0IAYgA0EVanZBAXFyQRxqIQMLIARCADcCECAEQRxqIAM2AgAgA0ECdEHYtYCAAGohBQJAQQAoAqyzgIAAIgBBASADdCIIcQ0AIAUgBDYCAEEAIAAgCHI2AqyzgIAAIARBGGogBTYCACAEIAQ2AgggBCAENgIMDAQLIAZBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhAANAIAAiBSgCBEF4cSAGRg0DIANBHXYhACADQQF0IQMgBSAAQQRxakEQaiIIKAIAIgANAAsgCCAENgIAIARBGGogBTYCACAEIAQ2AgwgBCAENgIIDAMLIAQoAggiAyACNgIMIAQgAjYCCCACQQA2AhggAiAENgIMIAIgAzYCCAsgBkEIaiEDDAULIAUoAggiAyAENgIMIAUgBDYCCCAEQRhqQQA2AgAgBCAFNgIMIAQgAzYCCAtBACgCtLOAgAAiAyACTQ0AQQAoAsCzgIAAIgQgAmoiBSADIAJrIgNBAXI2AgRBACADNgK0s4CAAEEAIAU2AsCzgIAAIAQgAkEDcjYCBCAEQQhqIQMMAwtBACEDQQBBMDYCmLeAgAAMAgsCQCALRQ0AAkACQCAIIAgoAhwiBUECdEHYtYCAAGoiAygCAEcNACADIAA2AgAgAA0BQQAgB0F+IAV3cSIHNgKss4CAAAwCCyALQRBBFCALKAIQIAhGG2ogADYCACAARQ0BCyAAIAs2AhgCQCAIKAIQIgNFDQAgACADNgIQIAMgADYCGAsgCEEUaigCACIDRQ0AIABBFGogAzYCACADIAA2AhgLAkACQCAEQQ9LDQAgCCAEIAJqIgNBA3I2AgQgAyAIakEEaiIDIAMoAgBBAXI2AgAMAQsgCCACaiIAIARBAXI2AgQgCCACQQNyNgIEIAAgBGogBDYCAAJAIARB/wFLDQAgBEEDdiIEQQN0QdCzgIAAaiEDAkACQEEAKAKos4CAACIFQQEgBHQiBHENAEEAIAUgBHI2AqizgIAAIAMhBAwBCyADKAIIIQQLIAQgADYCDCADIAA2AgggACADNgIMIAAgBDYCCAwBC0EfIQMCQCAEQf///wdLDQAgBEEIdiIDIANBgP4/akEQdkEIcSIDdCIFIAVBgOAfakEQdkEEcSIFdCICIAJBgIAPakEQdkECcSICdEEPdiADIAVyIAJyayIDQQF0IAQgA0EVanZBAXFyQRxqIQMLIAAgAzYCHCAAQgA3AhAgA0ECdEHYtYCAAGohBQJAIAdBASADdCICcQ0AIAUgADYCAEEAIAcgAnI2AqyzgIAAIAAgBTYCGCAAIAA2AgggACAANgIMDAELIARBAEEZIANBAXZrIANBH0YbdCEDIAUoAgAhAgJAA0AgAiIFKAIEQXhxIARGDQEgA0EddiECIANBAXQhAyAFIAJBBHFqQRBqIgYoAgAiAg0ACyAGIAA2AgAgACAFNgIYIAAgADYCDCAAIAA2AggMAQsgBSgCCCIDIAA2AgwgBSAANgIIIABBADYCGCAAIAU2AgwgACADNgIICyAIQQhqIQMMAQsCQCAKRQ0AAkACQCAAIAAoAhwiBUECdEHYtYCAAGoiAygCAEcNACADIAg2AgAgCA0BQQAgCUF+IAV3cTYCrLOAgAAMAgsgCkEQQRQgCigCECAARhtqIAg2AgAgCEUNAQsgCCAKNgIYAkAgACgCECIDRQ0AIAggAzYCECADIAg2AhgLIABBFGooAgAiA0UNACAIQRRqIAM2AgAgAyAINgIYCwJAAkAgBEEPSw0AIAAgBCACaiIDQQNyNgIEIAMgAGpBBGoiAyADKAIAQQFyNgIADAELIAAgAmoiBSAEQQFyNgIEIAAgAkEDcjYCBCAFIARqIAQ2AgACQCAHRQ0AIAdBA3YiCEEDdEHQs4CAAGohAkEAKAK8s4CAACEDAkACQEEBIAh0IgggBnENAEEAIAggBnI2AqizgIAAIAIhCAwBCyACKAIIIQgLIAggAzYCDCACIAM2AgggAyACNgIMIAMgCDYCCAtBACAFNgK8s4CAAEEAIAQ2ArCzgIAACyAAQQhqIQMLIAFBEGokgICAgAAgAwsKACAAEL2AgIAAC/ANAQd/AkAgAEUNACAAQXhqIgEgAEF8aigCACICQXhxIgBqIQMCQCACQQFxDQAgAkEDcUUNASABIAEoAgAiAmsiAUEAKAK4s4CAACIESQ0BIAIgAGohAAJAQQAoAryzgIAAIAFGDQACQCACQf8BSw0AIAEoAggiBCACQQN2IgVBA3RB0LOAgABqIgZGGgJAIAEoAgwiAiAERw0AQQBBACgCqLOAgABBfiAFd3E2AqizgIAADAMLIAIgBkYaIAIgBDYCCCAEIAI2AgwMAgsgASgCGCEHAkACQCABKAIMIgYgAUYNACAEIAEoAggiAksaIAYgAjYCCCACIAY2AgwMAQsCQCABQRRqIgIoAgAiBA0AIAFBEGoiAigCACIEDQBBACEGDAELA0AgAiEFIAQiBkEUaiICKAIAIgQNACAGQRBqIQIgBigCECIEDQALIAVBADYCAAsgB0UNAQJAAkAgASgCHCIEQQJ0Qdi1gIAAaiICKAIAIAFHDQAgAiAGNgIAIAYNAUEAQQAoAqyzgIAAQX4gBHdxNgKss4CAAAwDCyAHQRBBFCAHKAIQIAFGG2ogBjYCACAGRQ0CCyAGIAc2AhgCQCABKAIQIgJFDQAgBiACNgIQIAIgBjYCGAsgASgCFCICRQ0BIAZBFGogAjYCACACIAY2AhgMAQsgAygCBCICQQNxQQNHDQAgAyACQX5xNgIEQQAgADYCsLOAgAAgASAAaiAANgIAIAEgAEEBcjYCBA8LIAMgAU0NACADKAIEIgJBAXFFDQACQAJAIAJBAnENAAJAQQAoAsCzgIAAIANHDQBBACABNgLAs4CAAEEAQQAoArSzgIAAIABqIgA2ArSzgIAAIAEgAEEBcjYCBCABQQAoAryzgIAARw0DQQBBADYCsLOAgABBAEEANgK8s4CAAA8LAkBBACgCvLOAgAAgA0cNAEEAIAE2AryzgIAAQQBBACgCsLOAgAAgAGoiADYCsLOAgAAgASAAQQFyNgIEIAEgAGogADYCAA8LIAJBeHEgAGohAAJAAkAgAkH/AUsNACADKAIIIgQgAkEDdiIFQQN0QdCzgIAAaiIGRhoCQCADKAIMIgIgBEcNAEEAQQAoAqizgIAAQX4gBXdxNgKos4CAAAwCCyACIAZGGiACIAQ2AgggBCACNgIMDAELIAMoAhghBwJAAkAgAygCDCIGIANGDQBBACgCuLOAgAAgAygCCCICSxogBiACNgIIIAIgBjYCDAwBCwJAIANBFGoiAigCACIEDQAgA0EQaiICKAIAIgQNAEEAIQYMAQsDQCACIQUgBCIGQRRqIgIoAgAiBA0AIAZBEGohAiAGKAIQIgQNAAsgBUEANgIACyAHRQ0AAkACQCADKAIcIgRBAnRB2LWAgABqIgIoAgAgA0cNACACIAY2AgAgBg0BQQBBACgCrLOAgABBfiAEd3E2AqyzgIAADAILIAdBEEEUIAcoAhAgA0YbaiAGNgIAIAZFDQELIAYgBzYCGAJAIAMoAhAiAkUNACAGIAI2AhAgAiAGNgIYCyADKAIUIgJFDQAgBkEUaiACNgIAIAIgBjYCGAsgASAAaiAANgIAIAEgAEEBcjYCBCABQQAoAryzgIAARw0BQQAgADYCsLOAgAAPCyADIAJBfnE2AgQgASAAaiAANgIAIAEgAEEBcjYCBAsCQCAAQf8BSw0AIABBA3YiAkEDdEHQs4CAAGohAAJAAkBBACgCqLOAgAAiBEEBIAJ0IgJxDQBBACAEIAJyNgKos4CAACAAIQIMAQsgACgCCCECCyACIAE2AgwgACABNgIIIAEgADYCDCABIAI2AggPC0EfIQICQCAAQf///wdLDQAgAEEIdiICIAJBgP4/akEQdkEIcSICdCIEIARBgOAfakEQdkEEcSIEdCIGIAZBgIAPakEQdkECcSIGdEEPdiACIARyIAZyayICQQF0IAAgAkEVanZBAXFyQRxqIQILIAFCADcCECABQRxqIAI2AgAgAkECdEHYtYCAAGohBAJAAkBBACgCrLOAgAAiBkEBIAJ0IgNxDQAgBCABNgIAQQAgBiADcjYCrLOAgAAgAUEYaiAENgIAIAEgATYCCCABIAE2AgwMAQsgAEEAQRkgAkEBdmsgAkEfRht0IQIgBCgCACEGAkADQCAGIgQoAgRBeHEgAEYNASACQR12IQYgAkEBdCECIAQgBkEEcWpBEGoiAygCACIGDQALIAMgATYCACABQRhqIAQ2AgAgASABNgIMIAEgATYCCAwBCyAEKAIIIgAgATYCDCAEIAE2AgggAUEYakEANgIAIAEgBDYCDCABIAA2AggLQQBBACgCyLOAgABBf2oiAUF/IAEbNgLIs4CAAAsLTgACQCAADQA/AEEQdA8LAkAgAEH//wNxDQAgAEF/TA0AAkAgAEEQdkAAIgBBf0cNAEEAQTA2Api3gIAAQX8PCyAAQRB0DwsQv4CAgAAACwQAAAALC64rAQBBgAgLpisBAAAAAgAAAAMAAAAEAAAABQAAAAYAAAAHAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEludmFsaWQgY2hhciBpbiB1cmwgcXVlcnkAU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl9ib2R5AENvbnRlbnQtTGVuZ3RoIG92ZXJmbG93AENodW5rIHNpemUgb3ZlcmZsb3cAUmVzcG9uc2Ugb3ZlcmZsb3cASW52YWxpZCBtZXRob2QgZm9yIEhUVFAveC54IHJlcXVlc3QASW52YWxpZCBtZXRob2QgZm9yIFJUU1AveC54IHJlcXVlc3QARXhwZWN0ZWQgU09VUkNFIG1ldGhvZCBmb3IgSUNFL3gueCByZXF1ZXN0AEludmFsaWQgY2hhciBpbiB1cmwgZnJhZ21lbnQgc3RhcnQARXhwZWN0ZWQgZG90AFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25fc3RhdHVzAEludmFsaWQgcmVzcG9uc2Ugc3RhdHVzAEludmFsaWQgY2hhcmFjdGVyIGluIGNodW5rIHBhcmFtZXRlcnMAVXNlciBjYWxsYmFjayBlcnJvcgBgb25fY2h1bmtfaGVhZGVyYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9iZWdpbmAgY2FsbGJhY2sgZXJyb3IAYG9uX2NodW5rX2NvbXBsZXRlYCBjYWxsYmFjayBlcnJvcgBgb25fbWVzc2FnZV9jb21wbGV0ZWAgY2FsbGJhY2sgZXJyb3IAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzZXJ2ZXIASW52YWxpZCBoZWFkZXIgdmFsdWUgY2hhcgBJbnZhbGlkIGhlYWRlciBmaWVsZCBjaGFyAEludmFsaWQgbWlub3IgdmVyc2lvbgBJbnZhbGlkIG1ham9yIHZlcnNpb24ARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgdmVyc2lvbgBFeHBlY3RlZCBDUkxGIGFmdGVyIHZlcnNpb24ASW52YWxpZCBoZWFkZXIgdG9rZW4AU3BhbiBjYWxsYmFjayBlcnJvciBpbiBvbl91cmwASW52YWxpZCBjaGFyYWN0ZXJzIGluIHVybABVbmV4cGVjdGVkIHN0YXJ0IGNoYXIgaW4gdXJsAERvdWJsZSBAIGluIHVybABFbXB0eSBDb250ZW50LUxlbmd0aABJbnZhbGlkIGNoYXJhY3RlciBpbiBDb250ZW50LUxlbmd0aABEdXBsaWNhdGUgQ29udGVudC1MZW5ndGgASW52YWxpZCBjaGFyIGluIHVybCBwYXRoAENvbnRlbnQtTGVuZ3RoIGNhbid0IGJlIHByZXNlbnQgd2l0aCBUcmFuc2Zlci1FbmNvZGluZwBJbnZhbGlkIGNoYXJhY3RlciBpbiBjaHVuayBzaXplAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX3ZhbHVlAE1pc3NpbmcgZXhwZWN0ZWQgTEYgYWZ0ZXIgaGVhZGVyIHZhbHVlAFBhdXNlZCBieSBvbl9oZWFkZXJzX2NvbXBsZXRlAEludmFsaWQgRU9GIHN0YXRlAG9uX2NodW5rX2hlYWRlciBwYXVzZQBvbl9tZXNzYWdlX2JlZ2luIHBhdXNlAG9uX2NodW5rX2NvbXBsZXRlIHBhdXNlAG9uX21lc3NhZ2VfY29tcGxldGUgcGF1c2UAUGF1c2Ugb24gQ09OTkVDVC9VcGdyYWRlAFBhdXNlIG9uIFBSSS9VcGdyYWRlAEV4cGVjdGVkIEhUVFAvMiBDb25uZWN0aW9uIFByZWZhY2UARXhwZWN0ZWQgc3BhY2UgYWZ0ZXIgbWV0aG9kAFNwYW4gY2FsbGJhY2sgZXJyb3IgaW4gb25faGVhZGVyX2ZpZWxkAFBhdXNlZABJbnZhbGlkIHdvcmQgZW5jb3VudGVyZWQASW52YWxpZCBtZXRob2QgZW5jb3VudGVyZWQAVW5leHBlY3RlZCBjaGFyIGluIHVybCBzY2hlbWEAUmVxdWVzdCBoYXMgaW52YWxpZCBgVHJhbnNmZXItRW5jb2RpbmdgAE1LQUNUSVZJVFkAQ09QWQBOT1RJRlkAUExBWQBQVVQAQ0hFQ0tPVVQAUE9TVABSRVBPUlQASFBFX0lOVkFMSURfQ09OU1RBTlQAR0VUAEhQRV9TVFJJQ1QAUkVESVJFQ1QAQ09OTkVDVABIUEVfSU5WQUxJRF9TVEFUVVMAT1BUSU9OUwBTRVRfUEFSQU1FVEVSAEdFVF9QQVJBTUVURVIASFBFX1VTRVIASFBFX0NCX0NIVU5LX0hFQURFUgBNS0NBTEVOREFSAFNFVFVQAFRFQVJET1dOAEhQRV9DTE9TRURfQ09OTkVDVElPTgBIUEVfSU5WQUxJRF9WRVJTSU9OAEhQRV9DQl9NRVNTQUdFX0JFR0lOAEhQRV9JTlZBTElEX0hFQURFUl9UT0tFTgBIUEVfSU5WQUxJRF9VUkwATUtDT0wAQUNMAEhQRV9JTlRFUk5BTABIUEVfT0sAVU5MSU5LAFVOTE9DSwBQUkkASFBFX0lOVkFMSURfQ09OVEVOVF9MRU5HVEgASFBFX1VORVhQRUNURURfQ09OVEVOVF9MRU5HVEgARkxVU0gAUFJPUFBBVENIAE0tU0VBUkNIAEhQRV9JTlZBTElEX1RSQU5TRkVSX0VOQ09ESU5HAEV4cGVjdGVkIENSTEYASFBFX0lOVkFMSURfQ0hVTktfU0laRQBNT1ZFAEhQRV9DQl9IRUFERVJTX0NPTVBMRVRFAEhQRV9DQl9DSFVOS19DT01QTEVURQBIUEVfQ0JfTUVTU0FHRV9DT01QTEVURQBERUxFVEUASFBFX0lOVkFMSURfRU9GX1NUQVRFAFBBVVNFAFBVUkdFAE1FUkdFAEhQRV9QQVVTRURfVVBHUkFERQBIUEVfUEFVU0VEX0gyX1VQR1JBREUAU09VUkNFAEFOTk9VTkNFAFRSQUNFAERFU0NSSUJFAFVOU1VCU0NSSUJFAFJFQ09SRABIUEVfSU5WQUxJRF9NRVRIT0QAUFJPUEZJTkQAVU5CSU5EAFJFQklORABIUEVfTEZfRVhQRUNURUQASFBFX1BBVVNFRABIRUFEAEV4cGVjdGVkIEhUVFAvAIwLAAB/CwAAgwoAADkNAADACwAADQsAAA8NAABlCwAAagoAACMLAABMCwAApQsAACMMAACfCgAAjAwAAPcLAAA3CwAAPwwAAG0MAADfCgAAVwwAAEkNAAC0DAAAxwwAANYKAACFDAAAfwoAAFQNAABeCgAAUQoAAJcKAACyCgAA7QwAAEAKAACcCwAAdQsAADoMAAAiDQAA5AsAAPALAACaCwAANA0AADINAAArDQAAewsAAGMKAAA1CgAAVQoAAK4MAADuCwAARQoAAP4MAAD8DAAA6AsAAKgMAADzCgAAlQsAAJMLAADdDAAAoQsAAPMMAADkDAAA/goAAEwKAACiDAAABAsAAMgKAAC6CgAAjgoAAAgNAADeCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAIAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAWxvc2VlZXAtYWxpdmUAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAQEBAQEBAQEBAQECAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAWNodW5rZWQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEBAAEBAQEBAAABAQABAQABAQEBAQEBAQEBAAAAAAAAAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAZWN0aW9uZW50LWxlbmd0aG9ucm94eS1jb25uZWN0aW9uAAAAAAAAAAAAAAAAAAAAcmFuc2Zlci1lbmNvZGluZ3BncmFkZQ0KDQoNClNNDQoNClRUUC9DRS9UU1AvAAAAAAAAAAAAAAAAAQIAAQMAAAAAAAAAAAAAAAAAAAAAAAAEAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQAAAAAAAAAAAAECAAEDAAAAAAAAAAAAAAAAAAAAAAAABAEBBQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAAABAQABAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAAAAAAAAAAAAAAEAAAIAAAAAAAAAAAAAAAAAAAAAAAADBAAABAQEBAQEBAQEBAQFBAQEBAQEBAQEBAQEAAQABgcEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQABAAEAAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEBAQEAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAABAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAADAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAQAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAACAAAAAAIAAAAAAAAAAAAAAAAAAAAAAAMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAAAAAAAAAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAATk9VTkNFRUNLT1VUTkVDVEVURUNSSUJFTFVTSEVURUFEU0VBUkNIUkdFQ1RJVklUWUxFTkRBUlZFT1RJRllQVElPTlNDSFNFQVlTVEFUQ0hHRU9SRElSRUNUT1JUUkNIUEFSQU1FVEVSVVJDRUJTQ1JJQkVBUkRPV05BQ0VJTkROS0NLVUJTQ1JJQkVIVFRQL0FEVFAv';
var assert$7 = import_assert.default;
var net = import_net.default;
var util$b = util$h;
var Request$3 = request$2;
var DispatcherBase$2 = dispatcherBase;
var RedirectHandler$1 = redirect;
var {
	RequestContentLengthMismatchError,
	ResponseContentLengthMismatchError,
	InvalidArgumentError: InvalidArgumentError$9,
	RequestAbortedError: RequestAbortedError$7,
	HeadersTimeoutError,
	HeadersOverflowError,
	SocketError: SocketError$2,
	InformationalError,
	BodyTimeoutError,
	HTTPParserError
} = errors$1;
var buildConnector$1 = connect$2;
var {
	kUrl: kUrl$2,
	kReset,
	kServerName,
	kClient,
	kBusy: kBusy$1,
	kParser,
	kConnect,
	kBlocking,
	kResuming,
	kRunning: kRunning$3,
	kPending: kPending$2,
	kSize: kSize$4,
	kWriting,
	kQueue: kQueue$1,
	kConnected: kConnected$3,
	kConnecting,
	kNeedDrain: kNeedDrain$2,
	kNoRef,
	kKeepAliveDefaultTimeout,
	kHostHeader,
	kPendingIdx,
	kRunningIdx,
	kError,
	kPipelining,
	kSocket,
	kKeepAliveTimeoutValue,
	kMaxHeadersSize,
	kKeepAliveMaxTimeout,
	kKeepAliveTimeoutThreshold,
	kHeadersTimeout,
	kBodyTimeout,
	kStrictContentLength,
	kConnector,
	kMaxRedirections: kMaxRedirections$1,
	kMaxRequests,
	kCounter,
	kClose: kClose$2,
	kDestroy: kDestroy$2,
	kDispatch: kDispatch$2
} = symbols$1;
var kClosedResolve$1 = Symbol('kClosedResolve');
var channels = {};
try {
	const diagnosticsChannel = require('diagnostics_channel');
	channels.sendHeaders = diagnosticsChannel.channel('undici:client:sendHeaders');
	channels.beforeConnect = diagnosticsChannel.channel('undici:client:beforeConnect');
	channels.connectError = diagnosticsChannel.channel('undici:client:connectError');
	channels.connected = diagnosticsChannel.channel('undici:client:connected');
} catch {
	channels.sendHeaders = { hasSubscribers: false };
	channels.beforeConnect = { hasSubscribers: false };
	channels.connectError = { hasSubscribers: false };
	channels.connected = { hasSubscribers: false };
}
var Client$2 = class extends DispatcherBase$2 {
	constructor(
		url,
		{
			maxHeaderSize,
			headersTimeout,
			socketTimeout,
			requestTimeout,
			connectTimeout,
			bodyTimeout,
			idleTimeout,
			keepAlive,
			keepAliveTimeout,
			maxKeepAliveTimeout,
			keepAliveMaxTimeout,
			keepAliveTimeoutThreshold,
			socketPath,
			pipelining,
			tls: tls2,
			strictContentLength,
			maxCachedSessions,
			maxRedirections,
			connect: connect2,
			maxRequestsPerClient
		} = {}
	) {
		super();
		if (keepAlive !== void 0) {
			throw new InvalidArgumentError$9('unsupported keepAlive, use pipelining=0 instead');
		}
		if (socketTimeout !== void 0) {
			throw new InvalidArgumentError$9(
				'unsupported socketTimeout, use headersTimeout & bodyTimeout instead'
			);
		}
		if (requestTimeout !== void 0) {
			throw new InvalidArgumentError$9(
				'unsupported requestTimeout, use headersTimeout & bodyTimeout instead'
			);
		}
		if (idleTimeout !== void 0) {
			throw new InvalidArgumentError$9('unsupported idleTimeout, use keepAliveTimeout instead');
		}
		if (maxKeepAliveTimeout !== void 0) {
			throw new InvalidArgumentError$9(
				'unsupported maxKeepAliveTimeout, use keepAliveMaxTimeout instead'
			);
		}
		if (maxHeaderSize != null && !Number.isFinite(maxHeaderSize)) {
			throw new InvalidArgumentError$9('invalid maxHeaderSize');
		}
		if (socketPath != null && typeof socketPath !== 'string') {
			throw new InvalidArgumentError$9('invalid socketPath');
		}
		if (connectTimeout != null && (!Number.isFinite(connectTimeout) || connectTimeout < 0)) {
			throw new InvalidArgumentError$9('invalid connectTimeout');
		}
		if (keepAliveTimeout != null && (!Number.isFinite(keepAliveTimeout) || keepAliveTimeout <= 0)) {
			throw new InvalidArgumentError$9('invalid keepAliveTimeout');
		}
		if (
			keepAliveMaxTimeout != null &&
			(!Number.isFinite(keepAliveMaxTimeout) || keepAliveMaxTimeout <= 0)
		) {
			throw new InvalidArgumentError$9('invalid keepAliveMaxTimeout');
		}
		if (keepAliveTimeoutThreshold != null && !Number.isFinite(keepAliveTimeoutThreshold)) {
			throw new InvalidArgumentError$9('invalid keepAliveTimeoutThreshold');
		}
		if (headersTimeout != null && (!Number.isInteger(headersTimeout) || headersTimeout < 0)) {
			throw new InvalidArgumentError$9('headersTimeout must be a positive integer or zero');
		}
		if (bodyTimeout != null && (!Number.isInteger(bodyTimeout) || bodyTimeout < 0)) {
			throw new InvalidArgumentError$9('bodyTimeout must be a positive integer or zero');
		}
		if (connect2 != null && typeof connect2 !== 'function' && typeof connect2 !== 'object') {
			throw new InvalidArgumentError$9('connect must be a function or an object');
		}
		if (maxRedirections != null && (!Number.isInteger(maxRedirections) || maxRedirections < 0)) {
			throw new InvalidArgumentError$9('maxRedirections must be a positive number');
		}
		if (
			maxRequestsPerClient != null &&
			(!Number.isInteger(maxRequestsPerClient) || maxRequestsPerClient < 0)
		) {
			throw new InvalidArgumentError$9('maxRequestsPerClient must be a positive number');
		}
		if (typeof connect2 !== 'function') {
			connect2 = buildConnector$1({
				...tls2,
				maxCachedSessions,
				socketPath,
				timeout: connectTimeout,
				...connect2
			});
		}
		this[kUrl$2] = util$b.parseOrigin(url);
		this[kConnector] = connect2;
		this[kSocket] = null;
		this[kPipelining] = pipelining != null ? pipelining : 1;
		this[kMaxHeadersSize] = maxHeaderSize || 16384;
		this[kKeepAliveDefaultTimeout] = keepAliveTimeout == null ? 4e3 : keepAliveTimeout;
		this[kKeepAliveMaxTimeout] = keepAliveMaxTimeout == null ? 6e5 : keepAliveMaxTimeout;
		this[kKeepAliveTimeoutThreshold] =
			keepAliveTimeoutThreshold == null ? 1e3 : keepAliveTimeoutThreshold;
		this[kKeepAliveTimeoutValue] = this[kKeepAliveDefaultTimeout];
		this[kServerName] = null;
		this[kResuming] = 0;
		this[kNeedDrain$2] = 0;
		this[kHostHeader] = `host: ${this[kUrl$2].hostname}${
			this[kUrl$2].port ? `:${this[kUrl$2].port}` : ''
		}\r
`;
		this[kBodyTimeout] = bodyTimeout != null ? bodyTimeout : 3e4;
		this[kHeadersTimeout] = headersTimeout != null ? headersTimeout : 3e4;
		this[kStrictContentLength] = strictContentLength == null ? true : strictContentLength;
		this[kMaxRedirections$1] = maxRedirections;
		this[kMaxRequests] = maxRequestsPerClient;
		this[kClosedResolve$1] = null;
		this[kQueue$1] = [];
		this[kRunningIdx] = 0;
		this[kPendingIdx] = 0;
	}
	get pipelining() {
		return this[kPipelining];
	}
	set pipelining(value) {
		this[kPipelining] = value;
		resume(this, true);
	}
	get [kPending$2]() {
		return this[kQueue$1].length - this[kPendingIdx];
	}
	get [kRunning$3]() {
		return this[kPendingIdx] - this[kRunningIdx];
	}
	get [kSize$4]() {
		return this[kQueue$1].length - this[kRunningIdx];
	}
	get [kConnected$3]() {
		return !!this[kSocket] && !this[kConnecting] && !this[kSocket].destroyed;
	}
	get [kBusy$1]() {
		const socket = this[kSocket];
		return (
			(socket && (socket[kReset] || socket[kWriting] || socket[kBlocking])) ||
			this[kSize$4] >= (this[kPipelining] || 1) ||
			this[kPending$2] > 0
		);
	}
	[kConnect](cb) {
		connect$1(this);
		this.once('connect', cb);
	}
	[kDispatch$2](opts, handler) {
		const { maxRedirections = this[kMaxRedirections$1] } = opts;
		if (maxRedirections) {
			handler = new RedirectHandler$1(this, maxRedirections, opts, handler);
		}
		const origin = opts.origin || this[kUrl$2].origin;
		const request2 = new Request$3(origin, opts, handler);
		this[kQueue$1].push(request2);
		if (this[kResuming]);
		else if (util$b.bodyLength(request2.body) == null && util$b.isIterable(request2.body)) {
			this[kResuming] = 1;
			process.nextTick(resume, this);
		} else {
			resume(this, true);
		}
		if (this[kResuming] && this[kNeedDrain$2] !== 2 && this[kBusy$1]) {
			this[kNeedDrain$2] = 2;
		}
		return this[kNeedDrain$2] < 2;
	}
	async [kClose$2]() {
		return new Promise((resolve2) => {
			if (!this[kSize$4]) {
				this.destroy(resolve2);
			} else {
				this[kClosedResolve$1] = resolve2;
			}
		});
	}
	async [kDestroy$2](err) {
		return new Promise((resolve2) => {
			const requests = this[kQueue$1].splice(this[kPendingIdx]);
			for (let i2 = 0; i2 < requests.length; i2++) {
				const request2 = requests[i2];
				errorRequest(this, request2, err);
			}
			const callback = () => {
				if (this[kClosedResolve$1]) {
					this[kClosedResolve$1]();
					this[kClosedResolve$1] = null;
				}
				resolve2();
			};
			if (!this[kSocket]) {
				queueMicrotask(callback);
			} else {
				util$b.destroy(this[kSocket].on('close', callback), err);
			}
			resume(this);
		});
	}
};
var constants = constants$1;
var EMPTY_BUF = Buffer.alloc(0);
async function lazyllhttp() {
	const llhttpWasmData = process.env.JEST_WORKER_ID ? llhttp_wasm : void 0;
	let mod;
	try {
		mod = await WebAssembly.compile(Buffer.from(require('./llhttp/llhttp_simd.wasm.js'), 'base64'));
	} catch (e2) {
		mod = await WebAssembly.compile(Buffer.from(llhttpWasmData || llhttp_wasm, 'base64'));
	}
	return await WebAssembly.instantiate(mod, {
		env: {
			wasm_on_url: (p2, at, len) => {
				return 0;
			},
			wasm_on_status: (p2, at, len) => {
				assert$7.strictEqual(currentParser.ptr, p2);
				const start = at - currentBufferPtr;
				const end = start + len;
				return currentParser.onStatus(currentBufferRef.slice(start, end)) || 0;
			},
			wasm_on_message_begin: (p2) => {
				assert$7.strictEqual(currentParser.ptr, p2);
				return currentParser.onMessageBegin() || 0;
			},
			wasm_on_header_field: (p2, at, len) => {
				assert$7.strictEqual(currentParser.ptr, p2);
				const start = at - currentBufferPtr;
				const end = start + len;
				return currentParser.onHeaderField(currentBufferRef.slice(start, end)) || 0;
			},
			wasm_on_header_value: (p2, at, len) => {
				assert$7.strictEqual(currentParser.ptr, p2);
				const start = at - currentBufferPtr;
				const end = start + len;
				return currentParser.onHeaderValue(currentBufferRef.slice(start, end)) || 0;
			},
			wasm_on_headers_complete: (p2, statusCode, upgrade2, shouldKeepAlive) => {
				assert$7.strictEqual(currentParser.ptr, p2);
				return (
					currentParser.onHeadersComplete(
						statusCode,
						Boolean(upgrade2),
						Boolean(shouldKeepAlive)
					) || 0
				);
			},
			wasm_on_body: (p2, at, len) => {
				assert$7.strictEqual(currentParser.ptr, p2);
				const start = at - currentBufferPtr;
				const end = start + len;
				return currentParser.onBody(currentBufferRef.slice(start, end)) || 0;
			},
			wasm_on_message_complete: (p2) => {
				assert$7.strictEqual(currentParser.ptr, p2);
				return currentParser.onMessageComplete() || 0;
			}
		}
	});
}
var llhttpInstance = null;
var llhttpPromise = lazyllhttp().catch(() => {});
var currentParser = null;
var currentBufferRef = null;
var currentBufferSize = 0;
var currentBufferPtr = null;
var TIMEOUT_HEADERS = 1;
var TIMEOUT_BODY = 2;
var TIMEOUT_IDLE = 3;
var Parser = class {
	constructor(client2, socket, { exports }) {
		assert$7(Number.isFinite(client2[kMaxHeadersSize]) && client2[kMaxHeadersSize] > 0);
		this.llhttp = exports;
		this.ptr = this.llhttp.llhttp_alloc(constants.TYPE.RESPONSE);
		this.client = client2;
		this.socket = socket;
		this.timeout = null;
		this.timeoutValue = null;
		this.timeoutType = null;
		this.statusCode = null;
		this.statusText = '';
		this.upgrade = false;
		this.headers = [];
		this.headersSize = 0;
		this.headersMaxSize = client2[kMaxHeadersSize];
		this.shouldKeepAlive = false;
		this.paused = false;
		this.resume = this.resume.bind(this);
		this.bytesRead = 0;
		this.keepAlive = '';
		this.contentLength = '';
	}
	setTimeout(value, type) {
		this.timeoutType = type;
		if (value !== this.timeoutValue) {
			clearTimeout(this.timeout);
			if (value) {
				this.timeout = setTimeout(onParserTimeout, value, this);
				if (this.timeout.unref) {
					this.timeout.unref();
				}
			} else {
				this.timeout = null;
			}
			this.timeoutValue = value;
		} else if (this.timeout) {
			if (this.timeout.refresh) {
				this.timeout.refresh();
			}
		}
	}
	resume() {
		if (this.socket.destroyed || !this.paused) {
			return;
		}
		assert$7(this.ptr != null);
		assert$7(currentParser == null);
		this.llhttp.llhttp_resume(this.ptr);
		assert$7(this.timeoutType === TIMEOUT_BODY);
		if (this.timeout) {
			if (this.timeout.refresh) {
				this.timeout.refresh();
			}
		}
		this.paused = false;
		this.execute(this.socket.read() || EMPTY_BUF);
		this.readMore();
	}
	readMore() {
		while (!this.paused && this.ptr) {
			const chunk = this.socket.read();
			if (chunk === null) {
				break;
			}
			this.execute(chunk);
		}
	}
	execute(data2) {
		assert$7(this.ptr != null);
		assert$7(currentParser == null);
		assert$7(!this.paused);
		const { socket, llhttp } = this;
		if (data2.length > currentBufferSize) {
			if (currentBufferPtr) {
				llhttp.free(currentBufferPtr);
			}
			currentBufferSize = Math.ceil(data2.length / 4096) * 4096;
			currentBufferPtr = llhttp.malloc(currentBufferSize);
		}
		new Uint8Array(llhttp.memory.buffer, currentBufferPtr, currentBufferSize).set(data2);
		try {
			let ret;
			try {
				currentBufferRef = data2;
				currentParser = this;
				ret = llhttp.llhttp_execute(this.ptr, currentBufferPtr, data2.length);
			} catch (err) {
				throw err;
			} finally {
				currentParser = null;
				currentBufferRef = null;
			}
			const offset = llhttp.llhttp_get_error_pos(this.ptr) - currentBufferPtr;
			if (ret === constants.ERROR.PAUSED_UPGRADE) {
				this.onUpgrade(data2.slice(offset));
			} else if (ret === constants.ERROR.PAUSED) {
				this.paused = true;
				socket.unshift(data2.slice(offset));
			} else if (ret !== constants.ERROR.OK) {
				const ptr = llhttp.llhttp_get_error_reason(this.ptr);
				let message = '';
				if (ptr) {
					const len = new Uint8Array(llhttp.memory.buffer, ptr).indexOf(0);
					message = Buffer.from(llhttp.memory.buffer, ptr, len).toString();
				}
				throw new HTTPParserError(message, constants.ERROR[ret], data2.slice(offset));
			}
		} catch (err) {
			util$b.destroy(socket, err);
		}
	}
	finish() {
		try {
			try {
				currentParser = this;
			} finally {
				currentParser = null;
			}
		} catch (err) {
			util$b.destroy(this.socket, err);
		}
	}
	destroy() {
		assert$7(this.ptr != null);
		assert$7(currentParser == null);
		this.llhttp.llhttp_free(this.ptr);
		this.ptr = null;
		clearTimeout(this.timeout);
		this.timeout = null;
		this.timeoutValue = null;
		this.timeoutType = null;
		this.paused = false;
	}
	onStatus(buf) {
		this.statusText = buf.toString();
	}
	onMessageBegin() {
		const { socket, client: client2 } = this;
		if (socket.destroyed) {
			return -1;
		}
		const request2 = client2[kQueue$1][client2[kRunningIdx]];
		if (!request2) {
			return -1;
		}
	}
	onHeaderField(buf) {
		const len = this.headers.length;
		if ((len & 1) === 0) {
			this.headers.push(buf);
		} else {
			this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
		}
		this.trackHeader(buf.length);
	}
	onHeaderValue(buf) {
		let len = this.headers.length;
		if ((len & 1) === 1) {
			this.headers.push(buf);
			len += 1;
		} else {
			this.headers[len - 1] = Buffer.concat([this.headers[len - 1], buf]);
		}
		const key3 = this.headers[len - 2];
		if (key3.length === 10 && key3.toString().toLowerCase() === 'keep-alive') {
			this.keepAlive += buf.toString();
		} else if (key3.length === 14 && key3.toString().toLowerCase() === 'content-length') {
			this.contentLength += buf.toString();
		}
		this.trackHeader(buf.length);
	}
	trackHeader(len) {
		this.headersSize += len;
		if (this.headersSize >= this.headersMaxSize) {
			util$b.destroy(this.socket, new HeadersOverflowError());
		}
	}
	onUpgrade(head2) {
		const { upgrade: upgrade2, client: client2, socket, headers: headers2, statusCode } = this;
		assert$7(upgrade2);
		const request2 = client2[kQueue$1][client2[kRunningIdx]];
		assert$7(request2);
		assert$7(!socket.destroyed);
		assert$7(socket === client2[kSocket]);
		assert$7(!this.paused);
		assert$7(request2.upgrade || request2.method === 'CONNECT');
		this.statusCode = null;
		this.statusText = '';
		this.shouldKeepAlive = null;
		assert$7(this.headers.length % 2 === 0);
		this.headers = [];
		this.headersSize = 0;
		socket.unshift(head2);
		socket[kParser].destroy();
		socket[kParser] = null;
		socket[kClient] = null;
		socket[kError] = null;
		socket
			.removeListener('error', onSocketError)
			.removeListener('readable', onSocketReadable)
			.removeListener('end', onSocketEnd)
			.removeListener('close', onSocketClose);
		client2[kSocket] = null;
		client2[kQueue$1][client2[kRunningIdx]++] = null;
		client2.emit('disconnect', client2[kUrl$2], [client2], new InformationalError('upgrade'));
		try {
			request2.onUpgrade(statusCode, headers2, socket);
		} catch (err) {
			util$b.destroy(socket, err);
		}
		resume(client2);
	}
	onHeadersComplete(statusCode, upgrade2, shouldKeepAlive) {
		const { client: client2, socket, headers: headers2, statusText } = this;
		if (socket.destroyed) {
			return -1;
		}
		const request2 = client2[kQueue$1][client2[kRunningIdx]];
		if (!request2) {
			return -1;
		}
		assert$7(!this.upgrade);
		assert$7(this.statusCode < 200);
		if (statusCode === 100) {
			util$b.destroy(socket, new SocketError$2('bad response', util$b.getSocketInfo(socket)));
			return -1;
		}
		if (upgrade2 && !request2.upgrade) {
			util$b.destroy(socket, new SocketError$2('bad upgrade', util$b.getSocketInfo(socket)));
			return -1;
		}
		assert$7.strictEqual(this.timeoutType, TIMEOUT_HEADERS);
		this.statusCode = statusCode;
		this.shouldKeepAlive = shouldKeepAlive;
		if (this.statusCode >= 200) {
			const bodyTimeout =
				request2.bodyTimeout != null ? request2.bodyTimeout : client2[kBodyTimeout];
			this.setTimeout(bodyTimeout, TIMEOUT_BODY);
		} else if (this.timeout) {
			if (this.timeout.refresh) {
				this.timeout.refresh();
			}
		}
		if (request2.method === 'CONNECT' && statusCode >= 200 && statusCode < 300) {
			assert$7(client2[kRunning$3] === 1);
			this.upgrade = true;
			return 2;
		}
		if (upgrade2) {
			assert$7(client2[kRunning$3] === 1);
			this.upgrade = true;
			return 2;
		}
		assert$7(this.headers.length % 2 === 0);
		this.headers = [];
		this.headersSize = 0;
		if (shouldKeepAlive && client2[kPipelining]) {
			const keepAliveTimeout = this.keepAlive ? util$b.parseKeepAliveTimeout(this.keepAlive) : null;
			if (keepAliveTimeout != null) {
				const timeout = Math.min(
					keepAliveTimeout - client2[kKeepAliveTimeoutThreshold],
					client2[kKeepAliveMaxTimeout]
				);
				if (timeout <= 0) {
					socket[kReset] = true;
				} else {
					client2[kKeepAliveTimeoutValue] = timeout;
				}
			} else {
				client2[kKeepAliveTimeoutValue] = client2[kKeepAliveDefaultTimeout];
			}
		} else {
			socket[kReset] = true;
		}
		let pause;
		try {
			pause = request2.onHeaders(statusCode, headers2, this.resume, statusText) === false;
		} catch (err) {
			util$b.destroy(socket, err);
			return -1;
		}
		if (request2.method === 'HEAD') {
			assert$7(socket[kReset]);
			return 1;
		}
		if (statusCode < 200) {
			return 1;
		}
		if (socket[kBlocking]) {
			socket[kBlocking] = false;
			resume(client2);
		}
		return pause ? constants.ERROR.PAUSED : 0;
	}
	onBody(buf) {
		const { client: client2, socket, statusCode } = this;
		if (socket.destroyed) {
			return -1;
		}
		const request2 = client2[kQueue$1][client2[kRunningIdx]];
		assert$7(request2);
		assert$7.strictEqual(this.timeoutType, TIMEOUT_BODY);
		if (this.timeout) {
			if (this.timeout.refresh) {
				this.timeout.refresh();
			}
		}
		assert$7(statusCode >= 200);
		this.bytesRead += buf.length;
		try {
			if (request2.onData(buf) === false) {
				return constants.ERROR.PAUSED;
			}
		} catch (err) {
			util$b.destroy(socket, err);
			return -1;
		}
	}
	onMessageComplete() {
		const {
			client: client2,
			socket,
			statusCode,
			upgrade: upgrade2,
			headers: headers2,
			contentLength,
			bytesRead,
			shouldKeepAlive
		} = this;
		if (socket.destroyed && (!statusCode || shouldKeepAlive)) {
			return -1;
		}
		if (upgrade2) {
			return;
		}
		const request2 = client2[kQueue$1][client2[kRunningIdx]];
		assert$7(request2);
		assert$7(statusCode >= 100);
		this.statusCode = null;
		this.statusText = '';
		this.bytesRead = 0;
		this.contentLength = '';
		this.keepAlive = '';
		assert$7(this.headers.length % 2 === 0);
		this.headers = [];
		this.headersSize = 0;
		if (statusCode < 200) {
			return;
		}
		if (request2.method !== 'HEAD' && contentLength && bytesRead !== parseInt(contentLength, 10)) {
			util$b.destroy(socket, new ResponseContentLengthMismatchError());
			return -1;
		}
		try {
			request2.onComplete(headers2);
		} catch (err) {
			errorRequest(client2, request2, err);
		}
		client2[kQueue$1][client2[kRunningIdx]++] = null;
		if (socket[kWriting]) {
			assert$7.strictEqual(client2[kRunning$3], 0);
			util$b.destroy(socket, new InformationalError('reset'));
			return constants.ERROR.PAUSED;
		} else if (!shouldKeepAlive) {
			util$b.destroy(socket, new InformationalError('reset'));
			return constants.ERROR.PAUSED;
		} else if (socket[kReset] && client2[kRunning$3] === 0) {
			util$b.destroy(socket, new InformationalError('reset'));
			return constants.ERROR.PAUSED;
		} else if (client2[kPipelining] === 1) {
			setImmediate(resume, client2);
		} else {
			resume(client2);
		}
	}
};
function onParserTimeout(parser) {
	const { socket, timeoutType, client: client2 } = parser;
	if (timeoutType === TIMEOUT_HEADERS) {
		if (!socket[kWriting]) {
			assert$7(!parser.paused, 'cannot be paused while waiting for headers');
			util$b.destroy(socket, new HeadersTimeoutError());
		}
	} else if (timeoutType === TIMEOUT_BODY) {
		if (!parser.paused) {
			util$b.destroy(socket, new BodyTimeoutError());
		}
	} else if (timeoutType === TIMEOUT_IDLE) {
		assert$7(client2[kRunning$3] === 0 && client2[kKeepAliveTimeoutValue]);
		util$b.destroy(socket, new InformationalError('socket idle timeout'));
	}
}
function onSocketReadable() {
	const { [kParser]: parser } = this;
	parser.readMore();
}
function onSocketError(err) {
	const { [kParser]: parser } = this;
	assert$7(err.code !== 'ERR_TLS_CERT_ALTNAME_INVALID');
	if (err.code === 'ECONNRESET' && parser.statusCode && !parser.shouldKeepAlive) {
		parser.finish();
		return;
	}
	this[kError] = err;
	onError(this[kClient], err);
}
function onError(client2, err) {
	if (client2[kRunning$3] === 0 && err.code !== 'UND_ERR_INFO' && err.code !== 'UND_ERR_SOCKET') {
		assert$7(client2[kPendingIdx] === client2[kRunningIdx]);
		const requests = client2[kQueue$1].splice(client2[kRunningIdx]);
		for (let i2 = 0; i2 < requests.length; i2++) {
			const request2 = requests[i2];
			errorRequest(client2, request2, err);
		}
		assert$7(client2[kSize$4] === 0);
	}
}
function onSocketEnd() {
	const { [kParser]: parser } = this;
	if (parser.statusCode && !parser.shouldKeepAlive) {
		parser.finish();
		return;
	}
	util$b.destroy(this, new SocketError$2('other side closed', util$b.getSocketInfo(this)));
}
function onSocketClose() {
	const { [kClient]: client2 } = this;
	this[kParser].destroy();
	this[kParser] = null;
	const err = this[kError] || new SocketError$2('closed', util$b.getSocketInfo(this));
	client2[kSocket] = null;
	if (client2.destroyed) {
		assert$7(client2[kPending$2] === 0);
		const requests = client2[kQueue$1].splice(client2[kRunningIdx]);
		for (let i2 = 0; i2 < requests.length; i2++) {
			const request2 = requests[i2];
			errorRequest(client2, request2, err);
		}
	} else if (client2[kRunning$3] > 0 && err.code !== 'UND_ERR_INFO') {
		const request2 = client2[kQueue$1][client2[kRunningIdx]];
		client2[kQueue$1][client2[kRunningIdx]++] = null;
		errorRequest(client2, request2, err);
	}
	client2[kPendingIdx] = client2[kRunningIdx];
	assert$7(client2[kRunning$3] === 0);
	client2.emit('disconnect', client2[kUrl$2], [client2], err);
	resume(client2);
}
async function connect$1(client2) {
	assert$7(!client2[kConnecting]);
	assert$7(!client2[kSocket]);
	let { host, hostname, protocol, port } = client2[kUrl$2];
	if (hostname[0] === '[') {
		const idx = hostname.indexOf(']');
		assert$7(idx !== -1);
		const ip = hostname.substr(1, idx - 1);
		assert$7(net.isIP(ip));
		hostname = ip;
	}
	client2[kConnecting] = true;
	if (channels.beforeConnect.hasSubscribers) {
		channels.beforeConnect.publish({
			connectParams: {
				host,
				hostname,
				protocol,
				port,
				servername: client2[kServerName]
			},
			connector: client2[kConnector]
		});
	}
	try {
		const socket = await new Promise((resolve2, reject) => {
			client2[kConnector](
				{
					host,
					hostname,
					protocol,
					port,
					servername: client2[kServerName]
				},
				(err, socket2) => {
					if (err) {
						reject(err);
					} else {
						resolve2(socket2);
					}
				}
			);
		});
		if (!llhttpInstance) {
			llhttpInstance = await llhttpPromise;
			llhttpPromise = null;
		}
		client2[kConnecting] = false;
		assert$7(socket);
		client2[kSocket] = socket;
		socket[kNoRef] = false;
		socket[kWriting] = false;
		socket[kReset] = false;
		socket[kBlocking] = false;
		socket[kError] = null;
		socket[kParser] = new Parser(client2, socket, llhttpInstance);
		socket[kClient] = client2;
		socket[kCounter] = 0;
		socket[kMaxRequests] = client2[kMaxRequests];
		socket
			.on('error', onSocketError)
			.on('readable', onSocketReadable)
			.on('end', onSocketEnd)
			.on('close', onSocketClose);
		if (channels.connected.hasSubscribers) {
			channels.connected.publish({
				connectParams: {
					host,
					hostname,
					protocol,
					port,
					servername: client2[kServerName]
				},
				connector: client2[kConnector],
				socket
			});
		}
		client2.emit('connect', client2[kUrl$2], [client2]);
	} catch (err) {
		client2[kConnecting] = false;
		if (channels.connectError.hasSubscribers) {
			channels.connectError.publish({
				connectParams: {
					host,
					hostname,
					protocol,
					port,
					servername: client2[kServerName]
				},
				connector: client2[kConnector],
				error: err
			});
		}
		if (err.code === 'ERR_TLS_CERT_ALTNAME_INVALID') {
			assert$7(client2[kRunning$3] === 0);
			while (
				client2[kPending$2] > 0 &&
				client2[kQueue$1][client2[kPendingIdx]].servername === client2[kServerName]
			) {
				const request2 = client2[kQueue$1][client2[kPendingIdx]++];
				errorRequest(client2, request2, err);
			}
		} else {
			onError(client2, err);
		}
		client2.emit('connectionError', client2[kUrl$2], [client2], err);
	}
	resume(client2);
}
function emitDrain(client2) {
	client2[kNeedDrain$2] = 0;
	client2.emit('drain', client2[kUrl$2], [client2]);
}
function resume(client2, sync) {
	if (client2[kResuming] === 2) {
		return;
	}
	client2[kResuming] = 2;
	_resume(client2, sync);
	client2[kResuming] = 0;
	if (client2[kRunningIdx] > 256) {
		client2[kQueue$1].splice(0, client2[kRunningIdx]);
		client2[kPendingIdx] -= client2[kRunningIdx];
		client2[kRunningIdx] = 0;
	}
}
function _resume(client2, sync) {
	while (true) {
		if (client2.destroyed) {
			assert$7(client2[kPending$2] === 0);
			return;
		}
		if (client2.closed && !client2[kSize$4]) {
			client2.destroy();
			return;
		}
		const socket = client2[kSocket];
		if (socket) {
			if (client2[kSize$4] === 0) {
				if (!socket[kNoRef] && socket.unref) {
					socket.unref();
					socket[kNoRef] = true;
				}
			} else if (socket[kNoRef] && socket.ref) {
				socket.ref();
				socket[kNoRef] = false;
			}
			if (client2[kSize$4] === 0) {
				if (socket[kParser].timeoutType !== TIMEOUT_IDLE) {
					socket[kParser].setTimeout(client2[kKeepAliveTimeoutValue], TIMEOUT_IDLE);
				}
			} else if (client2[kRunning$3] > 0 && socket[kParser].statusCode < 200) {
				if (socket[kParser].timeoutType !== TIMEOUT_HEADERS) {
					const request3 = client2[kQueue$1][client2[kRunningIdx]];
					const headersTimeout =
						request3.headersTimeout != null ? request3.headersTimeout : client2[kHeadersTimeout];
					socket[kParser].setTimeout(headersTimeout, TIMEOUT_HEADERS);
				}
			}
		}
		if (client2[kBusy$1]) {
			client2[kNeedDrain$2] = 2;
		} else if (client2[kNeedDrain$2] === 2) {
			if (sync) {
				client2[kNeedDrain$2] = 1;
				process.nextTick(emitDrain, client2);
			} else {
				emitDrain(client2);
			}
			continue;
		}
		if (client2[kPending$2] === 0) {
			return;
		}
		if (client2[kRunning$3] >= (client2[kPipelining] || 1)) {
			return;
		}
		const request2 = client2[kQueue$1][client2[kPendingIdx]];
		if (client2[kUrl$2].protocol === 'https:' && client2[kServerName] !== request2.servername) {
			if (client2[kRunning$3] > 0) {
				return;
			}
			client2[kServerName] = request2.servername;
			if (socket && socket.servername !== request2.servername) {
				util$b.destroy(socket, new InformationalError('servername changed'));
				return;
			}
		}
		if (client2[kConnecting]) {
			return;
		}
		if (!socket) {
			connect$1(client2);
			continue;
		}
		if (socket.destroyed || socket[kWriting] || socket[kReset] || socket[kBlocking]) {
			return;
		}
		if (client2[kRunning$3] > 0 && !request2.idempotent) {
			return;
		}
		if (client2[kRunning$3] > 0 && (request2.upgrade || request2.method === 'CONNECT')) {
			return;
		}
		if (util$b.isStream(request2.body) && util$b.bodyLength(request2.body) === 0) {
			request2.body
				.on('data', function () {
					assert$7(false);
				})
				.on('error', function (err) {
					errorRequest(client2, request2, err);
				})
				.on('end', function () {
					util$b.destroy(this);
				});
			request2.body = null;
		}
		if (
			client2[kRunning$3] > 0 &&
			(util$b.isStream(request2.body) || util$b.isAsyncIterable(request2.body))
		) {
			return;
		}
		if (!request2.aborted && write(client2, request2)) {
			client2[kPendingIdx]++;
		} else {
			client2[kQueue$1].splice(client2[kPendingIdx], 1);
		}
	}
}
function write(client2, request2) {
	const {
		body: body4,
		method,
		path,
		host,
		upgrade: upgrade2,
		headers: headers2,
		blocking
	} = request2;
	const expectsPayload = method === 'PUT' || method === 'POST' || method === 'PATCH';
	if (body4 && typeof body4.read === 'function') {
		body4.read(0);
	}
	let contentLength = util$b.bodyLength(body4);
	if (contentLength === null) {
		contentLength = request2.contentLength;
	}
	if (contentLength === 0 && !expectsPayload) {
		contentLength = null;
	}
	if (request2.contentLength !== null && request2.contentLength !== contentLength) {
		if (client2[kStrictContentLength]) {
			errorRequest(client2, request2, new RequestContentLengthMismatchError());
			return false;
		}
		process.emitWarning(new RequestContentLengthMismatchError());
	}
	const socket = client2[kSocket];
	try {
		request2.onConnect((err) => {
			if (request2.aborted || request2.completed) {
				return;
			}
			errorRequest(client2, request2, err || new RequestAbortedError$7());
			util$b.destroy(socket, new InformationalError('aborted'));
		});
	} catch (err) {
		errorRequest(client2, request2, err);
	}
	if (request2.aborted) {
		return false;
	}
	if (method === 'HEAD') {
		socket[kReset] = true;
	}
	if (upgrade2 || method === 'CONNECT') {
		socket[kReset] = true;
	}
	if (client2[kMaxRequests] && socket[kCounter]++ >= client2[kMaxRequests]) {
		socket[kReset] = true;
	}
	if (blocking) {
		socket[kBlocking] = true;
	}
	let header = `${method} ${path} HTTP/1.1\r
`;
	if (typeof host === 'string') {
		header += `host: ${host}\r
`;
	} else {
		header += client2[kHostHeader];
	}
	if (upgrade2) {
		header += `connection: upgrade\r
upgrade: ${upgrade2}\r
`;
	} else if (client2[kPipelining]) {
		header += 'connection: keep-alive\r\n';
	} else {
		header += 'connection: close\r\n';
	}
	if (headers2) {
		header += headers2;
	}
	if (channels.sendHeaders.hasSubscribers) {
		channels.sendHeaders.publish({ request: request2, headers: header, socket });
	}
	if (!body4) {
		if (contentLength === 0) {
			socket.write(
				`${header}content-length: 0\r
\r
`,
				'ascii'
			);
		} else {
			assert$7(contentLength === null, 'no body must not have content length');
			socket.write(
				`${header}\r
`,
				'ascii'
			);
		}
		request2.onRequestSent();
	} else if (util$b.isBuffer(body4)) {
		assert$7(contentLength === body4.byteLength, 'buffer body must have content length');
		socket.cork();
		socket.write(
			`${header}content-length: ${contentLength}\r
\r
`,
			'ascii'
		);
		socket.write(body4);
		socket.uncork();
		request2.onBodySent(body4);
		request2.onRequestSent();
		if (!expectsPayload) {
			socket[kReset] = true;
		}
	} else if (util$b.isBlobLike(body4)) {
		if (typeof body4.stream === 'function') {
			writeIterable({
				body: body4.stream(),
				client: client2,
				request: request2,
				socket,
				contentLength,
				header,
				expectsPayload
			});
		} else {
			writeBlob({
				body: body4,
				client: client2,
				request: request2,
				socket,
				contentLength,
				header,
				expectsPayload
			});
		}
	} else if (util$b.isStream(body4)) {
		writeStream({
			body: body4,
			client: client2,
			request: request2,
			socket,
			contentLength,
			header,
			expectsPayload
		});
	} else if (util$b.isIterable(body4)) {
		writeIterable({
			body: body4,
			client: client2,
			request: request2,
			socket,
			contentLength,
			header,
			expectsPayload
		});
	} else {
		assert$7(false);
	}
	return true;
}
function writeStream({
	body: body4,
	client: client2,
	request: request2,
	socket,
	contentLength,
	header,
	expectsPayload
}) {
	assert$7(contentLength !== 0 || client2[kRunning$3] === 0, 'stream body cannot be pipelined');
	let finished2 = false;
	const writer = new AsyncWriter({
		socket,
		request: request2,
		contentLength,
		client: client2,
		expectsPayload,
		header
	});
	const onData = function (chunk) {
		try {
			assert$7(!finished2);
			if (!writer.write(chunk) && this.pause) {
				this.pause();
			}
		} catch (err) {
			util$b.destroy(this, err);
		}
	};
	const onDrain = function () {
		assert$7(!finished2);
		if (body4.resume) {
			body4.resume();
		}
	};
	const onAbort = function () {
		onFinished(new RequestAbortedError$7());
	};
	const onFinished = function (err) {
		if (finished2) {
			return;
		}
		finished2 = true;
		assert$7(socket.destroyed || (socket[kWriting] && client2[kRunning$3] <= 1));
		socket.off('drain', onDrain).off('error', onFinished);
		body4
			.removeListener('data', onData)
			.removeListener('end', onFinished)
			.removeListener('error', onFinished)
			.removeListener('close', onAbort);
		if (!err) {
			try {
				writer.end();
			} catch (er) {
				err = er;
			}
		}
		writer.destroy(err);
		if (err && (err.code !== 'UND_ERR_INFO' || err.message !== 'reset')) {
			util$b.destroy(body4, err);
		} else {
			util$b.destroy(body4);
		}
	};
	body4.on('data', onData).on('end', onFinished).on('error', onFinished).on('close', onAbort);
	if (body4.resume) {
		body4.resume();
	}
	socket.on('drain', onDrain).on('error', onFinished);
}
async function writeBlob({
	body: body4,
	client: client2,
	request: request2,
	socket,
	contentLength,
	header,
	expectsPayload
}) {
	assert$7(contentLength === body4.size, 'blob body must have content length');
	try {
		if (contentLength != null && contentLength !== body4.size) {
			throw new RequestContentLengthMismatchError();
		}
		const buffer2 = Buffer.from(await body4.arrayBuffer());
		socket.cork();
		socket.write(
			`${header}content-length: ${contentLength}\r
\r
`,
			'ascii'
		);
		socket.write(buffer2);
		socket.uncork();
		request2.onBodySent(buffer2);
		request2.onRequestSent();
		if (!expectsPayload) {
			socket[kReset] = true;
		}
		resume(client2);
	} catch (err) {
		util$b.destroy(socket, err);
	}
}
async function writeIterable({
	body: body4,
	client: client2,
	request: request2,
	socket,
	contentLength,
	header,
	expectsPayload
}) {
	assert$7(contentLength !== 0 || client2[kRunning$3] === 0, 'iterator body cannot be pipelined');
	let callback = null;
	function onDrain() {
		if (callback) {
			const cb = callback;
			callback = null;
			cb();
		}
	}
	const waitForDrain = () =>
		new Promise((resolve2, reject) => {
			assert$7(callback === null);
			if (socket[kError]) {
				reject(socket[kError]);
			} else {
				callback = resolve2;
			}
		});
	socket.on('close', onDrain).on('drain', onDrain);
	const writer = new AsyncWriter({
		socket,
		request: request2,
		contentLength,
		client: client2,
		expectsPayload,
		header
	});
	try {
		for await (const chunk of body4) {
			if (socket[kError]) {
				throw socket[kError];
			}
			if (!writer.write(chunk)) {
				await waitForDrain();
			}
		}
		writer.end();
	} catch (err) {
		writer.destroy(err);
	} finally {
		socket.off('close', onDrain).off('drain', onDrain);
	}
}
var AsyncWriter = class {
	constructor({
		socket,
		request: request2,
		contentLength,
		client: client2,
		expectsPayload,
		header
	}) {
		this.socket = socket;
		this.request = request2;
		this.contentLength = contentLength;
		this.client = client2;
		this.bytesWritten = 0;
		this.expectsPayload = expectsPayload;
		this.header = header;
		socket[kWriting] = true;
	}
	write(chunk) {
		const {
			socket,
			request: request2,
			contentLength,
			client: client2,
			bytesWritten,
			expectsPayload,
			header
		} = this;
		if (socket[kError]) {
			throw socket[kError];
		}
		if (socket.destroyed) {
			return false;
		}
		const len = Buffer.byteLength(chunk);
		if (!len) {
			return true;
		}
		if (contentLength !== null && bytesWritten + len > contentLength) {
			if (client2[kStrictContentLength]) {
				throw new RequestContentLengthMismatchError();
			}
			process.emitWarning(new RequestContentLengthMismatchError());
		}
		if (bytesWritten === 0) {
			if (!expectsPayload) {
				socket[kReset] = true;
			}
			if (contentLength === null) {
				socket.write(
					`${header}transfer-encoding: chunked\r
`,
					'ascii'
				);
			} else {
				socket.write(
					`${header}content-length: ${contentLength}\r
\r
`,
					'ascii'
				);
			}
		}
		if (contentLength === null) {
			socket.write(
				`\r
${len.toString(16)}\r
`,
				'ascii'
			);
		}
		this.bytesWritten += len;
		const ret = socket.write(chunk);
		request2.onBodySent(chunk);
		return ret;
	}
	end() {
		const {
			socket,
			contentLength,
			client: client2,
			bytesWritten,
			expectsPayload,
			header,
			request: request2
		} = this;
		request2.onRequestSent();
		socket[kWriting] = false;
		if (socket[kError]) {
			throw socket[kError];
		}
		if (socket.destroyed) {
			return;
		}
		if (bytesWritten === 0) {
			if (expectsPayload) {
				socket.write(
					`${header}content-length: 0\r
\r
`,
					'ascii'
				);
			} else {
				socket.write(
					`${header}\r
`,
					'ascii'
				);
			}
		} else if (contentLength === null) {
			socket.write('\r\n0\r\n\r\n', 'ascii');
		}
		if (contentLength !== null && bytesWritten !== contentLength) {
			if (client2[kStrictContentLength]) {
				throw new RequestContentLengthMismatchError();
			} else {
				process.emitWarning(new RequestContentLengthMismatchError());
			}
		}
		if (socket[kParser].timeout && socket[kParser].timeoutType === TIMEOUT_HEADERS) {
			if (socket[kParser].timeout.refresh) {
				socket[kParser].timeout.refresh();
			}
		}
		resume(client2);
	}
	destroy(err) {
		const { socket, client: client2 } = this;
		socket[kWriting] = false;
		if (err) {
			assert$7(client2[kRunning$3] <= 1, 'pipeline should only contain this request');
			util$b.destroy(socket, err);
		}
	}
};
function errorRequest(client2, request2, err) {
	try {
		request2.onError(err);
		assert$7(request2.aborted);
	} catch (err2) {
		client2.emit('error', err2);
	}
}
var client = Client$2;
var kSize$3 = 2048;
var kMask = kSize$3 - 1;
var FixedCircularBuffer = class {
	constructor() {
		this.bottom = 0;
		this.top = 0;
		this.list = new Array(kSize$3);
		this.next = null;
	}
	isEmpty() {
		return this.top === this.bottom;
	}
	isFull() {
		return ((this.top + 1) & kMask) === this.bottom;
	}
	push(data2) {
		this.list[this.top] = data2;
		this.top = (this.top + 1) & kMask;
	}
	shift() {
		const nextItem = this.list[this.bottom];
		if (nextItem === void 0) return null;
		this.list[this.bottom] = void 0;
		this.bottom = (this.bottom + 1) & kMask;
		return nextItem;
	}
};
var fixedQueue = class FixedQueue {
	constructor() {
		this.head = this.tail = new FixedCircularBuffer();
	}
	isEmpty() {
		return this.head.isEmpty();
	}
	push(data2) {
		if (this.head.isFull()) {
			this.head = this.head.next = new FixedCircularBuffer();
		}
		this.head.push(data2);
	}
	shift() {
		const tail = this.tail;
		const next = tail.shift();
		if (tail.isEmpty() && tail.next !== null) {
			this.tail = tail.next;
		}
		return next;
	}
};
var {
	kFree: kFree$1,
	kConnected: kConnected$2,
	kPending: kPending$1,
	kQueued: kQueued$1,
	kRunning: kRunning$2,
	kSize: kSize$2
} = symbols$1;
var kPool = Symbol('pool');
var PoolStats$1 = class {
	constructor(pool2) {
		this[kPool] = pool2;
	}
	get connected() {
		return this[kPool][kConnected$2];
	}
	get free() {
		return this[kPool][kFree$1];
	}
	get pending() {
		return this[kPool][kPending$1];
	}
	get queued() {
		return this[kPool][kQueued$1];
	}
	get running() {
		return this[kPool][kRunning$2];
	}
	get size() {
		return this[kPool][kSize$2];
	}
};
var poolStats = PoolStats$1;
var DispatcherBase$1 = dispatcherBase;
var FixedQueue2 = fixedQueue;
var {
	kConnected: kConnected$1,
	kSize: kSize$1,
	kRunning: kRunning$1,
	kPending,
	kQueued,
	kBusy,
	kFree,
	kUrl: kUrl$1,
	kClose: kClose$1,
	kDestroy: kDestroy$1,
	kDispatch: kDispatch$1
} = symbols$1;
var PoolStats = poolStats;
var kClients$2 = Symbol('clients');
var kNeedDrain$1 = Symbol('needDrain');
var kQueue = Symbol('queue');
var kClosedResolve = Symbol('closed resolve');
var kOnDrain$1 = Symbol('onDrain');
var kOnConnect$1 = Symbol('onConnect');
var kOnDisconnect$1 = Symbol('onDisconnect');
var kOnConnectionError$1 = Symbol('onConnectionError');
var kGetDispatcher$1 = Symbol('get dispatcher');
var kAddClient$1 = Symbol('add client');
var kRemoveClient = Symbol('remove client');
var kStats = Symbol('stats');
var PoolBase$1 = class extends DispatcherBase$1 {
	constructor() {
		super();
		this[kQueue] = new FixedQueue2();
		this[kClients$2] = [];
		this[kQueued] = 0;
		const pool2 = this;
		this[kOnDrain$1] = function onDrain(origin, targets) {
			const queue = pool2[kQueue];
			let needDrain = false;
			while (!needDrain) {
				const item = queue.shift();
				if (!item) {
					break;
				}
				pool2[kQueued]--;
				needDrain = !this.dispatch(item.opts, item.handler);
			}
			this[kNeedDrain$1] = needDrain;
			if (!this[kNeedDrain$1] && pool2[kNeedDrain$1]) {
				pool2[kNeedDrain$1] = false;
				pool2.emit('drain', origin, [pool2, ...targets]);
			}
			if (pool2[kClosedResolve] && queue.isEmpty()) {
				Promise.all(pool2[kClients$2].map((c) => c.close())).then(pool2[kClosedResolve]);
			}
		};
		this[kOnConnect$1] = (origin, targets) => {
			pool2.emit('connect', origin, [pool2, ...targets]);
		};
		this[kOnDisconnect$1] = (origin, targets, err) => {
			pool2.emit('disconnect', origin, [pool2, ...targets], err);
		};
		this[kOnConnectionError$1] = (origin, targets, err) => {
			pool2.emit('connectionError', origin, [pool2, ...targets], err);
		};
		this[kStats] = new PoolStats(this);
	}
	get [kBusy]() {
		return this[kNeedDrain$1];
	}
	get [kConnected$1]() {
		return this[kClients$2].filter((client2) => client2[kConnected$1]).length;
	}
	get [kFree]() {
		return this[kClients$2].filter((client2) => client2[kConnected$1] && !client2[kNeedDrain$1])
			.length;
	}
	get [kPending]() {
		let ret = this[kQueued];
		for (const { [kPending]: pending } of this[kClients$2]) {
			ret += pending;
		}
		return ret;
	}
	get [kRunning$1]() {
		let ret = 0;
		for (const { [kRunning$1]: running } of this[kClients$2]) {
			ret += running;
		}
		return ret;
	}
	get [kSize$1]() {
		let ret = this[kQueued];
		for (const { [kSize$1]: size } of this[kClients$2]) {
			ret += size;
		}
		return ret;
	}
	get stats() {
		return this[kStats];
	}
	async [kClose$1]() {
		if (this[kQueue].isEmpty()) {
			return Promise.all(this[kClients$2].map((c) => c.close()));
		} else {
			return new Promise((resolve2) => {
				this[kClosedResolve] = resolve2;
			});
		}
	}
	async [kDestroy$1](err) {
		while (true) {
			const item = this[kQueue].shift();
			if (!item) {
				break;
			}
			item.handler.onError(err);
		}
		return Promise.all(this[kClients$2].map((c) => c.destroy(err)));
	}
	[kDispatch$1](opts, handler) {
		const dispatcher2 = this[kGetDispatcher$1]();
		if (!dispatcher2) {
			this[kNeedDrain$1] = true;
			this[kQueue].push({ opts, handler });
			this[kQueued]++;
		} else if (!dispatcher2.dispatch(opts, handler)) {
			dispatcher2[kNeedDrain$1] = true;
			this[kNeedDrain$1] = !this[kGetDispatcher$1]();
		}
		return !this[kNeedDrain$1];
	}
	[kAddClient$1](client2) {
		client2
			.on('drain', this[kOnDrain$1])
			.on('connect', this[kOnConnect$1])
			.on('disconnect', this[kOnDisconnect$1])
			.on('connectionError', this[kOnConnectionError$1]);
		this[kClients$2].push(client2);
		if (this[kNeedDrain$1]) {
			process.nextTick(() => {
				if (this[kNeedDrain$1]) {
					this[kOnDrain$1](client2[kUrl$1], [this, client2]);
				}
			});
		}
		return this;
	}
	[kRemoveClient](client2) {
		client2.close(() => {
			const idx = this[kClients$2].indexOf(client2);
			if (idx !== -1) {
				this[kClients$2].splice(idx, 1);
			}
		});
		this[kNeedDrain$1] = this[kClients$2].some(
			(dispatcher2) =>
				!dispatcher2[kNeedDrain$1] && dispatcher2.closed !== true && dispatcher2.destroyed !== true
		);
	}
};
var poolBase = {
	PoolBase: PoolBase$1,
	kClients: kClients$2,
	kNeedDrain: kNeedDrain$1,
	kAddClient: kAddClient$1,
	kRemoveClient,
	kGetDispatcher: kGetDispatcher$1
};
var { PoolBase, kClients: kClients$1, kNeedDrain, kAddClient, kGetDispatcher } = poolBase;
var Client$1 = client;
var { InvalidArgumentError: InvalidArgumentError$8 } = errors$1;
var util$a = util$h;
var { kUrl } = symbols$1;
var buildConnector = connect$2;
var kOptions$1 = Symbol('options');
var kConnections = Symbol('connections');
var kFactory$1 = Symbol('factory');
function defaultFactory$1(origin, opts) {
	return new Client$1(origin, opts);
}
var Pool$1 = class extends PoolBase {
	constructor(
		origin,
		{
			connections,
			factory: factory2 = defaultFactory$1,
			connect: connect2,
			connectTimeout,
			tls: tls2,
			maxCachedSessions,
			socketPath,
			...options
		} = {}
	) {
		super();
		if (connections != null && (!Number.isFinite(connections) || connections < 0)) {
			throw new InvalidArgumentError$8('invalid connections');
		}
		if (typeof factory2 !== 'function') {
			throw new InvalidArgumentError$8('factory must be a function.');
		}
		if (connect2 != null && typeof connect2 !== 'function' && typeof connect2 !== 'object') {
			throw new InvalidArgumentError$8('connect must be a function or an object');
		}
		if (typeof connect2 !== 'function') {
			connect2 = buildConnector({
				...tls2,
				maxCachedSessions,
				socketPath,
				timeout: connectTimeout == null ? 1e4 : connectTimeout,
				...connect2
			});
		}
		this[kConnections] = connections || null;
		this[kUrl] = util$a.parseOrigin(origin);
		this[kOptions$1] = { ...util$a.deepClone(options), connect: connect2 };
		this[kFactory$1] = factory2;
	}
	[kGetDispatcher]() {
		let dispatcher2 = this[kClients$1].find((dispatcher3) => !dispatcher3[kNeedDrain]);
		if (dispatcher2) {
			return dispatcher2;
		}
		if (!this[kConnections] || this[kClients$1].length < this[kConnections]) {
			dispatcher2 = this[kFactory$1](this[kUrl], this[kOptions$1]);
			this[kAddClient](dispatcher2);
		}
		return dispatcher2;
	}
};
var pool = Pool$1;
var { kConnected, kSize } = symbols$1;
var CompatWeakRef = class {
	constructor(value) {
		this.value = value;
	}
	deref() {
		return this.value[kConnected] === 0 && this.value[kSize] === 0 ? void 0 : this.value;
	}
};
var CompatFinalizer = class {
	constructor(finalizer) {
		this.finalizer = finalizer;
	}
	register(dispatcher2, key3) {
		dispatcher2.on('disconnect', () => {
			if (dispatcher2[kConnected] === 0 && dispatcher2[kSize] === 0) {
				this.finalizer(key3);
			}
		});
	}
};
var dispatcherWeakref = function () {
	return {
		WeakRef: commonjsGlobal.WeakRef || CompatWeakRef,
		FinalizationRegistry: commonjsGlobal.FinalizationRegistry || CompatFinalizer
	};
};
var { InvalidArgumentError: InvalidArgumentError$7 } = errors$1;
var { kClients, kRunning, kClose, kDestroy, kDispatch } = symbols$1;
var DispatcherBase = dispatcherBase;
var Pool = pool;
var Client = client;
var util$9 = util$h;
var RedirectHandler = redirect;
var { WeakRef, FinalizationRegistry: FinalizationRegistry$1 } = dispatcherWeakref();
var kOnConnect = Symbol('onConnect');
var kOnDisconnect = Symbol('onDisconnect');
var kOnConnectionError = Symbol('onConnectionError');
var kMaxRedirections = Symbol('maxRedirections');
var kOnDrain = Symbol('onDrain');
var kFactory = Symbol('factory');
var kFinalizer = Symbol('finalizer');
var kOptions = Symbol('options');
function defaultFactory(origin, opts) {
	return opts && opts.connections === 1 ? new Client(origin, opts) : new Pool(origin, opts);
}
var Agent$1 = class extends DispatcherBase {
	constructor({
		factory: factory2 = defaultFactory,
		maxRedirections = 0,
		connect: connect2,
		...options
	} = {}) {
		super();
		if (typeof factory2 !== 'function') {
			throw new InvalidArgumentError$7('factory must be a function.');
		}
		if (connect2 != null && typeof connect2 !== 'function' && typeof connect2 !== 'object') {
			throw new InvalidArgumentError$7('connect must be a function or an object');
		}
		if (!Number.isInteger(maxRedirections) || maxRedirections < 0) {
			throw new InvalidArgumentError$7('maxRedirections must be a positive number');
		}
		if (connect2 && typeof connect2 !== 'function') {
			connect2 = { ...connect2 };
		}
		this[kOptions] = { ...util$9.deepClone(options), connect: connect2 };
		this[kMaxRedirections] = maxRedirections;
		this[kFactory] = factory2;
		this[kClients] = /* @__PURE__ */ new Map();
		this[kFinalizer] = new FinalizationRegistry$1((key3) => {
			const ref = this[kClients].get(key3);
			if (ref !== void 0 && ref.deref() === void 0) {
				this[kClients].delete(key3);
			}
		});
		const agent2 = this;
		this[kOnDrain] = (origin, targets) => {
			agent2.emit('drain', origin, [agent2, ...targets]);
		};
		this[kOnConnect] = (origin, targets) => {
			agent2.emit('connect', origin, [agent2, ...targets]);
		};
		this[kOnDisconnect] = (origin, targets, err) => {
			agent2.emit('disconnect', origin, [agent2, ...targets], err);
		};
		this[kOnConnectionError] = (origin, targets, err) => {
			agent2.emit('connectionError', origin, [agent2, ...targets], err);
		};
	}
	get [kRunning]() {
		let ret = 0;
		for (const ref of this[kClients].values()) {
			const client2 = ref.deref();
			if (client2) {
				ret += client2[kRunning];
			}
		}
		return ret;
	}
	[kDispatch](opts, handler) {
		let key3;
		if (opts.origin && (typeof opts.origin === 'string' || opts.origin instanceof URL)) {
			key3 = String(opts.origin);
		} else {
			throw new InvalidArgumentError$7('opts.origin must be a non-empty string or URL.');
		}
		const ref = this[kClients].get(key3);
		let dispatcher2 = ref ? ref.deref() : null;
		if (!dispatcher2) {
			dispatcher2 = this[kFactory](opts.origin, this[kOptions])
				.on('drain', this[kOnDrain])
				.on('connect', this[kOnConnect])
				.on('disconnect', this[kOnDisconnect])
				.on('connectionError', this[kOnConnectionError]);
			this[kClients].set(key3, new WeakRef(dispatcher2));
			this[kFinalizer].register(dispatcher2, key3);
		}
		const { maxRedirections = this[kMaxRedirections] } = opts;
		if (maxRedirections != null && maxRedirections !== 0) {
			opts = { ...opts, maxRedirections: 0 };
			handler = new RedirectHandler(this, maxRedirections, opts, handler);
		}
		return dispatcher2.dispatch(opts, handler);
	}
	async [kClose]() {
		const closePromises = [];
		for (const ref of this[kClients].values()) {
			const client2 = ref.deref();
			if (client2) {
				closePromises.push(client2.close());
			}
		}
		await Promise.all(closePromises);
	}
	async [kDestroy](err) {
		const destroyPromises = [];
		for (const ref of this[kClients].values()) {
			const client2 = ref.deref();
			if (client2) {
				destroyPromises.push(client2.destroy(err));
			}
		}
		await Promise.all(destroyPromises);
	}
};
var agent = Agent$1;
var api$1 = {};
var assert$6 = import_assert.default;
var { Readable: Readable$3 } = import_stream.default;
var { RequestAbortedError: RequestAbortedError$6, NotSupportedError } = errors$1;
var util$8 = util$h;
var { ReadableStreamFrom, toUSVString: toUSVString$2 } = util$h;
var Blob;
var kConsume = Symbol('kConsume');
var kReading = Symbol('kReading');
var kBody = Symbol('kBody');
var kAbort = Symbol('abort');
var kContentType = Symbol('kContentType');
var readable = class BodyReadable extends Readable$3 {
	constructor(resume2, abort2, contentType = '') {
		super({
			autoDestroy: true,
			read: resume2,
			highWaterMark: 64 * 1024
		});
		this._readableState.dataEmitted = false;
		this[kAbort] = abort2;
		this[kConsume] = null;
		this[kBody] = null;
		this[kContentType] = contentType;
		this[kReading] = false;
	}
	destroy(err) {
		if (this.destroyed) {
			return this;
		}
		if (!err && !this._readableState.endEmitted) {
			err = new RequestAbortedError$6();
		}
		if (err) {
			this[kAbort]();
		}
		return super.destroy(err);
	}
	emit(ev, ...args) {
		if (ev === 'data') {
			this._readableState.dataEmitted = true;
		} else if (ev === 'error') {
			this._readableState.errorEmitted = true;
		}
		return super.emit(ev, ...args);
	}
	on(ev, ...args) {
		if (ev === 'data' || ev === 'readable') {
			this[kReading] = true;
		}
		return super.on(ev, ...args);
	}
	addListener(ev, ...args) {
		return this.on(ev, ...args);
	}
	off(ev, ...args) {
		const ret = super.off(ev, ...args);
		if (ev === 'data' || ev === 'readable') {
			this[kReading] = this.listenerCount('data') > 0 || this.listenerCount('readable') > 0;
		}
		return ret;
	}
	removeListener(ev, ...args) {
		return this.off(ev, ...args);
	}
	push(chunk) {
		if (this[kConsume] && chunk !== null) {
			consumePush(this[kConsume], chunk);
			return this[kReading] ? super.push(chunk) : true;
		}
		return super.push(chunk);
	}
	async text() {
		return consume(this, 'text');
	}
	async json() {
		return consume(this, 'json');
	}
	async blob() {
		return consume(this, 'blob');
	}
	async arrayBuffer() {
		return consume(this, 'arrayBuffer');
	}
	async formData() {
		throw new NotSupportedError();
	}
	get bodyUsed() {
		return util$8.isDisturbed(this);
	}
	get body() {
		if (!this[kBody]) {
			this[kBody] = ReadableStreamFrom(this);
			if (this[kConsume]) {
				this[kBody].getReader();
				assert$6(this[kBody].locked);
			}
		}
		return this[kBody];
	}
	async dump(opts) {
		let limit = opts && Number.isFinite(opts.limit) ? opts.limit : 262144;
		try {
			for await (const chunk of this) {
				limit -= Buffer.byteLength(chunk);
				if (limit < 0) {
					return;
				}
			}
		} catch {}
	}
};
function isLocked(self2) {
	return (self2[kBody] && self2[kBody].locked === true) || self2[kConsume];
}
function isUnusable(self2) {
	return util$8.isDisturbed(self2) || isLocked(self2);
}
async function consume(stream2, type) {
	if (isUnusable(stream2)) {
		throw new TypeError('unusable');
	}
	assert$6(!stream2[kConsume]);
	return new Promise((resolve2, reject) => {
		stream2[kConsume] = {
			type,
			stream: stream2,
			resolve: resolve2,
			reject,
			length: 0,
			body: []
		};
		stream2
			.on('error', function (err) {
				consumeFinish(this[kConsume], err);
			})
			.on('close', function () {
				if (this[kConsume].body !== null) {
					consumeFinish(this[kConsume], new RequestAbortedError$6());
				}
			});
		process.nextTick(consumeStart, stream2[kConsume]);
	});
}
function consumeStart(consume2) {
	if (consume2.body === null) {
		return;
	}
	const { _readableState: state } = consume2.stream;
	for (const chunk of state.buffer) {
		consumePush(consume2, chunk);
	}
	if (state.endEmitted) {
		consumeEnd(this[kConsume]);
	} else {
		consume2.stream.on('end', function () {
			consumeEnd(this[kConsume]);
		});
	}
	consume2.stream.resume();
	while (consume2.stream.read() != null) {}
}
function consumeEnd(consume2) {
	const { type, body: body4, resolve: resolve2, stream: stream2, length } = consume2;
	try {
		if (type === 'text') {
			resolve2(toUSVString$2(Buffer.concat(body4)));
		} else if (type === 'json') {
			resolve2(JSON.parse(Buffer.concat(body4)));
		} else if (type === 'arrayBuffer') {
			const dst = new Uint8Array(length);
			let pos = 0;
			for (const buf of body4) {
				dst.set(buf, pos);
				pos += buf.byteLength;
			}
			resolve2(dst);
		} else if (type === 'blob') {
			if (!Blob) {
				Blob = require('buffer').Blob;
			}
			resolve2(new Blob(body4, { type: stream2[kContentType] }));
		}
		consumeFinish(consume2);
	} catch (err) {
		stream2.destroy(err);
	}
}
function consumePush(consume2, chunk) {
	consume2.length += chunk.length;
	consume2.body.push(chunk);
}
function consumeFinish(consume2, err) {
	if (consume2.body === null) {
		return;
	}
	if (err) {
		consume2.reject(err);
	} else {
		consume2.resolve();
	}
	consume2.type = null;
	consume2.stream = null;
	consume2.resolve = null;
	consume2.reject = null;
	consume2.length = 0;
	consume2.body = null;
}
var { RequestAbortedError: RequestAbortedError$5 } = errors$1;
var kListener = Symbol('kListener');
var kSignal$1 = Symbol('kSignal');
function abort(self2) {
	if (self2.abort) {
		self2.abort();
	} else {
		self2.onError(new RequestAbortedError$5());
	}
}
function addSignal$5(self2, signal) {
	self2[kSignal$1] = null;
	self2[kListener] = null;
	if (!signal) {
		return;
	}
	if (signal.aborted) {
		abort(self2);
		return;
	}
	self2[kSignal$1] = signal;
	self2[kListener] = () => {
		abort(self2);
	};
	if ('addEventListener' in self2[kSignal$1]) {
		self2[kSignal$1].addEventListener('abort', self2[kListener]);
	} else {
		self2[kSignal$1].addListener('abort', self2[kListener]);
	}
}
function removeSignal$5(self2) {
	if (!self2[kSignal$1]) {
		return;
	}
	if ('removeEventListener' in self2[kSignal$1]) {
		self2[kSignal$1].removeEventListener('abort', self2[kListener]);
	} else {
		self2[kSignal$1].removeListener('abort', self2[kListener]);
	}
	self2[kSignal$1] = null;
	self2[kListener] = null;
}
var abortSignal = {
	addSignal: addSignal$5,
	removeSignal: removeSignal$5
};
var Readable$2 = readable;
var {
	InvalidArgumentError: InvalidArgumentError$6,
	RequestAbortedError: RequestAbortedError$4,
	ResponseStatusCodeError
} = errors$1;
var util$7 = util$h;
var { AsyncResource: AsyncResource$4 } = import_async_hooks.default;
var { addSignal: addSignal$4, removeSignal: removeSignal$4 } = abortSignal;
var RequestHandler = class extends AsyncResource$4 {
	constructor(opts, callback) {
		if (!opts || typeof opts !== 'object') {
			throw new InvalidArgumentError$6('invalid opts');
		}
		const { signal, method, opaque, body: body4, onInfo, responseHeaders, throwOnError } = opts;
		try {
			if (typeof callback !== 'function') {
				throw new InvalidArgumentError$6('invalid callback');
			}
			if (
				signal &&
				typeof signal.on !== 'function' &&
				typeof signal.addEventListener !== 'function'
			) {
				throw new InvalidArgumentError$6('signal must be an EventEmitter or EventTarget');
			}
			if (method === 'CONNECT') {
				throw new InvalidArgumentError$6('invalid method');
			}
			if (onInfo && typeof onInfo !== 'function') {
				throw new InvalidArgumentError$6('invalid onInfo callback');
			}
			super('UNDICI_REQUEST');
		} catch (err) {
			if (util$7.isStream(body4)) {
				util$7.destroy(body4.on('error', util$7.nop), err);
			}
			throw err;
		}
		this.responseHeaders = responseHeaders || null;
		this.opaque = opaque || null;
		this.callback = callback;
		this.res = null;
		this.abort = null;
		this.body = body4;
		this.trailers = {};
		this.context = null;
		this.onInfo = onInfo || null;
		this.throwOnError = throwOnError;
		if (util$7.isStream(body4)) {
			body4.on('error', (err) => {
				this.onError(err);
			});
		}
		addSignal$4(this, signal);
	}
	onConnect(abort2, context) {
		if (!this.callback) {
			throw new RequestAbortedError$4();
		}
		this.abort = abort2;
		this.context = context;
	}
	onHeaders(statusCode, rawHeaders, resume2, statusMessage) {
		const { callback, opaque, abort: abort2, context } = this;
		if (statusCode < 200) {
			if (this.onInfo) {
				const headers3 =
					this.responseHeaders === 'raw'
						? util$7.parseRawHeaders(rawHeaders)
						: util$7.parseHeaders(rawHeaders);
				this.onInfo({ statusCode, headers: headers3 });
			}
			return;
		}
		const parsedHeaders = util$7.parseHeaders(rawHeaders);
		const body4 = new Readable$2(resume2, abort2, parsedHeaders['content-type']);
		this.callback = null;
		this.res = body4;
		const headers2 =
			this.responseHeaders === 'raw'
				? util$7.parseRawHeaders(rawHeaders)
				: util$7.parseHeaders(rawHeaders);
		if (callback !== null) {
			if (this.throwOnError && statusCode >= 400) {
				this.runInAsyncScope(
					callback,
					null,
					new ResponseStatusCodeError(
						`Response status code ${statusCode}${statusMessage ? `: ${statusMessage}` : ''}`,
						statusCode,
						headers2
					)
				);
				return;
			}
			this.runInAsyncScope(callback, null, null, {
				statusCode,
				headers: headers2,
				trailers: this.trailers,
				opaque,
				body: body4,
				context
			});
		}
	}
	onData(chunk) {
		const { res } = this;
		return res.push(chunk);
	}
	onComplete(trailers) {
		const { res } = this;
		removeSignal$4(this);
		util$7.parseHeaders(trailers, this.trailers);
		res.push(null);
	}
	onError(err) {
		const { res, callback, body: body4, opaque } = this;
		removeSignal$4(this);
		if (callback) {
			this.callback = null;
			queueMicrotask(() => {
				this.runInAsyncScope(callback, null, err, { opaque });
			});
		}
		if (res) {
			this.res = null;
			queueMicrotask(() => {
				util$7.destroy(res, err);
			});
		}
		if (body4) {
			this.body = null;
			util$7.destroy(body4, err);
		}
	}
};
function request$1(opts, callback) {
	if (callback === void 0) {
		return new Promise((resolve2, reject) => {
			request$1.call(this, opts, (err, data2) => {
				return err ? reject(err) : resolve2(data2);
			});
		});
	}
	try {
		this.dispatch(opts, new RequestHandler(opts, callback));
	} catch (err) {
		if (typeof callback !== 'function') {
			throw err;
		}
		const opaque = opts && opts.opaque;
		queueMicrotask(() => callback(err, { opaque }));
	}
}
var apiRequest = request$1;
var { finished } = import_stream.default;
var {
	InvalidArgumentError: InvalidArgumentError$5,
	InvalidReturnValueError: InvalidReturnValueError$1,
	RequestAbortedError: RequestAbortedError$3
} = errors$1;
var util$6 = util$h;
var { AsyncResource: AsyncResource$3 } = import_async_hooks.default;
var { addSignal: addSignal$3, removeSignal: removeSignal$3 } = abortSignal;
var StreamHandler = class extends AsyncResource$3 {
	constructor(opts, factory2, callback) {
		if (!opts || typeof opts !== 'object') {
			throw new InvalidArgumentError$5('invalid opts');
		}
		const { signal, method, opaque, body: body4, onInfo, responseHeaders } = opts;
		try {
			if (typeof callback !== 'function') {
				throw new InvalidArgumentError$5('invalid callback');
			}
			if (typeof factory2 !== 'function') {
				throw new InvalidArgumentError$5('invalid factory');
			}
			if (
				signal &&
				typeof signal.on !== 'function' &&
				typeof signal.addEventListener !== 'function'
			) {
				throw new InvalidArgumentError$5('signal must be an EventEmitter or EventTarget');
			}
			if (method === 'CONNECT') {
				throw new InvalidArgumentError$5('invalid method');
			}
			if (onInfo && typeof onInfo !== 'function') {
				throw new InvalidArgumentError$5('invalid onInfo callback');
			}
			super('UNDICI_STREAM');
		} catch (err) {
			if (util$6.isStream(body4)) {
				util$6.destroy(body4.on('error', util$6.nop), err);
			}
			throw err;
		}
		this.responseHeaders = responseHeaders || null;
		this.opaque = opaque || null;
		this.factory = factory2;
		this.callback = callback;
		this.res = null;
		this.abort = null;
		this.context = null;
		this.trailers = null;
		this.body = body4;
		this.onInfo = onInfo || null;
		if (util$6.isStream(body4)) {
			body4.on('error', (err) => {
				this.onError(err);
			});
		}
		addSignal$3(this, signal);
	}
	onConnect(abort2, context) {
		if (!this.callback) {
			throw new RequestAbortedError$3();
		}
		this.abort = abort2;
		this.context = context;
	}
	onHeaders(statusCode, rawHeaders, resume2) {
		const { factory: factory2, opaque, context } = this;
		if (statusCode < 200) {
			if (this.onInfo) {
				const headers3 =
					this.responseHeaders === 'raw'
						? util$6.parseRawHeaders(rawHeaders)
						: util$6.parseHeaders(rawHeaders);
				this.onInfo({ statusCode, headers: headers3 });
			}
			return;
		}
		this.factory = null;
		const headers2 =
			this.responseHeaders === 'raw'
				? util$6.parseRawHeaders(rawHeaders)
				: util$6.parseHeaders(rawHeaders);
		const res = this.runInAsyncScope(factory2, null, {
			statusCode,
			headers: headers2,
			opaque,
			context
		});
		if (
			!res ||
			typeof res.write !== 'function' ||
			typeof res.end !== 'function' ||
			typeof res.on !== 'function'
		) {
			throw new InvalidReturnValueError$1('expected Writable');
		}
		res.on('drain', resume2);
		finished(res, { readable: false }, (err) => {
			const { callback, res: res2, opaque: opaque2, trailers, abort: abort2 } = this;
			this.res = null;
			if (err || !res2.readable) {
				util$6.destroy(res2, err);
			}
			this.callback = null;
			this.runInAsyncScope(callback, null, err || null, { opaque: opaque2, trailers });
			if (err) {
				abort2();
			}
		});
		this.res = res;
		const needDrain =
			res.writableNeedDrain !== void 0
				? res.writableNeedDrain
				: res._writableState && res._writableState.needDrain;
		return needDrain !== true;
	}
	onData(chunk) {
		const { res } = this;
		return res.write(chunk);
	}
	onComplete(trailers) {
		const { res } = this;
		removeSignal$3(this);
		this.trailers = util$6.parseHeaders(trailers);
		res.end();
	}
	onError(err) {
		const { res, callback, opaque, body: body4 } = this;
		removeSignal$3(this);
		this.factory = null;
		if (res) {
			this.res = null;
			util$6.destroy(res, err);
		} else if (callback) {
			this.callback = null;
			queueMicrotask(() => {
				this.runInAsyncScope(callback, null, err, { opaque });
			});
		}
		if (body4) {
			this.body = null;
			util$6.destroy(body4, err);
		}
	}
};
function stream(opts, factory2, callback) {
	if (callback === void 0) {
		return new Promise((resolve2, reject) => {
			stream.call(this, opts, factory2, (err, data2) => {
				return err ? reject(err) : resolve2(data2);
			});
		});
	}
	try {
		this.dispatch(opts, new StreamHandler(opts, factory2, callback));
	} catch (err) {
		if (typeof callback !== 'function') {
			throw err;
		}
		const opaque = opts && opts.opaque;
		queueMicrotask(() => callback(err, { opaque }));
	}
}
var apiStream = stream;
var { Readable: Readable$1, Duplex, PassThrough } = import_stream.default;
var {
	InvalidArgumentError: InvalidArgumentError$4,
	InvalidReturnValueError,
	RequestAbortedError: RequestAbortedError$2
} = errors$1;
var util$5 = util$h;
var { AsyncResource: AsyncResource$2 } = import_async_hooks.default;
var { addSignal: addSignal$2, removeSignal: removeSignal$2 } = abortSignal;
var assert$5 = import_assert.default;
var kResume = Symbol('resume');
var PipelineRequest = class extends Readable$1 {
	constructor() {
		super({ autoDestroy: true });
		this[kResume] = null;
	}
	_read() {
		const { [kResume]: resume2 } = this;
		if (resume2) {
			this[kResume] = null;
			resume2();
		}
	}
	_destroy(err, callback) {
		this._read();
		callback(err);
	}
};
var PipelineResponse = class extends Readable$1 {
	constructor(resume2) {
		super({ autoDestroy: true });
		this[kResume] = resume2;
	}
	_read() {
		this[kResume]();
	}
	_destroy(err, callback) {
		if (!err && !this._readableState.endEmitted) {
			err = new RequestAbortedError$2();
		}
		callback(err);
	}
};
var PipelineHandler = class extends AsyncResource$2 {
	constructor(opts, handler) {
		if (!opts || typeof opts !== 'object') {
			throw new InvalidArgumentError$4('invalid opts');
		}
		if (typeof handler !== 'function') {
			throw new InvalidArgumentError$4('invalid handler');
		}
		const { signal, method, opaque, onInfo, responseHeaders } = opts;
		if (
			signal &&
			typeof signal.on !== 'function' &&
			typeof signal.addEventListener !== 'function'
		) {
			throw new InvalidArgumentError$4('signal must be an EventEmitter or EventTarget');
		}
		if (method === 'CONNECT') {
			throw new InvalidArgumentError$4('invalid method');
		}
		if (onInfo && typeof onInfo !== 'function') {
			throw new InvalidArgumentError$4('invalid onInfo callback');
		}
		super('UNDICI_PIPELINE');
		this.opaque = opaque || null;
		this.responseHeaders = responseHeaders || null;
		this.handler = handler;
		this.abort = null;
		this.context = null;
		this.onInfo = onInfo || null;
		this.req = new PipelineRequest().on('error', util$5.nop);
		this.ret = new Duplex({
			readableObjectMode: opts.objectMode,
			autoDestroy: true,
			read: () => {
				const { body: body4 } = this;
				if (body4 && body4.resume) {
					body4.resume();
				}
			},
			write: (chunk, encoding, callback) => {
				const { req } = this;
				if (req.push(chunk, encoding) || req._readableState.destroyed) {
					callback();
				} else {
					req[kResume] = callback;
				}
			},
			destroy: (err, callback) => {
				const { body: body4, req, res, ret, abort: abort2 } = this;
				if (!err && !ret._readableState.endEmitted) {
					err = new RequestAbortedError$2();
				}
				if (abort2 && err) {
					abort2();
				}
				util$5.destroy(body4, err);
				util$5.destroy(req, err);
				util$5.destroy(res, err);
				removeSignal$2(this);
				callback(err);
			}
		}).on('prefinish', () => {
			const { req } = this;
			req.push(null);
		});
		this.res = null;
		addSignal$2(this, signal);
	}
	onConnect(abort2, context) {
		const { ret, res } = this;
		assert$5(!res, 'pipeline cannot be retried');
		if (ret.destroyed) {
			throw new RequestAbortedError$2();
		}
		this.abort = abort2;
		this.context = context;
	}
	onHeaders(statusCode, rawHeaders, resume2) {
		const { opaque, handler, context } = this;
		if (statusCode < 200) {
			if (this.onInfo) {
				const headers2 =
					this.responseHeaders === 'raw'
						? util$5.parseRawHeaders(rawHeaders)
						: util$5.parseHeaders(rawHeaders);
				this.onInfo({ statusCode, headers: headers2 });
			}
			return;
		}
		this.res = new PipelineResponse(resume2);
		let body4;
		try {
			this.handler = null;
			const headers2 =
				this.responseHeaders === 'raw'
					? util$5.parseRawHeaders(rawHeaders)
					: util$5.parseHeaders(rawHeaders);
			body4 = this.runInAsyncScope(handler, null, {
				statusCode,
				headers: headers2,
				opaque,
				body: this.res,
				context
			});
		} catch (err) {
			this.res.on('error', util$5.nop);
			throw err;
		}
		if (!body4 || typeof body4.on !== 'function') {
			throw new InvalidReturnValueError('expected Readable');
		}
		body4
			.on('data', (chunk) => {
				const { ret, body: body5 } = this;
				if (!ret.push(chunk) && body5.pause) {
					body5.pause();
				}
			})
			.on('error', (err) => {
				const { ret } = this;
				util$5.destroy(ret, err);
			})
			.on('end', () => {
				const { ret } = this;
				ret.push(null);
			})
			.on('close', () => {
				const { ret } = this;
				if (!ret._readableState.ended) {
					util$5.destroy(ret, new RequestAbortedError$2());
				}
			});
		this.body = body4;
	}
	onData(chunk) {
		const { res } = this;
		return res.push(chunk);
	}
	onComplete(trailers) {
		const { res } = this;
		res.push(null);
	}
	onError(err) {
		const { ret } = this;
		this.handler = null;
		util$5.destroy(ret, err);
	}
};
function pipeline$1(opts, handler) {
	try {
		const pipelineHandler = new PipelineHandler(opts, handler);
		this.dispatch({ ...opts, body: pipelineHandler.req }, pipelineHandler);
		return pipelineHandler.ret;
	} catch (err) {
		return new PassThrough().destroy(err);
	}
}
var apiPipeline = pipeline$1;
var {
	InvalidArgumentError: InvalidArgumentError$3,
	RequestAbortedError: RequestAbortedError$1,
	SocketError: SocketError$1
} = errors$1;
var { AsyncResource: AsyncResource$1 } = import_async_hooks.default;
var util$4 = util$h;
var { addSignal: addSignal$1, removeSignal: removeSignal$1 } = abortSignal;
var assert$4 = import_assert.default;
var UpgradeHandler = class extends AsyncResource$1 {
	constructor(opts, callback) {
		if (!opts || typeof opts !== 'object') {
			throw new InvalidArgumentError$3('invalid opts');
		}
		if (typeof callback !== 'function') {
			throw new InvalidArgumentError$3('invalid callback');
		}
		const { signal, opaque, responseHeaders } = opts;
		if (
			signal &&
			typeof signal.on !== 'function' &&
			typeof signal.addEventListener !== 'function'
		) {
			throw new InvalidArgumentError$3('signal must be an EventEmitter or EventTarget');
		}
		super('UNDICI_UPGRADE');
		this.responseHeaders = responseHeaders || null;
		this.opaque = opaque || null;
		this.callback = callback;
		this.abort = null;
		this.context = null;
		addSignal$1(this, signal);
	}
	onConnect(abort2, context) {
		if (!this.callback) {
			throw new RequestAbortedError$1();
		}
		this.abort = abort2;
		this.context = null;
	}
	onHeaders() {
		throw new SocketError$1('bad upgrade', null);
	}
	onUpgrade(statusCode, rawHeaders, socket) {
		const { callback, opaque, context } = this;
		assert$4.strictEqual(statusCode, 101);
		removeSignal$1(this);
		this.callback = null;
		const headers2 =
			this.responseHeaders === 'raw'
				? util$4.parseRawHeaders(rawHeaders)
				: util$4.parseHeaders(rawHeaders);
		this.runInAsyncScope(callback, null, null, {
			headers: headers2,
			socket,
			opaque,
			context
		});
	}
	onError(err) {
		const { callback, opaque } = this;
		removeSignal$1(this);
		if (callback) {
			this.callback = null;
			queueMicrotask(() => {
				this.runInAsyncScope(callback, null, err, { opaque });
			});
		}
	}
};
function upgrade(opts, callback) {
	if (callback === void 0) {
		return new Promise((resolve2, reject) => {
			upgrade.call(this, opts, (err, data2) => {
				return err ? reject(err) : resolve2(data2);
			});
		});
	}
	try {
		const upgradeHandler = new UpgradeHandler(opts, callback);
		this.dispatch(
			{
				...opts,
				method: opts.method || 'GET',
				upgrade: opts.protocol || 'Websocket'
			},
			upgradeHandler
		);
	} catch (err) {
		if (typeof callback !== 'function') {
			throw err;
		}
		const opaque = opts && opts.opaque;
		queueMicrotask(() => callback(err, { opaque }));
	}
}
var apiUpgrade = upgrade;
var { InvalidArgumentError: InvalidArgumentError$2, RequestAbortedError, SocketError } = errors$1;
var { AsyncResource } = import_async_hooks.default;
var util$3 = util$h;
var { addSignal, removeSignal } = abortSignal;
var ConnectHandler = class extends AsyncResource {
	constructor(opts, callback) {
		if (!opts || typeof opts !== 'object') {
			throw new InvalidArgumentError$2('invalid opts');
		}
		if (typeof callback !== 'function') {
			throw new InvalidArgumentError$2('invalid callback');
		}
		const { signal, opaque, responseHeaders } = opts;
		if (
			signal &&
			typeof signal.on !== 'function' &&
			typeof signal.addEventListener !== 'function'
		) {
			throw new InvalidArgumentError$2('signal must be an EventEmitter or EventTarget');
		}
		super('UNDICI_CONNECT');
		this.opaque = opaque || null;
		this.responseHeaders = responseHeaders || null;
		this.callback = callback;
		this.abort = null;
		addSignal(this, signal);
	}
	onConnect(abort2, context) {
		if (!this.callback) {
			throw new RequestAbortedError();
		}
		this.abort = abort2;
		this.context = context;
	}
	onHeaders() {
		throw new SocketError('bad connect', null);
	}
	onUpgrade(statusCode, rawHeaders, socket) {
		const { callback, opaque, context } = this;
		removeSignal(this);
		this.callback = null;
		const headers2 =
			this.responseHeaders === 'raw'
				? util$3.parseRawHeaders(rawHeaders)
				: util$3.parseHeaders(rawHeaders);
		this.runInAsyncScope(callback, null, null, {
			statusCode,
			headers: headers2,
			socket,
			opaque,
			context
		});
	}
	onError(err) {
		const { callback, opaque } = this;
		removeSignal(this);
		if (callback) {
			this.callback = null;
			queueMicrotask(() => {
				this.runInAsyncScope(callback, null, err, { opaque });
			});
		}
	}
};
function connect(opts, callback) {
	if (callback === void 0) {
		return new Promise((resolve2, reject) => {
			connect.call(this, opts, (err, data2) => {
				return err ? reject(err) : resolve2(data2);
			});
		});
	}
	try {
		const connectHandler = new ConnectHandler(opts, callback);
		this.dispatch({ ...opts, method: 'CONNECT' }, connectHandler);
	} catch (err) {
		if (typeof callback !== 'function') {
			throw err;
		}
		const opaque = opts && opts.opaque;
		queueMicrotask(() => callback(err, { opaque }));
	}
}
var apiConnect = connect;
api$1.request = apiRequest;
api$1.stream = apiStream;
api$1.pipeline = apiPipeline;
api$1.upgrade = apiUpgrade;
api$1.connect = apiConnect;
var globalDispatcher = Symbol.for('undici.globalDispatcher.1');
var { InvalidArgumentError: InvalidArgumentError$1 } = errors$1;
var Agent = agent;
if (getGlobalDispatcher$1() === void 0) {
	setGlobalDispatcher$1(new Agent());
}
function setGlobalDispatcher$1(agent2) {
	if (!agent2 || typeof agent2.dispatch !== 'function') {
		throw new InvalidArgumentError$1('Argument agent must implement Agent');
	}
	Object.defineProperty(globalThis, globalDispatcher, {
		value: agent2,
		writable: true,
		enumerable: false,
		configurable: false
	});
}
function getGlobalDispatcher$1() {
	return globalThis[globalDispatcher];
}
var global2 = {
	setGlobalDispatcher: setGlobalDispatcher$1,
	getGlobalDispatcher: getGlobalDispatcher$1
};
var { validateHeaderName, validateHeaderValue } = import_http.default;
var { kHeadersList: kHeadersList$3 } = symbols$1;
var { kGuard: kGuard$3 } = symbols;
var { kEnumerableProperty: kEnumerableProperty$2 } = util$h;
var kHeadersMap = Symbol('headers map');
var kHeadersSortedMap = Symbol('headers map sorted');
function normalizeAndValidateHeaderName(name) {
	if (name === void 0) {
		throw new TypeError(`Header name ${name}`);
	}
	const normalizedHeaderName = name.toLocaleLowerCase();
	validateHeaderName(normalizedHeaderName);
	return normalizedHeaderName;
}
function normalizeAndValidateHeaderValue(name, value) {
	if (value === void 0) {
		throw new TypeError(value, name);
	}
	const normalizedHeaderValue = `${value}`.replace(/^[\n\t\r\x20]+|[\n\t\r\x20]+$/g, '');
	validateHeaderValue(name, normalizedHeaderValue);
	return normalizedHeaderValue;
}
function fill$1(headers2, object) {
	if (object[Symbol.iterator]) {
		for (let header of object) {
			if (!header[Symbol.iterator]) {
				throw new TypeError();
			}
			if (typeof header === 'string') {
				throw new TypeError();
			}
			if (!Array.isArray(header)) {
				header = [...header];
			}
			if (header.length !== 2) {
				throw new TypeError();
			}
			headers2.append(header[0], header[1]);
		}
	} else if (object && typeof object === 'object') {
		for (const header of Object.entries(object)) {
			headers2.append(header[0], header[1]);
		}
	} else {
		throw TypeError();
	}
}
var esIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf([][Symbol.iterator]()));
function makeHeadersIterator(iterator) {
	const i2 = {
		next() {
			if (Object.getPrototypeOf(this) !== i2) {
				throw new TypeError(
					"'next' called on an object that does not implement interface Headers Iterator."
				);
			}
			return iterator.next();
		},
		[Symbol.toStringTag]: 'Headers Iterator'
	};
	Object.setPrototypeOf(i2, esIteratorPrototype);
	return Object.setPrototypeOf({}, i2);
}
var HeadersList$2 = class {
	constructor(init2) {
		if (init2 instanceof HeadersList$2) {
			this[kHeadersMap] = new Map(init2[kHeadersMap]);
			this[kHeadersSortedMap] = init2[kHeadersSortedMap];
		} else {
			this[kHeadersMap] = new Map(init2);
			this[kHeadersSortedMap] = null;
		}
	}
	clear() {
		this[kHeadersMap].clear();
		this[kHeadersSortedMap] = null;
	}
	append(name, value) {
		this[kHeadersSortedMap] = null;
		const normalizedName = normalizeAndValidateHeaderName(name);
		const normalizedValue = normalizeAndValidateHeaderValue(name, value);
		const exists = this[kHeadersMap].get(normalizedName);
		if (exists) {
			this[kHeadersMap].set(normalizedName, `${exists}, ${normalizedValue}`);
		} else {
			this[kHeadersMap].set(normalizedName, `${normalizedValue}`);
		}
	}
	set(name, value) {
		this[kHeadersSortedMap] = null;
		const normalizedName = normalizeAndValidateHeaderName(name);
		return this[kHeadersMap].set(normalizedName, value);
	}
	delete(name) {
		this[kHeadersSortedMap] = null;
		const normalizedName = normalizeAndValidateHeaderName(name);
		return this[kHeadersMap].delete(normalizedName);
	}
	get(name) {
		const normalizedName = normalizeAndValidateHeaderName(name);
		return this[kHeadersMap].get(normalizedName) ?? null;
	}
	has(name) {
		const normalizedName = normalizeAndValidateHeaderName(name);
		return this[kHeadersMap].has(normalizedName);
	}
	keys() {
		return this[kHeadersMap].keys();
	}
	values() {
		return this[kHeadersMap].values();
	}
	entries() {
		return this[kHeadersMap].entries();
	}
	[Symbol.iterator]() {
		return this[kHeadersMap][Symbol.iterator]();
	}
};
var Headers$4 = class {
	constructor(...args) {
		if (
			args[0] !== void 0 &&
			!(typeof args[0] === 'object' && args[0] != null) &&
			!Array.isArray(args[0])
		) {
			throw new TypeError(
				"Failed to construct 'Headers': The provided value is not of type '(record<ByteString, ByteString> or sequence<sequence<ByteString>>"
			);
		}
		const init2 = args.length >= 1 ? args[0] ?? {} : {};
		this[kHeadersList$3] = new HeadersList$2();
		this[kGuard$3] = 'none';
		fill$1(this, init2);
	}
	get [Symbol.toStringTag]() {
		return this.constructor.name;
	}
	append(name, value) {
		if (!(this instanceof Headers$4)) {
			throw new TypeError('Illegal invocation');
		}
		if (arguments.length < 2) {
			throw new TypeError(
				`Failed to execute 'append' on 'Headers': 2 arguments required, but only ${arguments.length} present.`
			);
		}
		if (this[kGuard$3] === 'immutable') {
			throw new TypeError('immutable');
		} else if (this[kGuard$3] === 'request-no-cors');
		return this[kHeadersList$3].append(String(name), String(value));
	}
	delete(name) {
		if (!(this instanceof Headers$4)) {
			throw new TypeError('Illegal invocation');
		}
		if (arguments.length < 1) {
			throw new TypeError(
				`Failed to execute 'delete' on 'Headers': 1 argument required, but only ${arguments.length} present.`
			);
		}
		if (this[kGuard$3] === 'immutable') {
			throw new TypeError('immutable');
		} else if (this[kGuard$3] === 'request-no-cors');
		return this[kHeadersList$3].delete(String(name));
	}
	get(name) {
		if (!(this instanceof Headers$4)) {
			throw new TypeError('Illegal invocation');
		}
		if (arguments.length < 1) {
			throw new TypeError(
				`Failed to execute 'get' on 'Headers': 1 argument required, but only ${arguments.length} present.`
			);
		}
		return this[kHeadersList$3].get(String(name));
	}
	has(name) {
		if (!(this instanceof Headers$4)) {
			throw new TypeError('Illegal invocation');
		}
		if (arguments.length < 1) {
			throw new TypeError(
				`Failed to execute 'has' on 'Headers': 1 argument required, but only ${arguments.length} present.`
			);
		}
		return this[kHeadersList$3].has(String(name));
	}
	set(name, value) {
		if (!(this instanceof Headers$4)) {
			throw new TypeError('Illegal invocation');
		}
		if (arguments.length < 2) {
			throw new TypeError(
				`Failed to execute 'set' on 'Headers': 2 arguments required, but only ${arguments.length} present.`
			);
		}
		if (this[kGuard$3] === 'immutable') {
			throw new TypeError('immutable');
		} else if (this[kGuard$3] === 'request-no-cors');
		return this[kHeadersList$3].set(String(name), String(value));
	}
	get [kHeadersSortedMap]() {
		this[kHeadersList$3][kHeadersSortedMap] ??= new Map(
			[...this[kHeadersList$3]].sort((a, b) => (a[0] < b[0] ? -1 : 1))
		);
		return this[kHeadersList$3][kHeadersSortedMap];
	}
	keys() {
		if (!(this instanceof Headers$4)) {
			throw new TypeError('Illegal invocation');
		}
		return makeHeadersIterator(this[kHeadersSortedMap].keys());
	}
	values() {
		if (!(this instanceof Headers$4)) {
			throw new TypeError('Illegal invocation');
		}
		return makeHeadersIterator(this[kHeadersSortedMap].values());
	}
	entries() {
		if (!(this instanceof Headers$4)) {
			throw new TypeError('Illegal invocation');
		}
		return makeHeadersIterator(this[kHeadersSortedMap].entries());
	}
	forEach(callbackFn, thisArg = globalThis) {
		if (!(this instanceof Headers$4)) {
			throw new TypeError('Illegal invocation');
		}
		if (arguments.length < 1) {
			throw new TypeError(
				`Failed to execute 'forEach' on 'Headers': 1 argument required, but only ${arguments.length} present.`
			);
		}
		if (typeof callbackFn !== 'function') {
			throw new TypeError(
				"Failed to execute 'forEach' on 'Headers': parameter 1 is not of type 'Function'."
			);
		}
		for (const [key3, value] of this) {
			callbackFn.apply(thisArg, [value, key3, this]);
		}
	}
	[Symbol.for('nodejs.util.inspect.custom')]() {
		if (!(this instanceof Headers$4)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kHeadersList$3];
	}
};
Headers$4.prototype[Symbol.iterator] = Headers$4.prototype.entries;
Object.defineProperties(Headers$4.prototype, {
	append: kEnumerableProperty$2,
	delete: kEnumerableProperty$2,
	get: kEnumerableProperty$2,
	has: kEnumerableProperty$2,
	set: kEnumerableProperty$2,
	keys: kEnumerableProperty$2,
	values: kEnumerableProperty$2,
	entries: kEnumerableProperty$2,
	forEach: kEnumerableProperty$2
});
var headers = {
	fill: fill$1,
	Headers: Headers$4,
	HeadersList: HeadersList$2,
	normalizeAndValidateHeaderName,
	normalizeAndValidateHeaderValue
};
var { Headers: Headers$3, HeadersList: HeadersList$1, fill } = headers;
var { AbortError: AbortError$1 } = errors$1;
var { extractBody: extractBody$2, cloneBody: cloneBody$1, mixinBody: mixinBody$1 } = body;
var util$2 = util$h;
var { kEnumerableProperty: kEnumerableProperty$1 } = util$2;
var {
	responseURL,
	isValidReasonPhrase,
	toUSVString: toUSVString$1,
	isCancelled: isCancelled$1,
	isAborted: isAborted$1,
	serializeJavascriptValueToJSONString
} = util$g;
var { redirectStatus: redirectStatus$1, nullBodyStatus: nullBodyStatus$1 } = constants$2;
var { kState: kState$2, kHeaders: kHeaders$2, kGuard: kGuard$2, kRealm: kRealm$2 } = symbols;
var { kHeadersList: kHeadersList$2 } = symbols$1;
var assert$3 = import_assert.default;
var Response$2 = class {
	static error() {
		const relevantRealm = { settingsObject: {} };
		const responseObject = new Response$2();
		responseObject[kState$2] = makeNetworkError$1();
		responseObject[kRealm$2] = relevantRealm;
		responseObject[kHeaders$2][kHeadersList$2] = responseObject[kState$2].headersList;
		responseObject[kHeaders$2][kGuard$2] = 'immutable';
		responseObject[kHeaders$2][kRealm$2] = relevantRealm;
		return responseObject;
	}
	static json(data2, init2 = {}) {
		if (arguments.length === 0) {
			throw new TypeError(
				"Failed to execute 'json' on 'Response': 1 argument required, but 0 present."
			);
		}
		if (init2 === null || typeof init2 !== 'object') {
			throw new TypeError(
				`Failed to execute 'json' on 'Response': init must be a RequestInit, found ${typeof init2}.`
			);
		}
		init2 = {
			status: 200,
			statusText: '',
			headers: new HeadersList$1(),
			...init2
		};
		const bytes = new TextEncoder('utf-8').encode(serializeJavascriptValueToJSONString(data2));
		const body4 = extractBody$2(bytes);
		const relevantRealm = { settingsObject: {} };
		const responseObject = new Response$2();
		responseObject[kRealm$2] = relevantRealm;
		responseObject[kHeaders$2][kGuard$2] = 'response';
		responseObject[kHeaders$2][kRealm$2] = relevantRealm;
		initializeResponse(responseObject, init2, { body: body4[0], type: 'application/json' });
		return responseObject;
	}
	static redirect(...args) {
		const relevantRealm = { settingsObject: {} };
		if (args.length < 1) {
			throw new TypeError(
				`Failed to execute 'redirect' on 'Response': 1 argument required, but only ${args.length} present.`
			);
		}
		const status = args.length >= 2 ? args[1] : 302;
		const url = toUSVString$1(args[0]);
		let parsedURL;
		try {
			parsedURL = new URL(url);
		} catch (err) {
			throw Object.assign(new TypeError('Failed to parse URL from ' + url), {
				cause: err
			});
		}
		if (!redirectStatus$1.includes(status)) {
			throw new RangeError('Invalid status code');
		}
		const responseObject = new Response$2();
		responseObject[kRealm$2] = relevantRealm;
		responseObject[kHeaders$2][kGuard$2] = 'immutable';
		responseObject[kHeaders$2][kRealm$2] = relevantRealm;
		responseObject[kState$2].status = status;
		const value = parsedURL.toString();
		responseObject[kState$2].headersList.append('location', value);
		return responseObject;
	}
	constructor(...args) {
		if (args.length >= 1 && typeof args[1] !== 'object' && args[1] !== void 0) {
			throw new TypeError("Failed to construct 'Request': cannot convert to dictionary.");
		}
		const body4 = args.length >= 1 ? args[0] : null;
		const init2 = args.length >= 2 ? args[1] ?? {} : {};
		this[kRealm$2] = { settingsObject: {} };
		this[kState$2] = makeResponse$1({});
		this[kHeaders$2] = new Headers$3();
		this[kHeaders$2][kGuard$2] = 'response';
		this[kHeaders$2][kHeadersList$2] = this[kState$2].headersList;
		this[kHeaders$2][kRealm$2] = this[kRealm$2];
		let bodyWithType = null;
		if (body4 != null) {
			const [extractedBody, type] = extractBody$2(body4);
			bodyWithType = { body: extractedBody, type };
		}
		initializeResponse(this, init2, bodyWithType);
	}
	get [Symbol.toStringTag]() {
		return this.constructor.name;
	}
	get type() {
		if (!(this instanceof Response$2)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kState$2].type;
	}
	get url() {
		if (!(this instanceof Response$2)) {
			throw new TypeError('Illegal invocation');
		}
		let url = responseURL(this[kState$2]);
		if (url == null) {
			return '';
		}
		if (url.hash) {
			url = new URL(url);
			url.hash = '';
		}
		return url.toString();
	}
	get redirected() {
		if (!(this instanceof Response$2)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kState$2].urlList.length > 1;
	}
	get status() {
		if (!(this instanceof Response$2)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kState$2].status;
	}
	get ok() {
		if (!(this instanceof Response$2)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kState$2].status >= 200 && this[kState$2].status <= 299;
	}
	get statusText() {
		if (!(this instanceof Response$2)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kState$2].statusText;
	}
	get headers() {
		if (!(this instanceof Response$2)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kHeaders$2];
	}
	clone() {
		if (!(this instanceof Response$2)) {
			throw new TypeError('Illegal invocation');
		}
		if (this.bodyUsed || (this.body && this.body.locked)) {
			throw new TypeError();
		}
		const clonedResponse = cloneResponse(this[kState$2]);
		const clonedResponseObject = new Response$2();
		clonedResponseObject[kState$2] = clonedResponse;
		clonedResponseObject[kRealm$2] = this[kRealm$2];
		clonedResponseObject[kHeaders$2][kHeadersList$2] = clonedResponse.headersList;
		clonedResponseObject[kHeaders$2][kGuard$2] = this[kHeaders$2][kGuard$2];
		clonedResponseObject[kHeaders$2][kRealm$2] = this[kHeaders$2][kRealm$2];
		return clonedResponseObject;
	}
};
mixinBody$1(Response$2.prototype);
Object.defineProperties(Response$2.prototype, {
	type: kEnumerableProperty$1,
	url: kEnumerableProperty$1,
	status: kEnumerableProperty$1,
	ok: kEnumerableProperty$1,
	redirected: kEnumerableProperty$1,
	statusText: kEnumerableProperty$1,
	headers: kEnumerableProperty$1,
	clone: kEnumerableProperty$1
});
function cloneResponse(response2) {
	if (response2.internalResponse) {
		return filterResponse$1(cloneResponse(response2.internalResponse), response2.type);
	}
	const newResponse = makeResponse$1({ ...response2, body: null });
	if (response2.body != null) {
		newResponse.body = cloneBody$1(response2.body);
	}
	return newResponse;
}
function makeResponse$1(init2) {
	return {
		aborted: false,
		rangeRequested: false,
		timingAllowPassed: false,
		requestIncludesCredentials: false,
		type: 'default',
		status: 200,
		timingInfo: null,
		cacheState: '',
		statusText: '',
		...init2,
		headersList: init2.headersList ? new HeadersList$1(init2.headersList) : new HeadersList$1(),
		urlList: init2.urlList ? [...init2.urlList] : []
	};
}
function makeNetworkError$1(reason) {
	return makeResponse$1({
		type: 'error',
		status: 0,
		error:
			reason instanceof Error
				? reason
				: new Error(reason ? String(reason) : reason, {
						cause: reason instanceof Error ? reason : void 0
				  }),
		aborted: reason && reason.name === 'AbortError'
	});
}
function makeFilteredResponse(response2, state) {
	state = {
		internalResponse: response2,
		...state
	};
	return new Proxy(response2, {
		get(target, p2) {
			return p2 in state ? state[p2] : target[p2];
		},
		set(target, p2, value) {
			assert$3(!(p2 in state));
			target[p2] = value;
			return true;
		}
	});
}
function filterResponse$1(response2, type) {
	if (type === 'basic') {
		return makeFilteredResponse(response2, {
			type: 'basic',
			headersList: response2.headersList
		});
	} else if (type === 'cors') {
		return makeFilteredResponse(response2, {
			type: 'cors',
			headersList: response2.headersList
		});
	} else if (type === 'opaque') {
		return makeFilteredResponse(response2, {
			type: 'opaque',
			urlList: Object.freeze([]),
			status: 0,
			statusText: '',
			body: null
		});
	} else if (type === 'opaqueredirect') {
		return makeFilteredResponse(response2, {
			type: 'opaqueredirect',
			status: 0,
			statusText: '',
			headersList: [],
			body: null
		});
	} else {
		assert$3(false);
	}
}
function makeAppropriateNetworkError$1(fetchParams) {
	assert$3(isCancelled$1(fetchParams));
	return isAborted$1(fetchParams)
		? makeNetworkError$1(new AbortError$1())
		: makeNetworkError$1(fetchParams.controller.terminated.reason);
}
function initializeResponse(response2, init2, body4) {
	if (init2.status != null && (init2.status < 200 || init2.status > 599)) {
		throw new RangeError('init["status"] must be in the range of 200 to 599, inclusive.');
	}
	if ('statusText' in init2 && init2.statusText != null) {
		if (!isValidReasonPhrase(String(init2.statusText))) {
			throw new TypeError('Invalid statusText');
		}
	}
	if ('status' in init2 && init2.status != null) {
		response2[kState$2].status = init2.status;
	}
	if ('statusText' in init2 && init2.statusText != null) {
		response2[kState$2].statusText = init2.statusText;
	}
	if ('headers' in init2 && init2.headers != null) {
		fill(response2[kState$2].headersList, init2.headers);
	}
	if (body4) {
		if (nullBodyStatus$1.includes(response2.status)) {
			throw new TypeError();
		}
		response2[kState$2].body = body4.body;
		if (body4.type != null && !response2[kState$2].headersList.has('Content-Type')) {
			response2[kState$2].headersList.append('content-type', body4.type);
		}
	}
}
var response = {
	makeNetworkError: makeNetworkError$1,
	makeResponse: makeResponse$1,
	makeAppropriateNetworkError: makeAppropriateNetworkError$1,
	filterResponse: filterResponse$1,
	Response: Response$2
};
var { extractBody: extractBody$1, mixinBody, cloneBody } = body;
var { Headers: Headers$2, fill: fillHeaders, HeadersList } = headers;
var util$1 = util$h;
var { isValidHTTPToken, sameOrigin: sameOrigin$1, toUSVString, normalizeMethod } = util$g;
var {
	forbiddenMethods,
	corsSafeListedMethods,
	referrerPolicy,
	requestRedirect,
	requestMode,
	requestCredentials,
	requestCache
} = constants$2;
var { kEnumerableProperty } = util$1;
var {
	kHeaders: kHeaders$1,
	kSignal,
	kState: kState$1,
	kGuard: kGuard$1,
	kRealm: kRealm$1
} = symbols;
var { kHeadersList: kHeadersList$1 } = symbols$1;
var assert$2 = import_assert.default;
var TransformStream$1;
var kInit = Symbol('init');
var requestFinalizer = new FinalizationRegistry(({ signal, abort: abort2 }) => {
	signal.removeEventListener('abort', abort2);
});
var Request$2 = class {
	constructor(...args) {
		if (args[0] === kInit) {
			return;
		}
		if (args.length < 1) {
			throw new TypeError(
				`Failed to construct 'Request': 1 argument required, but only ${args.length} present.`
			);
		}
		if (args.length >= 1 && typeof args[1] !== 'object' && args[1] !== void 0) {
			throw new TypeError("Failed to construct 'Request': cannot convert to dictionary.");
		}
		const input = args[0] instanceof Request$2 ? args[0] : toUSVString(args[0]);
		const init2 = args.length >= 1 ? args[1] ?? {} : {};
		this[kRealm$1] = { settingsObject: {} };
		let request2 = null;
		let fallbackMode = null;
		const baseUrl = this[kRealm$1].settingsObject.baseUrl;
		let signal = null;
		if (typeof input === 'string') {
			let parsedURL;
			try {
				parsedURL = new URL(input, baseUrl);
			} catch (err) {
				throw new TypeError('Failed to parse URL from ' + input, { cause: err });
			}
			if (parsedURL.username || parsedURL.password) {
				throw new TypeError(
					'Request cannot be constructed from a URL that includes credentials: ' + input
				);
			}
			request2 = makeRequest$1({ urlList: [parsedURL] });
			fallbackMode = 'cors';
		} else {
			assert$2(input instanceof Request$2);
			request2 = input[kState$1];
			signal = input[kSignal];
		}
		const origin = this[kRealm$1].settingsObject.origin;
		let window2 = 'client';
		if (
			request2.window?.constructor?.name === 'EnvironmentSettingsObject' &&
			sameOrigin$1(request2.window, origin)
		) {
			window2 = request2.window;
		}
		if (init2.window !== void 0 && init2.window != null) {
			throw new TypeError(`'window' option '${window2}' must be null`);
		}
		if (init2.window !== void 0) {
			window2 = 'no-window';
		}
		request2 = makeRequest$1({
			method: request2.method,
			headersList: request2.headersList,
			unsafeRequest: request2.unsafeRequest,
			client: this[kRealm$1].settingsObject,
			window: window2,
			priority: request2.priority,
			origin: request2.origin,
			referrer: request2.referrer,
			referrerPolicy: request2.referrerPolicy,
			mode: request2.mode,
			credentials: request2.credentials,
			cache: request2.cache,
			redirect: request2.redirect,
			integrity: request2.integrity,
			keepalive: request2.keepalive,
			reloadNavigation: request2.reloadNavigation,
			historyNavigation: request2.historyNavigation,
			urlList: [...request2.urlList]
		});
		if (Object.keys(init2).length > 0) {
			if (request2.mode === 'navigate') {
				request2.mode = 'same-origin';
			}
			request2.reloadNavigation = false;
			request2.historyNavigation = false;
			request2.origin = 'client';
			request2.referrer = 'client';
			request2.referrerPolicy = '';
			request2.url = request2.urlList[request2.urlList.length - 1];
			request2.urlList = [request2.url];
		}
		if (init2.referrer !== void 0) {
			const referrer = init2.referrer;
			if (referrer === '') {
				request2.referrer = 'no-referrer';
			} else {
				let parsedReferrer;
				try {
					parsedReferrer = new URL(referrer, baseUrl);
				} catch (err) {
					throw new TypeError(`Referrer "${referrer}" is not a valid URL.`, { cause: err });
				}
				request2.referrer = parsedReferrer;
			}
		}
		if (init2.referrerPolicy !== void 0) {
			request2.referrerPolicy = init2.referrerPolicy;
			if (!referrerPolicy.includes(request2.referrerPolicy)) {
				throw new TypeError(
					`Failed to construct 'Request': The provided value '${request2.referrerPolicy}' is not a valid enum value of type ReferrerPolicy.`
				);
			}
		}
		let mode;
		if (init2.mode !== void 0) {
			mode = init2.mode;
			if (!requestMode.includes(mode)) {
				throw new TypeError(
					`Failed to construct 'Request': The provided value '${request2.mode}' is not a valid enum value of type RequestMode.`
				);
			}
		} else {
			mode = fallbackMode;
		}
		if (mode === 'navigate') {
			throw new TypeError();
		}
		if (mode != null) {
			request2.mode = mode;
		}
		if (init2.credentials !== void 0) {
			request2.credentials = init2.credentials;
			if (!requestCredentials.includes(request2.credentials)) {
				throw new TypeError(
					`Failed to construct 'Request': The provided value '${request2.credentials}' is not a valid enum value of type RequestCredentials.`
				);
			}
		}
		if (init2.cache !== void 0) {
			request2.cache = init2.cache;
			if (!requestCache.includes(request2.cache)) {
				throw new TypeError(
					`Failed to construct 'Request': The provided value '${request2.cache}' is not a valid enum value of type RequestCache.`
				);
			}
		}
		if (request2.cache === 'only-if-cached' && request2.mode !== 'same-origin') {
			throw new TypeError("'only-if-cached' can be set only with 'same-origin' mode");
		}
		if (init2.redirect !== void 0) {
			request2.redirect = init2.redirect;
			if (!requestRedirect.includes(request2.redirect)) {
				throw new TypeError(
					`Failed to construct 'Request': The provided value '${request2.redirect}' is not a valid enum value of type RequestRedirect.`
				);
			}
		}
		if (init2.integrity !== void 0 && init2.integrity != null) {
			request2.integrity = String(init2.integrity);
		}
		if (init2.keepalive !== void 0) {
			request2.keepalive = Boolean(init2.keepalive);
		}
		if (init2.method !== void 0) {
			let method = init2.method;
			if (!isValidHTTPToken(init2.method)) {
				throw TypeError(`'${init2.method}' is not a valid HTTP method.`);
			}
			if (forbiddenMethods.indexOf(method.toUpperCase()) !== -1) {
				throw TypeError(`'${init2.method}' HTTP method is unsupported.`);
			}
			method = normalizeMethod(init2.method);
			request2.method = method;
		}
		if (init2.signal !== void 0) {
			signal = init2.signal;
		}
		this[kState$1] = request2;
		const ac = new AbortController();
		this[kSignal] = ac.signal;
		this[kSignal][kRealm$1] = this[kRealm$1];
		if (signal != null) {
			if (
				!signal ||
				typeof signal.aborted !== 'boolean' ||
				typeof signal.addEventListener !== 'function'
			) {
				throw new TypeError(
					"Failed to construct 'Request': member signal is not of type AbortSignal."
				);
			}
			if (signal.aborted) {
				ac.abort();
			} else {
				const abort2 = () => ac.abort();
				signal.addEventListener('abort', abort2, { once: true });
				requestFinalizer.register(this, { signal, abort: abort2 });
			}
		}
		this[kHeaders$1] = new Headers$2();
		this[kHeaders$1][kHeadersList$1] = request2.headersList;
		this[kHeaders$1][kGuard$1] = 'request';
		this[kHeaders$1][kRealm$1] = this[kRealm$1];
		if (mode === 'no-cors') {
			if (!corsSafeListedMethods.includes(request2.method)) {
				throw new TypeError(`'${request2.method} is unsupported in no-cors mode.`);
			}
			this[kHeaders$1][kGuard$1] = 'request-no-cors';
		}
		if (Object.keys(init2).length !== 0) {
			let headers2 = new Headers$2(this[kHeaders$1]);
			if (init2.headers !== void 0) {
				headers2 = init2.headers;
			}
			this[kHeaders$1][kHeadersList$1].clear();
			if (headers2.constructor.name === 'Headers') {
				for (const [key3, val] of headers2) {
					this[kHeaders$1].append(key3, val);
				}
			} else {
				fillHeaders(this[kHeaders$1], headers2);
			}
		}
		const inputBody = input instanceof Request$2 ? input[kState$1].body : null;
		if (
			((init2.body !== void 0 && init2.body != null) || inputBody != null) &&
			(request2.method === 'GET' || request2.method === 'HEAD')
		) {
			throw new TypeError('Request with GET/HEAD method cannot have body.');
		}
		let initBody = null;
		if (init2.body !== void 0 && init2.body != null) {
			const [extractedBody, contentType] = extractBody$1(init2.body, request2.keepalive);
			initBody = extractedBody;
			if (contentType && !this[kHeaders$1].has('content-type')) {
				this[kHeaders$1].append('content-type', contentType);
			}
		}
		const inputOrInitBody = initBody ?? inputBody;
		if (inputOrInitBody != null && inputOrInitBody.source == null) {
			if (request2.mode !== 'same-origin' && request2.mode !== 'cors') {
				throw new TypeError(
					'If request is made from ReadableStream, mode should be "same-origin" or "cors"'
				);
			}
			request2.useCORSPreflightFlag = true;
		}
		let finalBody = inputOrInitBody;
		if (initBody == null && inputBody != null) {
			if (util$1.isDisturbed(inputBody.stream) || inputBody.stream.locked) {
				throw new TypeError(
					'Cannot construct a Request with a Request object that has already been used.'
				);
			}
			if (!TransformStream$1) {
				TransformStream$1 = import_web.default.TransformStream;
			}
			const identityTransform = new TransformStream$1();
			inputBody.stream.pipeThrough(identityTransform);
			finalBody = {
				source: inputBody.source,
				length: inputBody.length,
				stream: identityTransform.readable
			};
		}
		this[kState$1].body = finalBody;
	}
	get [Symbol.toStringTag]() {
		return this.constructor.name;
	}
	get method() {
		if (!(this instanceof Request$2)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kState$1].method;
	}
	get url() {
		if (!(this instanceof Request$2)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kState$1].url.toString();
	}
	get headers() {
		if (!(this instanceof Request$2)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kHeaders$1];
	}
	get destination() {
		if (!(this instanceof Request$2)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kState$1].destination;
	}
	get referrer() {
		if (!(this instanceof Request$2)) {
			throw new TypeError('Illegal invocation');
		}
		if (this[kState$1].referrer === 'no-referrer') {
			return '';
		}
		if (this[kState$1].referrer === 'client') {
			return 'about:client';
		}
		return this[kState$1].referrer.toString();
	}
	get referrerPolicy() {
		if (!(this instanceof Request$2)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kState$1].referrerPolicy;
	}
	get mode() {
		if (!(this instanceof Request$2)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kState$1].mode;
	}
	get credentials() {
		return this[kState$1].credentials;
	}
	get cache() {
		if (!(this instanceof Request$2)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kState$1].cache;
	}
	get redirect() {
		if (!(this instanceof Request$2)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kState$1].redirect;
	}
	get integrity() {
		if (!(this instanceof Request$2)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kState$1].integrity;
	}
	get keepalive() {
		if (!(this instanceof Request$2)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kState$1].keepalive;
	}
	get isReloadNavigation() {
		if (!(this instanceof Request$2)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kState$1].reloadNavigation;
	}
	get isHistoryNavigation() {
		if (!(this instanceof Request$2)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kState$1].historyNavigation;
	}
	get signal() {
		if (!(this instanceof Request$2)) {
			throw new TypeError('Illegal invocation');
		}
		return this[kSignal];
	}
	clone() {
		if (!(this instanceof Request$2)) {
			throw new TypeError('Illegal invocation');
		}
		if (this.bodyUsed || this.body?.locked) {
			throw new TypeError('unusable');
		}
		const clonedRequest = cloneRequest(this[kState$1]);
		const clonedRequestObject = new Request$2(kInit);
		clonedRequestObject[kState$1] = clonedRequest;
		clonedRequestObject[kRealm$1] = this[kRealm$1];
		clonedRequestObject[kHeaders$1] = new Headers$2();
		clonedRequestObject[kHeaders$1][kHeadersList$1] = clonedRequest.headersList;
		clonedRequestObject[kHeaders$1][kGuard$1] = this[kHeaders$1][kGuard$1];
		clonedRequestObject[kHeaders$1][kRealm$1] = this[kHeaders$1][kRealm$1];
		const ac = new AbortController();
		if (this.signal.aborted) {
			ac.abort();
		} else {
			this.signal.addEventListener(
				'abort',
				function () {
					ac.abort();
				},
				{ once: true }
			);
		}
		clonedRequestObject[kSignal] = ac.signal;
		return clonedRequestObject;
	}
};
mixinBody(Request$2.prototype);
function makeRequest$1(init2) {
	const request2 = {
		method: 'GET',
		localURLsOnly: false,
		unsafeRequest: false,
		body: null,
		client: null,
		reservedClient: null,
		replacesClientId: '',
		window: 'client',
		keepalive: false,
		serviceWorkers: 'all',
		initiator: '',
		destination: '',
		priority: null,
		origin: 'client',
		policyContainer: 'client',
		referrer: 'client',
		referrerPolicy: '',
		mode: 'no-cors',
		useCORSPreflightFlag: false,
		credentials: 'same-origin',
		useCredentials: false,
		cache: 'default',
		redirect: 'follow',
		integrity: '',
		cryptoGraphicsNonceMetadata: '',
		parserMetadata: '',
		reloadNavigation: false,
		historyNavigation: false,
		userActivation: false,
		taintedOrigin: false,
		redirectCount: 0,
		responseTainting: 'basic',
		preventNoCacheCacheControlHeaderModification: false,
		done: false,
		timingAllowFailed: false,
		...init2,
		headersList: init2.headersList ? new HeadersList(init2.headersList) : new HeadersList()
	};
	request2.url = request2.urlList[0];
	return request2;
}
function cloneRequest(request2) {
	const newRequest = makeRequest$1({ ...request2, body: null });
	if (request2.body != null) {
		newRequest.body = cloneBody(request2.body);
	}
	return newRequest;
}
Object.defineProperties(Request$2.prototype, {
	method: kEnumerableProperty,
	url: kEnumerableProperty,
	headers: kEnumerableProperty,
	redirect: kEnumerableProperty,
	clone: kEnumerableProperty,
	signal: kEnumerableProperty
});
var request = { Request: Request$2, makeRequest: makeRequest$1 };
var assert$1 = import_assert.default;
var { atob } = import_buffer.default;
var encoder = new TextEncoder();
function dataURLProcessor$1(dataURL2) {
	assert$1(dataURL2.protocol === 'data:');
	let input = URLSerializer(dataURL2, true);
	input = input.slice(5);
	const position3 = { position: 0 };
	let mimeType = collectASequenceOfCodePoints((char) => char !== ',', input, position3);
	const mimeTypeLength = mimeType.length;
	mimeType = mimeType.replace(/^(\u0020)+|(\u0020)+$/g, '');
	if (position3.position >= input.length) {
		return 'failure';
	}
	position3.position++;
	const encodedBody = input.slice(mimeTypeLength + 1);
	let body4 = stringPercentDecode(encodedBody);
	if (/;(\u0020){0,}base64$/i.test(mimeType)) {
		const stringBody = decodeURIComponent(new TextDecoder('utf-8').decode(body4));
		body4 = forgivingBase64(stringBody);
		if (body4 === 'failure') {
			return 'failure';
		}
		mimeType = mimeType.slice(0, -6);
		mimeType = mimeType.replace(/(\u0020)+$/, '');
		mimeType = mimeType.slice(0, -1);
	}
	if (mimeType.startsWith(';')) {
		mimeType = 'text/plain' + mimeType;
	}
	let mimeTypeRecord = parseMIMEType(mimeType);
	if (mimeTypeRecord === 'failure') {
		mimeTypeRecord = parseMIMEType('text/plain;charset=US-ASCII');
	}
	return { mimeType: mimeTypeRecord, body: body4 };
}
function URLSerializer(url, excludeFragment = false) {
	let output = url.protocol;
	if (url.host.length > 0) {
		output += '//';
		if (url.username.length > 0 || url.password.length > 0) {
			output += url.username;
			if (url.password.length > 0) {
				output += ':' + url.password;
			}
			output += '@';
		}
		output += decodeURIComponent(url.host);
		if (url.port.length > 0) {
			output += ':' + url.port;
		}
	}
	if (
		url.host.length === 0 &&
		url.pathname.length > 1 &&
		url.href.slice(url.protocol.length + 1)[0] === '.'
	) {
		output += '/.';
	}
	output += url.pathname;
	if (url.search.length > 0) {
		output += url.search;
	}
	if (excludeFragment === false && url.hash.length > 0) {
		output += url.hash;
	}
	return output;
}
function collectASequenceOfCodePoints(condition, input, position3) {
	let result = '';
	while (position3.position < input.length && condition(input[position3.position])) {
		result += input[position3.position];
		position3.position++;
	}
	return result;
}
function stringPercentDecode(input) {
	const bytes = encoder.encode(input);
	return percentDecode(bytes);
}
function percentDecode(input) {
	const output = [];
	for (let i2 = 0; i2 < input.length; i2++) {
		const byte = input[i2];
		if (byte !== 37) {
			output.push(byte);
		} else if (
			byte === 37 &&
			!/^[0-9A-Fa-f]{2}$/i.test(String.fromCharCode(input[i2 + 1], input[i2 + 2]))
		) {
			output.push(37);
		} else {
			const nextTwoBytes = String.fromCharCode(input[i2 + 1], input[i2 + 2]);
			const bytePoint = Number.parseInt(nextTwoBytes, 16);
			output.push(bytePoint);
			i2 += 2;
		}
	}
	return Uint8Array.of(...output);
}
function parseMIMEType(input) {
	input = input.trim();
	const position3 = { position: 0 };
	const type = collectASequenceOfCodePoints((char) => char !== '/', input, position3);
	if (type.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(type)) {
		return 'failure';
	}
	if (position3.position > input.length) {
		return 'failure';
	}
	position3.position++;
	let subtype = collectASequenceOfCodePoints((char) => char !== ';', input, position3);
	subtype = subtype.trim();
	if (subtype.length === 0 || !/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(subtype)) {
		return 'failure';
	}
	const mimeType = {
		type: type.toLowerCase(),
		subtype: subtype.toLowerCase(),
		parameters: /* @__PURE__ */ new Map()
	};
	while (position3.position < input.length) {
		position3.position++;
		collectASequenceOfCodePoints(
			(char) => /(\u000A|\u000D|\u0009|\u0020)/.test(char),
			input,
			position3
		);
		let parameterName = collectASequenceOfCodePoints(
			(char) => char !== ';' && char !== '=',
			input,
			position3
		);
		parameterName = parameterName.toLowerCase();
		if (position3.position < input.length) {
			if (input[position3.position] === ';') {
				continue;
			}
			position3.position++;
		}
		if (position3.position > input.length) {
			break;
		}
		let parameterValue = null;
		if (input[position3.position] === '"') {
			parameterValue = collectAnHTTPQuotedString(input, position3);
			collectASequenceOfCodePoints((char) => char !== ';', input, position3);
		} else {
			parameterValue = collectASequenceOfCodePoints((char) => char !== ';', input, position3);
			parameterValue = parameterValue.trim();
			if (parameterValue.length === 0) {
				continue;
			}
		}
		if (
			parameterName.length !== 0 &&
			/^[!#$%&'*+-.^_|~A-z0-9]+$/.test(parameterName) &&
			!/^(\u0009|\x{0020}-\x{007E}|\x{0080}-\x{00FF})+$/.test(parameterValue) &&
			!mimeType.parameters.has(parameterName)
		) {
			mimeType.parameters.set(parameterName, parameterValue);
		}
	}
	return mimeType;
}
function forgivingBase64(data2) {
	data2 = data2.replace(/[\u0009\u000A\u000C\u000D\u0020]/g, '');
	if (data2.length % 4 === 0) {
		data2 = data2.replace(/=?=$/, '');
	}
	if (data2.length % 4 === 1) {
		return 'failure';
	}
	if (/[^+/0-9A-Za-z]/.test(data2)) {
		return 'failure';
	}
	const binary = atob(data2);
	const bytes = new Uint8Array(binary.length);
	for (let byte = 0; byte < binary.length; byte++) {
		bytes[byte] = binary.charCodeAt(byte);
	}
	return bytes;
}
function collectAnHTTPQuotedString(input, position3, extractValue) {
	const positionStart = position3.position;
	let value = '';
	assert$1(input[position3.position] === '"');
	position3.position++;
	while (true) {
		value += collectASequenceOfCodePoints(
			(char) => char !== '"' && char !== '\\',
			input,
			position3
		);
		if (position3.position >= input.length) {
			break;
		}
		const quoteOrBackslash = input[position3.position];
		position3.position++;
		if (quoteOrBackslash === '\\') {
			if (position3.position >= input.length) {
				value += '\\';
				break;
			}
			value += input[position3.position];
			position3.position++;
		} else {
			assert$1(quoteOrBackslash === '"');
			break;
		}
	}
	if (extractValue) {
		return value;
	}
	return input.slice(positionStart, position3.position);
}
var dataURL = {
	dataURLProcessor: dataURLProcessor$1,
	URLSerializer,
	collectASequenceOfCodePoints,
	stringPercentDecode,
	parseMIMEType,
	collectAnHTTPQuotedString
};
var {
	Response: Response$1,
	makeNetworkError,
	makeAppropriateNetworkError,
	filterResponse,
	makeResponse
} = response;
var { Headers: Headers$1 } = headers;
var { Request: Request$1, makeRequest } = request;
var zlib = import_zlib.default;
var {
	matchRequestIntegrity,
	makePolicyContainer,
	clonePolicyContainer,
	requestBadPort,
	TAOCheck,
	appendRequestOriginHeader,
	responseLocationURL,
	requestCurrentURL,
	setRequestReferrerPolicyOnRedirect,
	tryUpgradeRequestToAPotentiallyTrustworthyURL,
	createOpaqueTimingInfo,
	appendFetchMetadata,
	corsCheck,
	crossOriginResourcePolicyCheck,
	determineRequestsReferrer,
	coarsenedSharedCurrentTime,
	createDeferredPromise,
	isBlobLike,
	sameOrigin,
	isCancelled,
	isAborted
} = util$g;
var { kState, kHeaders, kGuard, kRealm } = symbols;
var { AbortError } = errors$1;
var assert = import_assert.default;
var { safelyExtractBody, extractBody } = body;
var { redirectStatus, nullBodyStatus, safeMethods, requestBodyHeader, subresource } = constants$2;
var { kHeadersList } = symbols$1;
var EE = import_events.default;
var { Readable, pipeline } = import_stream.default;
var { isErrored, isReadable } = util$h;
var { dataURLProcessor } = dataURL;
var { TransformStream } = import_web.default;
var resolveObjectURL;
var ReadableStream2;
var Fetch = class extends EE {
	constructor(dispatcher2) {
		super();
		this.dispatcher = dispatcher2;
		this.connection = null;
		this.dump = false;
		this.state = 'ongoing';
	}
	terminate(reason) {
		if (this.state !== 'ongoing') {
			return;
		}
		this.state = 'terminated';
		this.connection?.destroy(reason);
		this.emit('terminated', reason);
	}
	abort() {
		if (this.state !== 'ongoing') {
			return;
		}
		const reason = new AbortError();
		this.state = 'aborted';
		this.connection?.destroy(reason);
		this.emit('terminated', reason);
	}
};
async function fetch$1(...args) {
	if (args.length < 1) {
		throw new TypeError(
			`Failed to execute 'fetch' on 'Window': 1 argument required, but only ${args.length} present.`
		);
	}
	if (args.length >= 1 && typeof args[1] !== 'object' && args[1] !== void 0) {
		throw new TypeError("Failed to execute 'fetch' on 'Window': cannot convert to dictionary.");
	}
	const resource = args[0];
	const init2 = args.length >= 1 ? args[1] ?? {} : {};
	const p2 = createDeferredPromise();
	const requestObject = new Request$1(resource, init2);
	const request2 = requestObject[kState];
	if (requestObject.signal.aborted) {
		abortFetch(p2, request2, null);
		return p2.promise;
	}
	const globalObject = request2.client.globalObject;
	if (globalObject?.constructor?.name === 'ServiceWorkerGlobalScope') {
		request2.serviceWorkers = 'none';
	}
	let responseObject = null;
	const relevantRealm = null;
	let locallyAborted = false;
	let controller = null;
	requestObject.signal.addEventListener(
		'abort',
		() => {
			locallyAborted = true;
			abortFetch(p2, request2, responseObject);
			if (controller != null) {
				controller.abort();
			}
		},
		{ once: true }
	);
	const handleFetchDone = (response2) => finalizeAndReportTiming(response2);
	const processResponse = (response2) => {
		if (locallyAborted) {
			return;
		}
		if (response2.aborted) {
			abortFetch(p2, request2, responseObject);
			return;
		}
		if (response2.type === 'error') {
			p2.reject(Object.assign(new TypeError('fetch failed'), { cause: response2.error }));
			return;
		}
		responseObject = new Response$1();
		responseObject[kState] = response2;
		responseObject[kRealm] = relevantRealm;
		responseObject[kHeaders][kHeadersList] = response2.headersList;
		responseObject[kHeaders][kGuard] = 'immutable';
		responseObject[kHeaders][kRealm] = relevantRealm;
		p2.resolve(responseObject);
	};
	controller = fetching({
		request: request2,
		processResponseEndOfBody: handleFetchDone,
		processResponse,
		dispatcher: this
	});
	return p2.promise;
}
function finalizeAndReportTiming(response2, initiatorType) {
	if (response2.type === 'error' && response2.aborted) {
		return;
	}
	if (!response2.urlList?.length) {
		return;
	}
	const originalURL = response2.urlList[0];
	let timingInfo = response2.timingInfo;
	response2.cacheState;
	if (!/^https?:/.test(originalURL.protocol)) {
		return;
	}
	if (timingInfo === null) {
		return;
	}
	if (!timingInfo.timingAllowPassed) {
		timingInfo = createOpaqueTimingInfo({
			startTime: timingInfo.startTime
		});
	}
	response2.timingInfo.endTime = coarsenedSharedCurrentTime();
	response2.timingInfo = timingInfo;
}
function abortFetch(p2, request2, responseObject) {
	const error2 = new AbortError();
	p2.reject(error2);
	if (request2.body != null && isReadable(request2.body?.stream)) {
		request2.body.stream.cancel(error2).catch((err) => {
			if (err.code === 'ERR_INVALID_STATE') {
				return;
			}
			throw err;
		});
	}
	if (responseObject == null) {
		return;
	}
	const response2 = responseObject[kState];
	if (response2.body != null && isReadable(response2.body?.stream)) {
		response2.body.stream.cancel(error2).catch((err) => {
			if (err.code === 'ERR_INVALID_STATE') {
				return;
			}
			throw err;
		});
	}
}
function fetching({
	request: request2,
	processRequestBodyChunkLength,
	processRequestEndOfBody,
	processResponse,
	processResponseEndOfBody,
	processResponseConsumeBody,
	useParallelQueue = false,
	dispatcher: dispatcher2
}) {
	let taskDestination = null;
	let crossOriginIsolatedCapability = false;
	if (request2.client != null) {
		taskDestination = request2.client.globalObject;
		crossOriginIsolatedCapability = request2.client.crossOriginIsolatedCapability;
	}
	const currenTime = coarsenedSharedCurrentTime(crossOriginIsolatedCapability);
	const timingInfo = createOpaqueTimingInfo({
		startTime: currenTime
	});
	const fetchParams = {
		controller: new Fetch(dispatcher2),
		request: request2,
		timingInfo,
		processRequestBodyChunkLength,
		processRequestEndOfBody,
		processResponse,
		processResponseConsumeBody,
		processResponseEndOfBody,
		taskDestination,
		crossOriginIsolatedCapability
	};
	assert(!request2.body || request2.body.stream);
	if (request2.window === 'client') {
		request2.window =
			request2.client?.globalObject?.constructor?.name === 'Window' ? request2.client : 'no-window';
	}
	if (request2.origin === 'client') {
		request2.origin = request2.client?.origin;
	}
	if (request2.policyContainer === 'client') {
		if (request2.client != null) {
			request2.policyContainer = clonePolicyContainer(request2.client.policyContainer);
		} else {
			request2.policyContainer = makePolicyContainer();
		}
	}
	if (!request2.headersList.has('accept')) {
		const value = '*/*';
		request2.headersList.append('accept', value);
	}
	if (!request2.headersList.has('accept-language')) {
		request2.headersList.append('accept-language', '*');
	}
	if (request2.priority === null);
	if (subresource.includes(request2.destination));
	mainFetch(fetchParams).catch((err) => {
		fetchParams.controller.terminate(err);
	});
	return fetchParams.controller;
}
async function mainFetch(fetchParams, recursive = false) {
	const request2 = fetchParams.request;
	let response2 = null;
	if (request2.localURLsOnly && !/^(about|blob|data):/.test(requestCurrentURL(request2).protocol)) {
		response2 = makeNetworkError('local URLs only');
	}
	tryUpgradeRequestToAPotentiallyTrustworthyURL(request2);
	if (requestBadPort(request2) === 'blocked') {
		response2 = makeNetworkError('bad port');
	}
	if (request2.referrerPolicy === '') {
		request2.referrerPolicy = request2.policyContainer.referrerPolicy;
	}
	if (request2.referrer !== 'no-referrer') {
		request2.referrer = determineRequestsReferrer(request2);
	}
	if (response2 === null) {
		response2 = await (async () => {
			const currentURL = requestCurrentURL(request2);
			if (
				(sameOrigin(currentURL, request2.url) && request2.responseTainting === 'basic') ||
				currentURL.protocol === 'data:' ||
				request2.mode === 'navigate' ||
				request2.mode === 'websocket'
			) {
				request2.responseTainting = 'basic';
				return await schemeFetch(fetchParams);
			}
			if (request2.mode === 'same-origin') {
				return makeNetworkError('request mode cannot be "same-origin"');
			}
			if (request2.mode === 'no-cors') {
				if (request2.redirect !== 'follow') {
					return makeNetworkError('redirect mode cannot be "follow" for "no-cors" request');
				}
				request2.responseTainting = 'opaque';
				return await schemeFetch(fetchParams);
			}
			if (!/^https?:/.test(requestCurrentURL(request2).protocol)) {
				return makeNetworkError('URL scheme must be a HTTP(S) scheme');
			}
			request2.responseTainting = 'cors';
			return await httpFetch(fetchParams);
		})();
	}
	if (recursive) {
		return response2;
	}
	if (response2.status !== 0 && !response2.internalResponse) {
		if (request2.responseTainting === 'cors');
		if (request2.responseTainting === 'basic') {
			response2 = filterResponse(response2, 'basic');
		} else if (request2.responseTainting === 'cors') {
			response2 = filterResponse(response2, 'cors');
		} else if (request2.responseTainting === 'opaque') {
			response2 = filterResponse(response2, 'opaque');
		} else {
			assert(false);
		}
	}
	let internalResponse = response2.status === 0 ? response2 : response2.internalResponse;
	if (internalResponse.urlList.length === 0) {
		internalResponse.urlList.push(...request2.urlList);
	}
	if (!request2.timingAllowFailed) {
		response2.timingAllowPassed = true;
	}
	if (
		response2.type === 'opaque' &&
		internalResponse.status === 206 &&
		internalResponse.rangeRequested &&
		!request2.headers.has('range')
	) {
		response2 = internalResponse = makeNetworkError();
	}
	if (
		response2.status !== 0 &&
		(request2.method === 'HEAD' ||
			request2.method === 'CONNECT' ||
			nullBodyStatus.includes(internalResponse.status))
	) {
		internalResponse.body = null;
		fetchParams.controller.dump = true;
	}
	if (request2.integrity) {
		const processBodyError = (reason) => fetchFinale(fetchParams, makeNetworkError(reason));
		if (request2.responseTainting === 'opaque' || response2.body == null) {
			processBodyError(response2.error);
			return;
		}
		const processBody = (bytes) => {
			if (!matchRequestIntegrity(request2, bytes)) {
				processBodyError('integrity mismatch');
				return;
			}
			response2.body = safelyExtractBody(bytes)[0];
			fetchFinale(fetchParams, response2);
		};
		try {
			processBody(await response2.arrayBuffer());
		} catch (err) {
			processBodyError(err);
		}
	} else {
		fetchFinale(fetchParams, response2);
	}
}
async function schemeFetch(fetchParams) {
	const { request: request2 } = fetchParams;
	const { protocol: scheme2, pathname: path } = requestCurrentURL(request2);
	switch (scheme2) {
		case 'about:': {
			if (path === 'blank') {
				const resp = makeResponse({
					statusText: 'OK',
					headersList: [['content-type', 'text/html;charset=utf-8']]
				});
				resp.urlList = [new URL('about:blank')];
				return resp;
			}
			return makeNetworkError('invalid path called');
		}
		case 'blob:': {
			resolveObjectURL = resolveObjectURL || import_buffer.default.resolveObjectURL;
			const currentURL = requestCurrentURL(request2);
			if (currentURL.search.length !== 0) {
				return makeNetworkError('NetworkError when attempting to fetch resource.');
			}
			const blob = resolveObjectURL(currentURL.toString());
			if (request2.method !== 'GET' || !isBlobLike(blob)) {
				return makeNetworkError('invalid method');
			}
			const response2 = makeResponse({ statusText: 'OK', urlList: [currentURL] });
			response2.headersList.set('content-length', `${blob.size}`);
			response2.headersList.set('content-type', blob.type);
			response2.body = extractBody(blob)[0];
			return response2;
		}
		case 'data:': {
			const currentURL = requestCurrentURL(request2);
			const dataURLStruct = dataURLProcessor(currentURL);
			if (dataURLStruct === 'failure') {
				return makeNetworkError('failed to fetch the data URL');
			}
			const { mimeType } = dataURLStruct;
			let contentType = `${mimeType.type}/${mimeType.subtype}`;
			const contentTypeParams = [];
			if (mimeType.parameters.size > 0) {
				contentType += ';';
			}
			for (const [key3, value] of mimeType.parameters) {
				if (value.length > 0) {
					contentTypeParams.push(`${key3}=${value}`);
				} else {
					contentTypeParams.push(key3);
				}
			}
			contentType += contentTypeParams.join(',');
			return makeResponse({
				statusText: 'OK',
				headersList: [['content-type', contentType]],
				body: extractBody(dataURLStruct.body)[0]
			});
		}
		case 'file:': {
			return makeNetworkError('not implemented... yet...');
		}
		case 'http:':
		case 'https:': {
			return await httpFetch(fetchParams).catch((err) => makeNetworkError(err));
		}
		default: {
			return makeNetworkError('unknown scheme');
		}
	}
}
function finalizeResponse(fetchParams, response2) {
	fetchParams.request.done = true;
	if (fetchParams.processResponseDone != null) {
		queueMicrotask(() => fetchParams.processResponseDone(response2));
	}
}
async function fetchFinale(fetchParams, response2) {
	if (response2.type === 'error') {
		response2.urlList = [fetchParams.request.urlList[0]];
		response2.timingInfo = createOpaqueTimingInfo({
			startTime: fetchParams.timingInfo.startTime
		});
	}
	const processResponseEndOfBody = () => {
		fetchParams.request.done = true;
		if (fetchParams.processResponseEndOfBody != null) {
			queueMicrotask(() => fetchParams.processResponseEndOfBody(response2));
		}
	};
	if (fetchParams.processResponse != null) {
		queueMicrotask(() => fetchParams.processResponse(response2));
	}
	if (response2.body == null) {
		processResponseEndOfBody();
	} else {
		const identityTransformAlgorithm = (chunk, controller) => {
			controller.enqueue(chunk);
		};
		const transformStream = new TransformStream({
			start() {},
			transform: identityTransformAlgorithm,
			flush: processResponseEndOfBody
		});
		response2.body = { stream: response2.body.stream.pipeThrough(transformStream) };
	}
	if (fetchParams.processResponseConsumeBody != null) {
		const processBody = (nullOrBytes) =>
			fetchParams.processResponseConsumeBody(response2, nullOrBytes);
		const processBodyError = (failure) =>
			fetchParams.processResponseConsumeBody(response2, failure);
		if (response2.body == null) {
			queueMicrotask(() => processBody(null));
		} else {
			try {
				processBody(await response2.body.stream.arrayBuffer());
			} catch (err) {
				processBodyError(err);
			}
		}
	}
}
async function httpFetch(fetchParams) {
	const request2 = fetchParams.request;
	let response2 = null;
	let actualResponse = null;
	const timingInfo = fetchParams.timingInfo;
	if (request2.serviceWorkers === 'all');
	if (response2 === null) {
		if (request2.redirect === 'follow') {
			request2.serviceWorkers = 'none';
		}
		actualResponse = response2 = await httpNetworkOrCacheFetch(fetchParams);
		if (request2.responseTainting === 'cors' && corsCheck(request2, response2) === 'failure') {
			return makeNetworkError('cors failure');
		}
		if (TAOCheck(request2, response2) === 'failure') {
			request2.timingAllowFailed = true;
		}
	}
	if (
		(request2.responseTainting === 'opaque' || response2.type === 'opaque') &&
		crossOriginResourcePolicyCheck(
			request2.origin,
			request2.client,
			request2.destination,
			actualResponse
		) === 'blocked'
	) {
		return makeNetworkError('blocked');
	}
	if (redirectStatus.includes(actualResponse.status)) {
		fetchParams.controller.connection.destroy();
		if (request2.redirect === 'error') {
			response2 = makeNetworkError();
		} else if (request2.redirect === 'manual') {
			response2 = actualResponse;
		} else if (request2.redirect === 'follow') {
			response2 = await httpRedirectFetch(fetchParams, response2);
		} else {
			assert(false);
		}
	}
	response2.timingInfo = timingInfo;
	return response2;
}
async function httpRedirectFetch(fetchParams, response2) {
	const request2 = fetchParams.request;
	const actualResponse = response2.internalResponse ? response2.internalResponse : response2;
	let locationURL;
	try {
		locationURL = responseLocationURL(actualResponse, requestCurrentURL(request2).hash);
		if (locationURL == null) {
			return response2;
		}
	} catch (err) {
		return makeNetworkError(err);
	}
	if (!/^https?:/.test(locationURL.protocol)) {
		return makeNetworkError('URL scheme must be a HTTP(S) scheme');
	}
	if (request2.redirectCount === 20) {
		return makeNetworkError('redirect count exceeded');
	}
	request2.redirectCount += 1;
	if (
		request2.mode === 'cors' &&
		(locationURL.username || locationURL.password) &&
		!sameOrigin(request2, locationURL)
	) {
		return makeNetworkError('cross origin not allowed for request mode "cors"');
	}
	if (request2.responseTainting === 'cors' && (locationURL.username || locationURL.password)) {
		return makeNetworkError('URL cannot contain credentials for request mode "cors"');
	}
	if (actualResponse.status !== 303 && request2.body != null && request2.body.source == null) {
		return makeNetworkError();
	}
	if (
		([301, 302].includes(actualResponse.status) && request2.method === 'POST') ||
		(actualResponse.status === 303 && !['GET', 'HEADER'].includes(request2.method))
	) {
		request2.method = 'GET';
		request2.body = null;
		for (const headerName of requestBodyHeader) {
			request2.headersList.delete(headerName);
		}
	}
	if (request2.body != null) {
		assert(request2.body.source);
		request2.body = safelyExtractBody(request2.body.source)[0];
	}
	const timingInfo = fetchParams.timingInfo;
	timingInfo.redirectEndTime = timingInfo.postRedirectStartTime = coarsenedSharedCurrentTime(
		fetchParams.crossOriginIsolatedCapability
	);
	if (timingInfo.redirectStartTime === 0) {
		timingInfo.redirectStartTime = timingInfo.startTime;
	}
	request2.urlList.push(locationURL);
	setRequestReferrerPolicyOnRedirect(request2, actualResponse);
	return mainFetch(fetchParams, true);
}
async function httpNetworkOrCacheFetch(
	fetchParams,
	isAuthenticationFetch = false,
	isNewConnectionFetch = false
) {
	const request2 = fetchParams.request;
	let httpFetchParams = null;
	let httpRequest = null;
	let response2 = null;
	if (request2.window === 'no-window' && request2.redirect === 'error') {
		httpFetchParams = fetchParams;
		httpRequest = request2;
	} else {
		httpRequest = makeRequest(request2);
		httpFetchParams = { ...fetchParams };
		httpFetchParams.request = httpRequest;
	}
	const includeCredentials =
		request2.credentials === 'include' ||
		(request2.credentials === 'same-origin' && request2.responseTainting === 'basic');
	const contentLength = httpRequest.body ? httpRequest.body.length : null;
	let contentLengthHeaderValue = null;
	if (httpRequest.body == null && ['POST', 'PUT'].includes(httpRequest.method)) {
		contentLengthHeaderValue = '0';
	}
	if (contentLength != null) {
		contentLengthHeaderValue = String(contentLength);
	}
	if (contentLengthHeaderValue != null) {
		httpRequest.headersList.append('content-length', contentLengthHeaderValue);
	}
	if (contentLength != null && httpRequest.keepalive);
	if (httpRequest.referrer instanceof URL) {
		httpRequest.headersList.append('referer', httpRequest.referrer.href);
	}
	appendRequestOriginHeader(httpRequest);
	appendFetchMetadata(httpRequest);
	if (!httpRequest.headersList.has('user-agent')) {
		httpRequest.headersList.append('user-agent', 'undici');
	}
	if (
		httpRequest.cache === 'default' &&
		(httpRequest.headersList.has('if-modified-since') ||
			httpRequest.headersList.has('if-none-match') ||
			httpRequest.headersList.has('if-unmodified-since') ||
			httpRequest.headersList.has('if-match') ||
			httpRequest.headersList.has('if-range'))
	) {
		httpRequest.cache = 'no-store';
	}
	if (
		httpRequest.cache === 'no-cache' &&
		!httpRequest.preventNoCacheCacheControlHeaderModification &&
		!httpRequest.headersList.has('cache-control')
	) {
		httpRequest.headersList.append('cache-control', 'max-age=0');
	}
	if (httpRequest.cache === 'no-store' || httpRequest.cache === 'reload') {
		if (!httpRequest.headersList.has('pragma')) {
			httpRequest.headersList.append('pragma', 'no-cache');
		}
		if (!httpRequest.headersList.has('cache-control')) {
			httpRequest.headersList.append('cache-control', 'no-cache');
		}
	}
	if (httpRequest.headersList.has('range')) {
		httpRequest.headersList.append('accept-encoding', 'identity');
	}
	if (!httpRequest.headersList.has('accept-encoding')) {
		if (/^https:/.test(requestCurrentURL(httpRequest).protocol)) {
			httpRequest.headersList.append('accept-encoding', 'br, gzip, deflate');
		} else {
			httpRequest.headersList.append('accept-encoding', 'gzip, deflate');
		}
	}
	{
		httpRequest.cache = 'no-store';
	}
	if (httpRequest.mode !== 'no-store' && httpRequest.mode !== 'reload');
	if (response2 == null) {
		if (httpRequest.mode === 'only-if-cached') {
			return makeNetworkError('only if cached');
		}
		const forwardResponse = await httpNetworkFetch(httpFetchParams);
		if (
			!safeMethods.includes(httpRequest.method) &&
			forwardResponse.status >= 200 &&
			forwardResponse.status <= 399
		);
		if (response2 == null) {
			response2 = forwardResponse;
		}
	}
	response2.urlList = [...httpRequest.urlList];
	if (httpRequest.headersList.has('range')) {
		response2.rangeRequested = true;
	}
	response2.requestIncludesCredentials = includeCredentials;
	if (response2.status === 407) {
		if (request2.window === 'no-window') {
			return makeNetworkError();
		}
		if (isCancelled(fetchParams)) {
			return makeAppropriateNetworkError(fetchParams);
		}
		return makeNetworkError('proxy authentication required');
	}
	if (
		response2.status === 421 &&
		!isNewConnectionFetch &&
		(request2.body == null || request2.body.source != null)
	) {
		if (isCancelled(fetchParams)) {
			return makeAppropriateNetworkError(fetchParams);
		}
		fetchParams.controller.connection.destroy();
		response2 = await httpNetworkOrCacheFetch(fetchParams, isAuthenticationFetch, true);
	}
	return response2;
}
async function httpNetworkFetch(fetchParams, includeCredentials, forceNewConnection) {
	assert(!fetchParams.controller.connection || fetchParams.controller.connection.destroyed);
	fetchParams.controller.connection = {
		abort: null,
		destroyed: false,
		destroy(err) {
			if (!this.destroyed) {
				this.destroyed = true;
				this.abort?.(err ?? new AbortError());
			}
		}
	};
	const request2 = fetchParams.request;
	let response2 = null;
	const timingInfo = fetchParams.timingInfo;
	{
		request2.cache = 'no-store';
	}
	if (request2.mode === 'websocket');
	let requestBody = null;
	if (request2.body == null && fetchParams.processRequestEndOfBody) {
		queueMicrotask(() => fetchParams.processRequestEndOfBody());
	} else if (request2.body != null) {
		const processBodyChunk = async function* (bytes) {
			if (isCancelled(fetchParams)) {
				return;
			}
			yield bytes;
			fetchParams.processRequestBodyChunkLength?.(bytes.byteLength);
		};
		const processEndOfBody = () => {
			if (isCancelled(fetchParams)) {
				return;
			}
			if (fetchParams.processRequestEndOfBody) {
				fetchParams.processRequestEndOfBody();
			}
		};
		const processBodyError = (e2) => {
			if (isCancelled(fetchParams)) {
				return;
			}
			if (e2.name === 'AbortError') {
				fetchParams.controller.abort();
			} else {
				fetchParams.controller.terminate(e2);
			}
		};
		requestBody = (async function* () {
			try {
				for await (const bytes of request2.body.stream) {
					yield* processBodyChunk(bytes);
				}
				processEndOfBody();
			} catch (err) {
				processBodyError(err);
			}
		})();
	}
	try {
		const { body: body4, status, statusText, headersList } = await dispatch({ body: requestBody });
		const iterator = body4[Symbol.asyncIterator]();
		fetchParams.controller.next = () => iterator.next();
		response2 = makeResponse({ status, statusText, headersList });
	} catch (err) {
		if (err.name === 'AbortError') {
			fetchParams.controller.connection.destroy();
			return makeAppropriateNetworkError(fetchParams);
		}
		return makeNetworkError(err);
	}
	const pullAlgorithm = () => {
		fetchParams.controller.resume();
	};
	const cancelAlgorithm = () => {
		fetchParams.controller.abort();
	};
	if (!ReadableStream2) {
		ReadableStream2 = import_web.default.ReadableStream;
	}
	const stream2 = new ReadableStream2(
		{
			async start(controller) {
				fetchParams.controller.controller = controller;
			},
			async pull(controller) {
				await pullAlgorithm();
			},
			async cancel(reason) {
				await cancelAlgorithm();
			}
		},
		{ highWaterMark: 0 }
	);
	response2.body = { stream: stream2 };
	fetchParams.controller.on('terminated', onAborted);
	fetchParams.controller.resume = async () => {
		while (true) {
			let bytes;
			try {
				const { done, value } = await fetchParams.controller.next();
				if (isAborted(fetchParams)) {
					break;
				}
				bytes = done ? void 0 : value;
			} catch (err) {
				if (fetchParams.controller.ended && !timingInfo.encodedBodySize) {
					bytes = void 0;
				} else {
					bytes = err;
				}
			}
			if (bytes === void 0) {
				try {
					fetchParams.controller.controller.close();
				} catch (err) {
					if (!/Controller is already closed/.test(err)) {
						throw err;
					}
				}
				finalizeResponse(fetchParams, response2);
				return;
			}
			timingInfo.decodedBodySize += bytes?.byteLength ?? 0;
			if (bytes instanceof Error) {
				fetchParams.controller.terminate(bytes);
				return;
			}
			fetchParams.controller.controller.enqueue(new Uint8Array(bytes));
			if (isErrored(stream2)) {
				fetchParams.controller.terminate();
				return;
			}
			if (!fetchParams.controller.controller.desiredSize) {
				return;
			}
		}
	};
	function onAborted(reason) {
		if (isAborted(fetchParams)) {
			response2.aborted = true;
			if (isReadable(stream2)) {
				fetchParams.controller.controller.error(new AbortError());
			}
		} else {
			if (isReadable(stream2)) {
				fetchParams.controller.controller.error(
					new TypeError('terminated', {
						cause: reason instanceof Error ? reason : void 0
					})
				);
			}
		}
		fetchParams.controller.connection.destroy();
	}
	return response2;
	async function dispatch({ body: body4 }) {
		const url = requestCurrentURL(request2);
		return new Promise((resolve2, reject) =>
			fetchParams.controller.dispatcher.dispatch(
				{
					path: url.pathname + url.search,
					origin: url.origin,
					method: request2.method,
					body: fetchParams.controller.dispatcher.isMockActive
						? request2.body && request2.body.source
						: body4,
					headers: [...request2.headersList].flat(),
					maxRedirections: 0,
					bodyTimeout: 3e5,
					headersTimeout: 3e5
				},
				{
					body: null,
					abort: null,
					onConnect(abort2) {
						const { connection } = fetchParams.controller;
						if (connection.destroyed) {
							abort2(new AbortError());
						} else {
							fetchParams.controller.on('terminated', abort2);
							this.abort = connection.abort = abort2;
						}
					},
					onHeaders(status, headersList, resume2, statusText) {
						if (status < 200) {
							return;
						}
						let codings = [];
						const headers2 = new Headers$1();
						for (let n = 0; n < headersList.length; n += 2) {
							const key3 = headersList[n + 0].toString();
							const val = headersList[n + 1].toString();
							if (key3.toLowerCase() === 'content-encoding') {
								codings = val.split(',').map((x2) => x2.trim());
							}
							headers2.append(key3, val);
						}
						this.body = new Readable({ read: resume2 });
						const decoders = [];
						if (
							request2.method !== 'HEAD' &&
							request2.method !== 'CONNECT' &&
							!nullBodyStatus.includes(status)
						) {
							for (const coding of codings) {
								if (/(x-)?gzip/.test(coding)) {
									decoders.push(zlib.createGunzip());
								} else if (/(x-)?deflate/.test(coding)) {
									decoders.push(zlib.createInflate());
								} else if (coding === 'br') {
									decoders.push(zlib.createBrotliDecompress());
								} else {
									decoders.length = 0;
									break;
								}
							}
						}
						resolve2({
							status,
							statusText,
							headersList: headers2[kHeadersList],
							body: decoders.length
								? pipeline(this.body, ...decoders, () => {})
								: this.body.on('error', () => {})
						});
						return true;
					},
					onData(chunk) {
						if (fetchParams.controller.dump) {
							return;
						}
						const bytes = chunk;
						timingInfo.encodedBodySize += bytes.byteLength;
						return this.body.push(bytes);
					},
					onComplete() {
						if (this.abort) {
							fetchParams.controller.off('terminated', this.abort);
						}
						fetchParams.controller.ended = true;
						this.body.push(null);
					},
					onError(error2) {
						if (this.abort) {
							fetchParams.controller.off('terminated', this.abort);
						}
						this.body?.destroy(error2);
						fetchParams.controller.terminate(error2);
						reject(error2);
					}
				}
			)
		);
	}
}
var fetch_1 = fetch$1;
var Request2;
var Response2;
var Headers2;
var fetch2;
var Dispatcher = dispatcher;
var errors = errors$1;
var util = util$h;
var { InvalidArgumentError } = errors;
var api = api$1;
var { getGlobalDispatcher, setGlobalDispatcher } = global2;
var nodeVersion = process.versions.node.split('.');
var nodeMajor = Number(nodeVersion[0]);
var nodeMinor = Number(nodeVersion[1]);
Object.assign(Dispatcher.prototype, api);
function makeDispatcher(fn) {
	return (url, opts, handler) => {
		if (typeof opts === 'function') {
			handler = opts;
			opts = null;
		}
		if (!url || (typeof url !== 'string' && typeof url !== 'object' && !(url instanceof URL))) {
			throw new InvalidArgumentError('invalid url');
		}
		if (opts != null && typeof opts !== 'object') {
			throw new InvalidArgumentError('invalid opts');
		}
		if (opts && opts.path != null) {
			if (typeof opts.path !== 'string') {
				throw new InvalidArgumentError('invalid opts.path');
			}
			url = new URL(opts.path, util.parseOrigin(url));
		} else {
			if (!opts) {
				opts = typeof url === 'object' ? url : {};
			}
			url = util.parseURL(url);
		}
		const { agent: agent2, dispatcher: dispatcher2 = getGlobalDispatcher() } = opts;
		if (agent2) {
			throw new InvalidArgumentError('unsupported opts.agent. Did you mean opts.client?');
		}
		return fn.call(
			dispatcher2,
			{
				...opts,
				origin: url.origin,
				path: url.search ? `${url.pathname}${url.search}` : url.pathname,
				method: opts.method || (opts.body ? 'PUT' : 'GET')
			},
			handler
		);
	};
}
if (nodeMajor > 16 || (nodeMajor === 16 && nodeMinor >= 5)) {
	let fetchImpl = null;
	fetch2 = async function fetch3(resource) {
		if (!fetchImpl) {
			fetchImpl = fetch_1;
		}
		const dispatcher2 = (arguments[1] && arguments[1].dispatcher) || getGlobalDispatcher();
		return fetchImpl.apply(dispatcher2, arguments);
	};
	Headers2 = headers.Headers;
	Response2 = response.Response;
	Request2 = request.Request;
}
makeDispatcher(api.request);
makeDispatcher(api.stream);
makeDispatcher(api.pipeline);
makeDispatcher(api.connect);
makeDispatcher(api.upgrade);
var globals = {
	crypto: import_crypto.webcrypto,
	fetch: fetch2,
	Response: Response2,
	Request: Request2,
	Headers: Headers2,
	ReadableStream: import_web.ReadableStream,
	TransformStream: import_web.TransformStream,
	WritableStream: import_web.WritableStream
};
function installPolyfills() {
	for (const name in globals) {
		Object.defineProperty(globalThis, name, {
			enumerable: true,
			configurable: true,
			value: globals[name]
		});
	}
}

// .svelte-kit/vercel-tmp/serverless.js
init_node();

// .svelte-kit/output/server/index.js
init_index_1259f1f6();
function afterUpdate() {}
var Root = create_ssr_component(($$result, $$props, $$bindings, slots) => {
	let { stores } = $$props;
	let { page } = $$props;
	let { components } = $$props;
	let { props_0 = null } = $$props;
	let { props_1 = null } = $$props;
	let { props_2 = null } = $$props;
	setContext('__svelte__', stores);
	afterUpdate(stores.page.notify);
	if ($$props.stores === void 0 && $$bindings.stores && stores !== void 0)
		$$bindings.stores(stores);
	if ($$props.page === void 0 && $$bindings.page && page !== void 0) $$bindings.page(page);
	if ($$props.components === void 0 && $$bindings.components && components !== void 0)
		$$bindings.components(components);
	if ($$props.props_0 === void 0 && $$bindings.props_0 && props_0 !== void 0)
		$$bindings.props_0(props_0);
	if ($$props.props_1 === void 0 && $$bindings.props_1 && props_1 !== void 0)
		$$bindings.props_1(props_1);
	if ($$props.props_2 === void 0 && $$bindings.props_2 && props_2 !== void 0)
		$$bindings.props_2(props_2);
	{
		stores.page.set(page);
	}
	return `


${
	components[1]
		? `${validate_component(components[0] || missing_component, 'svelte:component').$$render(
				$$result,
				Object.assign(props_0 || {}),
				{},
				{
					default: () => {
						return `${
							components[2]
								? `${validate_component(
										components[1] || missing_component,
										'svelte:component'
								  ).$$render(
										$$result,
										Object.assign(props_1 || {}),
										{},
										{
											default: () => {
												return `${validate_component(
													components[2] || missing_component,
													'svelte:component'
												).$$render($$result, Object.assign(props_2 || {}), {}, {})}`;
											}
										}
								  )}`
								: `${validate_component(
										components[1] || missing_component,
										'svelte:component'
								  ).$$render($$result, Object.assign(props_1 || {}), {}, {})}`
						}`;
					}
				}
		  )}`
		: `${validate_component(components[0] || missing_component, 'svelte:component').$$render(
				$$result,
				Object.assign(props_0 || {}),
				{},
				{}
		  )}`
}

${``}`;
});
function to_headers(object) {
	const headers2 = new Headers();
	if (object) {
		for (const key22 in object) {
			const value = object[key22];
			if (!value) continue;
			if (Array.isArray(value)) {
				value.forEach((value2) => {
					headers2.append(key22, value2);
				});
			} else {
				headers2.set(key22, value);
			}
		}
	}
	return headers2;
}
function hash(value) {
	let hash2 = 5381;
	let i2 = value.length;
	if (typeof value === 'string') {
		while (i2) hash2 = (hash2 * 33) ^ value.charCodeAt(--i2);
	} else {
		while (i2) hash2 = (hash2 * 33) ^ value[--i2];
	}
	return (hash2 >>> 0).toString(36);
}
function lowercase_keys(obj) {
	const clone2 = {};
	for (const key22 in obj) {
		clone2[key22.toLowerCase()] = obj[key22];
	}
	return clone2;
}
function decode_params(params) {
	for (const key22 in params) {
		params[key22] = params[key22]
			.replace(/%23/g, '#')
			.replace(/%3[Bb]/g, ';')
			.replace(/%2[Cc]/g, ',')
			.replace(/%2[Ff]/g, '/')
			.replace(/%3[Ff]/g, '?')
			.replace(/%3[Aa]/g, ':')
			.replace(/%40/g, '@')
			.replace(/%26/g, '&')
			.replace(/%3[Dd]/g, '=')
			.replace(/%2[Bb]/g, '+')
			.replace(/%24/g, '$');
	}
	return params;
}
function is_pojo(body4) {
	if (typeof body4 !== 'object') return false;
	if (body4) {
		if (body4 instanceof Uint8Array) return false;
		if (body4 instanceof ReadableStream) return false;
		if (body4._readableState && typeof body4.pipe === 'function') {
			throw new Error('Node streams are no longer supported \u2014 use a ReadableStream instead');
		}
	}
	return true;
}
function normalize_request_method(event) {
	const method = event.request.method.toLowerCase();
	return method === 'delete' ? 'del' : method;
}
function error(body4) {
	return new Response(body4, {
		status: 500
	});
}
function is_string(s22) {
	return typeof s22 === 'string' || s22 instanceof String;
}
var text_types = /* @__PURE__ */ new Set([
	'application/xml',
	'application/json',
	'application/x-www-form-urlencoded',
	'multipart/form-data'
]);
var bodyless_status_codes = /* @__PURE__ */ new Set([101, 204, 205, 304]);
function is_text(content_type) {
	if (!content_type) return true;
	const type = content_type.split(';')[0].toLowerCase();
	return type.startsWith('text/') || type.endsWith('+xml') || text_types.has(type);
}
async function render_endpoint(event, mod) {
	const method = normalize_request_method(event);
	let handler = mod[method];
	if (!handler && method === 'head') {
		handler = mod.get;
	}
	if (!handler) {
		const allowed = [];
		for (const method2 in ['get', 'post', 'put', 'patch']) {
			if (mod[method2]) allowed.push(method2.toUpperCase());
		}
		if (mod.del) allowed.push('DELETE');
		if (mod.get || mod.head) allowed.push('HEAD');
		return event.request.headers.get('x-sveltekit-load')
			? new Response(void 0, {
					status: 204
			  })
			: new Response(`${event.request.method} method not allowed`, {
					status: 405,
					headers: {
						allow: allowed.join(', ')
					}
			  });
	}
	const response2 = await handler(event);
	const preface = `Invalid response from route ${event.url.pathname}`;
	if (typeof response2 !== 'object') {
		return error(`${preface}: expected an object, got ${typeof response2}`);
	}
	if (response2.fallthrough) {
		throw new Error(
			'fallthrough is no longer supported. Use matchers instead: https://kit.svelte.dev/docs/routing#advanced-routing-matching'
		);
	}
	const { status = 200, body: body4 = {} } = response2;
	const headers2 =
		response2.headers instanceof Headers
			? new Headers(response2.headers)
			: to_headers(response2.headers);
	const type = headers2.get('content-type');
	if (!is_text(type) && !(body4 instanceof Uint8Array || is_string(body4))) {
		return error(
			`${preface}: body must be an instance of string or Uint8Array if content-type is not a supported textual content-type`
		);
	}
	let normalized_body;
	if (is_pojo(body4) && (!type || type.startsWith('application/json'))) {
		headers2.set('content-type', 'application/json; charset=utf-8');
		normalized_body = JSON.stringify(body4);
	} else {
		normalized_body = body4;
	}
	if (
		(typeof normalized_body === 'string' || normalized_body instanceof Uint8Array) &&
		!headers2.has('etag')
	) {
		const cache_control = headers2.get('cache-control');
		if (!cache_control || !/(no-store|immutable)/.test(cache_control)) {
			headers2.set('etag', `"${hash(normalized_body)}"`);
		}
	}
	return new Response(
		method !== 'head' && !bodyless_status_codes.has(status) ? normalized_body : void 0,
		{
			status,
			headers: headers2
		}
	);
}
var chars$1 = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ_$';
var unsafeChars = /[<>\b\f\n\r\t\0\u2028\u2029]/g;
var reserved =
	/^(?:do|if|in|for|int|let|new|try|var|byte|case|char|else|enum|goto|long|this|void|with|await|break|catch|class|const|final|float|short|super|throw|while|yield|delete|double|export|import|native|return|switch|throws|typeof|boolean|default|extends|finally|package|private|abstract|continue|debugger|function|volatile|interface|protected|transient|implements|instanceof|synchronized)$/;
var escaped2 = {
	'<': '\\u003C',
	'>': '\\u003E',
	'/': '\\u002F',
	'\\': '\\\\',
	'\b': '\\b',
	'\f': '\\f',
	'\n': '\\n',
	'\r': '\\r',
	'	': '\\t',
	'\0': '\\0',
	'\u2028': '\\u2028',
	'\u2029': '\\u2029'
};
var objectProtoOwnPropertyNames = Object.getOwnPropertyNames(Object.prototype).sort().join('\0');
function devalue(value) {
	var counts = /* @__PURE__ */ new Map();
	function walk(thing) {
		if (typeof thing === 'function') {
			throw new Error('Cannot stringify a function');
		}
		if (counts.has(thing)) {
			counts.set(thing, counts.get(thing) + 1);
			return;
		}
		counts.set(thing, 1);
		if (!isPrimitive(thing)) {
			var type = getType(thing);
			switch (type) {
				case 'Number':
				case 'String':
				case 'Boolean':
				case 'Date':
				case 'RegExp':
					return;
				case 'Array':
					thing.forEach(walk);
					break;
				case 'Set':
				case 'Map':
					Array.from(thing).forEach(walk);
					break;
				default:
					var proto = Object.getPrototypeOf(thing);
					if (
						proto !== Object.prototype &&
						proto !== null &&
						Object.getOwnPropertyNames(proto).sort().join('\0') !== objectProtoOwnPropertyNames
					) {
						throw new Error('Cannot stringify arbitrary non-POJOs');
					}
					if (Object.getOwnPropertySymbols(thing).length > 0) {
						throw new Error('Cannot stringify POJOs with symbolic keys');
					}
					Object.keys(thing).forEach(function (key22) {
						return walk(thing[key22]);
					});
			}
		}
	}
	walk(value);
	var names = /* @__PURE__ */ new Map();
	Array.from(counts)
		.filter(function (entry5) {
			return entry5[1] > 1;
		})
		.sort(function (a, b) {
			return b[1] - a[1];
		})
		.forEach(function (entry5, i2) {
			names.set(entry5[0], getName(i2));
		});
	function stringify3(thing) {
		if (names.has(thing)) {
			return names.get(thing);
		}
		if (isPrimitive(thing)) {
			return stringifyPrimitive(thing);
		}
		var type = getType(thing);
		switch (type) {
			case 'Number':
			case 'String':
			case 'Boolean':
				return 'Object(' + stringify3(thing.valueOf()) + ')';
			case 'RegExp':
				return 'new RegExp(' + stringifyString(thing.source) + ', "' + thing.flags + '")';
			case 'Date':
				return 'new Date(' + thing.getTime() + ')';
			case 'Array':
				var members = thing.map(function (v, i2) {
					return i2 in thing ? stringify3(v) : '';
				});
				var tail = thing.length === 0 || thing.length - 1 in thing ? '' : ',';
				return '[' + members.join(',') + tail + ']';
			case 'Set':
			case 'Map':
				return 'new ' + type + '([' + Array.from(thing).map(stringify3).join(',') + '])';
			default:
				var obj =
					'{' +
					Object.keys(thing)
						.map(function (key22) {
							return safeKey(key22) + ':' + stringify3(thing[key22]);
						})
						.join(',') +
					'}';
				var proto = Object.getPrototypeOf(thing);
				if (proto === null) {
					return Object.keys(thing).length > 0
						? 'Object.assign(Object.create(null),' + obj + ')'
						: 'Object.create(null)';
				}
				return obj;
		}
	}
	var str = stringify3(value);
	if (names.size) {
		var params_1 = [];
		var statements_1 = [];
		var values_1 = [];
		names.forEach(function (name, thing) {
			params_1.push(name);
			if (isPrimitive(thing)) {
				values_1.push(stringifyPrimitive(thing));
				return;
			}
			var type = getType(thing);
			switch (type) {
				case 'Number':
				case 'String':
				case 'Boolean':
					values_1.push('Object(' + stringify3(thing.valueOf()) + ')');
					break;
				case 'RegExp':
					values_1.push(thing.toString());
					break;
				case 'Date':
					values_1.push('new Date(' + thing.getTime() + ')');
					break;
				case 'Array':
					values_1.push('Array(' + thing.length + ')');
					thing.forEach(function (v, i2) {
						statements_1.push(name + '[' + i2 + ']=' + stringify3(v));
					});
					break;
				case 'Set':
					values_1.push('new Set');
					statements_1.push(
						name +
							'.' +
							Array.from(thing)
								.map(function (v) {
									return 'add(' + stringify3(v) + ')';
								})
								.join('.')
					);
					break;
				case 'Map':
					values_1.push('new Map');
					statements_1.push(
						name +
							'.' +
							Array.from(thing)
								.map(function (_a) {
									var k = _a[0],
										v = _a[1];
									return 'set(' + stringify3(k) + ', ' + stringify3(v) + ')';
								})
								.join('.')
					);
					break;
				default:
					values_1.push(Object.getPrototypeOf(thing) === null ? 'Object.create(null)' : '{}');
					Object.keys(thing).forEach(function (key22) {
						statements_1.push('' + name + safeProp(key22) + '=' + stringify3(thing[key22]));
					});
			}
		});
		statements_1.push('return ' + str);
		return (
			'(function(' +
			params_1.join(',') +
			'){' +
			statements_1.join(';') +
			'}(' +
			values_1.join(',') +
			'))'
		);
	} else {
		return str;
	}
}
function getName(num) {
	var name = '';
	do {
		name = chars$1[num % chars$1.length] + name;
		num = ~~(num / chars$1.length) - 1;
	} while (num >= 0);
	return reserved.test(name) ? name + '_' : name;
}
function isPrimitive(thing) {
	return Object(thing) !== thing;
}
function stringifyPrimitive(thing) {
	if (typeof thing === 'string') return stringifyString(thing);
	if (thing === void 0) return 'void 0';
	if (thing === 0 && 1 / thing < 0) return '-0';
	var str = String(thing);
	if (typeof thing === 'number') return str.replace(/^(-)?0\./, '$1.');
	return str;
}
function getType(thing) {
	return Object.prototype.toString.call(thing).slice(8, -1);
}
function escapeUnsafeChar(c) {
	return escaped2[c] || c;
}
function escapeUnsafeChars(str) {
	return str.replace(unsafeChars, escapeUnsafeChar);
}
function safeKey(key22) {
	return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key22)
		? key22
		: escapeUnsafeChars(JSON.stringify(key22));
}
function safeProp(key22) {
	return /^[_$a-zA-Z][_$a-zA-Z0-9]*$/.test(key22)
		? '.' + key22
		: '[' + escapeUnsafeChars(JSON.stringify(key22)) + ']';
}
function stringifyString(str) {
	var result = '"';
	for (var i2 = 0; i2 < str.length; i2 += 1) {
		var char = str.charAt(i2);
		var code3 = char.charCodeAt(0);
		if (char === '"') {
			result += '\\"';
		} else if (char in escaped2) {
			result += escaped2[char];
		} else if (code3 >= 55296 && code3 <= 57343) {
			var next = str.charCodeAt(i2 + 1);
			if (code3 <= 56319 && next >= 56320 && next <= 57343) {
				result += char + str[++i2];
			} else {
				result += '\\u' + code3.toString(16).toUpperCase();
			}
		} else {
			result += char;
		}
	}
	result += '"';
	return result;
}
function noop2() {}
function safe_not_equal(a, b) {
	return a != a ? b == b : a !== b || (a && typeof a === 'object') || typeof a === 'function';
}
Promise.resolve();
var subscriber_queue = [];
function readable2(value, start) {
	return {
		subscribe: writable(value, start).subscribe
	};
}
function writable(value, start = noop2) {
	let stop;
	const subscribers = /* @__PURE__ */ new Set();
	function set(new_value) {
		if (safe_not_equal(value, new_value)) {
			value = new_value;
			if (stop) {
				const run_queue = !subscriber_queue.length;
				for (const subscriber of subscribers) {
					subscriber[1]();
					subscriber_queue.push(subscriber, value);
				}
				if (run_queue) {
					for (let i2 = 0; i2 < subscriber_queue.length; i2 += 2) {
						subscriber_queue[i2][0](subscriber_queue[i2 + 1]);
					}
					subscriber_queue.length = 0;
				}
			}
		}
	}
	function update(fn) {
		set(fn(value));
	}
	function subscribe(run2, invalidate = noop2) {
		const subscriber = [run2, invalidate];
		subscribers.add(subscriber);
		if (subscribers.size === 1) {
			stop = start(set) || noop2;
		}
		run2(value);
		return () => {
			subscribers.delete(subscriber);
			if (subscribers.size === 0) {
				stop();
				stop = null;
			}
		};
	}
	return { set, update, subscribe };
}
function coalesce_to_error(err) {
	return err instanceof Error || (err && err.name && err.message)
		? err
		: new Error(JSON.stringify(err));
}
var render_json_payload_script_dict = {
	'<': '\\u003C',
	'\u2028': '\\u2028',
	'\u2029': '\\u2029'
};
var render_json_payload_script_regex = new RegExp(
	`[${Object.keys(render_json_payload_script_dict).join('')}]`,
	'g'
);
function render_json_payload_script(attrs, payload) {
	const safe_payload = JSON.stringify(payload).replace(
		render_json_payload_script_regex,
		(match) => render_json_payload_script_dict[match]
	);
	let safe_attrs = '';
	for (const [key22, value] of Object.entries(attrs)) {
		if (value === void 0) continue;
		safe_attrs += ` sveltekit:data-${key22}=${escape_html_attr(value)}`;
	}
	return `<script type="application/json"${safe_attrs}>${safe_payload}<\/script>`;
}
var escape_html_attr_dict = {
	'&': '&amp;',
	'"': '&quot;'
};
var escape_html_attr_regex = new RegExp(
	`[${Object.keys(escape_html_attr_dict).join(
		''
	)}]|[\\ud800-\\udbff](?![\\udc00-\\udfff])|[\\ud800-\\udbff][\\udc00-\\udfff]|[\\udc00-\\udfff]`,
	'g'
);
function escape_html_attr(str) {
	const escaped_str = str.replace(escape_html_attr_regex, (match) => {
		if (match.length === 2) {
			return match;
		}
		return escape_html_attr_dict[match] ?? `&#${match.charCodeAt(0)};`;
	});
	return `"${escaped_str}"`;
}
var s2 = JSON.stringify;
var encoder2 = new TextEncoder();
function sha256(data2) {
	if (!key[0]) precompute();
	const out = init.slice(0);
	const array2 = encode$1(data2);
	for (let i2 = 0; i2 < array2.length; i2 += 16) {
		const w = array2.subarray(i2, i2 + 16);
		let tmp;
		let a;
		let b;
		let out0 = out[0];
		let out1 = out[1];
		let out2 = out[2];
		let out3 = out[3];
		let out4 = out[4];
		let out5 = out[5];
		let out6 = out[6];
		let out7 = out[7];
		for (let i22 = 0; i22 < 64; i22++) {
			if (i22 < 16) {
				tmp = w[i22];
			} else {
				a = w[(i22 + 1) & 15];
				b = w[(i22 + 14) & 15];
				tmp = w[i22 & 15] =
					(((a >>> 7) ^ (a >>> 18) ^ (a >>> 3) ^ (a << 25) ^ (a << 14)) +
						((b >>> 17) ^ (b >>> 19) ^ (b >>> 10) ^ (b << 15) ^ (b << 13)) +
						w[i22 & 15] +
						w[(i22 + 9) & 15]) |
					0;
			}
			tmp =
				tmp +
				out7 +
				((out4 >>> 6) ^ (out4 >>> 11) ^ (out4 >>> 25) ^ (out4 << 26) ^ (out4 << 21) ^ (out4 << 7)) +
				(out6 ^ (out4 & (out5 ^ out6))) +
				key[i22];
			out7 = out6;
			out6 = out5;
			out5 = out4;
			out4 = (out3 + tmp) | 0;
			out3 = out2;
			out2 = out1;
			out1 = out0;
			out0 =
				(tmp +
					((out1 & out2) ^ (out3 & (out1 ^ out2))) +
					((out1 >>> 2) ^
						(out1 >>> 13) ^
						(out1 >>> 22) ^
						(out1 << 30) ^
						(out1 << 19) ^
						(out1 << 10))) |
				0;
		}
		out[0] = (out[0] + out0) | 0;
		out[1] = (out[1] + out1) | 0;
		out[2] = (out[2] + out2) | 0;
		out[3] = (out[3] + out3) | 0;
		out[4] = (out[4] + out4) | 0;
		out[5] = (out[5] + out5) | 0;
		out[6] = (out[6] + out6) | 0;
		out[7] = (out[7] + out7) | 0;
	}
	const bytes = new Uint8Array(out.buffer);
	reverse_endianness(bytes);
	return base64(bytes);
}
var init = new Uint32Array(8);
var key = new Uint32Array(64);
function precompute() {
	function frac(x2) {
		return (x2 - Math.floor(x2)) * 4294967296;
	}
	let prime = 2;
	for (let i2 = 0; i2 < 64; prime++) {
		let is_prime = true;
		for (let factor = 2; factor * factor <= prime; factor++) {
			if (prime % factor === 0) {
				is_prime = false;
				break;
			}
		}
		if (is_prime) {
			if (i2 < 8) {
				init[i2] = frac(prime ** (1 / 2));
			}
			key[i2] = frac(prime ** (1 / 3));
			i2++;
		}
	}
}
function reverse_endianness(bytes) {
	for (let i2 = 0; i2 < bytes.length; i2 += 4) {
		const a = bytes[i2 + 0];
		const b = bytes[i2 + 1];
		const c = bytes[i2 + 2];
		const d = bytes[i2 + 3];
		bytes[i2 + 0] = d;
		bytes[i2 + 1] = c;
		bytes[i2 + 2] = b;
		bytes[i2 + 3] = a;
	}
}
function encode$1(str) {
	const encoded = encoder2.encode(str);
	const length = encoded.length * 8;
	const size = 512 * Math.ceil((length + 65) / 512);
	const bytes = new Uint8Array(size / 8);
	bytes.set(encoded);
	bytes[encoded.length] = 128;
	reverse_endianness(bytes);
	const words = new Uint32Array(bytes.buffer);
	words[words.length - 2] = Math.floor(length / 4294967296);
	words[words.length - 1] = length;
	return words;
}
var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');
function base64(bytes) {
	const l = bytes.length;
	let result = '';
	let i2;
	for (i2 = 2; i2 < l; i2 += 3) {
		result += chars[bytes[i2 - 2] >> 2];
		result += chars[((bytes[i2 - 2] & 3) << 4) | (bytes[i2 - 1] >> 4)];
		result += chars[((bytes[i2 - 1] & 15) << 2) | (bytes[i2] >> 6)];
		result += chars[bytes[i2] & 63];
	}
	if (i2 === l + 1) {
		result += chars[bytes[i2 - 2] >> 2];
		result += chars[(bytes[i2 - 2] & 3) << 4];
		result += '==';
	}
	if (i2 === l) {
		result += chars[bytes[i2 - 2] >> 2];
		result += chars[((bytes[i2 - 2] & 3) << 4) | (bytes[i2 - 1] >> 4)];
		result += chars[(bytes[i2 - 1] & 15) << 2];
		result += '=';
	}
	return result;
}
var csp_ready;
var array = new Uint8Array(16);
function generate_nonce() {
	crypto.getRandomValues(array);
	return base64(array);
}
var quoted = /* @__PURE__ */ new Set([
	'self',
	'unsafe-eval',
	'unsafe-hashes',
	'unsafe-inline',
	'none',
	'strict-dynamic',
	'report-sample'
]);
var crypto_pattern = /^(nonce|sha\d\d\d)-/;
var Csp = class {
	#use_hashes;
	#dev;
	#script_needs_csp;
	#style_needs_csp;
	#directives;
	#script_src;
	#style_src;
	constructor({ mode, directives }, { dev, prerender, needs_nonce }) {
		this.#use_hashes = mode === 'hash' || (mode === 'auto' && prerender);
		this.#directives = dev ? { ...directives } : directives;
		this.#dev = dev;
		const d = this.#directives;
		if (dev) {
			const effective_style_src2 = d['style-src'] || d['default-src'];
			if (effective_style_src2 && !effective_style_src2.includes('unsafe-inline')) {
				d['style-src'] = [...effective_style_src2, 'unsafe-inline'];
			}
		}
		this.#script_src = [];
		this.#style_src = [];
		const effective_script_src = d['script-src'] || d['default-src'];
		const effective_style_src = d['style-src'] || d['default-src'];
		this.#script_needs_csp =
			!!effective_script_src &&
			effective_script_src.filter((value) => value !== 'unsafe-inline').length > 0;
		this.#style_needs_csp =
			!dev &&
			!!effective_style_src &&
			effective_style_src.filter((value) => value !== 'unsafe-inline').length > 0;
		this.script_needs_nonce = this.#script_needs_csp && !this.#use_hashes;
		this.style_needs_nonce = this.#style_needs_csp && !this.#use_hashes;
		if (this.script_needs_nonce || this.style_needs_nonce || needs_nonce) {
			this.nonce = generate_nonce();
		}
	}
	add_script(content3) {
		if (this.#script_needs_csp) {
			if (this.#use_hashes) {
				this.#script_src.push(`sha256-${sha256(content3)}`);
			} else if (this.#script_src.length === 0) {
				this.#script_src.push(`nonce-${this.nonce}`);
			}
		}
	}
	add_style(content3) {
		if (this.#style_needs_csp) {
			if (this.#use_hashes) {
				this.#style_src.push(`sha256-${sha256(content3)}`);
			} else if (this.#style_src.length === 0) {
				this.#style_src.push(`nonce-${this.nonce}`);
			}
		}
	}
	get_header(is_meta = false) {
		const header = [];
		const directives = { ...this.#directives };
		if (this.#style_src.length > 0) {
			directives['style-src'] = [
				...(directives['style-src'] || directives['default-src'] || []),
				...this.#style_src
			];
		}
		if (this.#script_src.length > 0) {
			directives['script-src'] = [
				...(directives['script-src'] || directives['default-src'] || []),
				...this.#script_src
			];
		}
		for (const key22 in directives) {
			if (
				is_meta &&
				(key22 === 'frame-ancestors' || key22 === 'report-uri' || key22 === 'sandbox')
			) {
				continue;
			}
			const value = directives[key22];
			if (!value) continue;
			const directive = [key22];
			if (Array.isArray(value)) {
				value.forEach((value2) => {
					if (quoted.has(value2) || crypto_pattern.test(value2)) {
						directive.push(`'${value2}'`);
					} else {
						directive.push(value2);
					}
				});
			}
			header.push(directive.join(' '));
		}
		return header.join('; ');
	}
	get_meta() {
		const content3 = escape_html_attr(this.get_header(true));
		return `<meta http-equiv="content-security-policy" content=${content3}>`;
	}
};
var absolute = /^([a-z]+:)?\/?\//;
var scheme = /^[a-z]+:/;
function resolve(base22, path) {
	if (scheme.test(path)) return path;
	const base_match = absolute.exec(base22);
	const path_match = absolute.exec(path);
	if (!base_match) {
		throw new Error(`bad base path: "${base22}"`);
	}
	const baseparts = path_match ? [] : base22.slice(base_match[0].length).split('/');
	const pathparts = path_match ? path.slice(path_match[0].length).split('/') : path.split('/');
	baseparts.pop();
	for (let i2 = 0; i2 < pathparts.length; i2 += 1) {
		const part = pathparts[i2];
		if (part === '.') continue;
		else if (part === '..') baseparts.pop();
		else baseparts.push(part);
	}
	const prefix = (path_match && path_match[0]) || (base_match && base_match[0]) || '';
	return `${prefix}${baseparts.join('/')}`;
}
function is_root_relative(path) {
	return path[0] === '/' && path[1] !== '/';
}
function normalize_path(path, trailing_slash) {
	if (path === '/' || trailing_slash === 'ignore') return path;
	if (trailing_slash === 'never') {
		return path.endsWith('/') ? path.slice(0, -1) : path;
	} else if (trailing_slash === 'always' && !path.endsWith('/')) {
		return path + '/';
	}
	return path;
}
var LoadURL = class extends URL {
	get hash() {
		throw new Error(
			'url.hash is inaccessible from load. Consider accessing hash from the page store within the script tag of your component.'
		);
	}
};
var PrerenderingURL = class extends URL {
	get search() {
		throw new Error('Cannot access url.search on a page with prerendering enabled');
	}
	get searchParams() {
		throw new Error('Cannot access url.searchParams on a page with prerendering enabled');
	}
};
var updated = {
	...readable2(false),
	check: () => false
};
async function render_response({
	branch,
	options,
	state,
	$session,
	page_config,
	status,
	error: error2 = null,
	event,
	resolve_opts,
	stuff
}) {
	if (state.prerendering) {
		if (options.csp.mode === 'nonce') {
			throw new Error('Cannot use prerendering if config.kit.csp.mode === "nonce"');
		}
		if (options.template_contains_nonce) {
			throw new Error('Cannot use prerendering if page template contains %sveltekit.nonce%');
		}
	}
	const stylesheets = new Set(options.manifest._.entry.css);
	const modulepreloads = new Set(options.manifest._.entry.js);
	const styles = /* @__PURE__ */ new Map();
	const serialized_data = [];
	let shadow_props;
	let rendered;
	let is_private = false;
	let cache;
	if (error2) {
		error2.stack = options.get_stack(error2);
	}
	if (resolve_opts.ssr) {
		branch.forEach(({ node, props: props2, loaded, fetched, uses_credentials }) => {
			if (node.css) node.css.forEach((url) => stylesheets.add(url));
			if (node.js) node.js.forEach((url) => modulepreloads.add(url));
			if (node.styles) Object.entries(node.styles).forEach(([k, v]) => styles.set(k, v));
			if (fetched && page_config.hydrate) serialized_data.push(...fetched);
			if (props2) shadow_props = props2;
			cache = loaded == null ? void 0 : loaded.cache;
			is_private = (cache == null ? void 0 : cache.private) ?? uses_credentials;
		});
		const session = writable($session);
		const props = {
			stores: {
				page: writable(null),
				navigating: writable(null),
				session: {
					...session,
					subscribe: (fn) => {
						is_private = (cache == null ? void 0 : cache.private) ?? true;
						return session.subscribe(fn);
					}
				},
				updated
			},
			page: {
				error: error2,
				params: event.params,
				routeId: event.routeId,
				status,
				stuff,
				url: state.prerendering ? new PrerenderingURL(event.url) : event.url
			},
			components: branch.map(({ node }) => node.module.default)
		};
		const print_error = (property, replacement) => {
			Object.defineProperty(props.page, property, {
				get: () => {
					throw new Error(`$page.${property} has been replaced by $page.url.${replacement}`);
				}
			});
		};
		print_error('origin', 'origin');
		print_error('path', 'pathname');
		print_error('query', 'searchParams');
		for (let i2 = 0; i2 < branch.length; i2 += 1) {
			props[`props_${i2}`] = await branch[i2].loaded.props;
		}
		rendered = options.root.render(props);
	} else {
		rendered = { head: '', html: '', css: { code: '', map: null } };
	}
	let { head: head2, html: body4 } = rendered;
	const inlined_style = Array.from(styles.values()).join('\n');
	await csp_ready;
	const csp = new Csp(options.csp, {
		dev: options.dev,
		prerender: !!state.prerendering,
		needs_nonce: options.template_contains_nonce
	});
	const target = hash(body4);
	const init_app = `
		import { start } from ${s2(options.prefix + options.manifest._.entry.file)};
		start({
			target: document.querySelector('[data-sveltekit-hydrate="${target}"]').parentNode,
			paths: ${s2(options.paths)},
			session: ${try_serialize($session, (error3) => {
				throw new Error(`Failed to serialize session data: ${error3.message}`);
			})},
			route: ${!!page_config.router},
			spa: ${!resolve_opts.ssr},
			trailing_slash: ${s2(options.trailing_slash)},
			hydrate: ${
				resolve_opts.ssr && page_config.hydrate
					? `{
				status: ${status},
				error: ${serialize_error(error2)},
				nodes: [${branch.map(({ node }) => node.index).join(', ')}],
				params: ${devalue(event.params)},
				routeId: ${s2(event.routeId)}
			}`
					: 'null'
			}
		});
	`;
	const init_service_worker = `
		if ('serviceWorker' in navigator) {
			addEventListener('load', () => {
				navigator.serviceWorker.register('${options.service_worker}');
			});
		}
	`;
	if (inlined_style) {
		const attributes = [];
		if (options.dev) attributes.push(' data-sveltekit');
		if (csp.style_needs_nonce) attributes.push(` nonce="${csp.nonce}"`);
		csp.add_style(inlined_style);
		head2 += `
	<style${attributes.join('')}>${inlined_style}</style>`;
	}
	head2 += Array.from(stylesheets)
		.map((dep) => {
			const attributes = ['rel="stylesheet"', `href="${options.prefix + dep}"`];
			if (csp.style_needs_nonce) {
				attributes.push(`nonce="${csp.nonce}"`);
			}
			if (styles.has(dep)) {
				attributes.push('disabled', 'media="(max-width: 0)"');
			}
			return `
	<link ${attributes.join(' ')}>`;
		})
		.join('');
	if (page_config.router || page_config.hydrate) {
		head2 += Array.from(modulepreloads)
			.map(
				(dep) => `
	<link rel="modulepreload" href="${options.prefix + dep}">`
			)
			.join('');
		const attributes = ['type="module"', `data-sveltekit-hydrate="${target}"`];
		csp.add_script(init_app);
		if (csp.script_needs_nonce) {
			attributes.push(`nonce="${csp.nonce}"`);
		}
		body4 += `
		<script ${attributes.join(' ')}>${init_app}<\/script>`;
		body4 += serialized_data
			.map(({ url, body: body22, response: response2 }) =>
				render_json_payload_script(
					{ type: 'data', url, body: typeof body22 === 'string' ? hash(body22) : void 0 },
					response2
				)
			)
			.join('\n	');
		if (shadow_props) {
			body4 += render_json_payload_script({ type: 'props' }, shadow_props);
		}
	}
	if (options.service_worker) {
		csp.add_script(init_service_worker);
		head2 += `
			<script${csp.script_needs_nonce ? ` nonce="${csp.nonce}"` : ''}>${init_service_worker}<\/script>`;
	}
	if (state.prerendering) {
		const http_equiv = [];
		const csp_headers = csp.get_meta();
		if (csp_headers) {
			http_equiv.push(csp_headers);
		}
		if (cache) {
			http_equiv.push(`<meta http-equiv="cache-control" content="max-age=${cache.maxage}">`);
		}
		if (http_equiv.length > 0) {
			head2 = http_equiv.join('\n') + head2;
		}
	}
	const segments = event.url.pathname.slice(options.paths.base.length).split('/').slice(2);
	const assets2 =
		options.paths.assets || (segments.length > 0 ? segments.map(() => '..').join('/') : '.');
	const html9 = await resolve_opts.transformPage({
		html: options.template({ head: head2, body: body4, assets: assets2, nonce: csp.nonce })
	});
	const headers2 = new Headers({
		'content-type': 'text/html',
		etag: `"${hash(html9)}"`
	});
	if (cache) {
		headers2.set('cache-control', `${is_private ? 'private' : 'public'}, max-age=${cache.maxage}`);
	}
	if (!options.floc) {
		headers2.set('permissions-policy', 'interest-cohort=()');
	}
	if (!state.prerendering) {
		const csp_header = csp.get_header();
		if (csp_header) {
			headers2.set('content-security-policy', csp_header);
		}
	}
	return new Response(html9, {
		status,
		headers: headers2
	});
}
function try_serialize(data2, fail) {
	try {
		return devalue(data2);
	} catch (err) {
		if (fail) fail(coalesce_to_error(err));
		return null;
	}
}
function serialize_error(error2) {
	if (!error2) return null;
	let serialized = try_serialize(error2);
	if (!serialized) {
		const { name, message, stack } = error2;
		serialized = try_serialize({ ...error2, name, message, stack });
	}
	if (!serialized) {
		serialized = '{}';
	}
	return serialized;
}
var parse_1 = parse$1;
var serialize_1 = serialize;
var __toString = Object.prototype.toString;
var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
function parse$1(str, options) {
	if (typeof str !== 'string') {
		throw new TypeError('argument str must be a string');
	}
	var obj = {};
	var opt = options || {};
	var dec = opt.decode || decode;
	var index6 = 0;
	while (index6 < str.length) {
		var eqIdx = str.indexOf('=', index6);
		if (eqIdx === -1) {
			break;
		}
		var endIdx = str.indexOf(';', index6);
		if (endIdx === -1) {
			endIdx = str.length;
		} else if (endIdx < eqIdx) {
			index6 = str.lastIndexOf(';', eqIdx - 1) + 1;
			continue;
		}
		var key22 = str.slice(index6, eqIdx).trim();
		if (obj[key22] === void 0) {
			var val = str.slice(eqIdx + 1, endIdx).trim();
			if (val.charCodeAt(0) === 34) {
				val = val.slice(1, -1);
			}
			obj[key22] = tryDecode(val, dec);
		}
		index6 = endIdx + 1;
	}
	return obj;
}
function serialize(name, val, options) {
	var opt = options || {};
	var enc = opt.encode || encode2;
	if (typeof enc !== 'function') {
		throw new TypeError('option encode is invalid');
	}
	if (!fieldContentRegExp.test(name)) {
		throw new TypeError('argument name is invalid');
	}
	var value = enc(val);
	if (value && !fieldContentRegExp.test(value)) {
		throw new TypeError('argument val is invalid');
	}
	var str = name + '=' + value;
	if (opt.maxAge != null) {
		var maxAge = opt.maxAge - 0;
		if (isNaN(maxAge) || !isFinite(maxAge)) {
			throw new TypeError('option maxAge is invalid');
		}
		str += '; Max-Age=' + Math.floor(maxAge);
	}
	if (opt.domain) {
		if (!fieldContentRegExp.test(opt.domain)) {
			throw new TypeError('option domain is invalid');
		}
		str += '; Domain=' + opt.domain;
	}
	if (opt.path) {
		if (!fieldContentRegExp.test(opt.path)) {
			throw new TypeError('option path is invalid');
		}
		str += '; Path=' + opt.path;
	}
	if (opt.expires) {
		var expires = opt.expires;
		if (!isDate(expires) || isNaN(expires.valueOf())) {
			throw new TypeError('option expires is invalid');
		}
		str += '; Expires=' + expires.toUTCString();
	}
	if (opt.httpOnly) {
		str += '; HttpOnly';
	}
	if (opt.secure) {
		str += '; Secure';
	}
	if (opt.priority) {
		var priority = typeof opt.priority === 'string' ? opt.priority.toLowerCase() : opt.priority;
		switch (priority) {
			case 'low':
				str += '; Priority=Low';
				break;
			case 'medium':
				str += '; Priority=Medium';
				break;
			case 'high':
				str += '; Priority=High';
				break;
			default:
				throw new TypeError('option priority is invalid');
		}
	}
	if (opt.sameSite) {
		var sameSite = typeof opt.sameSite === 'string' ? opt.sameSite.toLowerCase() : opt.sameSite;
		switch (sameSite) {
			case true:
				str += '; SameSite=Strict';
				break;
			case 'lax':
				str += '; SameSite=Lax';
				break;
			case 'strict':
				str += '; SameSite=Strict';
				break;
			case 'none':
				str += '; SameSite=None';
				break;
			default:
				throw new TypeError('option sameSite is invalid');
		}
	}
	return str;
}
function decode(str) {
	return str.indexOf('%') !== -1 ? decodeURIComponent(str) : str;
}
function encode2(val) {
	return encodeURIComponent(val);
}
function isDate(val) {
	return __toString.call(val) === '[object Date]' || val instanceof Date;
}
function tryDecode(str, decode22) {
	try {
		return decode22(str);
	} catch (e2) {
		return str;
	}
}
var setCookie2 = { exports: {} };
var defaultParseOptions2 = {
	decodeValues: true,
	map: false,
	silent: false
};
function isNonEmptyString2(str) {
	return typeof str === 'string' && !!str.trim();
}
function parseString2(setCookieValue, options) {
	var parts = setCookieValue.split(';').filter(isNonEmptyString2);
	var nameValue = parts.shift().split('=');
	var name = nameValue.shift();
	var value = nameValue.join('=');
	options = options ? Object.assign({}, defaultParseOptions2, options) : defaultParseOptions2;
	try {
		value = options.decodeValues ? decodeURIComponent(value) : value;
	} catch (e2) {
		console.error(
			"set-cookie-parser encountered an error while decoding a cookie with value '" +
				value +
				"'. Set options.decodeValues to false to disable this feature.",
			e2
		);
	}
	var cookie = {
		name,
		value
	};
	parts.forEach(function (part) {
		var sides = part.split('=');
		var key22 = sides.shift().trimLeft().toLowerCase();
		var value2 = sides.join('=');
		if (key22 === 'expires') {
			cookie.expires = new Date(value2);
		} else if (key22 === 'max-age') {
			cookie.maxAge = parseInt(value2, 10);
		} else if (key22 === 'secure') {
			cookie.secure = true;
		} else if (key22 === 'httponly') {
			cookie.httpOnly = true;
		} else if (key22 === 'samesite') {
			cookie.sameSite = value2;
		} else {
			cookie[key22] = value2;
		}
	});
	return cookie;
}
function parse2(input, options) {
	options = options ? Object.assign({}, defaultParseOptions2, options) : defaultParseOptions2;
	if (!input) {
		if (!options.map) {
			return [];
		} else {
			return {};
		}
	}
	if (input.headers && input.headers['set-cookie']) {
		input = input.headers['set-cookie'];
	} else if (input.headers) {
		var sch =
			input.headers[
				Object.keys(input.headers).find(function (key22) {
					return key22.toLowerCase() === 'set-cookie';
				})
			];
		if (!sch && input.headers.cookie && !options.silent) {
			console.warn(
				'Warning: set-cookie-parser appears to have been called on a request object. It is designed to parse Set-Cookie headers from responses, not Cookie headers from requests. Set the option {silent: true} to suppress this warning.'
			);
		}
		input = sch;
	}
	if (!Array.isArray(input)) {
		input = [input];
	}
	options = options ? Object.assign({}, defaultParseOptions2, options) : defaultParseOptions2;
	if (!options.map) {
		return input.filter(isNonEmptyString2).map(function (str) {
			return parseString2(str, options);
		});
	} else {
		var cookies = {};
		return input.filter(isNonEmptyString2).reduce(function (cookies2, str) {
			var cookie = parseString2(str, options);
			cookies2[cookie.name] = cookie;
			return cookies2;
		}, cookies);
	}
}
function splitCookiesString2(cookiesString) {
	if (Array.isArray(cookiesString)) {
		return cookiesString;
	}
	if (typeof cookiesString !== 'string') {
		return [];
	}
	var cookiesStrings = [];
	var pos = 0;
	var start;
	var ch;
	var lastComma;
	var nextStart;
	var cookiesSeparatorFound;
	function skipWhitespace() {
		while (pos < cookiesString.length && /\s/.test(cookiesString.charAt(pos))) {
			pos += 1;
		}
		return pos < cookiesString.length;
	}
	function notSpecialChar() {
		ch = cookiesString.charAt(pos);
		return ch !== '=' && ch !== ';' && ch !== ',';
	}
	while (pos < cookiesString.length) {
		start = pos;
		cookiesSeparatorFound = false;
		while (skipWhitespace()) {
			ch = cookiesString.charAt(pos);
			if (ch === ',') {
				lastComma = pos;
				pos += 1;
				skipWhitespace();
				nextStart = pos;
				while (pos < cookiesString.length && notSpecialChar()) {
					pos += 1;
				}
				if (pos < cookiesString.length && cookiesString.charAt(pos) === '=') {
					cookiesSeparatorFound = true;
					pos = nextStart;
					cookiesStrings.push(cookiesString.substring(start, lastComma));
					start = pos;
				} else {
					pos = lastComma + 1;
				}
			} else {
				pos += 1;
			}
		}
		if (!cookiesSeparatorFound || pos >= cookiesString.length) {
			cookiesStrings.push(cookiesString.substring(start, cookiesString.length));
		}
	}
	return cookiesStrings;
}
setCookie2.exports = parse2;
setCookie2.exports.parse = parse2;
var parseString_1 = (setCookie2.exports.parseString = parseString2);
var splitCookiesString_12 = (setCookie2.exports.splitCookiesString = splitCookiesString2);
function normalize(loaded) {
	if (loaded.fallthrough) {
		throw new Error(
			'fallthrough is no longer supported. Use matchers instead: https://kit.svelte.dev/docs/routing#advanced-routing-matching'
		);
	}
	if ('maxage' in loaded) {
		throw new Error('maxage should be replaced with cache: { maxage }');
	}
	const has_error_status =
		loaded.status && loaded.status >= 400 && loaded.status <= 599 && !loaded.redirect;
	if (loaded.error || has_error_status) {
		const status = loaded.status;
		if (!loaded.error && has_error_status) {
			return { status: status || 500, error: new Error() };
		}
		const error2 = typeof loaded.error === 'string' ? new Error(loaded.error) : loaded.error;
		if (!(error2 instanceof Error)) {
			return {
				status: 500,
				error: new Error(
					`"error" property returned from load() must be a string or instance of Error, received type "${typeof error2}"`
				)
			};
		}
		if (!status || status < 400 || status > 599) {
			console.warn(
				'"error" returned from load() without a valid status code \u2014 defaulting to 500'
			);
			return { status: 500, error: error2 };
		}
		return { status, error: error2 };
	}
	if (loaded.redirect) {
		if (!loaded.status || Math.floor(loaded.status / 100) !== 3) {
			throw new Error(
				'"redirect" property returned from load() must be accompanied by a 3xx status code'
			);
		}
		if (typeof loaded.redirect !== 'string') {
			throw new Error('"redirect" property returned from load() must be a string');
		}
	}
	if (loaded.dependencies) {
		if (
			!Array.isArray(loaded.dependencies) ||
			loaded.dependencies.some((dep) => typeof dep !== 'string')
		) {
			throw new Error('"dependencies" property returned from load() must be of type string[]');
		}
	}
	if (loaded.context) {
		throw new Error(
			'You are returning "context" from a load function. "context" was renamed to "stuff", please adjust your code accordingly.'
		);
	}
	return loaded;
}
function domain_matches(hostname, constraint) {
	if (!constraint) return true;
	const normalized = constraint[0] === '.' ? constraint.slice(1) : constraint;
	if (hostname === normalized) return true;
	return hostname.endsWith('.' + normalized);
}
function path_matches(path, constraint) {
	if (!constraint) return true;
	const normalized = constraint.endsWith('/') ? constraint.slice(0, -1) : constraint;
	if (path === normalized) return true;
	return path.startsWith(normalized + '/');
}
async function load_node({
	event,
	options,
	state,
	route,
	node,
	$session,
	stuff,
	is_error,
	is_leaf,
	status,
	error: error2
}) {
	const { module: module2 } = node;
	let uses_credentials = false;
	const fetched = [];
	const cookies = parse_1(event.request.headers.get('cookie') || '');
	const new_cookies = [];
	let loaded;
	const should_prerender = node.module.prerender ?? options.prerender.default;
	const shadow = is_leaf ? await load_shadow_data(route, event, options, should_prerender) : {};
	if (shadow.cookies) {
		shadow.cookies.forEach((header) => {
			new_cookies.push(parseString_1(header));
		});
	}
	if (shadow.error) {
		loaded = {
			status: shadow.status,
			error: shadow.error
		};
	} else if (shadow.redirect) {
		loaded = {
			status: shadow.status,
			redirect: shadow.redirect
		};
	} else if (module2.load) {
		const load_input = {
			url: state.prerendering ? new PrerenderingURL(event.url) : new LoadURL(event.url),
			params: event.params,
			props: shadow.body || {},
			routeId: event.routeId,
			get session() {
				if (node.module.prerender ?? options.prerender.default) {
					throw Error(
						'Attempted to access session from a prerendered page. Session would never be populated.'
					);
				}
				uses_credentials = true;
				return $session;
			},
			fetch: async (resource, opts = {}) => {
				let requested;
				if (typeof resource === 'string') {
					requested = resource;
				} else {
					requested = resource.url;
					opts = {
						method: resource.method,
						headers: resource.headers,
						body: resource.body,
						mode: resource.mode,
						credentials: resource.credentials,
						cache: resource.cache,
						redirect: resource.redirect,
						referrer: resource.referrer,
						integrity: resource.integrity,
						...opts
					};
				}
				opts.headers = new Headers(opts.headers);
				for (const [key22, value] of event.request.headers) {
					if (
						key22 !== 'authorization' &&
						key22 !== 'cookie' &&
						key22 !== 'host' &&
						key22 !== 'if-none-match' &&
						!opts.headers.has(key22)
					) {
						opts.headers.set(key22, value);
					}
				}
				const resolved = resolve(event.url.pathname, requested.split('?')[0]);
				let response2;
				let dependency;
				const prefix = options.paths.assets || options.paths.base;
				const filename = decodeURIComponent(
					resolved.startsWith(prefix) ? resolved.slice(prefix.length) : resolved
				).slice(1);
				const filename_html = `${filename}/index.html`;
				const is_asset = options.manifest.assets.has(filename);
				const is_asset_html = options.manifest.assets.has(filename_html);
				if (is_asset || is_asset_html) {
					const file2 = is_asset ? filename : filename_html;
					if (options.read) {
						const type = is_asset
							? options.manifest.mimeTypes[filename.slice(filename.lastIndexOf('.'))]
							: 'text/html';
						response2 = new Response(options.read(file2), {
							headers: type ? { 'content-type': type } : {}
						});
					} else {
						response2 = await fetch(`${event.url.origin}/${file2}`, opts);
					}
				} else if (is_root_relative(resolved)) {
					if (opts.credentials !== 'omit') {
						uses_credentials = true;
						const authorization = event.request.headers.get('authorization');
						const combined_cookies = { ...cookies };
						for (const cookie2 of new_cookies) {
							if (!domain_matches(event.url.hostname, cookie2.domain)) continue;
							if (!path_matches(resolved, cookie2.path)) continue;
							combined_cookies[cookie2.name] = cookie2.value;
						}
						const cookie = Object.entries(combined_cookies)
							.map(([name, value]) => `${name}=${value}`)
							.join('; ');
						if (cookie) {
							opts.headers.set('cookie', cookie);
						}
						if (authorization && !opts.headers.has('authorization')) {
							opts.headers.set('authorization', authorization);
						}
					}
					if (opts.body && typeof opts.body !== 'string') {
						throw new Error('Request body must be a string');
					}
					response2 = await respond(
						new Request(new URL(requested, event.url).href, { ...opts }),
						options,
						{
							...state,
							initiator: route
						}
					);
					if (state.prerendering) {
						dependency = { response: response2, body: null };
						state.prerendering.dependencies.set(resolved, dependency);
					}
				} else {
					if (resolved.startsWith('//')) {
						requested = event.url.protocol + requested;
					}
					if (
						`.${new URL(requested).hostname}`.endsWith(`.${event.url.hostname}`) &&
						opts.credentials !== 'omit'
					) {
						uses_credentials = true;
						const cookie = event.request.headers.get('cookie');
						if (cookie) opts.headers.set('cookie', cookie);
					}
					opts.headers.delete('connection');
					const external_request = new Request(requested, opts);
					response2 = await options.hooks.externalFetch.call(null, external_request);
				}
				const set_cookie = response2.headers.get('set-cookie');
				if (set_cookie) {
					new_cookies.push(...splitCookiesString_12(set_cookie).map((str) => parseString_1(str)));
				}
				const proxy = new Proxy(response2, {
					get(response22, key22, _receiver) {
						async function text7() {
							const body4 = await response22.text();
							const headers2 = {};
							for (const [key3, value] of response22.headers) {
								if (key3 !== 'set-cookie' && key3 !== 'etag') {
									headers2[key3] = value;
								}
							}
							if (!opts.body || typeof opts.body === 'string') {
								const status_number = Number(response22.status);
								if (isNaN(status_number)) {
									throw new Error(
										`response.status is not a number. value: "${
											response22.status
										}" type: ${typeof response22.status}`
									);
								}
								fetched.push({
									url: requested,
									body: opts.body,
									response: {
										status: status_number,
										statusText: response22.statusText,
										headers: headers2,
										body: body4
									}
								});
							}
							if (dependency) {
								dependency.body = body4;
							}
							return body4;
						}
						if (key22 === 'arrayBuffer') {
							return async () => {
								const buffer2 = await response22.arrayBuffer();
								if (dependency) {
									dependency.body = new Uint8Array(buffer2);
								}
								return buffer2;
							};
						}
						if (key22 === 'text') {
							return text7;
						}
						if (key22 === 'json') {
							return async () => {
								return JSON.parse(await text7());
							};
						}
						return Reflect.get(response22, key22, response22);
					}
				});
				return proxy;
			},
			stuff: { ...stuff },
			status: is_error ? status ?? null : null,
			error: is_error ? error2 ?? null : null
		};
		if (options.dev) {
			Object.defineProperty(load_input, 'page', {
				get: () => {
					throw new Error('`page` in `load` functions has been replaced by `url` and `params`');
				}
			});
		}
		loaded = await module2.load.call(null, load_input);
		if (!loaded) {
			throw new Error(`load function must return a value${options.dev ? ` (${node.entry})` : ''}`);
		}
	} else if (shadow.body) {
		loaded = {
			props: shadow.body
		};
	} else {
		loaded = {};
	}
	if (shadow.body && state.prerendering) {
		const pathname = `${event.url.pathname.replace(/\/$/, '')}/__data.json`;
		const dependency = {
			response: new Response(void 0),
			body: JSON.stringify(shadow.body)
		};
		state.prerendering.dependencies.set(pathname, dependency);
	}
	return {
		node,
		props: shadow.body,
		loaded: normalize(loaded),
		stuff: loaded.stuff || stuff,
		fetched,
		set_cookie_headers: new_cookies.map((new_cookie) => {
			const { name, value, ...options2 } = new_cookie;
			return serialize_1(name, value, options2);
		}),
		uses_credentials
	};
}
async function load_shadow_data(route, event, options, prerender) {
	if (!route.shadow) return {};
	try {
		const mod = await route.shadow();
		if (prerender && (mod.post || mod.put || mod.del || mod.patch)) {
			throw new Error('Cannot prerender pages that have endpoints with mutative methods');
		}
		const method = normalize_request_method(event);
		const is_get = method === 'head' || method === 'get';
		const handler = method === 'head' ? mod.head || mod.get : mod[method];
		if (!handler && !is_get) {
			return {
				status: 405,
				error: new Error(`${method} method not allowed`)
			};
		}
		const data2 = {
			status: 200,
			cookies: [],
			body: {}
		};
		if (!is_get) {
			const result = await handler(event);
			if (result.fallthrough) {
				throw new Error(
					'fallthrough is no longer supported. Use matchers instead: https://kit.svelte.dev/docs/routing#advanced-routing-matching'
				);
			}
			const { status, headers: headers2, body: body4 } = validate_shadow_output(result);
			data2.status = status;
			add_cookies(data2.cookies, headers2);
			if (status >= 300 && status < 400) {
				data2.redirect = headers2 instanceof Headers ? headers2.get('location') : headers2.location;
				return data2;
			}
			data2.body = body4;
		}
		const get3 = (method === 'head' && mod.head) || mod.get;
		if (get3) {
			const result = await get3(event);
			if (result.fallthrough) {
				throw new Error(
					'fallthrough is no longer supported. Use matchers instead: https://kit.svelte.dev/docs/routing#advanced-routing-matching'
				);
			}
			const { status, headers: headers2, body: body4 } = validate_shadow_output(result);
			add_cookies(data2.cookies, headers2);
			data2.status = status;
			if (status >= 400) {
				data2.error = new Error('Failed to load data');
				return data2;
			}
			if (status >= 300) {
				data2.redirect = headers2 instanceof Headers ? headers2.get('location') : headers2.location;
				return data2;
			}
			data2.body = { ...body4, ...data2.body };
		}
		return data2;
	} catch (e2) {
		const error2 = coalesce_to_error(e2);
		options.handle_error(error2, event);
		return {
			status: 500,
			error: error2
		};
	}
}
function add_cookies(target, headers2) {
	const cookies = headers2['set-cookie'];
	if (cookies) {
		if (Array.isArray(cookies)) {
			target.push(...cookies);
		} else {
			target.push(cookies);
		}
	}
}
function validate_shadow_output(result) {
	const { status = 200, body: body4 = {} } = result;
	let headers2 = result.headers || {};
	if (headers2 instanceof Headers) {
		if (headers2.has('set-cookie')) {
			throw new Error(
				'Endpoint request handler cannot use Headers interface with Set-Cookie headers'
			);
		}
	} else {
		headers2 = lowercase_keys(headers2);
	}
	if (!is_pojo(body4)) {
		throw new Error('Body returned from endpoint request handler must be a plain object');
	}
	return { status, headers: headers2, body: body4 };
}
async function respond_with_error({
	event,
	options,
	state,
	$session,
	status,
	error: error2,
	resolve_opts
}) {
	try {
		const branch = [];
		let stuff = {};
		if (resolve_opts.ssr) {
			const default_layout = await options.manifest._.nodes[0]();
			const default_error = await options.manifest._.nodes[1]();
			const layout_loaded = await load_node({
				event,
				options,
				state,
				route: null,
				node: default_layout,
				$session,
				stuff: {},
				is_error: false,
				is_leaf: false
			});
			const error_loaded = await load_node({
				event,
				options,
				state,
				route: null,
				node: default_error,
				$session,
				stuff: layout_loaded ? layout_loaded.stuff : {},
				is_error: true,
				is_leaf: false,
				status,
				error: error2
			});
			branch.push(layout_loaded, error_loaded);
			stuff = error_loaded.stuff;
		}
		return await render_response({
			options,
			state,
			$session,
			page_config: {
				hydrate: options.hydrate,
				router: options.router
			},
			stuff,
			status,
			error: error2,
			branch,
			event,
			resolve_opts
		});
	} catch (err) {
		const error3 = coalesce_to_error(err);
		options.handle_error(error3, event);
		return new Response(error3.stack, {
			status: 500
		});
	}
}
async function respond$1(opts) {
	const { event, options, state, $session, route, resolve_opts } = opts;
	let nodes2;
	if (!resolve_opts.ssr) {
		return await render_response({
			...opts,
			branch: [],
			page_config: {
				hydrate: true,
				router: true
			},
			status: 200,
			error: null,
			event,
			stuff: {}
		});
	}
	try {
		nodes2 = await Promise.all(
			route.a.map((n) => (n == void 0 ? n : options.manifest._.nodes[n]()))
		);
	} catch (err) {
		const error3 = coalesce_to_error(err);
		options.handle_error(error3, event);
		return await respond_with_error({
			event,
			options,
			state,
			$session,
			status: 500,
			error: error3,
			resolve_opts
		});
	}
	const leaf = nodes2[nodes2.length - 1].module;
	let page_config = get_page_config(leaf, options);
	if (state.prerendering) {
		const should_prerender = leaf.prerender ?? options.prerender.default;
		if (!should_prerender) {
			return new Response(void 0, {
				status: 204
			});
		}
	}
	let branch = [];
	let status = 200;
	let error2 = null;
	let set_cookie_headers = [];
	let stuff = {};
	ssr: {
		for (let i2 = 0; i2 < nodes2.length; i2 += 1) {
			const node = nodes2[i2];
			let loaded;
			if (node) {
				try {
					loaded = await load_node({
						...opts,
						node,
						stuff,
						is_error: false,
						is_leaf: i2 === nodes2.length - 1
					});
					set_cookie_headers = set_cookie_headers.concat(loaded.set_cookie_headers);
					if (loaded.loaded.redirect) {
						return with_cookies(
							new Response(void 0, {
								status: loaded.loaded.status,
								headers: {
									location: loaded.loaded.redirect
								}
							}),
							set_cookie_headers
						);
					}
					if (loaded.loaded.error) {
						({ status, error: error2 } = loaded.loaded);
					}
				} catch (err) {
					const e2 = coalesce_to_error(err);
					options.handle_error(e2, event);
					status = 500;
					error2 = e2;
				}
				if (loaded && !error2) {
					branch.push(loaded);
				}
				if (error2) {
					while (i2--) {
						if (route.b[i2]) {
							const index6 = route.b[i2];
							const error_node = await options.manifest._.nodes[index6]();
							let node_loaded;
							let j = i2;
							while (!(node_loaded = branch[j])) {
								j -= 1;
							}
							try {
								const error_loaded = await load_node({
									...opts,
									node: error_node,
									stuff: node_loaded.stuff,
									is_error: true,
									is_leaf: false,
									status,
									error: error2
								});
								if (error_loaded.loaded.error) {
									continue;
								}
								page_config = get_page_config(error_node.module, options);
								branch = branch.slice(0, j + 1).concat(error_loaded);
								stuff = { ...node_loaded.stuff, ...error_loaded.stuff };
								break ssr;
							} catch (err) {
								const e2 = coalesce_to_error(err);
								options.handle_error(e2, event);
								continue;
							}
						}
					}
					return with_cookies(
						await respond_with_error({
							event,
							options,
							state,
							$session,
							status,
							error: error2,
							resolve_opts
						}),
						set_cookie_headers
					);
				}
			}
			if (loaded && loaded.loaded.stuff) {
				stuff = {
					...stuff,
					...loaded.loaded.stuff
				};
			}
		}
	}
	try {
		return with_cookies(
			await render_response({
				...opts,
				stuff,
				event,
				page_config,
				status,
				error: error2,
				branch: branch.filter(Boolean)
			}),
			set_cookie_headers
		);
	} catch (err) {
		const error3 = coalesce_to_error(err);
		options.handle_error(error3, event);
		return with_cookies(
			await respond_with_error({
				...opts,
				status: 500,
				error: error3
			}),
			set_cookie_headers
		);
	}
}
function get_page_config(leaf, options) {
	if ('ssr' in leaf) {
		throw new Error(
			'`export const ssr` has been removed \u2014 use the handle hook instead: https://kit.svelte.dev/docs/hooks#handle'
		);
	}
	return {
		router: 'router' in leaf ? !!leaf.router : options.router,
		hydrate: 'hydrate' in leaf ? !!leaf.hydrate : options.hydrate
	};
}
function with_cookies(response2, set_cookie_headers) {
	if (set_cookie_headers.length) {
		set_cookie_headers.forEach((value) => {
			response2.headers.append('set-cookie', value);
		});
	}
	return response2;
}
async function render_page(event, route, options, state, resolve_opts) {
	if (state.initiator === route) {
		return new Response(`Not found: ${event.url.pathname}`, {
			status: 404
		});
	}
	if (route.shadow) {
		const type = negotiate(event.request.headers.get('accept') || 'text/html', [
			'text/html',
			'application/json'
		]);
		if (type === 'application/json') {
			return render_endpoint(event, await route.shadow());
		}
	}
	const $session = await options.hooks.getSession(event);
	return respond$1({
		event,
		options,
		state,
		$session,
		resolve_opts,
		route
	});
}
function negotiate(accept, types2) {
	const parts = accept
		.split(',')
		.map((str, i2) => {
			const match = /([^/]+)\/([^;]+)(?:;q=([0-9.]+))?/.exec(str);
			if (match) {
				const [, type, subtype, q = '1'] = match;
				return { type, subtype, q: +q, i: i2 };
			}
			throw new Error(`Invalid Accept header: ${accept}`);
		})
		.sort((a, b) => {
			if (a.q !== b.q) {
				return b.q - a.q;
			}
			if ((a.subtype === '*') !== (b.subtype === '*')) {
				return a.subtype === '*' ? 1 : -1;
			}
			if ((a.type === '*') !== (b.type === '*')) {
				return a.type === '*' ? 1 : -1;
			}
			return a.i - b.i;
		});
	let accepted;
	let min_priority = Infinity;
	for (const mimetype of types2) {
		const [type, subtype] = mimetype.split('/');
		const priority = parts.findIndex(
			(part) =>
				(part.type === type || part.type === '*') &&
				(part.subtype === subtype || part.subtype === '*')
		);
		if (priority !== -1 && priority < min_priority) {
			accepted = mimetype;
			min_priority = priority;
		}
	}
	return accepted;
}
function exec(match, names, types2, matchers) {
	const params = {};
	for (let i2 = 0; i2 < names.length; i2 += 1) {
		const name = names[i2];
		const type = types2[i2];
		const value = match[i2 + 1] || '';
		if (type) {
			const matcher = matchers[type];
			if (!matcher) throw new Error(`Missing "${type}" param matcher`);
			if (!matcher(value)) return;
		}
		params[name] = value;
	}
	return params;
}
var DATA_SUFFIX = '/__data.json';
var default_transform = ({ html: html9 }) => html9;
async function respond(request2, options, state) {
	var _a, _b, _c, _d;
	let url = new URL(request2.url);
	const { parameter, allowed } = options.method_override;
	const method_override =
		(_a = url.searchParams.get(parameter)) == null ? void 0 : _a.toUpperCase();
	if (method_override) {
		if (request2.method === 'POST') {
			if (allowed.includes(method_override)) {
				request2 = new Proxy(request2, {
					get: (target, property, _receiver) => {
						if (property === 'method') return method_override;
						return Reflect.get(target, property, target);
					}
				});
			} else {
				const verb = allowed.length === 0 ? 'enabled' : 'allowed';
				const body4 = `${parameter}=${method_override} is not ${verb}. See https://kit.svelte.dev/docs/configuration#methodoverride`;
				return new Response(body4, {
					status: 400
				});
			}
		} else {
			throw new Error(`${parameter}=${method_override} is only allowed with POST requests`);
		}
	}
	let decoded;
	try {
		decoded = decodeURI(url.pathname);
	} catch {
		return new Response('Malformed URI', { status: 400 });
	}
	let route = null;
	let params = {};
	if (options.paths.base && !((_b = state.prerendering) == null ? void 0 : _b.fallback)) {
		if (!decoded.startsWith(options.paths.base)) {
			return new Response('Not found', { status: 404 });
		}
		decoded = decoded.slice(options.paths.base.length) || '/';
	}
	const is_data_request = decoded.endsWith(DATA_SUFFIX);
	if (is_data_request) {
		const data_suffix_length = DATA_SUFFIX.length - (options.trailing_slash === 'always' ? 1 : 0);
		decoded = decoded.slice(0, -data_suffix_length) || '/';
		url = new URL(url.origin + url.pathname.slice(0, -data_suffix_length) + url.search);
	}
	if (!((_c = state.prerendering) == null ? void 0 : _c.fallback)) {
		const matchers = await options.manifest._.matchers();
		for (const candidate of options.manifest._.routes) {
			const match = candidate.pattern.exec(decoded);
			if (!match) continue;
			const matched = exec(match, candidate.names, candidate.types, matchers);
			if (matched) {
				route = candidate;
				params = decode_params(matched);
				break;
			}
		}
	}
	if (route) {
		if (route.type === 'page') {
			const normalized = normalize_path(url.pathname, options.trailing_slash);
			if (
				normalized !== url.pathname &&
				!((_d = state.prerendering) == null ? void 0 : _d.fallback)
			) {
				return new Response(void 0, {
					status: 301,
					headers: {
						'x-sveltekit-normalize': '1',
						location:
							(normalized.startsWith('//') ? url.origin + normalized : normalized) +
							(url.search === '?' ? '' : url.search)
					}
				});
			}
		} else if (is_data_request) {
			return new Response(void 0, {
				status: 404
			});
		}
	}
	const event = {
		get clientAddress() {
			if (!state.getClientAddress) {
				throw new Error(
					`${'@sveltejs/adapter-vercel'} does not specify getClientAddress. Please raise an issue`
				);
			}
			Object.defineProperty(event, 'clientAddress', {
				value: state.getClientAddress()
			});
			return event.clientAddress;
		},
		locals: {},
		params,
		platform: state.platform,
		request: request2,
		routeId: route && route.id,
		url
	};
	const removed = (property, replacement, suffix = '') => ({
		get: () => {
			throw new Error(`event.${property} has been replaced by event.${replacement}` + suffix);
		}
	});
	const details = '. See https://github.com/sveltejs/kit/pull/3384 for details';
	const body_getter = {
		get: () => {
			throw new Error(
				'To access the request body use the text/json/arrayBuffer/formData methods, e.g. `body = await request.json()`' +
					details
			);
		}
	};
	Object.defineProperties(event, {
		method: removed('method', 'request.method', details),
		headers: removed('headers', 'request.headers', details),
		origin: removed('origin', 'url.origin'),
		path: removed('path', 'url.pathname'),
		query: removed('query', 'url.searchParams'),
		body: body_getter,
		rawBody: body_getter
	});
	let resolve_opts = {
		ssr: true,
		transformPage: default_transform
	};
	try {
		const response2 = await options.hooks.handle({
			event,
			resolve: async (event2, opts) => {
				var _a2;
				if (opts) {
					resolve_opts = {
						ssr: opts.ssr !== false,
						transformPage: opts.transformPage || default_transform
					};
				}
				if ((_a2 = state.prerendering) == null ? void 0 : _a2.fallback) {
					return await render_response({
						event: event2,
						options,
						state,
						$session: await options.hooks.getSession(event2),
						page_config: { router: true, hydrate: true },
						stuff: {},
						status: 200,
						error: null,
						branch: [],
						resolve_opts: {
							...resolve_opts,
							ssr: false
						}
					});
				}
				if (route) {
					let response22;
					if (is_data_request && route.type === 'page' && route.shadow) {
						response22 = await render_endpoint(event2, await route.shadow());
						if (request2.headers.has('x-sveltekit-load')) {
							if (response22.status >= 300 && response22.status < 400) {
								const location2 = response22.headers.get('location');
								if (location2) {
									const headers2 = new Headers(response22.headers);
									headers2.set('x-sveltekit-location', location2);
									response22 = new Response(void 0, {
										status: 204,
										headers: headers2
									});
								}
							}
						}
					} else {
						response22 =
							route.type === 'endpoint'
								? await render_endpoint(event2, await route.load())
								: await render_page(event2, route, options, state, resolve_opts);
					}
					if (response22) {
						if (response22.status === 200 && response22.headers.has('etag')) {
							let if_none_match_value = request2.headers.get('if-none-match');
							if (if_none_match_value == null ? void 0 : if_none_match_value.startsWith('W/"')) {
								if_none_match_value = if_none_match_value.substring(2);
							}
							const etag = response22.headers.get('etag');
							if (if_none_match_value === etag) {
								const headers2 = new Headers({ etag });
								for (const key22 of [
									'cache-control',
									'content-location',
									'date',
									'expires',
									'vary'
								]) {
									const value = response22.headers.get(key22);
									if (value) headers2.set(key22, value);
								}
								return new Response(void 0, {
									status: 304,
									headers: headers2
								});
							}
						}
						return response22;
					}
				}
				if (!state.initiator) {
					const $session = await options.hooks.getSession(event2);
					return await respond_with_error({
						event: event2,
						options,
						state,
						$session,
						status: 404,
						error: new Error(`Not found: ${event2.url.pathname}`),
						resolve_opts
					});
				}
				if (state.prerendering) {
					return new Response('not found', { status: 404 });
				}
				return await fetch(request2);
			},
			get request() {
				throw new Error('request in handle has been replaced with event' + details);
			}
		});
		if (response2 && !(response2 instanceof Response)) {
			throw new Error('handle must return a Response object' + details);
		}
		return response2;
	} catch (e2) {
		const error2 = coalesce_to_error(e2);
		options.handle_error(error2, event);
		try {
			const $session = await options.hooks.getSession(event);
			return await respond_with_error({
				event,
				options,
				state,
				$session,
				status: 500,
				error: error2,
				resolve_opts
			});
		} catch (e22) {
			const error3 = coalesce_to_error(e22);
			return new Response(options.dev ? error3.stack : error3.message, {
				status: 500
			});
		}
	}
}
var base = '';
var assets = '';
function set_paths(paths) {
	base = paths.base;
	assets = paths.assets || base;
}
var template = ({ head: head2, body: body4, assets: assets2, nonce }) =>
	'<!DOCTYPE html>\n<html>\n    <head>\n        <meta charset="utf-8" />\n		<link rel="icon" href="/favicon.ico" />\n		<meta name="viewport" content="width=device-width, initial-scale=1" />\n		<link rel="stylesheet" href="./global.css"> <!-- add this to import global.css -->\n		' +
	head2 +
	'\n    </head>\n    <body>\n        <div id="svelte">' +
	body4 +
	'</div>\n    </body>\n</html>';
var read = null;
set_paths({ base: '', assets: '' });
var Server = class {
	constructor(manifest2) {
		this.options = {
			csp: {
				mode: 'auto',
				directives: { 'upgrade-insecure-requests': false, 'block-all-mixed-content': false }
			},
			dev: false,
			floc: false,
			get_stack: (error2) => String(error2),
			handle_error: (error2, event) => {
				this.options.hooks.handleError({
					error: error2,
					event,
					get request() {
						throw new Error(
							'request in handleError has been replaced with event. See https://github.com/sveltejs/kit/pull/3384 for details'
						);
					}
				});
				error2.stack = this.options.get_stack(error2);
			},
			hooks: null,
			hydrate: true,
			manifest: manifest2,
			method_override: { parameter: '_method', allowed: [] },
			paths: { base, assets },
			prefix: assets + '/_app/immutable/',
			prerender: {
				default: false,
				enabled: true
			},
			read,
			root: Root,
			service_worker: null,
			router: true,
			template,
			template_contains_nonce: false,
			trailing_slash: 'never'
		};
	}
	async respond(request2, options = {}) {
		if (!(request2 instanceof Request)) {
			throw new Error(
				'The first argument to server.respond must be a Request object. See https://github.com/sveltejs/kit/pull/3384 for details'
			);
		}
		if (!this.options.hooks) {
			const module2 = await Promise.resolve().then(
				() => (init_hooks_1c45ba0b(), hooks_1c45ba0b_exports)
			);
			this.options.hooks = {
				getSession: module2.getSession || (() => ({})),
				handle: module2.handle || (({ event, resolve: resolve2 }) => resolve2(event)),
				handleError: module2.handleError || (({ error: error2 }) => console.error(error2.stack)),
				externalFetch: module2.externalFetch || fetch
			};
		}
		return respond(request2, this.options, options);
	}
};

// .svelte-kit/vercel-tmp/manifest.js
var manifest = {
	appDir: '_app',
	assets: /* @__PURE__ */ new Set(['favicon.png']),
	mimeTypes: { '.png': 'image/png' },
	_: {
		entry: {
			file: 'start-ece7844a.js',
			js: ['start-ece7844a.js', 'chunks/index-429e7792.js'],
			css: []
		},
		nodes: [
			() => Promise.resolve().then(() => (init__(), __exports)),
			() => Promise.resolve().then(() => (init__2(), __exports2)),
			() => Promise.resolve().then(() => (init__3(), __exports3)),
			() => Promise.resolve().then(() => (init__4(), __exports4))
		],
		routes: [
			{
				type: 'page',
				id: '',
				pattern: /^\/$/,
				names: [],
				types: [],
				path: '/',
				shadow: null,
				a: [0, 2],
				b: [1]
			},
			{
				type: 'endpoint',
				id: 'post.json',
				pattern: /^\/post\.json$/,
				names: [],
				types: [],
				load: () => Promise.resolve().then(() => (init_post_json(), post_json_exports))
			},
			{
				type: 'endpoint',
				id: 'posts/[slug].json',
				pattern: /^\/posts\/([^/]+?)\.json$/,
				names: ['slug'],
				types: [null],
				load: () => Promise.resolve().then(() => (init_slug_json(), slug_json_exports))
			},
			{
				type: 'page',
				id: 'posts/[slug]',
				pattern: /^\/posts\/([^/]+?)\/?$/,
				names: ['slug'],
				types: [null],
				path: null,
				shadow: null,
				a: [0, 3],
				b: [1]
			}
		],
		matchers: async () => {
			return {};
		}
	}
};

// .svelte-kit/vercel-tmp/serverless.js
installPolyfills();
var server = new Server(manifest);
var serverless_default = async (req, res) => {
	let request2;
	try {
		request2 = await getRequest(`https://${req.headers.host}`, req);
	} catch (err) {
		res.statusCode = err.status || 400;
		return res.end(err.reason || 'Invalid request body');
	}
	setResponse(
		res,
		await server.respond(request2, {
			getClientAddress() {
				return request2.headers.get('x-forwarded-for');
			}
		})
	);
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {});
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */
/*! fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
/*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
/*! node-domexception. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */
/**
 * Prism: Lightweight, robust, elegant syntax highlighting
 *
 * @license MIT <https://opensource.org/licenses/MIT>
 * @author Lea Verou <https://lea.verou.me>
 * @namespace
 * @public
 */
//# sourceMappingURL=index.js.map
